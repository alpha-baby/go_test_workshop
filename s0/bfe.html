
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>backend: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/bfenetworks/bfe/bfe_balance/backend/bfe_backend.go (48.7%)</option>
				
				<option value="file1">github.com/bfenetworks/bfe/bfe_balance/backend/health_check.go (72.2%)</option>
				
				<option value="file2">github.com/bfenetworks/bfe/bfe_balance/bal_gslb/bal_gslb.go (31.7%)</option>
				
				<option value="file3">github.com/bfenetworks/bfe/bfe_balance/bal_gslb/state.go (0.0%)</option>
				
				<option value="file4">github.com/bfenetworks/bfe/bfe_balance/bal_gslb/sub_cluster.go (61.1%)</option>
				
				<option value="file5">github.com/bfenetworks/bfe/bfe_balance/bal_slb/backend_rr.go (43.3%)</option>
				
				<option value="file6">github.com/bfenetworks/bfe/bfe_balance/bal_slb/bal_rr.go (77.6%)</option>
				
				<option value="file7">github.com/bfenetworks/bfe/bfe_balance/bal_table.go (64.3%)</option>
				
				<option value="file8">github.com/bfenetworks/bfe/bfe_basic/action/action.go (75.5%)</option>
				
				<option value="file9">github.com/bfenetworks/bfe/bfe_basic/action/action_host.go (15.4%)</option>
				
				<option value="file10">github.com/bfenetworks/bfe/bfe_basic/action/action_path.go (93.3%)</option>
				
				<option value="file11">github.com/bfenetworks/bfe/bfe_basic/action/action_query.go (87.1%)</option>
				
				<option value="file12">github.com/bfenetworks/bfe/bfe_basic/condition/build.go (28.1%)</option>
				
				<option value="file13">github.com/bfenetworks/bfe/bfe_basic/condition/composite.go (0.0%)</option>
				
				<option value="file14">github.com/bfenetworks/bfe/bfe_basic/condition/parser/ast.go (7.1%)</option>
				
				<option value="file15">github.com/bfenetworks/bfe/bfe_basic/condition/parser/parser.go (75.0%)</option>
				
				<option value="file16">github.com/bfenetworks/bfe/bfe_basic/condition/parser/scanner.go (32.0%)</option>
				
				<option value="file17">github.com/bfenetworks/bfe/bfe_basic/condition/parser/semant.go (85.7%)</option>
				
				<option value="file18">github.com/bfenetworks/bfe/bfe_basic/condition/parser/token.go (66.7%)</option>
				
				<option value="file19">github.com/bfenetworks/bfe/bfe_basic/condition/parser/walk.go (84.6%)</option>
				
				<option value="file20">github.com/bfenetworks/bfe/bfe_basic/condition/parser/y.go (57.5%)</option>
				
				<option value="file21">github.com/bfenetworks/bfe/bfe_basic/condition/primitive.go (54.4%)</option>
				
				<option value="file22">github.com/bfenetworks/bfe/bfe_bufio/bufio.go (89.3%)</option>
				
				<option value="file23">github.com/bfenetworks/bfe/bfe_config/bfe_cluster_conf/cluster_conf/cluster_conf_load.go (66.3%)</option>
				
				<option value="file24">github.com/bfenetworks/bfe/bfe_config/bfe_cluster_conf/cluster_table_conf/cluster_table_load.go (36.8%)</option>
				
				<option value="file25">github.com/bfenetworks/bfe/bfe_config/bfe_cluster_conf/gslb_conf/gslb_conf_load.go (49.1%)</option>
				
				<option value="file26">github.com/bfenetworks/bfe/bfe_config/bfe_conf/bfe_config_load.go (73.7%)</option>
				
				<option value="file27">github.com/bfenetworks/bfe/bfe_config/bfe_conf/conf_basic.go (78.9%)</option>
				
				<option value="file28">github.com/bfenetworks/bfe/bfe_config/bfe_conf/conf_https_basic.go (57.9%)</option>
				
				<option value="file29">github.com/bfenetworks/bfe/bfe_config/bfe_conf/conf_session_cache.go (81.0%)</option>
				
				<option value="file30">github.com/bfenetworks/bfe/bfe_config/bfe_conf/conf_session_ticket.go (80.0%)</option>
				
				<option value="file31">github.com/bfenetworks/bfe/bfe_config/bfe_route_conf/host_rule_conf/host_table_load.go (76.8%)</option>
				
				<option value="file32">github.com/bfenetworks/bfe/bfe_config/bfe_route_conf/route_rule_conf/basic_rule_tree.go (100.0%)</option>
				
				<option value="file33">github.com/bfenetworks/bfe/bfe_config/bfe_route_conf/route_rule_conf/route_table_load.go (85.2%)</option>
				
				<option value="file34">github.com/bfenetworks/bfe/bfe_config/bfe_route_conf/vip_rule_conf/vip_table_load.go (90.3%)</option>
				
				<option value="file35">github.com/bfenetworks/bfe/bfe_config/bfe_tls_conf/session_ticket_key_conf/session_ticket_key_conf.go (56.2%)</option>
				
				<option value="file36">github.com/bfenetworks/bfe/bfe_config/bfe_tls_conf/tls_rule_conf/tls_rule_conf_load.go (50.7%)</option>
				
				<option value="file37">github.com/bfenetworks/bfe/bfe_fcgi/common.go (0.0%)</option>
				
				<option value="file38">github.com/bfenetworks/bfe/bfe_fcgi/fcgi_client.go (62.0%)</option>
				
				<option value="file39">github.com/bfenetworks/bfe/bfe_fcgi/transport.go (81.4%)</option>
				
				<option value="file40">github.com/bfenetworks/bfe/bfe_http/chunked.go (76.6%)</option>
				
				<option value="file41">github.com/bfenetworks/bfe/bfe_http/client.go (6.1%)</option>
				
				<option value="file42">github.com/bfenetworks/bfe/bfe_http/common.go (0.0%)</option>
				
				<option value="file43">github.com/bfenetworks/bfe/bfe_http/cookie.go (83.8%)</option>
				
				<option value="file44">github.com/bfenetworks/bfe/bfe_http/header.go (65.4%)</option>
				
				<option value="file45">github.com/bfenetworks/bfe/bfe_http/lex.go (100.0%)</option>
				
				<option value="file46">github.com/bfenetworks/bfe/bfe_http/request.go (78.3%)</option>
				
				<option value="file47">github.com/bfenetworks/bfe/bfe_http/response.go (73.8%)</option>
				
				<option value="file48">github.com/bfenetworks/bfe/bfe_http/sniff.go (0.0%)</option>
				
				<option value="file49">github.com/bfenetworks/bfe/bfe_http/state.go (0.0%)</option>
				
				<option value="file50">github.com/bfenetworks/bfe/bfe_http/status.go (0.0%)</option>
				
				<option value="file51">github.com/bfenetworks/bfe/bfe_http/transfer.go (77.4%)</option>
				
				<option value="file52">github.com/bfenetworks/bfe/bfe_http/transport.go (0.0%)</option>
				
				<option value="file53">github.com/bfenetworks/bfe/bfe_http2/errors.go (64.3%)</option>
				
				<option value="file54">github.com/bfenetworks/bfe/bfe_http2/flow.go (93.3%)</option>
				
				<option value="file55">github.com/bfenetworks/bfe/bfe_http2/frame.go (83.4%)</option>
				
				<option value="file56">github.com/bfenetworks/bfe/bfe_http2/headermap.go (100.0%)</option>
				
				<option value="file57">github.com/bfenetworks/bfe/bfe_http2/hpack/encode.go (98.9%)</option>
				
				<option value="file58">github.com/bfenetworks/bfe/bfe_http2/hpack/hpack.go (74.6%)</option>
				
				<option value="file59">github.com/bfenetworks/bfe/bfe_http2/hpack/huffman.go (96.5%)</option>
				
				<option value="file60">github.com/bfenetworks/bfe/bfe_http2/hpack/tables.go (100.0%)</option>
				
				<option value="file61">github.com/bfenetworks/bfe/bfe_http2/http2.go (67.0%)</option>
				
				<option value="file62">github.com/bfenetworks/bfe/bfe_http2/server.go (77.8%)</option>
				
				<option value="file63">github.com/bfenetworks/bfe/bfe_http2/state.go (0.0%)</option>
				
				<option value="file64">github.com/bfenetworks/bfe/bfe_http2/transport.go (0.0%)</option>
				
				<option value="file65">github.com/bfenetworks/bfe/bfe_http2/write.go (88.9%)</option>
				
				<option value="file66">github.com/bfenetworks/bfe/bfe_http2/writesched.go (84.9%)</option>
				
				<option value="file67">github.com/bfenetworks/bfe/bfe_module/bfe_callback.go (97.9%)</option>
				
				<option value="file68">github.com/bfenetworks/bfe/bfe_module/bfe_filter.go (66.7%)</option>
				
				<option value="file69">github.com/bfenetworks/bfe/bfe_module/bfe_handler_list.go (84.0%)</option>
				
				<option value="file70">github.com/bfenetworks/bfe/bfe_module/bfe_module.go (93.1%)</option>
				
				<option value="file71">github.com/bfenetworks/bfe/bfe_module/bfe_plugin.go (0.0%)</option>
				
				<option value="file72">github.com/bfenetworks/bfe/bfe_modules/mod_access/conf_mod_access.go (38.1%)</option>
				
				<option value="file73">github.com/bfenetworks/bfe/bfe_modules/mod_access/mod_access.go (0.0%)</option>
				
				<option value="file74">github.com/bfenetworks/bfe/bfe_modules/mod_access/request_log.go (0.0%)</option>
				
				<option value="file75">github.com/bfenetworks/bfe/bfe_modules/mod_access/session_log.go (0.0%)</option>
				
				<option value="file76">github.com/bfenetworks/bfe/bfe_modules/mod_auth_basic/auth_basic_rule_load.go (84.1%)</option>
				
				<option value="file77">github.com/bfenetworks/bfe/bfe_modules/mod_auth_basic/auth_basic_table.go (100.0%)</option>
				
				<option value="file78">github.com/bfenetworks/bfe/bfe_modules/mod_auth_basic/conf_mod_auth_basic.go (71.4%)</option>
				
				<option value="file79">github.com/bfenetworks/bfe/bfe_modules/mod_auth_basic/mod_auth_basic.go (74.3%)</option>
				
				<option value="file80">github.com/bfenetworks/bfe/bfe_modules/mod_auth_jwt/auth_jwt_rule_load.go (82.3%)</option>
				
				<option value="file81">github.com/bfenetworks/bfe/bfe_modules/mod_auth_jwt/auth_jwt_table.go (100.0%)</option>
				
				<option value="file82">github.com/bfenetworks/bfe/bfe_modules/mod_auth_jwt/conf_mod_auth_jwt.go (71.4%)</option>
				
				<option value="file83">github.com/bfenetworks/bfe/bfe_modules/mod_auth_jwt/mod_auth_jwt.go (80.5%)</option>
				
				<option value="file84">github.com/bfenetworks/bfe/bfe_modules/mod_auth_request/auth_request_rule_load.go (85.7%)</option>
				
				<option value="file85">github.com/bfenetworks/bfe/bfe_modules/mod_auth_request/auth_request_table.go (100.0%)</option>
				
				<option value="file86">github.com/bfenetworks/bfe/bfe_modules/mod_auth_request/conf_mod_auth_request.go (66.7%)</option>
				
				<option value="file87">github.com/bfenetworks/bfe/bfe_modules/mod_auth_request/mod_auth_request.go (76.1%)</option>
				
				<option value="file88">github.com/bfenetworks/bfe/bfe_modules/mod_block/action.go (77.8%)</option>
				
				<option value="file89">github.com/bfenetworks/bfe/bfe_modules/mod_block/conf_mod_block.go (89.5%)</option>
				
				<option value="file90">github.com/bfenetworks/bfe/bfe_modules/mod_block/global_ip_table_load.go (87.5%)</option>
				
				<option value="file91">github.com/bfenetworks/bfe/bfe_modules/mod_block/mod_block.go (75.7%)</option>
				
				<option value="file92">github.com/bfenetworks/bfe/bfe_modules/mod_block/product_rule_load.go (83.3%)</option>
				
				<option value="file93">github.com/bfenetworks/bfe/bfe_modules/mod_block/product_rule_table.go (100.0%)</option>
				
				<option value="file94">github.com/bfenetworks/bfe/bfe_modules/mod_compress/action.go (68.8%)</option>
				
				<option value="file95">github.com/bfenetworks/bfe/bfe_modules/mod_compress/brotli_filter.go (0.0%)</option>
				
				<option value="file96">github.com/bfenetworks/bfe/bfe_modules/mod_compress/compress_rule_load.go (84.6%)</option>
				
				<option value="file97">github.com/bfenetworks/bfe/bfe_modules/mod_compress/compress_rule_table.go (100.0%)</option>
				
				<option value="file98">github.com/bfenetworks/bfe/bfe_modules/mod_compress/conf_mod_compress.go (71.4%)</option>
				
				<option value="file99">github.com/bfenetworks/bfe/bfe_modules/mod_compress/gzip_filter.go (76.2%)</option>
				
				<option value="file100">github.com/bfenetworks/bfe/bfe_modules/mod_compress/mod_compress.go (66.3%)</option>
				
				<option value="file101">github.com/bfenetworks/bfe/bfe_modules/mod_cors/conf_mod_cors.go (71.4%)</option>
				
				<option value="file102">github.com/bfenetworks/bfe/bfe_modules/mod_cors/cors_rule_load.go (88.8%)</option>
				
				<option value="file103">github.com/bfenetworks/bfe/bfe_modules/mod_cors/cors_rule_table.go (100.0%)</option>
				
				<option value="file104">github.com/bfenetworks/bfe/bfe_modules/mod_cors/mod_cors.go (69.4%)</option>
				
				<option value="file105">github.com/bfenetworks/bfe/bfe_modules/mod_doh/conf_mod_doh.go (72.2%)</option>
				
				<option value="file106">github.com/bfenetworks/bfe/bfe_modules/mod_doh/dns_fetcher.go (17.9%)</option>
				
				<option value="file107">github.com/bfenetworks/bfe/bfe_modules/mod_doh/dns_msg_convert.go (85.5%)</option>
				
				<option value="file108">github.com/bfenetworks/bfe/bfe_modules/mod_doh/mod_doh.go (64.1%)</option>
				
				<option value="file109">github.com/bfenetworks/bfe/bfe_modules/mod_errors/action.go (34.3%)</option>
				
				<option value="file110">github.com/bfenetworks/bfe/bfe_modules/mod_errors/conf_mod_errors.go (0.0%)</option>
				
				<option value="file111">github.com/bfenetworks/bfe/bfe_modules/mod_errors/errors_rule_load.go (0.0%)</option>
				
				<option value="file112">github.com/bfenetworks/bfe/bfe_modules/mod_errors/errors_rule_table.go (0.0%)</option>
				
				<option value="file113">github.com/bfenetworks/bfe/bfe_modules/mod_errors/mod_errors.go (0.0%)</option>
				
				<option value="file114">github.com/bfenetworks/bfe/bfe_modules/mod_geo/conf_mod_geo.go (86.7%)</option>
				
				<option value="file115">github.com/bfenetworks/bfe/bfe_modules/mod_geo/mod_geo.go (77.1%)</option>
				
				<option value="file116">github.com/bfenetworks/bfe/bfe_modules/mod_header/action.go (65.9%)</option>
				
				<option value="file117">github.com/bfenetworks/bfe/bfe_modules/mod_header/action_cookie.go (91.0%)</option>
				
				<option value="file118">github.com/bfenetworks/bfe/bfe_modules/mod_header/action_header.go (100.0%)</option>
				
				<option value="file119">github.com/bfenetworks/bfe/bfe_modules/mod_header/action_header_var.go (0.0%)</option>
				
				<option value="file120">github.com/bfenetworks/bfe/bfe_modules/mod_header/conf_mod_header.go (85.7%)</option>
				
				<option value="file121">github.com/bfenetworks/bfe/bfe_modules/mod_header/default_header.go (40.0%)</option>
				
				<option value="file122">github.com/bfenetworks/bfe/bfe_modules/mod_header/header_rule_load.go (85.6%)</option>
				
				<option value="file123">github.com/bfenetworks/bfe/bfe_modules/mod_header/header_table.go (100.0%)</option>
				
				<option value="file124">github.com/bfenetworks/bfe/bfe_modules/mod_header/mod_header.go (83.6%)</option>
				
				<option value="file125">github.com/bfenetworks/bfe/bfe_modules/mod_http_code/mod_http_code.go (64.3%)</option>
				
				<option value="file126">github.com/bfenetworks/bfe/bfe_modules/mod_key_log/conf_mod_key_log.go (0.0%)</option>
				
				<option value="file127">github.com/bfenetworks/bfe/bfe_modules/mod_key_log/key_log_conf_load.go (86.7%)</option>
				
				<option value="file128">github.com/bfenetworks/bfe/bfe_modules/mod_key_log/key_log_table.go (0.0%)</option>
				
				<option value="file129">github.com/bfenetworks/bfe/bfe_modules/mod_key_log/mod_key_log.go (0.0%)</option>
				
				<option value="file130">github.com/bfenetworks/bfe/bfe_modules/mod_markdown/conf_mod_md.go (92.3%)</option>
				
				<option value="file131">github.com/bfenetworks/bfe/bfe_modules/mod_markdown/md_render.go (100.0%)</option>
				
				<option value="file132">github.com/bfenetworks/bfe/bfe_modules/mod_markdown/md_rule_load.go (94.0%)</option>
				
				<option value="file133">github.com/bfenetworks/bfe/bfe_modules/mod_markdown/md_rule_table.go (100.0%)</option>
				
				<option value="file134">github.com/bfenetworks/bfe/bfe_modules/mod_markdown/mod_markdown.go (75.6%)</option>
				
				<option value="file135">github.com/bfenetworks/bfe/bfe_modules/mod_prison/access.go (13.2%)</option>
				
				<option value="file136">github.com/bfenetworks/bfe/bfe_modules/mod_prison/conf_load.go (0.0%)</option>
				
				<option value="file137">github.com/bfenetworks/bfe/bfe_modules/mod_prison/data_load.go (55.3%)</option>
				
				<option value="file138">github.com/bfenetworks/bfe/bfe_modules/mod_prison/mod_prison.go (0.0%)</option>
				
				<option value="file139">github.com/bfenetworks/bfe/bfe_modules/mod_prison/product_rule_table.go (0.0%)</option>
				
				<option value="file140">github.com/bfenetworks/bfe/bfe_modules/mod_prison/rule.go (81.1%)</option>
				
				<option value="file141">github.com/bfenetworks/bfe/bfe_modules/mod_prison/rules.go (0.0%)</option>
				
				<option value="file142">github.com/bfenetworks/bfe/bfe_modules/mod_redirect/action.go (70.2%)</option>
				
				<option value="file143">github.com/bfenetworks/bfe/bfe_modules/mod_redirect/action_url.go (92.3%)</option>
				
				<option value="file144">github.com/bfenetworks/bfe/bfe_modules/mod_redirect/conf_mod_redirect.go (86.7%)</option>
				
				<option value="file145">github.com/bfenetworks/bfe/bfe_modules/mod_redirect/mod_redirect.go (78.0%)</option>
				
				<option value="file146">github.com/bfenetworks/bfe/bfe_modules/mod_redirect/redirect_conf_load.go (84.3%)</option>
				
				<option value="file147">github.com/bfenetworks/bfe/bfe_modules/mod_redirect/redirect_table.go (100.0%)</option>
				
				<option value="file148">github.com/bfenetworks/bfe/bfe_modules/mod_rewrite/action.go (0.0%)</option>
				
				<option value="file149">github.com/bfenetworks/bfe/bfe_modules/mod_rewrite/conf_mod_rewrite.go (86.7%)</option>
				
				<option value="file150">github.com/bfenetworks/bfe/bfe_modules/mod_rewrite/mod_rewrite.go (0.0%)</option>
				
				<option value="file151">github.com/bfenetworks/bfe/bfe_modules/mod_rewrite/rewrite_conf_load.go (82.4%)</option>
				
				<option value="file152">github.com/bfenetworks/bfe/bfe_modules/mod_rewrite/rewrite_table.go (100.0%)</option>
				
				<option value="file153">github.com/bfenetworks/bfe/bfe_modules/mod_secure_link/checker.go (82.7%)</option>
				
				<option value="file154">github.com/bfenetworks/bfe/bfe_modules/mod_secure_link/conf_load.go (66.7%)</option>
				
				<option value="file155">github.com/bfenetworks/bfe/bfe_modules/mod_secure_link/data_load.go (75.6%)</option>
				
				<option value="file156">github.com/bfenetworks/bfe/bfe_modules/mod_secure_link/mod_secure_link.go (50.0%)</option>
				
				<option value="file157">github.com/bfenetworks/bfe/bfe_modules/mod_secure_link/prodcut_table.go (100.0%)</option>
				
				<option value="file158">github.com/bfenetworks/bfe/bfe_modules/mod_static/action.go (76.5%)</option>
				
				<option value="file159">github.com/bfenetworks/bfe/bfe_modules/mod_static/conf_mod_static.go (66.7%)</option>
				
				<option value="file160">github.com/bfenetworks/bfe/bfe_modules/mod_static/mime_type_load.go (81.0%)</option>
				
				<option value="file161">github.com/bfenetworks/bfe/bfe_modules/mod_static/mime_type_table.go (100.0%)</option>
				
				<option value="file162">github.com/bfenetworks/bfe/bfe_modules/mod_static/mod_static.go (85.3%)</option>
				
				<option value="file163">github.com/bfenetworks/bfe/bfe_modules/mod_static/static_file.go (84.6%)</option>
				
				<option value="file164">github.com/bfenetworks/bfe/bfe_modules/mod_static/static_rule_load.go (84.4%)</option>
				
				<option value="file165">github.com/bfenetworks/bfe/bfe_modules/mod_static/static_rule_table.go (100.0%)</option>
				
				<option value="file166">github.com/bfenetworks/bfe/bfe_modules/mod_tag/conf_mod_tag.go (85.7%)</option>
				
				<option value="file167">github.com/bfenetworks/bfe/bfe_modules/mod_tag/mod_tag.go (82.6%)</option>
				
				<option value="file168">github.com/bfenetworks/bfe/bfe_modules/mod_tag/tag_rule_load.go (85.1%)</option>
				
				<option value="file169">github.com/bfenetworks/bfe/bfe_modules/mod_tag/tag_table.go (100.0%)</option>
				
				<option value="file170">github.com/bfenetworks/bfe/bfe_modules/mod_tcp_keepalive/conf_load.go (86.7%)</option>
				
				<option value="file171">github.com/bfenetworks/bfe/bfe_modules/mod_tcp_keepalive/data_load.go (81.0%)</option>
				
				<option value="file172">github.com/bfenetworks/bfe/bfe_modules/mod_tcp_keepalive/keepalive_darwin.go (75.0%)</option>
				
				<option value="file173">github.com/bfenetworks/bfe/bfe_modules/mod_tcp_keepalive/keepalive_table.go (100.0%)</option>
				
				<option value="file174">github.com/bfenetworks/bfe/bfe_modules/mod_tcp_keepalive/mod_tcp_keepalive.go (63.3%)</option>
				
				<option value="file175">github.com/bfenetworks/bfe/bfe_modules/mod_trace/conf_mod_trace.go (60.9%)</option>
				
				<option value="file176">github.com/bfenetworks/bfe/bfe_modules/mod_trace/mod_trace.go (66.0%)</option>
				
				<option value="file177">github.com/bfenetworks/bfe/bfe_modules/mod_trace/trace_rule_load.go (78.6%)</option>
				
				<option value="file178">github.com/bfenetworks/bfe/bfe_modules/mod_trace/trace_table.go (100.0%)</option>
				
				<option value="file179">github.com/bfenetworks/bfe/bfe_modules/mod_trust_clientip/conf_mod_trust_clientip.go (86.7%)</option>
				
				<option value="file180">github.com/bfenetworks/bfe/bfe_modules/mod_trust_clientip/mod_trust_clientip.go (53.9%)</option>
				
				<option value="file181">github.com/bfenetworks/bfe/bfe_modules/mod_trust_clientip/trustip_conf_load.go (78.3%)</option>
				
				<option value="file182">github.com/bfenetworks/bfe/bfe_modules/mod_userid/conf_mod_userid.go (100.0%)</option>
				
				<option value="file183">github.com/bfenetworks/bfe/bfe_modules/mod_userid/mod_userid.go (66.7%)</option>
				
				<option value="file184">github.com/bfenetworks/bfe/bfe_modules/mod_userid/userid_conf_load.go (81.0%)</option>
				
				<option value="file185">github.com/bfenetworks/bfe/bfe_modules/mod_waf/conf_mod_waf.go (92.3%)</option>
				
				<option value="file186">github.com/bfenetworks/bfe/bfe_modules/mod_waf/mod_waf.go (72.1%)</option>
				
				<option value="file187">github.com/bfenetworks/bfe/bfe_modules/mod_waf/waf_handler.go (84.0%)</option>
				
				<option value="file188">github.com/bfenetworks/bfe/bfe_modules/mod_waf/waf_job.go (100.0%)</option>
				
				<option value="file189">github.com/bfenetworks/bfe/bfe_modules/mod_waf/waf_log.go (87.5%)</option>
				
				<option value="file190">github.com/bfenetworks/bfe/bfe_modules/mod_waf/waf_rule/rule_bash_cmd.go (86.3%)</option>
				
				<option value="file191">github.com/bfenetworks/bfe/bfe_modules/mod_waf/waf_rule/rule_request_info.go (0.0%)</option>
				
				<option value="file192">github.com/bfenetworks/bfe/bfe_modules/mod_waf/waf_rule/waf_rule.go (100.0%)</option>
				
				<option value="file193">github.com/bfenetworks/bfe/bfe_modules/mod_waf/waf_rule_load.go (89.9%)</option>
				
				<option value="file194">github.com/bfenetworks/bfe/bfe_modules/mod_waf/waf_rule_table.go (100.0%)</option>
				
				<option value="file195">github.com/bfenetworks/bfe/bfe_net/textproto/header.go (46.2%)</option>
				
				<option value="file196">github.com/bfenetworks/bfe/bfe_net/textproto/pipeline.go (0.0%)</option>
				
				<option value="file197">github.com/bfenetworks/bfe/bfe_net/textproto/reader.go (86.6%)</option>
				
				<option value="file198">github.com/bfenetworks/bfe/bfe_net/textproto/textproto.go (7.1%)</option>
				
				<option value="file199">github.com/bfenetworks/bfe/bfe_net/textproto/writer.go (85.0%)</option>
				
				<option value="file200">github.com/bfenetworks/bfe/bfe_proxy/addr_proto.go (100.0%)</option>
				
				<option value="file201">github.com/bfenetworks/bfe/bfe_proxy/common.go (0.0%)</option>
				
				<option value="file202">github.com/bfenetworks/bfe/bfe_proxy/conn.go (93.2%)</option>
				
				<option value="file203">github.com/bfenetworks/bfe/bfe_proxy/header.go (86.0%)</option>
				
				<option value="file204">github.com/bfenetworks/bfe/bfe_proxy/v1.go (91.3%)</option>
				
				<option value="file205">github.com/bfenetworks/bfe/bfe_proxy/v2.go (87.4%)</option>
				
				<option value="file206">github.com/bfenetworks/bfe/bfe_proxy/version_cmd.go (87.5%)</option>
				
				<option value="file207">github.com/bfenetworks/bfe/bfe_route/cluster_table.go (90.5%)</option>
				
				<option value="file208">github.com/bfenetworks/bfe/bfe_route/host_table.go (0.0%)</option>
				
				<option value="file209">github.com/bfenetworks/bfe/bfe_route/server_data_conf.go (0.0%)</option>
				
				<option value="file210">github.com/bfenetworks/bfe/bfe_route/trie/trie.go (96.4%)</option>
				
				<option value="file211">github.com/bfenetworks/bfe/bfe_server/bfe_confdata_load.go (0.0%)</option>
				
				<option value="file212">github.com/bfenetworks/bfe/bfe_server/bfe_listener.go (0.0%)</option>
				
				<option value="file213">github.com/bfenetworks/bfe/bfe_server/bfe_server.go (0.0%)</option>
				
				<option value="file214">github.com/bfenetworks/bfe/bfe_server/bfe_server_init.go (0.0%)</option>
				
				<option value="file215">github.com/bfenetworks/bfe/bfe_server/bufio_cache.go (0.0%)</option>
				
				<option value="file216">github.com/bfenetworks/bfe/bfe_server/chunk_writer.go (0.0%)</option>
				
				<option value="file217">github.com/bfenetworks/bfe/bfe_server/expect_continue_reader.go (0.0%)</option>
				
				<option value="file218">github.com/bfenetworks/bfe/bfe_server/find_location.go (0.0%)</option>
				
				<option value="file219">github.com/bfenetworks/bfe/bfe_server/http_conn.go (0.0%)</option>
				
				<option value="file220">github.com/bfenetworks/bfe/bfe_server/http_server.go (0.0%)</option>
				
				<option value="file221">github.com/bfenetworks/bfe/bfe_server/https_listener.go (0.0%)</option>
				
				<option value="file222">github.com/bfenetworks/bfe/bfe_server/monitor_stat.go (0.0%)</option>
				
				<option value="file223">github.com/bfenetworks/bfe/bfe_server/protocol_handler.go (0.0%)</option>
				
				<option value="file224">github.com/bfenetworks/bfe/bfe_server/proxy_state.go (0.0%)</option>
				
				<option value="file225">github.com/bfenetworks/bfe/bfe_server/redirect.go (0.0%)</option>
				
				<option value="file226">github.com/bfenetworks/bfe/bfe_server/register_modules.go (0.0%)</option>
				
				<option value="file227">github.com/bfenetworks/bfe/bfe_server/response.go (1.7%)</option>
				
				<option value="file228">github.com/bfenetworks/bfe/bfe_server/reverseproxy.go (0.0%)</option>
				
				<option value="file229">github.com/bfenetworks/bfe/bfe_server/server_status.go (0.0%)</option>
				
				<option value="file230">github.com/bfenetworks/bfe/bfe_server/set_client_addr.go (0.0%)</option>
				
				<option value="file231">github.com/bfenetworks/bfe/bfe_server/tls_multi_cert.go (0.0%)</option>
				
				<option value="file232">github.com/bfenetworks/bfe/bfe_server/tls_server_rule.go (0.0%)</option>
				
				<option value="file233">github.com/bfenetworks/bfe/bfe_server/tls_session_cache.go (0.0%)</option>
				
				<option value="file234">github.com/bfenetworks/bfe/bfe_server/web_server.go (0.0%)</option>
				
				<option value="file235">github.com/bfenetworks/bfe/bfe_spdy/flow.go (77.8%)</option>
				
				<option value="file236">github.com/bfenetworks/bfe/bfe_spdy/frame_read.go (77.0%)</option>
				
				<option value="file237">github.com/bfenetworks/bfe/bfe_spdy/frame_types.go (80.0%)</option>
				
				<option value="file238">github.com/bfenetworks/bfe/bfe_spdy/frame_write.go (71.5%)</option>
				
				<option value="file239">github.com/bfenetworks/bfe/bfe_spdy/request_body.go (92.9%)</option>
				
				<option value="file240">github.com/bfenetworks/bfe/bfe_spdy/response_writer.go (92.3%)</option>
				
				<option value="file241">github.com/bfenetworks/bfe/bfe_spdy/server_conn.go (79.2%)</option>
				
				<option value="file242">github.com/bfenetworks/bfe/bfe_spdy/server_flow_control.go (82.1%)</option>
				
				<option value="file243">github.com/bfenetworks/bfe/bfe_spdy/server_process_frame.go (77.4%)</option>
				
				<option value="file244">github.com/bfenetworks/bfe/bfe_spdy/server_write_sched.go (83.8%)</option>
				
				<option value="file245">github.com/bfenetworks/bfe/bfe_spdy/spdy.go (54.2%)</option>
				
				<option value="file246">github.com/bfenetworks/bfe/bfe_spdy/state.go (0.0%)</option>
				
				<option value="file247">github.com/bfenetworks/bfe/bfe_stream/common.go (0.0%)</option>
				
				<option value="file248">github.com/bfenetworks/bfe/bfe_stream/server.go (82.4%)</option>
				
				<option value="file249">github.com/bfenetworks/bfe/bfe_stream/server_conn.go (92.6%)</option>
				
				<option value="file250">github.com/bfenetworks/bfe/bfe_stream/server_tester.go (88.6%)</option>
				
				<option value="file251">github.com/bfenetworks/bfe/bfe_tls/alert.go (0.0%)</option>
				
				<option value="file252">github.com/bfenetworks/bfe/bfe_tls/cipher_suites.go (57.3%)</option>
				
				<option value="file253">github.com/bfenetworks/bfe/bfe_tls/common.go (72.6%)</option>
				
				<option value="file254">github.com/bfenetworks/bfe/bfe_tls/conn.go (70.9%)</option>
				
				<option value="file255">github.com/bfenetworks/bfe/bfe_tls/crl_pool.go (0.0%)</option>
				
				<option value="file256">github.com/bfenetworks/bfe/bfe_tls/handshake_client.go (70.1%)</option>
				
				<option value="file257">github.com/bfenetworks/bfe/bfe_tls/handshake_messages.go (90.9%)</option>
				
				<option value="file258">github.com/bfenetworks/bfe/bfe_tls/handshake_server.go (72.2%)</option>
				
				<option value="file259">github.com/bfenetworks/bfe/bfe_tls/key_agreement.go (77.6%)</option>
				
				<option value="file260">github.com/bfenetworks/bfe/bfe_tls/prf.go (99.3%)</option>
				
				<option value="file261">github.com/bfenetworks/bfe/bfe_tls/state.go (0.0%)</option>
				
				<option value="file262">github.com/bfenetworks/bfe/bfe_tls/ticket.go (87.8%)</option>
				
				<option value="file263">github.com/bfenetworks/bfe/bfe_tls/tls.go (54.0%)</option>
				
				<option value="file264">github.com/bfenetworks/bfe/bfe_util/access_log/access_log.go (22.6%)</option>
				
				<option value="file265">github.com/bfenetworks/bfe/bfe_util/bns/bns_client.go (33.3%)</option>
				
				<option value="file266">github.com/bfenetworks/bfe/bfe_util/bns/bns_local.go (77.8%)</option>
				
				<option value="file267">github.com/bfenetworks/bfe/bfe_util/byte_pool/byte_pool.go (100.0%)</option>
				
				<option value="file268">github.com/bfenetworks/bfe/bfe_util/byte_pool/fixed_byte_pool.go (100.0%)</option>
				
				<option value="file269">github.com/bfenetworks/bfe/bfe_util/conf_path.go (0.0%)</option>
				
				<option value="file270">github.com/bfenetworks/bfe/bfe_util/copy_util.go (70.0%)</option>
				
				<option value="file271">github.com/bfenetworks/bfe/bfe_util/exit.go (0.0%)</option>
				
				<option value="file272">github.com/bfenetworks/bfe/bfe_util/file.go (0.0%)</option>
				
				<option value="file273">github.com/bfenetworks/bfe/bfe_util/fixed_pool.go (100.0%)</option>
				
				<option value="file274">github.com/bfenetworks/bfe/bfe_util/get_l4lb_info.go (0.0%)</option>
				
				<option value="file275">github.com/bfenetworks/bfe/bfe_util/get_net_info.go (0.0%)</option>
				
				<option value="file276">github.com/bfenetworks/bfe/bfe_util/hash_set/hash_set.go (85.4%)</option>
				
				<option value="file277">github.com/bfenetworks/bfe/bfe_util/hash_set/node_pool.go (94.8%)</option>
				
				<option value="file278">github.com/bfenetworks/bfe/bfe_util/ipdict/ip_loc_table.go (90.6%)</option>
				
				<option value="file279">github.com/bfenetworks/bfe/bfe_util/ipdict/ipdict.go (93.5%)</option>
				
				<option value="file280">github.com/bfenetworks/bfe/bfe_util/ipdict/ipdict_util.go (85.7%)</option>
				
				<option value="file281">github.com/bfenetworks/bfe/bfe_util/ipdict/iptable.go (70.0%)</option>
				
				<option value="file282">github.com/bfenetworks/bfe/bfe_util/ipdict/txt_load/txt_info.go (84.3%)</option>
				
				<option value="file283">github.com/bfenetworks/bfe/bfe_util/ipdict/txt_load/txt_load.go (82.2%)</option>
				
				<option value="file284">github.com/bfenetworks/bfe/bfe_util/json/json.go (85.7%)</option>
				
				<option value="file285">github.com/bfenetworks/bfe/bfe_util/json_util.go (0.0%)</option>
				
				<option value="file286">github.com/bfenetworks/bfe/bfe_util/mock_server.go (0.0%)</option>
				
				<option value="file287">github.com/bfenetworks/bfe/bfe_util/net_util/acl_table.go (0.0%)</option>
				
				<option value="file288">github.com/bfenetworks/bfe/bfe_util/net_util/ip.go (96.7%)</option>
				
				<option value="file289">github.com/bfenetworks/bfe/bfe_util/pipe/fixed_buffer.go (73.9%)</option>
				
				<option value="file290">github.com/bfenetworks/bfe/bfe_util/pipe/pipe.go (63.8%)</option>
				
				<option value="file291">github.com/bfenetworks/bfe/bfe_util/semver/semver.go (72.7%)</option>
				
				<option value="file292">github.com/bfenetworks/bfe/bfe_util/signal_table/register_signal.go (0.0%)</option>
				
				<option value="file293">github.com/bfenetworks/bfe/bfe_util/signal_table/signal_handlers.go (25.0%)</option>
				
				<option value="file294">github.com/bfenetworks/bfe/bfe_util/signal_table/signal_table.go (40.9%)</option>
				
				<option value="file295">github.com/bfenetworks/bfe/bfe_util/socket_util.go (0.0%)</option>
				
				<option value="file296">github.com/bfenetworks/bfe/bfe_util/time.go (91.7%)</option>
				
				<option value="file297">github.com/bfenetworks/bfe/bfe_websocket/common.go (66.7%)</option>
				
				<option value="file298">github.com/bfenetworks/bfe/bfe_websocket/server.go (95.5%)</option>
				
				<option value="file299">github.com/bfenetworks/bfe/bfe_websocket/server_conn.go (80.3%)</option>
				
				<option value="file300">github.com/bfenetworks/bfe/bfe_websocket/server_tester.go (91.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// backend framework for bfe

package backend

import (
        "fmt"
        "sync"
)

import (
        "github.com/bfenetworks/bfe/bfe_config/bfe_cluster_conf/cluster_table_conf"
)

// BfeBackend is a backend server.
type BfeBackend struct {
        // immutable
        Name       string // backend's name
        Addr       string // backend's address, e.g., "10.1.1.1"
        Port       int    // backend's port, e.g., 8080
        AddrInfo   string // backend's address and port, e.g., "10.1.1.1:8080"
        SubCluster string // name of sub-cluster

        sync.RWMutex      // guards following fields
        avail        bool // whether the backend is usable
        restarted    bool // indicate if this backend is new bring-up by health-check
        connNum      int  // number of connections backend hold
        failNum      int  // number of consecutive failures of normal requests
        succNum      int  // number of consecutive successes of health-check request

        closeChan chan bool // tell health-check to stop

}

func NewBfeBackend() *BfeBackend <span class="cov8" title="1">{
        backend := new(BfeBackend)
        backend.avail = true
        backend.closeChan = make(chan bool)

        return backend
}</span>

// Init initializes BfeBackend with BackendConf
func (back *BfeBackend) Init(subCluster string, conf *cluster_table_conf.BackendConf) <span class="cov8" title="1">{
        back.Name = *conf.Name
        back.Addr = *conf.Addr
        back.Port = *conf.Port
        back.AddrInfo = fmt.Sprintf("%s:%d", back.Addr, back.Port)
        back.SubCluster = subCluster
}</span>

func (back *BfeBackend) GetAddr() string <span class="cov8" title="1">{
        return back.Addr
}</span>

func (back *BfeBackend) GetAddrInfo() string <span class="cov8" title="1">{
        return back.AddrInfo
}</span>

func (back *BfeBackend) Avail() bool <span class="cov8" title="1">{
        back.RLock()
        avail := back.avail
        back.RUnlock()

        return avail
}</span>

func (back *BfeBackend) SetAvail(avail bool) <span class="cov8" title="1">{
        back.Lock()
        back.setAvail(avail)
        back.Unlock()
}</span>

func (back *BfeBackend) setAvail(avail bool) <span class="cov8" title="1">{
        // no lock, caller to call lock
        back.avail = avail
        if back.avail </span><span class="cov8" title="1">{
                back.failNum = 0
        }</span>
}

func (back *BfeBackend) SetRestart(restart bool) <span class="cov8" title="1">{
        back.Lock()
        back.restarted = restart
        back.Unlock()
}</span>

func (back *BfeBackend) GetRestart() bool <span class="cov0" title="0">{
        back.RLock()
        restart := back.restarted
        back.RUnlock()
        return restart
}</span>

func (back *BfeBackend) ConnNum() int <span class="cov0" title="0">{
        back.RLock()
        connNum := back.connNum
        back.RUnlock()

        return connNum
}</span>

func (back *BfeBackend) IncConnNum() <span class="cov0" title="0">{
        back.Lock()
        back.connNum++
        back.Unlock()
}</span>

func (back *BfeBackend) DecConnNum() <span class="cov0" title="0">{
        back.Lock()
        back.connNum--
        back.Unlock()
}</span>

func (back *BfeBackend) AddFailNum() <span class="cov0" title="0">{
        back.Lock()
        back.failNum++
        back.Unlock()
}</span>

func (back *BfeBackend) ResetFailNum() <span class="cov0" title="0">{
        back.Lock()
        back.failNum = 0
        back.Unlock()
}</span>

func (back *BfeBackend) FailNum() int <span class="cov0" title="0">{
        back.RLock()
        failNum := back.failNum
        back.RUnlock()

        return failNum
}</span>

func (back *BfeBackend) AddSuccNum() <span class="cov8" title="1">{
        back.Lock()
        back.succNum++
        back.Unlock()
}</span>

func (back *BfeBackend) ResetSuccNum() <span class="cov0" title="0">{
        back.Lock()
        back.succNum = 0
        back.Unlock()
}</span>

func (back *BfeBackend) SuccNum() int <span class="cov8" title="1">{
        back.Lock()
        succNum := back.succNum
        back.Unlock()

        return succNum
}</span>

// CheckAvail check whether backend becomes available.
func (back *BfeBackend) CheckAvail(succThreshold int) bool <span class="cov8" title="1">{
        back.Lock()
        defer back.Unlock()

        if back.succNum &gt;= succThreshold </span><span class="cov8" title="1">{
                back.succNum = 0
                return true
        }</span>

        <span class="cov8" title="1">return false</span>
}

func (back *BfeBackend) UpdateStatus(failThreshold int) bool <span class="cov0" title="0">{
        back.Lock()
        defer back.Unlock()

        prevStatus := back.avail

        // set status to false when failNum &gt;= threshold and
        // return true if status flip to false.
        if back.failNum &gt;= failThreshold </span><span class="cov0" title="0">{
                back.setAvail(false)
                if prevStatus </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

func (back *BfeBackend) Release() <span class="cov0" title="0">{
        back.Close()
}</span>

func (back *BfeBackend) Close() <span class="cov0" title="0">{
        close(back.closeChan)
}</span>

func (back *BfeBackend) CloseChan() &lt;-chan bool <span class="cov8" title="1">{
        return back.closeChan
}</span>

// OnSuccess is called when request backend success
func (back *BfeBackend) OnSuccess() <span class="cov0" title="0">{
        // reset backend failnum
        back.ResetFailNum()
}</span>

// OnFail is called when request backend fail
func (back *BfeBackend) OnFail(cluster string) <span class="cov0" title="0">{
        back.AddFailNum()
        UpdateStatus(back, cluster)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// health check for backend

package backend

import (
        "fmt"
        "net"
        "net/http"
        "strings"
        "time"
)

import (
        "github.com/baidu/go-lib/log"
)

import (
        "github.com/bfenetworks/bfe/bfe_config/bfe_cluster_conf/cluster_conf"
        "github.com/bfenetworks/bfe/bfe_debug"
)

func UpdateStatus(backend *BfeBackend, cluster string) bool <span class="cov0" title="0">{
        // get conf of health check, which is separately stored for each cluster
        checkConf := getCheckConf(cluster)
        if checkConf == nil </span><span class="cov0" title="0">{
                // just ignore if not found health check conf
                return false
        }</span>

        // UpdateStatus update backend status.
        // if backend's status become fail, start healthcheck.
        // at most start 1 check goroutine for each backend.
        <span class="cov0" title="0">if backend.UpdateStatus(*checkConf.FailNum) </span><span class="cov0" title="0">{
                go check(backend, cluster)
                return true
        }</span>

        <span class="cov0" title="0">return false</span>
}

func check(backend *BfeBackend, cluster string) <span class="cov8" title="1">{
        log.Logger.Info("start healthcheck for %s", backend.Name)

        // backend close chan
        c := backend.CloseChan()

loop:
        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-c:<span class="cov0" title="0"> // backend deleted
                        break loop</span>
                default:<span class="cov8" title="1"></span>
                }

                // get the latest conf to do health check
                <span class="cov8" title="1">checkConf := getCheckConf(cluster)
                if checkConf == nil </span><span class="cov0" title="0">{
                        // never come here
                        time.Sleep(time.Second)
                        continue</span>
                }
                <span class="cov8" title="1">checkInterval := time.Duration(*checkConf.CheckInterval) * time.Millisecond

                // health check
                if ok, err := CheckConnect(backend, checkConf); !ok </span><span class="cov0" title="0">{
                        backend.ResetSuccNum()
                        if bfe_debug.DebugHealthCheck </span><span class="cov0" title="0">{
                                log.Logger.Debug("backend %s still not avail (check failure: %s)", backend.Name, err)
                        }</span>
                        <span class="cov0" title="0">time.Sleep(checkInterval)
                        continue</span>
                }

                // check whether backend becomes available
                <span class="cov8" title="1">backend.AddSuccNum()
                if !backend.CheckAvail(*checkConf.SuccNum) </span><span class="cov8" title="1">{
                        if bfe_debug.DebugHealthCheck </span><span class="cov0" title="0">{
                                log.Logger.Debug("backend %s still not avail (check success, waiting for more checks)", backend.Name)
                        }</span>
                        <span class="cov8" title="1">time.Sleep(checkInterval)
                        continue</span>
                }

                <span class="cov8" title="1">log.Logger.Info("backend %s back to Normal", backend.Name)
                backend.SetRestart(true)
                backend.SetAvail(true)
                break loop</span>
        }
}

func getHealthCheckAddrInfo(backend *BfeBackend, checkConf *cluster_conf.BackendCheck) string <span class="cov8" title="1">{
        if checkConf.Host != nil </span><span class="cov8" title="1">{
                // if port for health check is configured, use it instead of backend port
                hostInfo := strings.Split(*checkConf.Host, ":")
                if len(hostInfo) == 2 </span><span class="cov8" title="1">{
                        port := hostInfo[1]
                        return fmt.Sprintf("%s:%s", backend.GetAddr(), port)
                }</span>
        }
        <span class="cov8" title="1">return backend.GetAddrInfo()</span>
}

func checkTCPConnect(backend *BfeBackend, checkConf *cluster_conf.BackendCheck) (bool, error) <span class="cov8" title="1">{
        addrInfo := getHealthCheckAddrInfo(backend, checkConf)

        var conn net.Conn
        var err error
        if checkConf.CheckTimeout != nil </span><span class="cov8" title="1">{
                conn, err = net.DialTimeout("tcp", addrInfo,
                        time.Duration(*checkConf.CheckTimeout)*time.Millisecond)
        }</span> else<span class="cov8" title="1"> {
                conn, err = net.Dial("tcp", addrInfo)
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">conn.Close()
        return true, nil</span>
}

func doHTTPHealthCheck(request *http.Request, timeout time.Duration) (int, error) <span class="cov8" title="1">{
        client := &amp;http.Client{
                // Note: disable following an HTTP redirect
                CheckRedirect: func(*http.Request, []*http.Request) error </span><span class="cov8" title="1">{ return http.ErrUseLastResponse }</span>,
                // Note: timeout of zero means no timeout
                Timeout: timeout,
        }

        <span class="cov8" title="1">response, err := client.Do(request)
        if err != nil </span><span class="cov0" title="0">{
                return -1, err
        }</span>
        <span class="cov8" title="1">defer response.Body.Close()

        return response.StatusCode, nil</span>
}

func checkHTTPConnect(backend *BfeBackend, checkConf *cluster_conf.BackendCheck) (bool, error) <span class="cov8" title="1">{
        // prepare health check request
        addrInfo := getHealthCheckAddrInfo(backend, checkConf)
        urlStr := fmt.Sprintf("%s://%s%s", "http", addrInfo, *checkConf.Uri)
        request, err := http.NewRequest("GET", urlStr, nil)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        // modify http host header if needed
        <span class="cov8" title="1">if checkConf.Host != nil </span><span class="cov8" title="1">{
                request.Host = *checkConf.Host
        }</span>

        // add headers required by downstream servers
        <span class="cov8" title="1">request.Header.Set("Accept", "*/*")

        // do http health check
        checkTimeout := time.Duration(0)
        if checkConf.CheckTimeout != nil </span><span class="cov8" title="1">{
                checkTimeout = time.Duration(*checkConf.CheckTimeout) * time.Millisecond
        }</span>

        <span class="cov8" title="1">statusCode, err := doHTTPHealthCheck(request, checkTimeout)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov8" title="1">return cluster_conf.MatchStatusCode(statusCode, *checkConf.StatusCode)</span>
}

// CheckConnect checks whether backend server become available.
func CheckConnect(backend *BfeBackend, checkConf *cluster_conf.BackendCheck) (bool, error) <span class="cov8" title="1">{
        switch *checkConf.Schem </span>{
        case "http":<span class="cov8" title="1">
                return checkHTTPConnect(backend, checkConf)</span>
        case "tcp":<span class="cov8" title="1">
                return checkTCPConnect(backend, checkConf)</span>
        default:<span class="cov8" title="1">
                // never come here
                return checkHTTPConnect(backend, checkConf)</span>
        }
}

// CheckConfFetcher returns current health check conf for cluster.
type CheckConfFetcher func(cluster string) *cluster_conf.BackendCheck

var checkConfFetcher CheckConfFetcher

func getCheckConf(cluster string) *cluster_conf.BackendCheck <span class="cov8" title="1">{
        if checkConfFetcher == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return checkConfFetcher(cluster)</span>
}

// SetCheckConfFetcher initializes CheckConfFetcher handler.
func SetCheckConfFetcher(confFetcher CheckConfFetcher) <span class="cov0" title="0">{
        checkConfFetcher = confFetcher
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// sub-cluster level load balance using gslb

package bal_gslb

import (
        "encoding/binary"
        "fmt"
        "math/rand"
        "net"
        "sort"
        "sync"
        "time"
)

import (
        "github.com/baidu/go-lib/log"
        "github.com/baidu/go-lib/web-monitor/metrics"
)

import (
        bal_backend "github.com/bfenetworks/bfe/bfe_balance/backend"
        "github.com/bfenetworks/bfe/bfe_balance/bal_slb"
        "github.com/bfenetworks/bfe/bfe_basic"
        "github.com/bfenetworks/bfe/bfe_config/bfe_cluster_conf/cluster_conf"
        "github.com/bfenetworks/bfe/bfe_config/bfe_cluster_conf/cluster_table_conf"
        "github.com/bfenetworks/bfe/bfe_config/bfe_cluster_conf/gslb_conf"
)

const (
        DefaultRetryMax      = 3 // default max retries in assigned sub cluster
        DefaultCrossRetryMax = 1 // default max retries in other sub cluster, if retries in assigned sub cluster fail
)

type BalanceGslb struct {
        lock sync.Mutex

        name        string         // name of cluster, e.g., "news"
        subClusters SubClusterList // list of sub cluster

        totalWeight int  // sum weight of sub clusters that has a weight &gt;0
        single      bool // only one sub cluster?
        avail       int  // if single is true, avail is index of avail sub cluster

        retryMax    int                   // max retries in assigned sub cluster
        crossRetry  int                   // max retries in other sub cluster, if all retry within assigned sub cluster fail
        hashConf    cluster_conf.HashConf // gslb hash conf
        BalanceMode string                // balanceMode, WRR or WLC, defined in cluster_conf
}

func NewBalanceGslb(name string) *BalanceGslb <span class="cov8" title="1">{
        bal := new(BalanceGslb)
        bal.name = name

        bal.retryMax = DefaultRetryMax
        bal.crossRetry = DefaultCrossRetryMax
        defaultStrategy := cluster_conf.ClientIpOnly
        defaultSessionSticky := false
        bal.hashConf = cluster_conf.HashConf{
                HashStrategy:  &amp;defaultStrategy,
                SessionSticky: &amp;defaultSessionSticky,
        }
        bal.BalanceMode = cluster_conf.BalanceModeWrr

        return bal
}</span>

func (bal *BalanceGslb) SetGslbBasic(gslbBasic cluster_conf.GslbBasicConf) <span class="cov8" title="1">{
        bal.lock.Lock()

        bal.crossRetry = *gslbBasic.CrossRetry
        bal.retryMax = *gslbBasic.RetryMax
        bal.hashConf = *gslbBasic.HashConf
        bal.BalanceMode = *gslbBasic.BalanceMode

        bal.lock.Unlock()
}</span>

func (bal *BalanceGslb) SetSlowStart(backendConf cluster_conf.BackendBasic) <span class="cov8" title="1">{
        bal.lock.Lock()

        for _, sub := range bal.subClusters </span><span class="cov8" title="1">{
                sub.setSlowStart(*backendConf.SlowStartTime)
        }</span>

        <span class="cov8" title="1">bal.lock.Unlock()</span>
}

// Init initializes gslb cluster with config
func (bal *BalanceGslb) Init(gslbConf gslb_conf.GslbClusterConf) error <span class="cov8" title="1">{
        totalWeight := 0

        for subClusterName, weight := range gslbConf </span><span class="cov8" title="1">{
                subCluster := newSubCluster(subClusterName)
                subCluster.weight = weight

                if weight &gt; 0 </span><span class="cov8" title="1">{
                        totalWeight += weight
                }</span>

                // add sub-cluster to cluster
                <span class="cov8" title="1">bal.subClusters = append(bal.subClusters, subCluster)</span>
        }

        <span class="cov8" title="1">if totalWeight == 0 </span><span class="cov0" title="0">{
                // should never be here, as ClusterCheck return true
                log.Logger.Critical("gslb total weight = 0 [%s]", bal.name)
                return fmt.Errorf("gslb total weight = 0 [%s]", bal.name)
        }</span>

        <span class="cov8" title="1">bal.totalWeight = totalWeight

        // sort list to guarantee same order, since map iteration is not in order
        sort.Sort(SubClusterListSorter{bal.subClusters})
        availNum := 0
        for index, sub := range bal.subClusters </span><span class="cov8" title="1">{
                if sub.weight &gt; 0 </span><span class="cov8" title="1">{
                        bal.avail = index
                        availNum += 1
                }</span>
        }
        <span class="cov8" title="1">bal.single = (availNum == 1)

        return nil</span>
}

func (bal *BalanceGslb) BackendInit(clusterBackend cluster_table_conf.ClusterBackend) error <span class="cov0" title="0">{
        bal.lock.Lock()

        for _, subCluster := range bal.subClusters </span><span class="cov0" title="0">{
                if backend, ok := clusterBackend[subCluster.Name]; ok </span><span class="cov0" title="0">{
                        subCluster.init(backend)
                }</span>
        }

        <span class="cov0" title="0">bal.lock.Unlock()
        return nil</span>
}

// Reload reloads gslb config
func (bal *BalanceGslb) Reload(gslbConf gslb_conf.GslbClusterConf) error <span class="cov8" title="1">{
        bal.lock.Lock()
        defer bal.lock.Unlock()

        // create new SubClusterList
        var subListNew SubClusterList

        // create a map to record exist subCluster in gslbConf
        subExist := make(map[string]bool)

        // go through existing sub cluster, and doing update
        for i := 0; i &lt; len(bal.subClusters); i++ </span><span class="cov8" title="1">{
                sub := bal.subClusters[i]

                // find new conf of sub in gslbConf
                weight, ok := gslbConf[sub.Name]

                if ok </span><span class="cov8" title="1">{
                        // exist in new conf
                        sub.weight = weight

                        // add sub cluster to subListNew
                        subListNew = append(subListNew, sub)
                }</span> else<span class="cov0" title="0"> {
                        // release sub_cluster
                        sub.release()
                        log.Logger.Info("release subcluster %s", sub.Name)
                }</span>

                // record in the map of subExist
                <span class="cov8" title="1">subExist[sub.Name] = true</span>
        }

        // go through gslbConf, and doing init for those not in subExist
        <span class="cov8" title="1">for subName, weight := range gslbConf </span><span class="cov8" title="1">{
                _, ok := subExist[subName]

                if !ok </span><span class="cov0" title="0">{
                        // create new sub cluster
                        sub := newSubCluster(subName)
                        sub.weight = weight

                        // add sub cluster to subListNew
                        subListNew = append(subListNew, sub)
                }</span>
        }

        // sort list
        <span class="cov8" title="1">sort.Sort(SubClusterListSorter{subListNew})

        // calc total_weight
        totalWeight := 0
        availableNum := 0
        lastAvailIndex := 0

        for index, sub := range subListNew </span><span class="cov8" title="1">{
                if sub.weight &gt; 0 </span><span class="cov8" title="1">{
                        totalWeight += sub.weight
                        availableNum += 1
                        lastAvailIndex = index
                }</span>
        }

        <span class="cov8" title="1">if totalWeight == 0 </span><span class="cov0" title="0">{
                // should never be here, as ClusterCheck return true
                log.Logger.Critical("gslb total weight = 0 [%s]", bal.name)
                return fmt.Errorf("gslb total weight = 0 [%s]", bal.name)
        }</span>

        <span class="cov8" title="1">bal.totalWeight = totalWeight

        if availableNum == 1 </span><span class="cov0" title="0">{
                bal.single = true
                bal.avail = lastAvailIndex
        }</span> else<span class="cov8" title="1"> {
                bal.single = false
        }</span>

        // update gslb.subClusters
        <span class="cov8" title="1">bal.subClusters = subListNew

        return nil</span>
}

func (bal *BalanceGslb) BackendReload(clusterBackend cluster_table_conf.ClusterBackend) error <span class="cov0" title="0">{
        bal.lock.Lock()

        for _, subCluster := range bal.subClusters </span><span class="cov0" title="0">{
                if backend, ok := clusterBackend[subCluster.Name]; ok </span><span class="cov0" title="0">{
                        subCluster.update(backend)
                }</span>
        }

        <span class="cov0" title="0">bal.lock.Unlock()

        return nil</span>
}

func (bal *BalanceGslb) Release() <span class="cov0" title="0">{
        bal.lock.Lock()

        // go through all sub clusters
        for i := 0; i &lt; len(bal.subClusters); i++ </span><span class="cov0" title="0">{
                // release sub_cluster
                bal.subClusters[i].release()
        }</span>

        <span class="cov0" title="0">bal.lock.Unlock()</span>
}

// getHashKey returns hash key according hash strategy
func (bal *BalanceGslb) getHashKey(req *bfe_basic.Request) []byte <span class="cov0" title="0">{
        var clientIP net.IP
        var hashKey []byte

        if req.ClientAddr != nil </span><span class="cov0" title="0">{
                clientIP = req.ClientAddr.IP
        }</span> else<span class="cov0" title="0"> {
                clientIP = nil
        }</span>

        <span class="cov0" title="0">switch *bal.hashConf.HashStrategy </span>{
        case cluster_conf.ClientIdOnly:<span class="cov0" title="0">
                hashKey = getHashKeyByHeader(req, *bal.hashConf.HashHeader)</span>

        case cluster_conf.ClientIpOnly:<span class="cov0" title="0">
                hashKey = clientIP</span>

        case cluster_conf.ClientIdPreferred:<span class="cov0" title="0">
                hashKey = getHashKeyByHeader(req, *bal.hashConf.HashHeader)
                if hashKey == nil </span><span class="cov0" title="0">{
                        hashKey = clientIP
                }</span>

        case cluster_conf.RequestURI:<span class="cov0" title="0">
                hashKey = []byte(req.HttpRequest.RequestURI)</span>
        }

        // if hashKey is empty, use random value
        <span class="cov0" title="0">if len(hashKey) == 0 </span><span class="cov0" title="0">{
                hashKey = make([]byte, 8)
                binary.BigEndian.PutUint64(hashKey, rand.Uint64())
        }</span>

        <span class="cov0" title="0">return hashKey</span>
}

func getHashKeyByHeader(req *bfe_basic.Request, header string) []byte <span class="cov0" title="0">{
        if val := req.HttpRequest.Header.Get(header); len(val) &gt; 0 </span><span class="cov0" title="0">{
                return []byte(val)
        }</span>

        <span class="cov0" title="0">if cookieKey, ok := cluster_conf.GetCookieKey(header); ok </span><span class="cov0" title="0">{
                if cookie, ok := req.Cookie(cookieKey); ok </span><span class="cov0" title="0">{
                        return []byte(cookie.Value)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// Balance selects a backend for given request.
func (bal *BalanceGslb) Balance(req *bfe_basic.Request) (*bal_backend.BfeBackend, error) <span class="cov0" title="0">{
        var backend *bal_backend.BfeBackend
        var current *SubCluster
        var err error
        var balAlgor int

        bal.lock.Lock()
        defer bal.lock.Unlock()

        if req.RetryTime &gt; (bal.retryMax + bal.crossRetry) </span><span class="cov0" title="0">{
                // both in-cluster and cross-cluster retry failed.
                state.ErrBkRetryTooMany.Inc(1)
                // Note: req.ErrCode is not modified to ErrBkRetryTooMany, to record last error msg
                return nil, bfe_basic.ErrBkRetryTooMany
        }</span>

        // select balance mode
        <span class="cov0" title="0">switch bal.BalanceMode </span>{
        case cluster_conf.BalanceModeWlc:<span class="cov0" title="0">
                balAlgor = bal_slb.WlcSmooth</span>
        default:<span class="cov0" title="0">
                balAlgor = bal_slb.WrrSmooth</span>
        }

        // If use sticky session feature, bfe bind a user's session to a specific backend.
        // All requests from the user during the session are sent to the same backend.
        <span class="cov0" title="0">if *bal.hashConf.SessionSticky </span><span class="cov0" title="0">{
                balAlgor = bal_slb.WrrSticky
        }</span>

        <span class="cov0" title="0">hashKey := bal.getHashKey(req)

        // subCluster-level balance
        current, err = bal.subClusterBalance(hashKey)
        if err != nil </span><span class="cov0" title="0">{
                // no sub cluster available
                state.ErrBkNoSubCluster.Inc(1)
                req.ErrCode = bfe_basic.ErrBkNoSubCluster
                return nil, bfe_basic.ErrBkNoSubCluster
        }</span>
        <span class="cov0" title="0">req.Backend.SubclusterName = current.Name
        log.Logger.Debug("sub cluster=[%s],total_weight=[%d]",
                current.Name, bal.totalWeight)

        // after get the distribution subcluster

        // black hole
        if current.sType == TypeGslbBlackhole </span><span class="cov0" title="0">{
                state.ErrGslbBlackhole.Inc(1)
                req.ErrCode = bfe_basic.ErrGslbBlackhole
                return nil, bfe_basic.ErrGslbBlackhole
        }</span>

        // still in-cluster selection
        <span class="cov0" title="0">if req.RetryTime &lt;= bal.retryMax </span><span class="cov0" title="0">{
                backend, err = current.balance(balAlgor, hashKey)
                if err == nil </span><span class="cov0" title="0">{
                        return backend, nil
                }</span> else<span class="cov0" title="0"> {
                        // fail to get backend from current sub-cluster
                        state.ErrBkNoBackend.Inc(1)
                        log.Logger.Info("gslb.Balance():no backend(in cluster):cluster[%s], sub[%s], err[%s]",
                                bal.name, current.Name, err.Error())
                        req.ErrMsg = fmt.Sprintf("cluster[%s], sub[%s], err[%s]", bal.name, current.Name, err.Error())
                        // Note: all backends down in current sub-cluster, may cross retry
                        req.RetryTime = bal.retryMax
                }</span>
        }

        // check if cross retry is disabled
        <span class="cov0" title="0">if bal.crossRetry &lt;= 0 </span><span class="cov0" title="0">{
                req.ErrCode = bfe_basic.ErrBkNoBackend
                return nil, bfe_basic.ErrBkNoBackend
        }</span>

        // in-cluster selection failed, select from cross-cluster
        <span class="cov0" title="0">log.Logger.Debug("start cross-cluster selection , retry = %d", req.RetryTime)
        if req.Stat != nil </span><span class="cov0" title="0">{
                req.Stat.IsCrossCluster = true
        }</span>

        <span class="cov0" title="0">current, err = bal.randomSelectExclude(current)
        if err != nil </span><span class="cov0" title="0">{
                state.ErrBkNoSubClusterCross.Inc(1)
                req.ErrCode = bfe_basic.ErrBkNoSubClusterCross
                return nil, bfe_basic.ErrBkNoSubClusterCross
        }</span>
        <span class="cov0" title="0">req.Backend.SubclusterName = current.Name

        backend, err = current.balance(balAlgor, hashKey)
        if err == nil </span><span class="cov0" title="0">{
                return backend, nil
        }</span>

        // fail to get backend from current sub-cluster
        <span class="cov0" title="0">state.ErrBkNoBackend.Inc(1)
        req.ErrCode = bfe_basic.ErrBkNoBackend
        req.ErrMsg = fmt.Sprintf("cluster[%s], sub[%s], err[%s]", bal.name, current.Name, err.Error())
        log.Logger.Info("gslb.Balance():no backend(cross cluster):cluster[%s], sub[%s], err[%s]",
                bal.name, current.Name, err.Error())

        return backend, bfe_basic.ErrBkCrossRetryBalance</span>
}

// subClusterBalance selects one sub cluster.
func (bal *BalanceGslb) subClusterBalance(value []byte) (*SubCluster, error) <span class="cov0" title="0">{
        var subCluster *SubCluster
        var w int

        if bal == nil </span><span class="cov0" title="0">{
                return subCluster, fmt.Errorf("gslb is nil")
        }</span>

        <span class="cov0" title="0">if bal.totalWeight == 0 </span><span class="cov0" title="0">{
                return subCluster, fmt.Errorf("totalWeight is 0")
        }</span>

        <span class="cov0" title="0">if bal.single </span><span class="cov0" title="0">{
                return bal.subClusters[bal.avail], nil
        }</span>

        <span class="cov0" title="0">w = bal_slb.GetHash(value, uint(bal.totalWeight))

        for i := 0; i &lt; len(bal.subClusters); i++ </span><span class="cov0" title="0">{
                subCluster = bal.subClusters[i]
                if subCluster.weight &lt;= 0 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">w -= subCluster.weight
                // got it
                if w &lt; 0 </span><span class="cov0" title="0">{
                        break</span>
                }
        }

        <span class="cov0" title="0">return subCluster, nil</span>
}

// randomSelectExclude randomly selects a sub cluster, exclude exclude_sub_cluster, gslb blackhole.
func (bal *BalanceGslb) randomSelectExclude(excludeCluster *SubCluster) (*SubCluster, error) <span class="cov0" title="0">{
        var i int
        var subCluster *SubCluster

        available := 0

        for i = 0; i &lt; len(bal.subClusters); i++ </span><span class="cov0" title="0">{
                subCluster = bal.subClusters[i]
                if subCluster != excludeCluster &amp;&amp; subCluster.weight &gt;= 0 &amp;&amp;
                        subCluster.sType != TypeGslbBlackhole </span><span class="cov0" title="0">{
                        available++
                }</span>
        }

        <span class="cov0" title="0">if available == 0 </span><span class="cov0" title="0">{
                return subCluster, fmt.Errorf("no sub cluster available")
        }</span>

        <span class="cov0" title="0">r := rand.New(rand.NewSource(time.Now().UnixNano()))
        n := int(r.Int31()) % available

        for i = 0; i &lt; len(bal.subClusters); i++ </span><span class="cov0" title="0">{
                subCluster = bal.subClusters[i]
                if subCluster != excludeCluster &amp;&amp; subCluster.weight &gt;= 0 &amp;&amp;
                        subCluster.sType != TypeGslbBlackhole </span><span class="cov0" title="0">{
                        if n == 0 </span><span class="cov0" title="0">{
                                return subCluster, nil
                        }</span> else<span class="cov0" title="0"> {
                                n--
                        }</span>
                }
        }

        // never reach here
        <span class="cov0" title="0">return subCluster, fmt.Errorf("randomSelectExclude():should not reach here")</span>
}

func (bal *BalanceGslb) SubClusterNum() int <span class="cov0" title="0">{
        return len(bal.subClusters)
}</span>

type BalErrState struct {
        ErrBkNoSubCluster      *metrics.Counter
        ErrBkNoSubClusterCross *metrics.Counter
        ErrBkNoBackend         *metrics.Counter
        ErrBkRetryTooMany      *metrics.Counter
        ErrGslbBlackhole       *metrics.Counter
}

var state BalErrState

func GetBalErrState() *BalErrState <span class="cov0" title="0">{
        return &amp;state
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package bal_gslb

// SubClusterState is state of sub-cluster.
type SubClusterState struct {
        BackendNum int // number of backends
}

// GslbState is state of cluster.
type GslbState struct {
        SubClusters map[string]*SubClusterState // state of sub-cluster
        BackendNum  int                         // number of cluster backend
}

func State(bal *BalanceGslb) *GslbState <span class="cov0" title="0">{
        gslbState := new(GslbState)
        gslbState.SubClusters = make(map[string]*SubClusterState)

        bal.lock.Lock()

        for _, sub := range bal.subClusters </span><span class="cov0" title="0">{
                subState := &amp;SubClusterState{
                        BackendNum: sub.Len(),
                }

                gslbState.SubClusters[sub.Name] = subState
                gslbState.BackendNum += subState.BackendNum
        }</span>

        <span class="cov0" title="0">bal.lock.Unlock()

        return gslbState</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package bal_gslb

import (
        "fmt"
)

import (
        "github.com/bfenetworks/bfe/bfe_balance/backend"
        "github.com/bfenetworks/bfe/bfe_balance/bal_slb"
        "github.com/bfenetworks/bfe/bfe_config/bfe_cluster_conf/cluster_table_conf"
)

// type of sub cluster
const (
        TypeGslbNormal    = 0 // normal sub cluster
        TypeGslbBlackhole = 1 // gslb black hole
)

type SubCluster struct {
        Name     string             // name of sub cluster
        sType    int                // TypeGslbNormal, or TypeGslbBlackhole
        backends *bal_slb.BalanceRR // backend with round-robin
        weight   int                // weight between sub-clusters
}

func newSubCluster(name string) *SubCluster <span class="cov8" title="1">{
        sub := new(SubCluster)

        // set name
        sub.Name = name

        // set type
        if name == "GSLB_BLACKHOLE" </span><span class="cov8" title="1">{
                sub.sType = TypeGslbBlackhole
        }</span> else<span class="cov8" title="1"> {
                sub.sType = TypeGslbNormal
        }</span>

        // create backends
        <span class="cov8" title="1">sub.backends = bal_slb.NewBalanceRR(name)

        return sub</span>
}

// init initializes sub-cluster with backend list.
func (sub *SubCluster) init(backends cluster_table_conf.SubClusterBackend) <span class="cov0" title="0">{
        sub.backends.Init(backends)
}</span>

// update updates sub-cluster with backend list.
func (sub *SubCluster) update(backends cluster_table_conf.SubClusterBackend) <span class="cov0" title="0">{
        sub.backends.Update(backends)
}</span>

// release releases sub-cluster.
func (sub *SubCluster) release() <span class="cov0" title="0">{
        sub.backends.Release()
}</span>

// Len return length of sub-cluster.
func (sub *SubCluster) Len() int <span class="cov0" title="0">{
        return sub.backends.Len()
}</span>

func (sub *SubCluster) balance(algor int, key []byte) (*backend.BfeBackend, error) <span class="cov0" title="0">{
        if sub.backends.Len() == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no backend in sub cluster [%s]", sub.Name)
        }</span>

        // balance from sub-cluster
        <span class="cov0" title="0">return sub.backends.Balance(algor, key)</span>
}

func (sub *SubCluster) setSlowStart(slowStartTime int) <span class="cov8" title="1">{
        sub.backends.SetSlowStart(slowStartTime)
}</span>

// SubClusterList is a list of sub-cluster.
type SubClusterList []*SubCluster

type SubClusterListSorter struct {
        l SubClusterList
}

func (s SubClusterListSorter) Len() int <span class="cov8" title="1">{
        return len(s.l)
}</span>

func (s SubClusterListSorter) Swap(i, j int) <span class="cov8" title="1">{
        s.l[i], s.l[j] = s.l[j], s.l[i]
}</span>

func (s SubClusterListSorter) Less(i, j int) bool <span class="cov8" title="1">{
        return s.l[i].Name &lt; s.l[j].Name
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// backend with round-robin

package bal_slb

import (
        "time"
)

import (
        "github.com/bfenetworks/bfe/bfe_balance/backend"
        "github.com/bfenetworks/bfe/bfe_config/bfe_cluster_conf/cluster_table_conf"
)

type WeightSS struct {
        final         int       // final target weight after slow-start
        slowStartTime int       // time for backend increases the weight to the full value, in seconds
        startTime     time.Time // time of the first request
}

type BackendRR struct {
        weight      int                 // weight of this backend
        current     int                 // current weight
        backend     *backend.BfeBackend // point to BfeBackend
        inSlowStart bool                // indicate if in slow-start phase
        weightSS    WeightSS            // slow_start related parameters
}

func NewBackendRR() *BackendRR <span class="cov8" title="1">{
        backendRR := new(BackendRR)
        backendRR.backend = backend.NewBfeBackend()

        return backendRR
}</span>

// Init initialize BackendRR with BackendConf
func (backRR *BackendRR) Init(subClusterName string, conf *cluster_table_conf.BackendConf) <span class="cov8" title="1">{
        // scale up 100 times from conf file
        backRR.weight = *conf.Weight * 100
        backRR.current = backRR.weight
        backRR.weightSS.final = backRR.weight

        back := backRR.backend
        back.Init(subClusterName, conf)
}</span>

func (backRR *BackendRR) UpdateWeight(weight int) <span class="cov8" title="1">{
        backRR.weight = weight * 100

        // if weight &gt; 0, don't touch backRR.current
        if weight &lt;= 0 </span><span class="cov0" title="0">{
                backRR.current = 0
        }</span>
}

func (backRR *BackendRR) Release() <span class="cov8" title="1">{
        backRR.backend.Release()
}</span>

func (backRR *BackendRR) MatchAddrPort(addr string, port int) bool <span class="cov8" title="1">{
        back := backRR.backend
        return back.Addr == addr &amp;&amp; back.Port == port
}</span>

func (backRR *BackendRR) initSlowStart(ssTime int) <span class="cov0" title="0">{
        backRR.weightSS.slowStartTime = ssTime
        if backRR.weightSS.slowStartTime == 0 </span><span class="cov0" title="0">{
                backRR.inSlowStart = false
        }</span> else<span class="cov0" title="0"> {
                backRR.weightSS.startTime = time.Now()
                backRR.inSlowStart = true

                // set weight/current to 1, to avoid no traffic allowed at the beginning of start
                backRR.weight = 1
                backRR.current = 1
        }</span>
}

func (backRR *BackendRR) updateSlowStart() <span class="cov0" title="0">{
        if backRR.inSlowStart </span><span class="cov0" title="0">{
                current := time.Duration(backRR.weightSS.final) * time.Since(backRR.weightSS.startTime)
                if backRR.weightSS.slowStartTime != 0 </span><span class="cov0" title="0">{
                        current /= time.Duration(backRR.weightSS.slowStartTime) * time.Second
                        backRR.weight = int(current)
                }</span> else<span class="cov0" title="0"> {
                        backRR.weight = backRR.weightSS.final
                }</span>
                <span class="cov0" title="0">if backRR.weight &gt;= backRR.weightSS.final </span><span class="cov0" title="0">{
                        backRR.weight = backRR.weightSS.final
                        backRR.inSlowStart = false
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file6" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// weighted round-robin balance
//
// Algorithm:
//   smooth Weighted Round Robin algorithm is as follows: on each backend selection,
//   1. increase CurrentWeight of each eligible backend by its weight,
//   2. select backend with greatest CurrentWeight and reduce its CurrentWeight
//      by total number of weight points distributed among backends.
//
// Example:
//   In case of {a:5, b:1, c:1} weights this gives the following sequence 'aabacaa'
//   instead of 'abcaaaa'.
//
//      a  b  c
//      0  0  0  initial state
//      5  1  1  a selected; 5-7+5 1+1   1+1   -&gt; 3  2  2
//      3  2  2  a selected; 3-7+5 2+1   2+1   -&gt; 1  3  3
//      1  3  3  b selected; 1+5   3-7+1 3+1   -&gt; 6 -3  4
//      6 -3  4  a selected; 6-7+5 -3+1  5+1   -&gt; 4 -2  5
//      4 -2  5  c selected; 4+5   -2+1  5-7+1 -&gt; 9 -1 -1
//      9 -1 -1  a selected; 9-7+5 -1+1  -1+1  -&gt; 7  0  0
//      7  0  0  a selected; 7-7+5 0+1   0+1   -&gt; 5  1  1

package bal_slb

import (
        "fmt"
        "math/rand"
        "sort"
        "sync"
)

import (
        "github.com/baidu/go-lib/log"
        "github.com/spaolacci/murmur3"
)

import (
        "github.com/bfenetworks/bfe/bfe_balance/backend"
        "github.com/bfenetworks/bfe/bfe_config/bfe_cluster_conf/cluster_table_conf"
        "github.com/bfenetworks/bfe/bfe_debug"
)

// implementation versions of weighted round-robin algorithm
const (
        WrrSimple = 0
        WrrSmooth = 1
        WrrSticky = 2
        WlcSimple = 3
        WlcSmooth = 4
)

type BackendList []*BackendRR

func (bl *BackendList) ResetWeight() <span class="cov8" title="1">{
        for _, backendRR := range *bl </span><span class="cov8" title="1">{
                backendRR.current = backendRR.weight
        }</span>
}

type BackendListSorter struct {
        l BackendList
}

func (s BackendListSorter) Len() int <span class="cov8" title="1">{
        return len(s.l)
}</span>

func (s BackendListSorter) Swap(i, j int) <span class="cov8" title="1">{
        s.l[i], s.l[j] = s.l[j], s.l[i]
}</span>

func (s BackendListSorter) Less(i, j int) bool <span class="cov8" title="1">{
        return s.l[i].backend.AddrInfo &lt; s.l[j].backend.AddrInfo
}</span>

type BalanceRR struct {
        sync.Mutex
        Name     string
        backends BackendList // list of BackendRR
        sorted   bool        // list of BackendRR sorted or not
        next     int         // next backend to schedule

        slowStartNum  int // number of backends in slow_start phase
        slowStartTime int // time for backend increases the weight to the full value, in seconds
}

func NewBalanceRR(name string) *BalanceRR <span class="cov0" title="0">{
        brr := new(BalanceRR)
        brr.Name = name
        return brr
}</span>

// Init initializes RRList with config.
func (brr *BalanceRR) Init(conf cluster_table_conf.SubClusterBackend) <span class="cov0" title="0">{
        for _, backendConf := range conf </span><span class="cov0" title="0">{
                backendRR := NewBackendRR()
                backendRR.Init(brr.Name, backendConf)
                // add to backends
                brr.backends = append(brr.backends, backendRR)
        }</span>
        <span class="cov0" title="0">brr.sorted = false
        brr.next = 0</span>
}

func (brr *BalanceRR) SetSlowStart(ssTime int) <span class="cov8" title="1">{
        brr.Lock()
        brr.slowStartTime = ssTime
        brr.Unlock()
}</span>

func (brr *BalanceRR) checkSlowStart() <span class="cov8" title="1">{
        brr.Lock()
        defer brr.Unlock()
        if brr.slowStartTime &gt; 0 </span><span class="cov0" title="0">{
                for _, backendRR := range brr.backends </span><span class="cov0" title="0">{
                        backend := backendRR.backend
                        if backend.GetRestart() </span><span class="cov0" title="0">{
                                backend.SetRestart(false)
                                backendRR.initSlowStart(brr.slowStartTime)
                        }</span>
                        <span class="cov0" title="0">backendRR.updateSlowStart()</span>
                }
        }
}

// Release releases backend list.
func (brr *BalanceRR) Release() <span class="cov0" title="0">{
        for _, back := range brr.backends </span><span class="cov0" title="0">{
                back.Release()
        }</span>
}

func confMapMake(conf cluster_table_conf.SubClusterBackend) map[string]*cluster_table_conf.BackendConf <span class="cov8" title="1">{
        retVal := make(map[string]*cluster_table_conf.BackendConf)

        for _, backend := range conf </span><span class="cov8" title="1">{
                retVal[backend.AddrInfo()] = backend
        }</span>

        <span class="cov8" title="1">return retVal</span>
}

// Update updates BalanceRR with new config.
func (brr *BalanceRR) Update(conf cluster_table_conf.SubClusterBackend) <span class="cov8" title="1">{
        // create new BackendList
        var backendsNew BackendList

        // create map for config
        confMap := confMapMake(conf)

        brr.Lock()
        defer brr.Unlock()

        // go through backendsOld, make update and delete
        for index := 0; index &lt; len(brr.backends); index++ </span><span class="cov8" title="1">{
                backendRR := brr.backends[index]

                backendKey := backendRR.backend.GetAddrInfo()
                bkConf, ok := confMap[backendKey]
                if ok &amp;&amp; backendRR.MatchAddrPort(*bkConf.Addr, *bkConf.Port) </span><span class="cov8" title="1">{
                        // found existing backend
                        backendRR.UpdateWeight(*bkConf.Weight)
                        backendsNew = append(backendsNew, backendRR)
                        delete(confMap, backendKey)
                }</span> else<span class="cov8" title="1"> {
                        // tell health-check to stop
                        backendRR.Release()
                }</span>
        }

        // add new backend to backendsNew
        <span class="cov8" title="1">for _, bkConf := range confMap </span><span class="cov8" title="1">{
                backendRR := NewBackendRR()
                backendRR.Init(brr.Name, bkConf)
                backend := backendRR.backend
                backend.SetRestart(true)
                // add to backendsNew
                backendsNew = append(backendsNew, backendRR)
        }</span>

        // point brr.backends to backendsNew
        <span class="cov8" title="1">brr.backends = backendsNew
        brr.sorted = false
        brr.next = 0</span>
}

// initWeight initializes all backendRR.current to backendRR.weight.
func (brr *BalanceRR) initWeight() <span class="cov8" title="1">{
        brr.backends.ResetWeight()
}</span>

func moveToNext(next int, backends BackendList) int <span class="cov8" title="1">{
        // move to next. if at end of list, move back to 0
        next += 1
        if next &gt;= len(backends) </span><span class="cov8" title="1">{
                next = 0
        }</span>
        <span class="cov8" title="1">return next</span>
}

func (brr *BalanceRR) ensureSortedUnlocked() <span class="cov8" title="1">{
        if !brr.sorted </span><span class="cov8" title="1">{
                sort.Sort(BackendListSorter{brr.backends})
                brr.sorted = true
        }</span>
}

// Balance select one backend from sub cluster in round-robin manner.
func (brr *BalanceRR) Balance(algor int, key []byte) (*backend.BfeBackend, error) <span class="cov8" title="1">{
        // Slow start is not supported when session sticky is enabled
        if algor != WrrSticky </span><span class="cov8" title="1">{
                brr.checkSlowStart()
        }</span>
        <span class="cov8" title="1">switch algor </span>{
        case WrrSimple:<span class="cov8" title="1">
                return brr.simpleBalance()</span>
        case WrrSmooth:<span class="cov8" title="1">
                return brr.smoothBalance()</span>
        case WrrSticky:<span class="cov8" title="1">
                return brr.stickyBalance(key)</span>
        case WlcSimple:<span class="cov0" title="0">
                return brr.leastConnsSimpleBalance()</span>
        case WlcSmooth:<span class="cov8" title="1">
                return brr.leastConnsSmoothBalance()</span>
        default:<span class="cov0" title="0">
                return brr.smoothBalance()</span>
        }
}

func (brr *BalanceRR) smoothBalance() (*backend.BfeBackend, error) <span class="cov8" title="1">{
        brr.Lock()
        defer brr.Unlock()

        return smoothBalance(brr.backends)
}</span>

func smoothBalance(backs BackendList) (*backend.BfeBackend, error) <span class="cov8" title="1">{
        var best *BackendRR
        total, max := 0, 0

        for _, backendRR := range backs </span><span class="cov8" title="1">{
                backend := backendRR.backend
                // skip ineligible backend
                if !backend.Avail() || backendRR.weight &lt;= 0 </span><span class="cov8" title="1">{
                        continue</span>
                }

                // select backend with the greatest current weight
                <span class="cov8" title="1">if best == nil || backendRR.current &gt; max </span><span class="cov8" title="1">{
                        best = backendRR
                        max = backendRR.current
                }</span>
                <span class="cov8" title="1">total += backendRR.current

                // update current weight
                backendRR.current += backendRR.weight</span>
        }

        <span class="cov8" title="1">if best == nil </span><span class="cov0" title="0">{
                if bfe_debug.DebugBal </span><span class="cov0" title="0">{
                        log.Logger.Debug("rr_bal:reset backend weight")
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("rr_bal:all backend is down")</span>
        }

        // update current weight for chosen backend
        <span class="cov8" title="1">best.current -= total

        return best.backend, nil</span>
}

func (brr *BalanceRR) leastConnsSmoothBalance() (*backend.BfeBackend, error) <span class="cov8" title="1">{
        brr.Lock()
        defer brr.Unlock()

        // select available candidates
        candidates, err := leastConnsBalance(brr.backends)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // single candidate, return directly
        <span class="cov8" title="1">if len(candidates) == 1 </span><span class="cov8" title="1">{
                return candidates[0].backend, nil
        }</span>

        // select backends by smooth balance
        <span class="cov8" title="1">return smoothBalance(candidates)</span>
}

func (brr *BalanceRR) leastConnsSimpleBalance() (*backend.BfeBackend, error) <span class="cov0" title="0">{
        brr.Lock()
        defer brr.Unlock()

        // select candidates
        candidates, err := leastConnsBalance(brr.backends)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // single candidate, return directly
        <span class="cov0" title="0">if len(candidates) == 1 </span><span class="cov0" title="0">{
                return candidates[0].backend, nil
        }</span>

        // random select
        <span class="cov0" title="0">return randomBalance(candidates)</span>
}

func leastConnsBalance(backs BackendList) (BackendList, error) <span class="cov8" title="1">{
        var best *BackendRR
        candidates := make(BackendList, 0, len(backs))

        // select available candidates
        singleBackend := true
        for _, backendRR := range backs </span><span class="cov8" title="1">{
                if !backendRR.backend.Avail() || backendRR.weight &lt;= 0 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">if best == nil </span><span class="cov8" title="1">{
                        best = backendRR
                        singleBackend = true
                        continue</span>
                }

                // compare backends
                <span class="cov8" title="1">ret := compLCWeight(best, backendRR)
                if ret &gt; 0 </span><span class="cov8" title="1">{
                        best = backendRR
                        singleBackend = true
                }</span> else<span class="cov8" title="1"> if ret == 0 </span><span class="cov8" title="1">{
                        singleBackend = false
                        if len(candidates) &gt; 0 </span><span class="cov8" title="1">{
                                candidates = append(candidates, backendRR)
                        }</span> else<span class="cov8" title="1"> {
                                candidates = append(candidates, best, backendRR)
                        }</span>

                }
        }

        <span class="cov8" title="1">if best == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("rr_bal:all backend is down")
        }</span>

        // single backend, return directly
        <span class="cov8" title="1">if singleBackend </span><span class="cov8" title="1">{
                return BackendList{best}, nil
        }</span>
        // more than one backend have same connections/weight,
        // return all the candidates
        <span class="cov8" title="1">return candidates, nil</span>
}

func randomBalance(backs BackendList) (*backend.BfeBackend, error) <span class="cov0" title="0">{
        i := rand.Int() % len(backs)
        return backs[i].backend, nil
}</span>

func (brr *BalanceRR) simpleBalance() (*backend.BfeBackend, error) <span class="cov8" title="1">{
        var backend *backend.BfeBackend
        var backendRR *BackendRR

        brr.Lock()
        defer brr.Unlock()

        backends := brr.backends
        allBackendDown := true

        next := brr.next
        for </span><span class="cov8" title="1">{
                backendRR = backends[next]
                backend = backendRR.backend

                avail := backend.Avail()
                if avail &amp;&amp; backendRR.current &gt; 0 </span><span class="cov8" title="1">{
                        // find one available backend
                        break</span>
                }

                <span class="cov8" title="1">if bfe_debug.DebugBal </span><span class="cov0" title="0">{
                        log.Logger.Debug("backend[%s],avail[%d],weight[%d]",
                                backend.Name, avail, backendRR.weight)
                }</span>

                <span class="cov8" title="1">if avail &amp;&amp; backendRR.weight != 0 </span><span class="cov8" title="1">{
                        allBackendDown = false
                }</span>

                // move to next
                <span class="cov8" title="1">next = moveToNext(next, backends)

                if next == brr.next </span><span class="cov8" title="1">{
                        // all backends have been checked
                        if allBackendDown </span><span class="cov0" title="0">{
                                if bfe_debug.DebugBal </span><span class="cov0" title="0">{
                                        log.Logger.Debug("rr_bal:all backend is down")
                                }</span>
                                <span class="cov0" title="0">return backend, fmt.Errorf("rr_bal:all backend is down")</span>
                        } else<span class="cov8" title="1"> {
                                if bfe_debug.DebugBal </span><span class="cov0" title="0">{
                                        log.Logger.Debug("rr_bal:reset backend weight")
                                }</span>
                                <span class="cov8" title="1">brr.initWeight()
                                brr.next = 0
                                next = 0</span>
                        }
                }
        }

        // modify current
        <span class="cov8" title="1">backendRR.current--

        // modify brr.next, for next use
        next = moveToNext(next, backends)
        brr.next = next

        if bfe_debug.DebugBal </span><span class="cov0" title="0">{
                log.Logger.Debug("rr.Balance: backend[%s] weight[%d]current[%d]",
                        backend.Name, backendRR.weight, backendRR.current)
        }</span>
        <span class="cov8" title="1">return backend, nil</span>
}

func (brr *BalanceRR) stickyBalance(key []byte) (*backend.BfeBackend, error) <span class="cov8" title="1">{
        candidates := make(BackendList, 0, brr.Len())
        totalWeight := 0

        brr.Lock()
        defer brr.Unlock()

        // select available candidates
        brr.ensureSortedUnlocked()
        for _, backendRR := range brr.backends </span><span class="cov8" title="1">{
                if backendRR.backend.Avail() &amp;&amp; backendRR.weight &gt; 0 </span><span class="cov8" title="1">{
                        candidates = append(candidates, backendRR)
                        totalWeight += backendRR.weight
                }</span>
        }

        <span class="cov8" title="1">if len(candidates) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("rr_bal:all backend is down")
        }</span>

        // select backend from candidates
        <span class="cov8" title="1">value := GetHash(key, uint(totalWeight))
        for _, backendRR := range candidates </span><span class="cov8" title="1">{
                value -= backendRR.weight
                if value &lt; 0 </span><span class="cov8" title="1">{
                        return backendRR.backend, nil
                }</span>
        }

        /* never come here */
        <span class="cov0" title="0">return nil, fmt.Errorf("rr_bal:stickyBalance fail")</span>
}

// compLCWeight returns an integer comparing two backends by connNum/Weight.
// result will be 0 if a == b, -1 if a &lt; b, +1 if a &gt; b
func compLCWeight(a, b *BackendRR) int <span class="cov8" title="1">{
        // compare a.backend.ConnNum() / a.weight and b.backend.ConnNum() / b.weight
        // to avoid compare floating num, both multiple a.weight * b.weight
        ret := a.backend.ConnNum()*b.weight - b.backend.ConnNum()*a.weight

        // a.backend.ConnNum() / a.weight &gt; b.backend.ConnNum() / b.weight
        if ret &gt; 0 </span><span class="cov8" title="1">{
                return 1
        }</span>

        // a.backend.ConnNum() / a.weight == b.backend.ConnNum() / b.weight
        <span class="cov8" title="1">if ret == 0 </span><span class="cov8" title="1">{
                return 0
        }</span>

        <span class="cov8" title="1">return -1</span>
}

func (brr *BalanceRR) Len() int <span class="cov8" title="1">{
        return len(brr.backends)
}</span>

func GetHash(value []byte, base uint) int <span class="cov8" title="1">{
        var hash uint64

        if value == nil </span><span class="cov0" title="0">{
                hash = uint64(rand.Uint32())
        }</span> else<span class="cov8" title="1"> {
                hash = murmur3.Sum64(value)
        }</span>

        <span class="cov8" title="1">return int(hash % uint64(base))</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// table for maintain backend cluster

package bfe_balance

import (
        "fmt"
        "strings"
        "sync"
)

import (
        "github.com/baidu/go-lib/log"
)

import (
        "github.com/bfenetworks/bfe/bfe_balance/backend"
        "github.com/bfenetworks/bfe/bfe_balance/bal_gslb"
        "github.com/bfenetworks/bfe/bfe_config/bfe_cluster_conf/cluster_table_conf"
        "github.com/bfenetworks/bfe/bfe_config/bfe_cluster_conf/gslb_conf"
        "github.com/bfenetworks/bfe/bfe_route"
)

// BalMap holds mappings from clusterName to BalanceGslb.
type BalMap map[string]*bal_gslb.BalanceGslb

type BalTable struct {
        lock     sync.RWMutex
        balTable BalMap // from cluster to balancer
        versions BalVersion
}

type BalVersion struct {
        ClusterTableConfVer string // cluster table conf version
        GslbConfTimeStamp   string // timestamp of gslb-conf
        GslbConfSrc         string // which gslb-scheduler come from?
}

type BalTableState struct {
        Balancers  map[string]*bal_gslb.GslbState // state of cluster
        BackendNum int                            // size of backendTable
}

func NewBalTable(checkConfFetcher backend.CheckConfFetcher) *BalTable <span class="cov8" title="1">{
        t := new(BalTable)
        t.balTable = make(BalMap)
        backend.SetCheckConfFetcher(checkConfFetcher)
        return t
}</span>

func (t *BalTable) BalTableConfLoad(gslbConfFilename, clusterTableFilename string) (
        gslb_conf.GslbConf, cluster_table_conf.ClusterTableConf, error) <span class="cov8" title="1">{

        var gslbConf gslb_conf.GslbConf
        var backendConf cluster_table_conf.ClusterTableConf
        var err error

        gslbConf, err = gslb_conf.GslbConfLoad(gslbConfFilename)
        if err != nil </span><span class="cov8" title="1">{
                log.Logger.Error("gslb_conf.GslbConfLoad err [%s]", err)
                return gslbConf, backendConf, err
        }</span>

        <span class="cov8" title="1">backendConf, err = cluster_table_conf.ClusterTableLoad(clusterTableFilename)
        if err != nil </span><span class="cov8" title="1">{
                log.Logger.Error("clusterBackendConfLoad err [%s]", err)
        }</span>

        <span class="cov8" title="1">return gslbConf, backendConf, err</span>
}

func (t *BalTable) Init(gslbConfFilename, clusterTableFilename string) error <span class="cov8" title="1">{
        gslbConf, backendConf, err := t.BalTableConfLoad(gslbConfFilename, clusterTableFilename)

        if err != nil </span><span class="cov8" title="1">{
                log.Logger.Error("BalTable conf load err %s", err)
                return err
        }</span>

        // init gslb
        <span class="cov8" title="1">if err := t.gslbInit(gslbConf); err != nil </span><span class="cov0" title="0">{
                log.Logger.Error("clusterTable gslb init err [%s]", err)
                return err
        }</span>

        // init backend
        <span class="cov8" title="1">if err := t.backendInit(backendConf); err != nil </span><span class="cov0" title="0">{
                log.Logger.Error("clusterTable backend init err [%s]", err)
                return err
        }</span>

        <span class="cov8" title="1">log.Logger.Info("init bal table success")
        return nil</span>
}

func (t *BalTable) gslbInit(gslbConfs gslb_conf.GslbConf) error <span class="cov8" title="1">{
        fails := make([]string, 0)

        for clusterName, gslbConf := range *gslbConfs.Clusters </span><span class="cov8" title="1">{
                bal := bal_gslb.NewBalanceGslb(clusterName)
                err := bal.Init(gslbConf)
                if err != nil </span><span class="cov8" title="1">{
                        log.Logger.Error("BalTable.gslbInit():err[%s] in bal_gslb.GslbInit() for %s",
                                err.Error(), clusterName)
                        fails = append(fails, clusterName)
                        continue</span>
                }
                <span class="cov8" title="1">t.balTable[clusterName] = bal</span>
        }

        // update versions
        <span class="cov8" title="1">t.versions.GslbConfTimeStamp = *gslbConfs.Ts
        t.versions.GslbConfSrc = *gslbConfs.Hostname

        if len(fails) != 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("error in ClusterTable.gslbInit() for [%s]",
                        strings.Join(fails, ","))
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (t *BalTable) backendInit(backendConfs cluster_table_conf.ClusterTableConf) error <span class="cov8" title="1">{
        fails := make([]string, 0)

        for clusterName, bal := range t.balTable </span><span class="cov8" title="1">{
                // get gslbConf
                backendConf, ok := (*backendConfs.Config)[clusterName]
                if !ok </span><span class="cov8" title="1">{
                        // external checking guarantee. should not come here in theory
                        log.Logger.Error("BalTable.backendInit():no backend conf for %s", clusterName)
                        fails = append(fails, clusterName)
                        continue</span>
                }

                // initialize
                <span class="cov8" title="1">err := bal.BackendInit(backendConf)
                if err != nil </span><span class="cov0" title="0">{
                        log.Logger.Error("ClusterTable.backendInit():err[%s] in cluster.BackendInit() for %s",
                                err.Error(), clusterName)
                        fails = append(fails, clusterName)
                        continue</span>
                }
        }

        // update versions
        <span class="cov8" title="1">t.versions.ClusterTableConfVer = *backendConfs.Version

        if len(fails) != 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("error in ClusterTable.backendInit() for [%s]",
                        strings.Join(fails, ","))
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// SetGslbBasic sets gslb basic conf (from server data conf) for BalTable.
//
// Note:
//  - SetGslbBasic() is called after server reload gslb conf or server data conf
//  - SetGslbBasic() should be concurrency safe
func (t *BalTable) SetGslbBasic(clusterTable *bfe_route.ClusterTable) <span class="cov0" title="0">{
        t.lock.Lock()
        defer t.lock.Unlock()

        if clusterTable == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">for clusterName, bal := range t.balTable </span><span class="cov0" title="0">{
                cluster, err := clusterTable.Lookup(clusterName)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">bal.SetGslbBasic(*cluster.GslbBasic)</span>
        }
}

// SetSlowStart sets slow_start related conf (from server data conf) for BalTable.
//
// Note:
//  - SetSlowStart() is called after server reload server data conf
//  - SetSlowStart() should be concurrency safe
func (t *BalTable) SetSlowStart(clusterTable *bfe_route.ClusterTable) <span class="cov0" title="0">{
        t.lock.RLock()
        defer t.lock.RUnlock()

        if clusterTable == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">for clusterName, bal := range t.balTable </span><span class="cov0" title="0">{
                cluster, err := clusterTable.Lookup(clusterName)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">bal.SetSlowStart(*cluster.BackendConf())</span>
        }
}

func (t *BalTable) BalTableReload(gslbConfs gslb_conf.GslbConf,
        backendConfs cluster_table_conf.ClusterTableConf) error <span class="cov8" title="1">{
        t.lock.Lock()

        var fails []string
        bmNew := make(BalMap)
        for clusterName, gslbConf := range *gslbConfs.Clusters </span><span class="cov8" title="1">{
                bal, ok := t.balTable[clusterName]
                if !ok </span><span class="cov8" title="1">{
                        // new one balance
                        bal = bal_gslb.NewBalanceGslb(clusterName)
                }</span> else<span class="cov8" title="1"> {
                        delete(t.balTable, clusterName)
                }</span>

                // update balance
                <span class="cov8" title="1">if err := bal.Reload(gslbConf); err != nil </span><span class="cov0" title="0">{
                        log.Logger.Error("BalTableReload():err[%s] in bal.Reload() for %s",
                                err.Error(), clusterName)
                        fails = append(fails, clusterName)
                }</span>

                <span class="cov8" title="1">bmNew[clusterName] = bal</span>
        }

        // remove bal not in configure file
        <span class="cov8" title="1">for _, remainder := range t.balTable </span><span class="cov0" title="0">{
                remainder.Release()
        }</span>

        <span class="cov8" title="1">t.balTable = bmNew
        for clusterName, bal := range t.balTable </span><span class="cov8" title="1">{
                backendConf, ok1 := (*backendConfs.Config)[clusterName]
                if !ok1 </span><span class="cov0" title="0">{
                        // never comes here
                        log.Logger.Error("BalTableReload():no backend conf for %s", clusterName)
                        fails = append(fails, clusterName)
                        continue</span>
                }

                <span class="cov8" title="1">if err := bal.BackendReload(backendConf); err != nil </span><span class="cov0" title="0">{
                        log.Logger.Error("BalTableReload():err[%s] in bal.BackendReload() for %s",
                                err.Error(), clusterName)
                        fails = append(fails, clusterName)
                }</span>
        }

        // update versions
        <span class="cov8" title="1">t.versions.ClusterTableConfVer = *backendConfs.Version
        t.versions.GslbConfTimeStamp = *gslbConfs.Ts
        t.versions.GslbConfSrc = *gslbConfs.Hostname

        t.lock.Unlock()

        if len(fails) != 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("error in BalTableReload() for [%s]", strings.Join(fails, ","))
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (t *BalTable) lookup(clusterName string) (*bal_gslb.BalanceGslb, error) <span class="cov0" title="0">{
        bal, ok := t.balTable[clusterName]
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no bal found for %s", clusterName)
        }</span>
        <span class="cov0" title="0">return bal, nil</span>
}

// Lookup lookup BalanceGslb by cluster name.
func (t *BalTable) Lookup(clusterName string) (*bal_gslb.BalanceGslb, error) <span class="cov0" title="0">{
        t.lock.RLock()
        res, err := t.lookup(clusterName)
        t.lock.RUnlock()

        return res, err
}</span>

func NewBalTableState() *BalTableState <span class="cov8" title="1">{
        state := new(BalTableState)
        state.Balancers = make(map[string]*bal_gslb.GslbState)

        return state
}</span>

// GetState returns state of BalTable.
func (t *BalTable) GetState() *BalTableState <span class="cov8" title="1">{
        state := NewBalTableState()

        t.lock.RLock()

        // go through clusters
        for name, bal := range t.balTable </span><span class="cov8" title="1">{
                gs := bal_gslb.State(bal)
                state.Balancers[name] = gs
                state.BackendNum += gs.BackendNum
        }</span>

        <span class="cov8" title="1">t.lock.RUnlock()

        return state</span>
}

// GetVersions returns versions of BalTable.
func (t *BalTable) GetVersions() BalVersion <span class="cov0" title="0">{
        t.lock.RLock()
        versions := t.versions
        t.lock.RUnlock()

        return versions
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package action

import (
        "bytes"
        "fmt"
        "strings"
)

import (
        "github.com/bfenetworks/bfe/bfe_basic"
        "github.com/bfenetworks/bfe/bfe_util/json"
)

const (
        // connection actions
        ActionClose  = "CLOSE"  // close, close the connection directly
        ActionPass   = "PASS"   // pass, do nothing
        ActionFinish = "FINISH" // finish, close connection after reply

        // header actions
        ActionReqHeaderAdd = "REQ_HEADER_ADD" // add request header
        ActionReqHeaderSet = "REQ_HEADER_SET" // set request header
        ActionReqHeaderDel = "REQ_HEADER_DEL" // del request header

        // host actions
        ActionHostSetFromPathPrefix = "HOST_SET_FROM_PATH_PREFIX" // set host from path prefix
        ActionHostSet               = "HOST_SET"                  // set host
        ActionHostSuffixReplace     = "HOST_SUFFIX_REPLACE"       // set host replaced suffx

        // path actions
        ActionPathSet        = "PATH_SET"         // set path
        ActionPathPrefixAdd  = "PATH_PREFIX_ADD"  // add path prefix
        ActionPathPrefixTrim = "PATH_PREFIX_TRIM" // trim path prefix

        // query actions
        ActionQueryAdd          = "QUERY_ADD"            // add query
        ActionQueryDel          = "QUERY_DEL"            // del query
        ActionQueryRename       = "QUERY_RENAME"         // rename query
        ActionQueryDelAllExcept = "QUERY_DEL_ALL_EXCEPT" // del query except given query key
)

type ActionFile struct {
        Cmd    *string // command of action
        Params []string
}

type Action struct {
        Cmd    string   // command of action
        Params []string // params of action
}

// UnmarshalJSON decodes given data in json format
func (ac *Action) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        var actionFile ActionFile

        // decode
        dec := json.NewDecoder(bytes.NewReader(data))
        if err := dec.Decode(&amp;actionFile); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("decode Action err: %s", err)
        }</span>

        // check
        <span class="cov8" title="1">if err := ActionFileCheck(actionFile); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("actionFileCheck err: %s", err)
        }</span>

        // convert to action
        <span class="cov8" title="1">ac.Cmd = *actionFile.Cmd
        ac.Params = actionFile.Params

        return nil</span>
}

func (ac *Action) Check(allowActions map[string]bool) error <span class="cov0" title="0">{
        cmd := ac.Cmd

        if _, ok := allowActions[cmd]; !ok </span><span class="cov0" title="0">{
                // cmd not allowed
                return fmt.Errorf("action cmd[%s], is not allowed", cmd)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Do process action for request
func (ac *Action) Do(req *bfe_basic.Request) error <span class="cov8" title="1">{
        switch ac.Cmd </span>{
        // for req header
        case ActionReqHeaderAdd:<span class="cov8" title="1">
                req.HttpRequest.Header.Add(ac.Params[0], ac.Params[1])</span>
        case ActionReqHeaderSet:<span class="cov8" title="1">
                req.HttpRequest.Header.Set(ac.Params[0], ac.Params[1])</span>
        case ActionReqHeaderDel:<span class="cov8" title="1">
                req.HttpRequest.Header.Del(ac.Params[0])</span>

        // for host
        case ActionHostSet:<span class="cov8" title="1">
                ReqHostSet(req, ac.Params[0])</span>
        case ActionHostSetFromPathPrefix:<span class="cov0" title="0">
                ReqHostSetFromFirstPathSegment(req)</span>
        case ActionHostSuffixReplace:<span class="cov0" title="0">
                ReqHostSuffixReplace(req, ac.Params[0], ac.Params[1])</span>

        // for path
        case ActionPathSet:<span class="cov8" title="1">
                ReqPathSet(req, ac.Params[0])</span>
        case ActionPathPrefixAdd:<span class="cov8" title="1">
                ReqPathPrefixAdd(req, ac.Params[0])</span>
        case ActionPathPrefixTrim:<span class="cov8" title="1">
                ReqPathPrefixTrim(req, ac.Params[0])</span>

        // for query
        case ActionQueryAdd:<span class="cov8" title="1">
                ReqQueryAdd(req, ac.Params)</span>
        case ActionQueryRename:<span class="cov8" title="1">
                ReqQueryRename(req, ac.Params[0], ac.Params[1])</span>
        case ActionQueryDel:<span class="cov8" title="1">
                ReqQueryDel(req, ac.Params)</span>
        case ActionQueryDelAllExcept:<span class="cov8" title="1">
                ReqQueryDelAllExcept(req, ac.Params)</span>
        case ActionClose, ActionPass, ActionFinish:<span class="cov8" title="1"></span>
                // pass
        default:<span class="cov0" title="0">
                return fmt.Errorf("unknown cmd[%s]", ac.Cmd)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

const HeaderPrefix = "X-BFE-"

func ActionFileCheck(conf ActionFile) error <span class="cov8" title="1">{
        var paramsLenCheck int

        // check command
        if conf.Cmd == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("no Cmd")
        }</span>

        // validate command
        <span class="cov8" title="1">*conf.Cmd = strings.ToUpper(*conf.Cmd)
        switch *conf.Cmd </span>{
        case ActionReqHeaderAdd, ActionReqHeaderSet:<span class="cov8" title="1">
                paramsLenCheck = 2</span>
        case ActionReqHeaderDel:<span class="cov8" title="1">
                paramsLenCheck = 1</span>
        case ActionClose, ActionPass, ActionFinish:<span class="cov8" title="1">
                paramsLenCheck = 0</span>
        case ActionHostSetFromPathPrefix:<span class="cov0" title="0">
                paramsLenCheck = 0</span>
        case ActionHostSet:<span class="cov8" title="1">
                paramsLenCheck = 1</span>
        case ActionPathSet, ActionPathPrefixAdd, ActionPathPrefixTrim:<span class="cov0" title="0">
                paramsLenCheck = 1</span>
        case ActionQueryAdd, ActionQueryRename:<span class="cov0" title="0">
                paramsLenCheck = 2</span>
        case ActionQueryDel, ActionQueryDelAllExcept:<span class="cov0" title="0">
                paramsLenCheck = -1</span> // any is OK
        default:<span class="cov0" title="0">
                return fmt.Errorf("invalid cmd:%s", *conf.Cmd)</span>
        }

        <span class="cov8" title="1">if paramsLenCheck != -1 &amp;&amp; len(conf.Params) != paramsLenCheck </span><span class="cov8" title="1">{
                return fmt.Errorf("num of params:[ok:%d, now:%d]", paramsLenCheck, len(conf.Params))
        }</span>

        <span class="cov8" title="1">for _, p := range conf.Params </span><span class="cov8" title="1">{
                if len(p) == 0 </span><span class="cov8" title="1">{
                        return fmt.Errorf("empty Params")
                }</span>
        }

        <span class="cov8" title="1">if *conf.Cmd == ActionReqHeaderSet || *conf.Cmd == ActionReqHeaderAdd </span><span class="cov8" title="1">{
                header := strings.ToUpper(conf.Params[0])

                if !strings.HasPrefix(header, HeaderPrefix) </span><span class="cov0" title="0">{
                        return fmt.Errorf("add/set header key must start with X-Bfe-, got %s", header)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package action

import (
        "strings"
)
import (
        "github.com/bfenetworks/bfe/bfe_basic"
)

// ReqHostSet sets hostname to request.
func ReqHostSet(req *bfe_basic.Request, hostname string) <span class="cov8" title="1">{
        httpReq := req.HttpRequest
        httpReq.Host = hostname
}</span>

// ReqHostSetFromFirstPathSegment set hostname from first path segment.
//
// example:
// if uri path pattern is /x.baidu.com/xxxx,
//     set host x.baidu.com
//     set uri path  /xxx
// if do not match this pattern, do noting
func ReqHostSetFromFirstPathSegment(req *bfe_basic.Request) <span class="cov0" title="0">{
        path := req.HttpRequest.URL.Path

        // path: /x.baidu.com/xxxx
        // segs[0]: ""
        // segs[1]: "x.baidu.com"
        // segs[2]: "xxx"
        segs := strings.SplitN(path, "/", 3)
        if len(segs) &lt; 3 </span><span class="cov0" title="0">{
                return
        }</span>

        // set host and trim path prefix
        <span class="cov0" title="0">req.HttpRequest.Host = segs[1]
        req.HttpRequest.URL.Path = "/" + segs[2]</span>
}

// ReqHostSuffixReplace replaces suffix of hostname.
func ReqHostSuffixReplace(req *bfe_basic.Request, originSuffix, newSuffix string) <span class="cov0" title="0">{
        hostname := req.HttpRequest.URL.Host
        if !strings.HasSuffix(hostname, originSuffix) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">hostname = strings.TrimSuffix(hostname, originSuffix) + newSuffix
        req.HttpRequest.Host = hostname</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package action

import (
        "strings"
)

import (
        "github.com/bfenetworks/bfe/bfe_basic"
)

// ReqPathSet sets path to request.
func ReqPathSet(req *bfe_basic.Request, path string) <span class="cov8" title="1">{
        httpReq := req.HttpRequest
        httpReq.URL.Path = path
}</span>

// ReqPathPrefixAdd adds prefix to path.
// e.g., path  "/(.*)" =&gt; "/link?$1",
func ReqPathPrefixAdd(req *bfe_basic.Request, prefix string) <span class="cov8" title="1">{
        httpReq := req.HttpRequest
        pathStr := httpReq.URL.Path
        // remove "/" from path
        pathStr = strings.TrimPrefix(pathStr, "/")
        // add prefix to path
        pathStr = prefix + pathStr

        // add "/" to path
        if !strings.HasPrefix(pathStr, "/") </span><span class="cov8" title="1">{
                pathStr = "/" + pathStr
        }</span>

        // set new path
        <span class="cov8" title="1">httpReq.URL.Path = pathStr</span>
}

// ReqPathPrefixTrim trims prefix of path
// e.g., path "/service/shortcut/(.*)" =&gt; "/$1",
func ReqPathPrefixTrim(req *bfe_basic.Request, prefix string) <span class="cov8" title="1">{
        httpReq := req.HttpRequest
        pathStr := httpReq.URL.Path
        // trim prefix from path
        pathStr = strings.TrimPrefix(pathStr, prefix)
        // add "/" to prefix
        if !strings.HasPrefix(pathStr, "/") </span><span class="cov0" title="0">{
                pathStr = "/" + pathStr
        }</span>

        // set new path
        <span class="cov8" title="1">httpReq.URL.Path = pathStr</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package action

import (
        "fmt"
        "net/url"
        "strings"
)

import (
        "github.com/bfenetworks/bfe/bfe_basic"
)

// queryParse parses request query.
func queryParse(req *bfe_basic.Request) url.Values <span class="cov8" title="1">{
        // re-use req.Query
        if req.Query == nil </span><span class="cov8" title="1">{
                req.Query = req.HttpRequest.URL.Query()
        }</span>

        <span class="cov8" title="1">return req.Query</span>
}

// queryDump dumps queries to string, e.g., key1=value1&amp;key2=value2.
func queryDump(queries url.Values) string <span class="cov0" title="0">{
        strs := make([]string, 0)

        for key, values := range queries </span><span class="cov0" title="0">{
                for _, value := range values </span><span class="cov0" title="0">{
                        str := fmt.Sprintf("%s=%s", key, value)
                        strs = append(strs, str)
                }</span>
        }

        <span class="cov0" title="0">return strings.Join(strs, "&amp;")</span>
}

// ReqQueryAdd adds some number of (key, value) to query.
func ReqQueryAdd(req *bfe_basic.Request, params []string) <span class="cov8" title="1">{
        var addQueryString string

        // parse the query
        queries := queryParse(req)

        // get number of pairs
        pairNum := len(params) / 2

        // add (key, value) to queries
        for i := 0; i &lt; pairNum; i++ </span><span class="cov8" title="1">{
                key := params[2*i]
                value := params[2*i+1]

                // try to get value of given key
                oldValue := queries.Get(key)

                if oldValue == "" </span><span class="cov8" title="1">{
                        // key not exist, use Set()
                        queries.Set(key, value)
                }</span> else<span class="cov0" title="0"> {
                        // key exist, use Add()
                        queries.Add(key, value)
                }</span>

                <span class="cov8" title="1">addQueryString = addQueryString + "&amp;" + key + "=" + value</span>
        }

        // add rawQuery directly
        <span class="cov8" title="1">if req.HttpRequest.URL.RawQuery == "" </span><span class="cov8" title="1">{
                // if RawQuery is empty, remove prefix "&amp;"
                req.HttpRequest.URL.RawQuery = addQueryString[1:]
        }</span> else<span class="cov8" title="1"> {
                req.HttpRequest.URL.RawQuery += addQueryString
        }</span>
}

// ReqQueryRename renames query key from old name to new name.
func ReqQueryRename(req *bfe_basic.Request, oldName string, newName string) <span class="cov8" title="1">{
        var values []string
        var ok bool

        // add prefix "&amp;" to simplify process
        rawQuery := "&amp;" + req.HttpRequest.URL.RawQuery

        // parse the query
        queries := queryParse(req)

        // renanme query key from old name to new name
        if values, ok = queries[oldName]; !ok </span><span class="cov8" title="1">{
                // not find
                return
        }</span>

        <span class="cov8" title="1">queries.Del(oldName)
        queries[newName] = values

        // rename keys
        srcKey := "&amp;" + oldName + "="
        dstKey := "&amp;" + newName + "="
        rawQuery = strings.ReplaceAll(rawQuery, srcKey, dstKey)

        // remove prefix "&amp;"
        req.HttpRequest.URL.RawQuery = rawQuery[1:]</span>
}

// ReqQueryDel deletes some keys from query
func ReqQueryDel(req *bfe_basic.Request, keys []string) <span class="cov8" title="1">{
        // add "&amp;" prefix and suffix to simplify process
        rawQuery := "&amp;" + req.HttpRequest.URL.RawQuery + "&amp;"

        // parse the query
        queries := queryParse(req)

        // delete some keys from queries
        for _, key := range keys </span><span class="cov8" title="1">{
                queries.Del(key)

                for </span><span class="cov8" title="1">{
                        // find key start &amp;key=
                        start := strings.Index(rawQuery, "&amp;"+key+"=")
                        if start == -1 </span><span class="cov8" title="1">{
                                break</span>
                        }

                        // find value end
                        <span class="cov8" title="1">end := strings.Index(rawQuery[start+1:], "&amp;")
                        if end == -1 </span><span class="cov0" title="0">{
                                break</span>
                        }

                        // remove start:start+end part
                        <span class="cov8" title="1">rawQuery = rawQuery[:start] + rawQuery[start+end+1:]</span>
                }
        }

        // set rawQuery, remove "&amp;" prefix and suffix
        <span class="cov8" title="1">if len(rawQuery) == 1 </span><span class="cov8" title="1">{
                req.HttpRequest.URL.RawQuery = ""
        }</span> else<span class="cov8" title="1"> {
                req.HttpRequest.URL.RawQuery = rawQuery[1 : len(rawQuery)-1]
        }</span>
}

// ReqQueryDelAllExcept deletes all keys from query, except some keys
func ReqQueryDelAllExcept(req *bfe_basic.Request, keys []string) <span class="cov8" title="1">{
        // add "&amp;" prefix and suffix to simplify process
        rawQuery := "&amp;" + req.HttpRequest.URL.RawQuery + "&amp;"

        // parse the query
        queries := queryParse(req)

        // prepare map for keys
        keysMap := make(map[string]bool)
        for _, key := range keys </span><span class="cov8" title="1">{
                keysMap[key] = true
        }</span>

        // delete some keys from queries, except keys in keysMap
        <span class="cov8" title="1">for key := range queries </span><span class="cov8" title="1">{
                if _, ok := keysMap[key]; ok </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">queries.Del(key)
                for </span><span class="cov8" title="1">{
                        // find key start
                        start := strings.Index(rawQuery, "&amp;"+key+"=")
                        if start == -1 </span><span class="cov8" title="1">{
                                break</span>
                        }

                        // find value end
                        <span class="cov8" title="1">end := strings.Index(rawQuery[start+1:], "&amp;")
                        if end == -1 </span><span class="cov0" title="0">{
                                break</span>
                        }

                        // remove start:start+end part
                        <span class="cov8" title="1">rawQuery = rawQuery[:start] + rawQuery[start+end+1:]</span>
                }
        }

        // set rawQuery, remove "&amp;" prefix and suffix
        <span class="cov8" title="1">if len(rawQuery) == 1 </span><span class="cov8" title="1">{
                req.HttpRequest.URL.RawQuery = ""
        }</span> else<span class="cov8" title="1"> {
                req.HttpRequest.URL.RawQuery = rawQuery[1 : len(rawQuery)-1]
        }</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// build condition by config ast

package condition

import (
        "fmt"
        "regexp"
        "strings"
)

import (
        "github.com/bfenetworks/bfe/bfe_basic/condition/parser"
)

func Build(condStr string) (Condition, error) <span class="cov8" title="1">{
        node, identList, err := parser.Parse(condStr)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if len(identList) != 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("found unresolved variable %s %d", identList[0].Name, identList[0].Pos())
        }</span>

        <span class="cov8" title="1">return build(node)</span>
}

func build(node parser.Node) (Condition, error) <span class="cov8" title="1">{
        switch n := node.(type) </span>{
        case *parser.CallExpr:<span class="cov8" title="1">
                return buildPrimitive(n)</span>
        case *parser.UnaryExpr:<span class="cov0" title="0">
                return buildUnary(n)</span>
        case *parser.BinaryExpr:<span class="cov0" title="0">
                return buildBinary(n)</span>
        case *parser.ParenExpr:<span class="cov0" title="0">
                return build(n.X)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported node %s", node)</span>
        }
}

func buildUnary(node *parser.UnaryExpr) (Condition, error) <span class="cov0" title="0">{
        c, err := build(node.X)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;UnaryCond{op: node.Op, cond: c}, nil</span>

}

func buildBinary(node *parser.BinaryExpr) (Condition, error) <span class="cov0" title="0">{
        l, err := build(node.X)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">r, err := build(node.Y)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;BinaryCond{op: node.Op, lc: l, rc: r}, nil</span>
}

// buildPrimitive builds primitive from PrimitiveCondExpr.
// if failed, b.err is set to err, return Condition is nil
// if success, b.err is nil
func buildPrimitive(node *parser.CallExpr) (Condition, error) <span class="cov8" title="1">{
        switch node.Fun.Name </span>{
        case "default_t":<span class="cov8" title="1">
                return &amp;DefaultTrueCond{}, nil</span>
        case "req_cip_trusted":<span class="cov0" title="0">
                return &amp;TrustedCIpMatcher{}, nil</span>
        case "req_vip_in":<span class="cov8" title="1">
                matcher, err := NewIpInMatcher(node.Args[0].Value)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return &amp;PrimitiveCond{
                        name:    node.Fun.Name,
                        node:    node,
                        fetcher: &amp;VIPFetcher{},
                        matcher: matcher,
                }, nil</span>
        case "req_vip_range":<span class="cov8" title="1">
                matcher, err := NewIPMatcher(node.Args[0].Value, node.Args[1].Value)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">return &amp;PrimitiveCond{
                        name:    node.Fun.Name,
                        node:    node,
                        fetcher: &amp;VIPFetcher{},
                        matcher: matcher,
                }, nil</span>
        case "req_cip_range":<span class="cov8" title="1">
                matcher, err := NewIPMatcher(node.Args[0].Value, node.Args[1].Value)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">return &amp;PrimitiveCond{
                        name:    node.Fun.Name,
                        node:    node,
                        fetcher: &amp;CIPFetcher{},
                        matcher: matcher,
                }, nil</span>
        case "req_cip_hash_in":<span class="cov0" title="0">
                matcher, err := NewHashMatcher(node.Args[0].Value, false)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">return &amp;PrimitiveCond{
                        name:    node.Fun.Name,
                        node:    node,
                        fetcher: &amp;CIPFetcher{},
                        matcher: matcher,
                }, nil</span>
        case "req_proto_match":<span class="cov0" title="0">
                return &amp;PrimitiveCond{
                        name:    node.Fun.Name,
                        fetcher: &amp;ProtoFetcher{},
                        matcher: NewExactMatcher(node.Args[0].Value, true),
                }, nil</span>
        case "req_proto_secure":<span class="cov0" title="0">
                return &amp;SecureProtoMatcher{}, nil</span>
        case "req_host_in":<span class="cov0" title="0">
                matcher, err := NewHostMatcher(node.Args[0].Value)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">return &amp;PrimitiveCond{
                        name:    node.Fun.Name,
                        node:    node,
                        fetcher: &amp;HostFetcher{},
                        matcher: matcher,
                }, nil</span>
        case "req_host_tag_in":<span class="cov8" title="1">
                return &amp;PrimitiveCond{
                        name:    node.Fun.Name,
                        node:    node,
                        fetcher: &amp;HostTagFetcher{},
                        matcher: NewInMatcher(node.Args[0].Value, true),
                }, nil</span>
        case "req_host_regmatch":<span class="cov0" title="0">
                reg, err := regexp.Compile(node.Args[0].Value)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("compile regexp err %s", err)
                }</span>
                <span class="cov0" title="0">return &amp;PrimitiveCond{
                        name:    node.Fun.Name,
                        node:    node,
                        fetcher: &amp;HostFetcher{},
                        matcher: NewRegMatcher(reg),
                }, nil</span>
        case "req_host_suffix_in":<span class="cov0" title="0">
                return &amp;PrimitiveCond{
                        name:    node.Fun.Name,
                        node:    node,
                        fetcher: &amp;HostFetcher{},
                        matcher: NewSuffixInMatcher(node.Args[0].Value, true),
                }, nil</span>
        case "req_path_in":<span class="cov8" title="1">
                return &amp;PrimitiveCond{
                        name:    node.Fun.Name,
                        node:    node,
                        fetcher: &amp;PathFetcher{},
                        matcher: NewInMatcher(node.Args[0].Value, node.Args[1].ToBool()),
                }, nil</span>
        case "req_path_prefix_in":<span class="cov0" title="0">
                return &amp;PrimitiveCond{
                        name:    node.Fun.Name,
                        node:    node,
                        fetcher: &amp;PathFetcher{},
                        matcher: NewPrefixInMatcher(node.Args[0].Value, node.Args[1].ToBool()),
                }, nil</span>
        case "req_path_suffix_in":<span class="cov0" title="0">
                return &amp;PrimitiveCond{
                        name:    node.Fun.Name,
                        node:    node,
                        fetcher: &amp;PathFetcher{},
                        matcher: NewSuffixInMatcher(node.Args[0].Value, node.Args[1].ToBool()),
                }, nil</span>
        case "req_path_element_prefix_in":<span class="cov8" title="1">
                return &amp;PrimitiveCond{
                        name:    node.Fun.Name,
                        node:    node,
                        fetcher: &amp;PathFetcher{},
                        matcher: NewPathElementPrefixMatcher(node.Args[0].Value, node.Args[1].ToBool()),
                }, nil</span>
        case "req_path_regmatch":<span class="cov0" title="0">
                reg, err := regexp.Compile(node.Args[0].Value)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("compile regexp err %s", err)
                }</span>
                <span class="cov0" title="0">return &amp;PrimitiveCond{
                        name:    node.Fun.Name,
                        node:    node,
                        fetcher: &amp;PathFetcher{},
                        matcher: NewRegMatcher(reg),
                }, nil</span>
        case "req_path_contain":<span class="cov0" title="0">
                return &amp;PrimitiveCond{
                        name:    node.Fun.Name,
                        node:    node,
                        fetcher: &amp;PathFetcher{},
                        matcher: NewContainMatcher(node.Args[0].Value, node.Args[1].ToBool()),
                }, nil</span>
        case "req_url_regmatch":<span class="cov8" title="1">
                reg, err := regexp.Compile(node.Args[0].Value)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("compile regexp err %s", err)
                }</span>
                <span class="cov8" title="1">return &amp;PrimitiveCond{
                        name:    node.Fun.Name,
                        node:    node,
                        fetcher: &amp;UrlFetcher{},
                        matcher: NewRegMatcher(reg),
                }, nil</span>
        case "req_query_key_in":<span class="cov0" title="0">
                return &amp;PrimitiveCond{
                        name: node.Fun.Name,
                        node: node,
                        fetcher: &amp;QueryKeyInFetcher{
                                keys: strings.Split(node.Args[0].Value, "|"),
                        },
                        matcher: &amp;BypassMatcher{},
                }, nil</span>
        case "req_query_exist":<span class="cov8" title="1">
                return &amp;QueryExistMatcher{}, nil</span>
        case "req_query_key_prefix_in":<span class="cov0" title="0">
                return &amp;PrimitiveCond{
                        name: node.Fun.Name,
                        node: node,
                        fetcher: &amp;QueryKeyPrefixInFetcher{
                                keys: strings.Split(node.Args[0].Value, "|"),
                        },
                        matcher: &amp;BypassMatcher{},
                }, nil</span>
        case "req_query_value_in":<span class="cov0" title="0">
                return &amp;PrimitiveCond{
                        name: node.Fun.Name,
                        node: node,
                        fetcher: &amp;QueryValueFetcher{
                                key: node.Args[0].Value,
                        },
                        matcher: NewInMatcher(node.Args[1].Value, node.Args[2].ToBool()),
                }, nil</span>
        case "req_query_value_prefix_in":<span class="cov0" title="0">
                return &amp;PrimitiveCond{
                        name:    node.Fun.Name,
                        node:    node,
                        fetcher: &amp;QueryValueFetcher{node.Args[0].Value},
                        matcher: NewPrefixInMatcher(node.Args[1].Value, node.Args[2].ToBool()),
                }, nil</span>
        case "req_query_value_suffix_in":<span class="cov0" title="0">
                return &amp;PrimitiveCond{
                        name:    node.Fun.Name,
                        node:    node,
                        fetcher: &amp;QueryValueFetcher{node.Args[0].Value},
                        matcher: NewSuffixInMatcher(node.Args[1].Value, node.Args[2].ToBool()),
                }, nil</span>
        case "req_query_value_regmatch":<span class="cov8" title="1">
                reg, err := regexp.Compile(node.Args[1].Value)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("compile regexp err %s", err)
                }</span>

                <span class="cov8" title="1">return &amp;PrimitiveCond{
                        name:    node.Fun.Name,
                        node:    node,
                        fetcher: &amp;QueryValueFetcher{node.Args[0].Value},
                        matcher: NewRegMatcher(reg),
                }, nil</span>
        case "req_query_value_contain":<span class="cov0" title="0">
                return &amp;PrimitiveCond{
                        name:    node.Fun.Name,
                        node:    node,
                        fetcher: &amp;QueryValueFetcher{node.Args[0].Value},
                        matcher: NewContainMatcher(node.Args[1].Value, node.Args[2].ToBool()),
                }, nil</span>
        case "req_query_value_hash_in":<span class="cov0" title="0">
                matcher, err := NewHashMatcher(node.Args[1].Value, node.Args[2].ToBool())
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">return &amp;PrimitiveCond{
                        name:    node.Fun.Name,
                        node:    node,
                        fetcher: &amp;QueryValueFetcher{node.Args[0].Value},
                        matcher: matcher,
                }, nil</span>
        case "req_cookie_key_in":<span class="cov0" title="0">
                return &amp;PrimitiveCond{
                        name: node.Fun.Name,
                        node: node,
                        fetcher: &amp;CookieKeyInFetcher{
                                keys: strings.Split(node.Args[0].Value, "|"),
                        },
                        matcher: &amp;BypassMatcher{},
                }, nil</span>
        case "req_cookie_value_in":<span class="cov0" title="0">
                return &amp;PrimitiveCond{
                        name:    node.Fun.Name,
                        node:    node,
                        fetcher: &amp;CookieValueFetcher{node.Args[0].Value},
                        matcher: NewInMatcher(node.Args[1].Value, node.Args[2].ToBool()),
                }, nil</span>
        case "req_cookie_value_prefix_in":<span class="cov0" title="0">
                return &amp;PrimitiveCond{
                        name:    node.Fun.Name,
                        node:    node,
                        fetcher: &amp;CookieValueFetcher{node.Args[0].Value},
                        matcher: NewPrefixInMatcher(node.Args[1].Value, node.Args[2].ToBool()),
                }, nil</span>
        case "req_cookie_value_suffix_in":<span class="cov0" title="0">
                return &amp;PrimitiveCond{
                        name:    node.Fun.Name,
                        node:    node,
                        fetcher: &amp;CookieValueFetcher{node.Args[0].Value},
                        matcher: NewSuffixInMatcher(node.Args[1].Value, node.Args[2].ToBool()),
                }, nil</span>
        case "req_cookie_value_contain":<span class="cov0" title="0">
                return &amp;PrimitiveCond{
                        name:    node.Fun.Name,
                        node:    node,
                        fetcher: &amp;CookieValueFetcher{node.Args[0].Value},
                        matcher: NewContainMatcher(node.Args[1].Value, node.Args[2].ToBool()),
                }, nil</span>
        case "req_cookie_value_hash_in":<span class="cov0" title="0">
                matcher, err := NewHashMatcher(node.Args[1].Value, node.Args[2].ToBool())
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">return &amp;PrimitiveCond{
                        name:    node.Fun.Name,
                        node:    node,
                        fetcher: &amp;CookieValueFetcher{node.Args[0].Value},
                        matcher: matcher,
                }, nil</span>
        case "req_port_in":<span class="cov0" title="0">
                return &amp;PrimitiveCond{
                        name:    node.Fun.Name,
                        node:    node,
                        fetcher: &amp;PortFetcher{},
                        matcher: NewInMatcher(node.Args[0].Value, false),
                }, nil</span>
        case "req_tag_match":<span class="cov0" title="0">
                return &amp;PrimitiveCond{
                        name:    node.Fun.Name,
                        node:    node,
                        fetcher: &amp;TagFetcher{key: node.Args[0].Value},
                        matcher: &amp;HasTagMatcher{value: node.Args[1].Value},
                }, nil</span>
        case "req_ua_regmatch":<span class="cov0" title="0">
                reg, err := regexp.Compile(node.Args[0].Value)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("compile regexp err %s", err)
                }</span>

                <span class="cov0" title="0">return &amp;PrimitiveCond{
                        name:    node.Fun.Name,
                        node:    node,
                        fetcher: &amp;UAFetcher{},
                        matcher: NewRegMatcher(reg),
                }, nil</span>
        case "req_header_key_in":<span class="cov0" title="0">
                return &amp;PrimitiveCond{
                        name: node.Fun.Name,
                        node: node,
                        fetcher: &amp;HeaderKeyInFetcher{
                                keys: strings.Split(node.Args[0].Value, "|"),
                        },
                        matcher: &amp;BypassMatcher{},
                }, nil</span>
        case "req_header_value_in":<span class="cov0" title="0">
                return &amp;PrimitiveCond{
                        name:    node.Fun.Name,
                        node:    node,
                        fetcher: &amp;HeaderValueFetcher{node.Args[0].Value},
                        matcher: NewInMatcher(node.Args[1].Value, node.Args[2].ToBool()),
                }, nil</span>
        case "req_header_value_prefix_in":<span class="cov0" title="0">
                return &amp;PrimitiveCond{
                        name:    node.Fun.Name,
                        node:    node,
                        fetcher: &amp;HeaderValueFetcher{node.Args[0].Value},
                        matcher: NewPrefixInMatcher(node.Args[1].Value, node.Args[2].ToBool()),
                }, nil</span>
        case "req_header_value_suffix_in":<span class="cov0" title="0">
                return &amp;PrimitiveCond{
                        name:    node.Fun.Name,
                        node:    node,
                        fetcher: &amp;HeaderValueFetcher{node.Args[0].Value},
                        matcher: NewSuffixInMatcher(node.Args[1].Value, node.Args[2].ToBool()),
                }, nil</span>
        case "req_header_value_regmatch":<span class="cov0" title="0">
                reg, err := regexp.Compile(node.Args[1].Value)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("compile regexp err %s", err)
                }</span>

                <span class="cov0" title="0">return &amp;PrimitiveCond{
                        name:    node.Fun.Name,
                        node:    node,
                        fetcher: &amp;HeaderValueFetcher{node.Args[0].Value},
                        matcher: NewRegMatcher(reg),
                }, nil</span>
        case "req_header_value_contain":<span class="cov0" title="0">
                return &amp;PrimitiveCond{
                        name:    node.Fun.Name,
                        node:    node,
                        fetcher: &amp;HeaderValueFetcher{node.Args[0].Value},
                        matcher: NewContainMatcher(node.Args[1].Value, node.Args[2].ToBool()),
                }, nil</span>
        case "req_header_value_hash_in":<span class="cov8" title="1">
                matcher, err := NewHashMatcher(node.Args[1].Value, node.Args[2].ToBool())
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">return &amp;PrimitiveCond{
                        name:    node.Fun.Name,
                        node:    node,
                        fetcher: &amp;HeaderValueFetcher{node.Args[0].Value},
                        matcher: matcher,
                }, nil</span>
        case "req_method_in":<span class="cov0" title="0">
                return &amp;PrimitiveCond{
                        name:    node.Fun.Name,
                        node:    node,
                        fetcher: &amp;MethodFetcher{},
                        matcher: NewInMatcher(node.Args[0].Value, true),
                }, nil</span>
        case "res_code_in":<span class="cov0" title="0">
                return &amp;PrimitiveCond{
                        name:    node.Fun.Name,
                        node:    node,
                        fetcher: &amp;ResCodeFetcher{},
                        matcher: NewInMatcher(node.Args[0].Value, false),
                }, nil</span>
        case "res_header_key_in":<span class="cov0" title="0">
                return &amp;PrimitiveCond{
                        name: node.Fun.Name,
                        node: node,
                        fetcher: &amp;ResHeaderKeyInFetcher{
                                keys: strings.Split(node.Args[0].Value, "|"),
                        },
                        matcher: &amp;BypassMatcher{},
                }, nil</span>
        case "res_header_value_in":<span class="cov0" title="0">
                return &amp;PrimitiveCond{
                        name:    node.Fun.Name,
                        node:    node,
                        fetcher: &amp;ResHeaderValueFetcher{node.Args[0].Value},
                        matcher: NewInMatcher(node.Args[1].Value, node.Args[2].ToBool()),
                }, nil</span>

        case "ses_vip_range":<span class="cov0" title="0">
                matcher, err := NewIPMatcher(node.Args[0].Value, node.Args[1].Value)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">return &amp;PrimitiveCond{
                        name:    node.Fun.Name,
                        node:    node,
                        fetcher: &amp;VIPFetcher{},
                        matcher: matcher,
                }, nil</span>
        case "ses_sip_range":<span class="cov0" title="0">
                matcher, err := NewIPMatcher(node.Args[0].Value, node.Args[1].Value)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">return &amp;PrimitiveCond{
                        name:    node.Fun.Name,
                        node:    node,
                        fetcher: &amp;SIPFetcher{},
                        matcher: matcher,
                }, nil</span>
        case "ses_tls_sni_in":<span class="cov8" title="1">
                return &amp;PrimitiveCond{
                        name:    node.Fun.Name,
                        node:    node,
                        fetcher: &amp;SniFetcher{},
                        matcher: NewInMatcher(node.Args[0].Value, true),
                }, nil</span>
        case "ses_tls_client_auth":<span class="cov8" title="1">
                return &amp;ClientAuthMatcher{}, nil</span>
        case "ses_tls_client_ca_in":<span class="cov8" title="1">
                return &amp;PrimitiveCond{
                        name:    node.Fun.Name,
                        node:    node,
                        fetcher: &amp;ClientCANameFetcher{},
                        matcher: NewInMatcher(node.Args[0].Value, false),
                }, nil</span>
        case "req_context_value_in":<span class="cov0" title="0">
                return &amp;PrimitiveCond{
                        name:    node.Fun.Name,
                        node:    node,
                        fetcher: &amp;ContextValueFetcher{node.Args[0].Value},
                        matcher: NewInMatcher(node.Args[1].Value, node.Args[2].ToBool()),
                }, nil</span>

        case "bfe_time_range":<span class="cov0" title="0">
                matcher, err := NewTimeMatcher(node.Args[0].Value, node.Args[1].Value)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return &amp;PrimitiveCond{
                        name:    node.Fun.Name,
                        node:    node,
                        fetcher: &amp;BfeTimeFetcher{},
                        matcher: matcher,
                }, nil</span>

        case "bfe_periodic_time_range":<span class="cov0" title="0">
                matcher, err := NewPeriodicTimeMatcher(node.Args[0].Value, node.Args[1].Value, node.Args[2].Value)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return &amp;PrimitiveCond{
                        name:    node.Fun.Name,
                        node:    node,
                        fetcher: &amp;BfeTimeFetcher{},
                        matcher: matcher,
                }, nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported primitive %s", node.Fun.Name)</span>
        }
}
</pre>
		
		<pre class="file" id="file13" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// composite condition implementation

package condition

import (
        "github.com/bfenetworks/bfe/bfe_basic"
        "github.com/bfenetworks/bfe/bfe_basic/condition/parser"
)

// UnaryCond is unary condition for !cond
type UnaryCond struct {
        op   parser.Token
        cond Condition
}

func (uc *UnaryCond) Match(req *bfe_basic.Request) bool <span class="cov0" title="0">{
        switch uc.op </span>{
        case parser.NOT:<span class="cov0" title="0">
                return !uc.cond.Match(req)</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

// BinaryCond is binary condition for lc&amp;&amp;rc , lc||rc
type BinaryCond struct {
        op parser.Token
        lc Condition
        rc Condition
}

func (bc *BinaryCond) Match(req *bfe_basic.Request) bool <span class="cov0" title="0">{
        switch bc.op </span>{
        case parser.LAND:<span class="cov0" title="0">
                return bc.lc.Match(req) &amp;&amp; bc.rc.Match(req)</span>
        case parser.LOR:<span class="cov0" title="0">
                return bc.lc.Match(req) || bc.rc.Match(req)</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}
</pre>
		
		<pre class="file" id="file14" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// ast node for condition expression

package parser

import (
        "bytes"
        "go/token"
        "strconv"
        "strings"
)

type Node interface {
        Pos() token.Pos
        End() token.Pos
}

type Expr interface {
        Node
        //    exprNode()
}

type BinaryExpr struct {
        X  Expr
        Op Token
        Y  Expr
}

type UnaryExpr struct {
        X     Expr
        Op    Token
        OpPos token.Pos
}

type Ident struct {
        Name    string
        NamePos token.Pos
}

type BasicLit struct {
        Kind     Token
        Value    string
        ValuePos token.Pos
}

type CallExpr struct {
        Fun    *Ident
        Args   BasicLitList
        Rparen token.Pos
}

type ParenExpr struct {
        X Expr
}

func (c CallExpr) String() string <span class="cov0" title="0">{
        var b bytes.Buffer

        b.WriteString(c.Fun.Name)
        b.WriteString("(")

        var strArgs []string
        for _, arg := range c.Args </span><span class="cov0" title="0">{
                if arg.Kind == STRING </span><span class="cov0" title="0">{
                        strArgs = append(strArgs, strconv.Quote(arg.Value))
                }</span> else<span class="cov0" title="0"> {
                        strArgs = append(strArgs, arg.Value)
                }</span>
        }

        <span class="cov0" title="0">b.WriteString(strings.Join(strArgs, ","))
        b.WriteString(")")

        return b.String()</span>

}

type BasicLitList []*BasicLit

func (b *BinaryExpr) Pos() token.Pos <span class="cov0" title="0">{
        return b.X.Pos()
}</span>

func (b *BinaryExpr) End() token.Pos <span class="cov0" title="0">{
        return b.Y.End()
}</span>

func (u *UnaryExpr) Pos() token.Pos <span class="cov0" title="0">{
        return u.OpPos
}</span>

func (u *UnaryExpr) End() token.Pos <span class="cov0" title="0">{
        return u.X.End()
}</span>

func (id *Ident) Pos() token.Pos <span class="cov8" title="1">{
        return id.NamePos
}</span>

func (id *Ident) End() token.Pos <span class="cov0" title="0">{
        return token.Pos(int(id.NamePos) + len(id.Name))
}</span>

func (b *BasicLit) Pos() token.Pos <span class="cov0" title="0">{
        return b.ValuePos
}</span>

func (b *BasicLit) End() token.Pos <span class="cov0" title="0">{
        return token.Pos(int(b.ValuePos) + len(b.Value))
}</span>

func (c *CallExpr) Pos() token.Pos <span class="cov8" title="1">{
        return c.Fun.Pos()
}</span>

func (c *CallExpr) End() token.Pos <span class="cov0" title="0">{
        return c.Rparen
}</span>

func (b BasicLitList) Pos() token.Pos <span class="cov0" title="0">{
        return b[0].Pos()
}</span>

func (b BasicLitList) End() token.Pos <span class="cov0" title="0">{
        return b[len(b)].End()
}</span>

func (p ParenExpr) Pos() token.Pos <span class="cov0" title="0">{
        return p.X.Pos()
}</span>

func (p ParenExpr) End() token.Pos <span class="cov0" title="0">{
        return p.X.End()
}</span>

func (b *BasicLit) ToBool() bool <span class="cov0" title="0">{
        if b.Kind != BOOL </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return strings.ToUpper(b.Value) == "TRUE"</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">//go:generate goyacc -p cond cond.y

// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// parser for condition expression

package parser

import (
        "fmt"
        "go/token"
        "strings"
        "sync"
)

// ErrorHandler is error handler for scanner and lexer
type ErrorHandler func(pos token.Pos, msg string)

type Parser struct {
        fset    *token.FileSet
        scanner Scanner
        lexer   *condLex

        identList []*Ident
        errors    []Error
        ast       Node
}

type Error struct {
        pos token.Position
        msg string
}

func (e Error) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("%s %s", e.pos, e.msg)
}</span>

func (p *Parser) Init(src []byte) <span class="cov8" title="1">{
        p.fset = token.NewFileSet()
        p.errors = p.errors[0:0]
        p.identList = p.identList[0:0]

        file := p.fset.AddFile("", p.fset.Base(), len(src))
        p.scanner.Init(file, src, p.addError)
        p.lexer = &amp;condLex{
                s:   &amp;p.scanner,
                err: p.addError,
        }
}</span>

func (p *Parser) addError(pos token.Pos, msg string) <span class="cov8" title="1">{
        p.errors = append(p.errors, Error{pos: p.fset.Position(pos), msg: msg})
}</span>

// Error return first error.
func (p *Parser) Error() error <span class="cov8" title="1">{
        if len(p.errors) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">return p.errors[0]</span>
}

var parseLock sync.Mutex

func (p *Parser) Parse() <span class="cov8" title="1">{
        parseLock.Lock()
        defer parseLock.Unlock()

        // Note: y.go:condParse() use global variable for parsed nodes.
        condParse(p.lexer)
        p.ast = parseNode

        if len(p.errors) &gt; 0 </span><span class="cov0" title="0">{
                return
        }</span>

        // colllect all variables
        <span class="cov8" title="1">Inspect(p.ast, p.collectVariable)

        // static check for all call expr
        Inspect(p.ast, p.primitiveCheck)</span>
}

// String returns string representation of parsed variables and errors.
func (p Parser) String() string <span class="cov0" title="0">{
        var variables []string

        for _, ident := range p.identList </span><span class="cov0" title="0">{
                variables = append(variables, ident.Name)
        }</span>

        <span class="cov0" title="0">var errors []string

        for _, err := range p.errors </span><span class="cov0" title="0">{
                errors = append(errors, err.Error())
        }</span>

        <span class="cov0" title="0">return "names: " + strings.Join(variables, ",") + "\terrors: " + strings.Join(errors, ",")</span>
}

// Parse parse given condition string.
//
// condStr: input condition expression
// err : err is not nil if parse error(including scan, lexer, prototype check)
// idents: if err is nil, all conditionVariable is list in idents ([]*Ident)
// node: if err is nil, parsed ast is returned by node
func Parse(condStr string) (Node, []*Ident, error) <span class="cov8" title="1">{
        var p Parser

        p.Init([]byte(condStr))
        p.Parse()

        if err := p.Error(); err != nil </span><span class="cov8" title="1">{
                return nil, nil, err
        }</span>

        <span class="cov8" title="1">return p.ast, p.identList, nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// scanner for condition expression

package parser

import (
        "fmt"
        "go/token"
        "path/filepath"
        "unicode"
        "unicode/utf8"
)

type Scanner struct {
        file *token.File
        dir  string
        src  []byte
        err  ErrorHandler // error reporting; or nil

        ch         rune
        offset     int
        rdOffset   int
        lineOffset int

        ErrorCount int
}

const bom = 0xFEFF // byte order mark, only permitted as very first character

// Init prepares the scanner s to tokenize the text src by setting the
// scanner at the beginning of src. The scanner uses the file set file
// for position information and it adds line information for each line.
// It is ok to re-use the same file when re-scanning the same file as
// line information which is already present is ignored. Init causes a
// panic if the file size does not match the src size.
//
// Calls to Scan will invoke the error handler err if they encounter a
// syntax error and err is not nil. Also, for each error encountered,
// the Scanner field ErrorCount is incremented by one. The mode parameter
// determines how comments are handled.
//
// Note that Init may call err if there is an error in the first character
// of the file.
//
func (s *Scanner) Init(file *token.File, src []byte, err ErrorHandler) <span class="cov8" title="1">{
        // Explicitly initialize all fields since a scanner may be reused.
        if file.Size() != len(src) </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("file size (%d) does not match src len (%d)", file.Size(), len(src)))</span>
        }
        <span class="cov8" title="1">s.file = file
        s.dir, _ = filepath.Split(file.Name())
        s.src = src
        s.err = err

        s.ch = ' '
        s.offset = 0
        s.rdOffset = 0
        s.lineOffset = 0
        s.ErrorCount = 0

        s.next()
        if s.ch == bom </span><span class="cov0" title="0">{
                s.next() // ignore BOM at file beginning
        }</span>
}

func (s *Scanner) error(offs int, msg string) <span class="cov0" title="0">{
        if s.err != nil </span><span class="cov0" title="0">{
                s.err(s.file.Pos(offs), msg)
        }</span>
        <span class="cov0" title="0">s.ErrorCount++</span>
}

func (s *Scanner) next() <span class="cov8" title="1">{
        if s.rdOffset &lt; len(s.src) </span><span class="cov8" title="1">{
                s.offset = s.rdOffset
                if s.ch == '\n' </span><span class="cov0" title="0">{
                        s.lineOffset = s.offset
                        s.file.AddLine(s.offset)
                }</span>
                <span class="cov8" title="1">r, w := rune(s.src[s.rdOffset]), 1
                switch </span>{
                case r == 0:<span class="cov0" title="0">
                        s.error(s.offset, "illegal character NUL")</span>
                case r &gt;= 0x80:<span class="cov0" title="0">
                        r, w = utf8.DecodeRune(s.src[s.rdOffset:])
                        if r == utf8.RuneError &amp;&amp; w == 1 </span><span class="cov0" title="0">{
                                s.error(s.offset, "illegal UTF-8 encoding")
                        }</span> else<span class="cov0" title="0"> if r == bom &amp;&amp; s.offset &gt; 0 </span><span class="cov0" title="0">{
                                s.error(s.offset, "illegal byte order mark")
                        }</span>
                }
                <span class="cov8" title="1">s.rdOffset += w
                s.ch = r</span>
        } else<span class="cov8" title="1"> {
                s.offset = len(s.src)
                if s.ch == '\n' </span><span class="cov0" title="0">{
                        s.lineOffset = s.offset
                        s.file.AddLine(s.offset)
                }</span>
                <span class="cov8" title="1">s.ch = -1</span>
        }
}

func (s *Scanner) skipWhitespace() <span class="cov8" title="1">{
        for s.ch == ' ' || s.ch == '\t' || s.ch == '\r' || s.ch == '\n' </span><span class="cov8" title="1">{
                s.next()
        }</span>
}

func isLetter(ch rune) bool <span class="cov8" title="1">{
        return 'a' &lt;= ch &amp;&amp; ch &lt;= 'z' || 'A' &lt;= ch &amp;&amp; ch &lt;= 'Z' || ch == '_' || ch == '-' || ch &gt;= 0x80 &amp;&amp; unicode.IsLetter(ch)
}</span>

func isDigit(ch rune) bool <span class="cov8" title="1">{
        return '0' &lt;= ch &amp;&amp; ch &lt;= '9' || ch &gt;= 0x80 &amp;&amp; unicode.IsDigit(ch)
}</span>

func (s *Scanner) scanIdentifier() string <span class="cov8" title="1">{
        offs := s.offset
        for isLetter(s.ch) || isDigit(s.ch) </span><span class="cov8" title="1">{
                s.next()
        }</span>
        <span class="cov8" title="1">return string(s.src[offs:s.offset])</span>
}

func stripCR(b []byte) []byte <span class="cov0" title="0">{
        c := make([]byte, len(b))
        i := 0
        for _, ch := range b </span><span class="cov0" title="0">{
                if ch != '\r' </span><span class="cov0" title="0">{
                        c[i] = ch
                        i++
                }</span>
        }
        <span class="cov0" title="0">return c[:i]</span>
}

func (s *Scanner) scanString() string <span class="cov8" title="1">{
        // '"' opening already consumed
        offs := s.offset - 1

        for </span><span class="cov8" title="1">{
                ch := s.ch
                if ch == '\n' || ch &lt; 0 </span><span class="cov0" title="0">{
                        s.error(offs, "string literal not terminated")
                        break</span>
                }
                <span class="cov8" title="1">s.next()
                if ch == '"' </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">if ch == '\\' </span><span class="cov0" title="0">{
                        s.scanEscape('"')
                }</span>
        }

        <span class="cov8" title="1">return string(s.src[offs+1 : s.offset-1])</span>
}

// scanEscape parses an escape sequence where rune is the accepted
// escaped quote. In case of a syntax error, it stops at the offending
// character (without consuming it) and returns false. Otherwise
// it returns true.
func (s *Scanner) scanEscape(quote rune) bool <span class="cov0" title="0">{
        offs := s.offset

        var n int
        var base, max uint32
        switch s.ch </span>{
        case 'a', 'b', 'f', 'n', 'r', 't', 'v', '\\', quote:<span class="cov0" title="0">
                s.next()
                return true</span>
        case '0', '1', '2', '3', '4', '5', '6', '7':<span class="cov0" title="0">
                n, base, max = 3, 8, 255</span>
        case 'x':<span class="cov0" title="0">
                s.next()
                n, base, max = 2, 16, 255</span>
        case 'u':<span class="cov0" title="0">
                s.next()
                n, base, max = 4, 16, unicode.MaxRune</span>
        case 'U':<span class="cov0" title="0">
                s.next()
                n, base, max = 8, 16, unicode.MaxRune</span>
        default:<span class="cov0" title="0">
                msg := "unknown escape sequence"
                if s.ch &lt; 0 </span><span class="cov0" title="0">{
                        msg = "escape sequence not terminated"
                }</span>
                <span class="cov0" title="0">s.error(offs, msg)
                return false</span>
        }

        <span class="cov0" title="0">var x uint32
        for n &gt; 0 </span><span class="cov0" title="0">{
                d := uint32(digitVal(s.ch))
                if d &gt;= base </span><span class="cov0" title="0">{
                        msg := fmt.Sprintf("illegal character %#U in escape sequence", s.ch)
                        if s.ch &lt; 0 </span><span class="cov0" title="0">{
                                msg = "escape sequence not terminated"
                        }</span>
                        <span class="cov0" title="0">s.error(s.offset, msg)
                        return false</span>
                }
                <span class="cov0" title="0">x = x*base + d
                s.next()
                n--</span>
        }

        <span class="cov0" title="0">if x &gt; max || 0xD800 &lt;= x &amp;&amp; x &lt; 0xE000 </span><span class="cov0" title="0">{
                s.error(offs, "escape sequence is invalid Unicode code point")
                return false
        }</span>

        <span class="cov0" title="0">return true</span>
}

func digitVal(ch rune) int <span class="cov0" title="0">{
        switch </span>{
        case '0' &lt;= ch &amp;&amp; ch &lt;= '9':<span class="cov0" title="0">
                return int(ch - '0')</span>
        case 'a' &lt;= ch &amp;&amp; ch &lt;= 'f':<span class="cov0" title="0">
                return int(ch - 'a' + 10)</span>
        case 'A' &lt;= ch &amp;&amp; ch &lt;= 'F':<span class="cov0" title="0">
                return int(ch - 'A' + 10)</span>
        }
        <span class="cov0" title="0">return 16</span> // larger than any legal digit val
}

func (s *Scanner) scanRawString() string <span class="cov0" title="0">{
        // '`' opening already consumed
        offs := s.offset - 1

        hasCR := false
        for </span><span class="cov0" title="0">{
                ch := s.ch
                if ch &lt; 0 </span><span class="cov0" title="0">{
                        s.error(offs, "raw string literal not terminated")
                        break</span>
                }
                <span class="cov0" title="0">s.next()
                if ch == '`' </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">if ch == '\r' </span><span class="cov0" title="0">{
                        hasCR = true
                }</span>
        }

        <span class="cov0" title="0">lit := s.src[offs+1 : s.offset-1]
        if hasCR </span><span class="cov0" title="0">{
                lit = stripCR(lit)
        }</span>

        <span class="cov0" title="0">return string(lit)</span>
}

func (s *Scanner) scanComment() string <span class="cov0" title="0">{
        offs := s.offset - 1
        hasCR := false

        s.next()
        for s.ch != '\n' &amp;&amp; s.ch &gt;= 0 </span><span class="cov0" title="0">{
                if s.ch == '\r' </span><span class="cov0" title="0">{
                        hasCR = true
                }</span>
                <span class="cov0" title="0">s.next()</span>
        }

        <span class="cov0" title="0">lit := s.src[offs:s.offset]
        if hasCR </span><span class="cov0" title="0">{
                lit = stripCR(lit)
        }</span>

        <span class="cov0" title="0">return string(lit)</span>
}

func (s *Scanner) scanMantissa(base int) <span class="cov0" title="0">{
        for digitVal(s.ch) &lt; base </span><span class="cov0" title="0">{
                s.next()
        }</span>
}

func (s *Scanner) scanNumber(seenDecimalPoint bool) (Token, string) <span class="cov0" title="0">{
        // digitVal(s.ch) &lt; 10
        offs := s.offset
        tok := INT

        if seenDecimalPoint </span><span class="cov0" title="0">{
                offs--
                tok = FLOAT
                s.scanMantissa(10)
                goto exponent</span>
        }

        <span class="cov0" title="0">if s.ch == '0' </span><span class="cov0" title="0">{
                // int or float
                offs := s.offset
                s.next()
                if s.ch == 'x' || s.ch == 'X' </span><span class="cov0" title="0">{
                        // hexadecimal int
                        s.next()
                        s.scanMantissa(16)
                        if s.offset-offs &lt;= 2 </span><span class="cov0" title="0">{
                                // only scanned "0x" or "0X"
                                s.error(offs, "illegal hexadecimal number")
                        }</span>
                } else<span class="cov0" title="0"> {
                        // octal int or float
                        seenDecimalDigit := false
                        s.scanMantissa(8)
                        if s.ch == '8' || s.ch == '9' </span><span class="cov0" title="0">{
                                // illegal octal int or float
                                seenDecimalDigit = true
                                s.scanMantissa(10)
                        }</span>
                        <span class="cov0" title="0">if s.ch == '.' || s.ch == 'e' || s.ch == 'E' || s.ch == 'i' </span><span class="cov0" title="0">{
                                goto fraction</span>
                        }
                        // octal int
                        <span class="cov0" title="0">if seenDecimalDigit </span><span class="cov0" title="0">{
                                s.error(offs, "illegal octal number")
                        }</span>
                }
                <span class="cov0" title="0">goto exit</span>
        }

        // decimal int or float
        <span class="cov0" title="0">s.scanMantissa(10)

</span>fraction:
        <span class="cov0" title="0">if s.ch == '.' </span><span class="cov0" title="0">{
                tok = FLOAT
                s.next()
                s.scanMantissa(10)
        }</span>

exponent:
        <span class="cov0" title="0">if s.ch == 'e' || s.ch == 'E' </span><span class="cov0" title="0">{
                tok = FLOAT
                s.next()
                if s.ch == '-' || s.ch == '+' </span><span class="cov0" title="0">{
                        s.next()
                }</span>
                <span class="cov0" title="0">s.scanMantissa(10)</span>
        }

        <span class="cov0" title="0">if s.ch == 'i' </span><span class="cov0" title="0">{
                tok = IMAG
                s.next()
        }</span>

exit:
        <span class="cov0" title="0">return Token(tok), string(s.src[offs:s.offset])</span>
}

func (s *Scanner) Scan() (pos token.Pos, tok Token, lit string) <span class="cov8" title="1">{
</span>scanAgain:
        <span class="cov8" title="1">s.skipWhitespace()

        // current token start
        pos = s.file.Pos(s.offset)

        // determine token value
        switch ch := s.ch; </span>{
        case isLetter(ch):<span class="cov8" title="1">
                lit = s.scanIdentifier()
                if len(lit) &gt; 1 </span><span class="cov8" title="1">{
                        // keywords are longer than one letter - avoid lookup otherwise
                        tok = Lookup(lit)
                        if tok != IDENT </span><span class="cov0" title="0">{
                                // go keyword can't be used
                                tok = ILLEGAL
                                s.error(s.offset, "keyword can't be used")
                        }</span>
                        <span class="cov8" title="1">if lit == "true" || lit == "false" </span><span class="cov8" title="1">{
                                tok = BOOL
                        }</span>

                } else<span class="cov8" title="1"> {
                        tok = IDENT
                }</span>
        case '0' &lt;= ch &amp;&amp; ch &lt;= '9':<span class="cov0" title="0">
                tok, lit = s.scanNumber(false)</span>
        default:<span class="cov8" title="1">
                s.next() // always make progress
                switch ch </span>{
                case -1:<span class="cov8" title="1">
                        tok = EOF</span>
                case ';':<span class="cov0" title="0">
                        tok = SEMICOLON
                        lit = ";"</span>
                case '"':<span class="cov8" title="1">
                        tok = STRING
                        lit = s.scanString()</span>
                case '`':<span class="cov0" title="0">
                        tok = STRING
                        lit = s.scanRawString()</span>
                case '(':<span class="cov8" title="1">
                        tok = LPAREN
                        lit = "("</span>
                case ')':<span class="cov8" title="1">
                        tok = RPAREN
                        lit = ")"</span>
                case '!':<span class="cov8" title="1">
                        tok = NOT
                        lit = "!"</span>
                case ',':<span class="cov8" title="1">
                        tok = COMMA
                        lit = ","</span>
                case '&amp;':<span class="cov8" title="1">
                        if s.ch == '&amp;' </span><span class="cov8" title="1">{
                                s.next()
                                tok = LAND
                                lit = "&amp;&amp;"
                        }</span> else<span class="cov0" title="0"> {
                                tok = ILLEGAL
                                lit = string(ch)
                        }</span>
                case '|':<span class="cov8" title="1">
                        if s.ch == '|' </span><span class="cov8" title="1">{
                                s.next()
                                tok = LOR
                                lit = "||"
                        }</span> else<span class="cov0" title="0"> {
                                tok = ILLEGAL
                                lit = string(ch)
                        }</span>
                case '/':<span class="cov0" title="0">
                        if s.ch == '/' </span><span class="cov0" title="0">{
                                tok = COMMENT
                                lit = s.scanComment()
                                goto scanAgain</span>
                        } else<span class="cov0" title="0"> {
                                tok = ILLEGAL
                                lit = string(ch)
                        }</span>
                default:<span class="cov0" title="0">
                        tok = ILLEGAL
                        lit = string(ch)</span>
                }
        }

        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// semant check for condition expression

package parser

import (
        "fmt"
        "log"
)

// funcProtos holds a mapping from func name to args types.
var funcProtos = map[string][]Token{
        "default_t":                  nil,
        "req_cip_trusted":            nil,
        "req_vip_in":                 {STRING},
        "req_proto_match":            {STRING},
        "req_proto_secure":           nil,
        "req_host_in":                {STRING},
        "req_host_regmatch":          {STRING},
        "req_host_tag_in":            {STRING},
        "req_host_suffix_in":         {STRING},
        "req_path_in":                {STRING, BOOL},
        "req_path_prefix_in":         {STRING, BOOL},
        "req_path_suffix_in":         {STRING, BOOL},
        "req_path_contain":           {STRING, BOOL},
        "req_path_regmatch":          {STRING},
        "req_path_element_prefix_in": {STRING, BOOL},
        "req_query_key_prefix_in":    {STRING},
        "req_query_key_in":           {STRING},
        "req_query_exist":            nil,
        "req_query_value_in":         {STRING, STRING, BOOL},
        "req_query_value_prefix_in":  {STRING, STRING, BOOL},
        "req_query_value_suffix_in":  {STRING, STRING, BOOL},
        "req_query_value_regmatch":   {STRING, STRING},
        "req_query_value_contain":    {STRING, STRING, BOOL},
        "req_query_value_hash_in":    {STRING, STRING, BOOL},
        "req_url_regmatch":           {STRING},
        "req_cookie_key_in":          {STRING},
        "req_cookie_value_in":        {STRING, STRING, BOOL},
        "req_cookie_value_prefix_in": {STRING, STRING, BOOL},
        "req_cookie_value_suffix_in": {STRING, STRING, BOOL},
        "req_cookie_value_contain":   {STRING, STRING, BOOL},
        "req_cookie_value_hash_in":   {STRING, STRING, BOOL},
        "req_port_in":                {STRING},
        "req_tag_match":              {STRING, STRING},
        "req_ua_regmatch":            {STRING},
        "req_header_key_in":          {STRING},
        "req_header_value_in":        {STRING, STRING, BOOL},
        "req_header_value_prefix_in": {STRING, STRING, BOOL},
        "req_header_value_suffix_in": {STRING, STRING, BOOL},
        "req_header_value_regmatch":  {STRING, STRING},
        "req_header_value_contain":   {STRING, STRING, BOOL},
        "req_header_value_hash_in":   {STRING, STRING, BOOL},
        "req_method_in":              {STRING},
        "req_cip_range":              {STRING, STRING},
        "req_vip_range":              {STRING, STRING},
        "req_cip_hash_in":            {STRING},
        "res_code_in":                {STRING},
        "res_header_key_in":          {STRING},
        "res_header_value_in":        {STRING, STRING, BOOL},
        "ses_vip_range":              {STRING, STRING},
        "ses_sip_range":              {STRING, STRING},
        "ses_tls_sni_in":             {STRING},
        "ses_tls_client_auth":        nil,
        "ses_tls_client_ca_in":       {STRING},
        "req_context_value_in":       {STRING, STRING, BOOL},
        "bfe_time_range":             []Token{STRING, STRING},
        "bfe_periodic_time_range":    []Token{STRING, STRING, STRING},
}

func prototypeCheck(expr *CallExpr) error <span class="cov8" title="1">{
        // log.Printf("start prototype Check")
        argsType, ok := funcProtos[expr.Fun.Name]
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("primitive %s not found", expr.Fun.Name)
        }</span>

        <span class="cov8" title="1">if len(argsType) != len(expr.Args) </span><span class="cov8" title="1">{
                return fmt.Errorf("primitive args len error, expect %v, got %v", len(argsType), len(expr.Args))
        }</span>

        <span class="cov8" title="1">for i, argType := range argsType </span><span class="cov8" title="1">{
                if argType != expr.Args[i].Kind </span><span class="cov8" title="1">{
                        return fmt.Errorf("primitive %s arg %d expect %s, got %s",
                                expr.Fun.Name, i, argType, expr.Args[i].Kind)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// primitiveCheck is a traverse function to check all func call prototype.
// check: 1. func name 2. func args len and type
func (p *Parser) primitiveCheck(n Node) bool <span class="cov8" title="1">{
        switch x := n.(type) </span>{
        case *BinaryExpr, *UnaryExpr, *ParenExpr:<span class="cov8" title="1">
                return true</span>
        case *Ident:<span class="cov8" title="1">
                return false</span>
        case *CallExpr:<span class="cov8" title="1">
                if err := prototypeCheck(x); err != nil </span><span class="cov8" title="1">{
                        p.addError(x.Pos(), err.Error())
                }</span>
                <span class="cov8" title="1">return false</span>
        default:<span class="cov0" title="0">
                log.Printf("get a node %s", n)</span>
        }

        <span class="cov0" title="0">return false</span>
}

// collectVariable is a traverse function to collect all variables(Ident) from nodeTree.
func (p *Parser) collectVariable(n Node) bool <span class="cov8" title="1">{
        switch x := n.(type) </span>{
        case *BinaryExpr, *UnaryExpr, *ParenExpr:<span class="cov8" title="1">
                return true</span>
        case *Ident:<span class="cov8" title="1">
                exist := false
                for _, i := range p.identList </span><span class="cov8" title="1">{
                        if i.Name == x.Name </span><span class="cov8" title="1">{
                                exist = true
                        }</span>
                }

                <span class="cov8" title="1">if !exist </span><span class="cov8" title="1">{
                        p.identList = append(p.identList, x)
                }</span>
        case *CallExpr:<span class="cov8" title="1">
                return false</span>
        default:<span class="cov0" title="0">
                return false</span>
        }

        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// token utility for condition expression

package parser

type Token int

var keywords = []string{
        "break",
        "case",
        "chan",
        "const",
        "continue",

        "default",
        "defer",
        "else",
        "fallthrough",
        "for",

        "func",
        "go",
        "goto",
        "if",
        "import",

        "interface",
        "map",
        "package",
        "range",
        "return",

        "select",
        "struct",
        "switch",
        "type",
        "var",
}

var tokens = map[Token]string{
        IDENT:     "IDENT",
        LAND:      "LAND",
        LOR:       "LOR",
        LPAREN:    "LPAREN",
        RPAREN:    "RPAREN",
        NOT:       "NOT",
        SEMICOLON: "SEMICOLON",
        BASICLIT:  "BASICLIT",
        COMMA:     "COMMA",
        BOOL:      "BOOL",
        STRING:    "STRING",
        INT:       "INT",
        FLOAT:     "FLOAT",
        IMAG:      "IMAG",
        COMMENT:   "COMMENT",
        ILLEGAL:   "ILLEGAL",
        EOF:       "EOF",
}

var symbols = map[Token]string{
        IDENT:     "",
        LAND:      "&amp;&amp;",
        LOR:       "||",
        LPAREN:    "(",
        RPAREN:    ")",
        NOT:       "!",
        SEMICOLON: ";",
        BASICLIT:  "BASICLIT",
        COMMA:     ",",
        BOOL:      "BOOL",
        STRING:    "STRING",
        INT:       "INT",
        FLOAT:     "FLOAT",
        IMAG:      "IMAG",
        COMMENT:   "//",
        ILLEGAL:   "ILLEGAL",
        EOF:       "EOF",
}

func (t Token) Symbol() string <span class="cov0" title="0">{
        return symbols[t]
}</span>

func (t Token) String() string <span class="cov8" title="1">{
        return tokens[t]
}</span>

func Lookup(ident string) Token <span class="cov8" title="1">{
        for _, keyword := range keywords </span><span class="cov8" title="1">{
                if ident == keyword </span><span class="cov0" title="0">{
                        // reserved
                        return ILLEGAL
                }</span>
        }
        <span class="cov8" title="1">return IDENT</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// visitor over ast nodes

package parser

// Visitor wraps the Visit method which is invoked for each node encountered by Walk.
// If the result visitor w is not nil, Walk visits each of the children
// of node with the visitor w, followed by a call of w.Visit(nil).
type Visitor interface {
        Visit(node Node) (w Visitor)
}

func Walk(v Visitor, node Node) <span class="cov8" title="1">{
        if v = v.Visit(node); v == nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">switch n := node.(type) </span>{
        case *BinaryExpr:<span class="cov8" title="1">
                // semant check for X,Y
                Walk(v, n.X)
                Walk(v, n.Y)</span>
        case *UnaryExpr:<span class="cov8" title="1">
                // semant check for X
                Walk(v, n.X)</span>
        case *Ident:<span class="cov0" title="0"></span>
                // do nothing
        case *CallExpr:<span class="cov0" title="0">
                Walk(v, n.Fun)
                Walk(v, n.Args)</span>
        case *ParenExpr:<span class="cov8" title="1">
                Walk(v, n.X)</span>
        }
}

type inspector func(Node) bool

func (f inspector) Visit(node Node) Visitor <span class="cov8" title="1">{
        if f(node) </span><span class="cov8" title="1">{
                return f
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Inspect traverses an AST in depth-first order: It starts by calling
// f(node); node must not be nil. If f returns true, Inspect invokes f
// for all the non-nil children of node, recursively.
//
func Inspect(node Node, f func(Node) bool) <span class="cov8" title="1">{
        Walk(inspector(f), node)
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">// Code generated by goyacc -p cond cond.y. DO NOT EDIT.

//line cond.y:21

package parser

import __yyfmt__ "fmt"

//line cond.y:22

import (
        "fmt"
        "go/token"
)

//line cond.y:31
type condSymType struct {
        yys  int
        Node Node
        str  string
}

const IDENT = 57346
const LAND = 57347
const LOR = 57348
const LPAREN = 57349
const RPAREN = 57350
</span>const NOT = 57351
const SEMICOLON = 57352
const BASICLIT = 57353
const COMMA = 57354
</span>const BOOL = 57355
const STRING = 57356
const INT = 57357
const FLOAT = 57358
const IMAG = 57359
</span>const COMMENT = 57360
</span>const ILLEGAL = 57361

</span>var condToknames = [...]string{
        "$end",
</span>        "error",
        "$unk",
        "IDENT",
        "LAND",
</span>        "LOR",
</span>        "LPAREN",
</span>        "RPAREN",
</span>        "NOT",
        "SEMICOLON",
</span>        "BASICLIT",
        "COMMA",
        "BOOL",
</span></span>        "STRING",
        "INT",
        "FLOAT",
</span></span>        "IMAG",
</span>        "COMMENT",
</span>        "ILLEGAL",
</span>}

</span></span></span>var condStatenames = [...]string{}

</span></span>const condEofCode = 1
const condErrCode = 2
</span>const condInitialStackSize = 16

</span>//line cond.y:96

// The parser expects the lexer to return 0 on EOF.  Give it a name
// for clarity.
const EOF = 0

</span></span></span></span>var (
</span>        parseNode    Node // save parse node
        lastPos      token.Pos
        lastTokenPos token.Pos
</span></span></span>)

</span></span>// The parser uses the type &lt;prefix&gt;Lex as a lexer.  It must provide
// the methods Lex(*&lt;prefix&gt;SymType) int and Error(string).
</span>type condLex struct {
        s   *Scanner
</span>        err ErrorHandler
</span></span>}

</span>// The parser calls this method to get each new token.
</span>func (x *condLex) Lex(yylval *condSymType) int {
        for {
</span></span>                pos, tok, lit := x.s.Scan()

</span></span>                lastPos = pos

</span></span>                // fmt.Printf("got token %s %s\n", tok, lit)
                switch tok {
                case EOF:
</span></span></span>                        return EOF
</span>                case IDENT:
                        yylval.Node = &amp;Ident{Name: lit, NamePos: pos}
                        return IDENT
                case BOOL, STRING, INT:
</span>                        yylval.Node = &amp;BasicLit{Kind: tok, Value: lit, ValuePos: pos}
                        return BASICLIT
</span>                case LPAREN, RPAREN, LAND, LOR, SEMICOLON, COMMA, NOT:
                        lastTokenPos = pos
                        return int(tok)
                default:
</span></span>                        x.Error(fmt.Sprintf("unrecognized token %d", tok))
                        return EOF
</span>                }
        }
</span>}
</span>
// The parser calls this method on a parse error.
</span>func (x *condLex) Error(s string) {
        if x.err != nil {
</span>                x.err(lastPos, s)
        }
}

//line yacctab:1
var condExca = [...]int{
</span></span></span>        -1, 1,
        1, -1,
</span></span>        -2, 0,
}
</span>
</span>const condPrivate = 57344

const condLast = 23
</span></span></span>
</span>var condAct = [...]int{
        18, 20, 16, 2, 19, 17, 11, 9, 10, 8,
</span>        6, 12, 13, 3, 15, 4, 7, 8, 5, 14,
        7, 8, 1,
}
</span></span>
var condPact = [...]int{
</span>        6, -1000, 15, 6, 6, -1000, -1, 6, 6, 11,
        -1000, -6, 3, -1000, -1000, -8, -1000, -1000, -1000, -10,
        -1000,
}

</span></span>var condPgo = [...]int{
        0, 22, 3, 18, 14,
</span>}
</span>
var condR1 = [...]int{
</span>        0, 1, 2, 2, 2, 2, 2, 2, 3, 3,
</span>        4, 4,
}

var condR2 = [...]int{
        0, 1, 3, 3, 3, 2, 1, 1, 4, 3,
</span>        1, 3,
}

var condChk = [...]int{
        -1000, -1, -2, 7, 9, -3, 4, 5, 6, -2,
        -2, 7, -2, -2, 8, -4, 8, 11, 8, 12,
        11,
}

var condDef = [...]int{
        0, -2, 1, 0, 0, 6, 7, 0, 0, 0,
        5, 0, 3, 4, 2, 0, 9, 10, 8, 0,
        11,
}
</span>
var condTok1 = [...]int{
        1,
}

</span>var condTok2 = [...]int{
        2, 3, 4, 5, 6, 7, 8, 9, 10, 11,
</span>        12, 13, 14, 15, 16, 17, 18, 19,
}

var condTok3 = [...]int{
        0,
</span>}

var condErrorMessages = [...]struct {
</span>        state int
        token int
</span>        msg   string
}{}
</span>
//line yaccpar:1

</span>/*        parser for yacc output        */

var (
        condDebug        = 0
</span>        condErrorVerbose = false
)

type condLexer interface {
</span>        Lex(lval *condSymType) int
        Error(s string)
</span>}
</span>
type condParser interface {
        Parse(condLexer) int
        Lookahead() int
</span></span>}

</span>type condParserImpl struct {
</span>        lval  condSymType
        stack [condInitialStackSize]condSymType
        char  int
</span>}

func (p *condParserImpl) Lookahead() int {
        return p.char
}
</span>
func condNewParser() condParser {
</span>        return &amp;condParserImpl{}
</span>}

const condFlag = -1000

func condTokname(c int) string {
        if c &gt;= 1 &amp;&amp; c-1 &lt; len(condToknames) {
</span>                if condToknames[c-1] != "" {
</span>                        return condToknames[c-1]
                }
</span>        }
        return __yyfmt__.Sprintf("tok-%v", c)
}

</span>func condStatname(s int) string {
</span>        if s &gt;= 0 &amp;&amp; s &lt; len(condStatenames) {
</span>                if condStatenames[s] != "" {
                        return condStatenames[s]
</span>                }
        }
        return __yyfmt__.Sprintf("state-%v", s)
}
</span></span>
</span>func condErrorMessage(state, lookAhead int) string {
        const TOKSTART = 4

        if !condErrorVerbose {
</span>                return "syntax error"
</span>        }

        for _, e := range condErrorMessages {
</span>                if e.state == state &amp;&amp; e.token == lookAhead {
                        return "syntax error: " + e.msg
</span>                }
        }

        res := "syntax error: unexpected " + condTokname(lookAhead)
</span>
        // To match Bison, suggest at most four expected tokens.
        expected := make([]int, 0, 4)
</span>
</span>        // Look for shiftable tokens.
        base := condPact[state]
        for tok := TOKSTART; tok-1 &lt; len(condToknames); tok++ {
                if n := base + tok; n &gt;= 0 &amp;&amp; n &lt; condLast &amp;&amp; condChk[condAct[n]] == tok {
                        if len(expected) == cap(expected) {
                                return res
</span>                        }
                        expected = append(expected, tok)
</span>                }
        }
</span>
</span>        if condDef[state] == -2 {
                i := 0
                for condExca[i] != -1 || condExca[i+1] != state {
                        i += 2
                }

                // Look for tokens that we accept or reduce.
</span></span>                for i += 2; condExca[i] &gt;= 0; i += 2 {
</span>                        tok := condExca[i]
                        if tok &lt; TOKSTART || condExca[i+1] == 0 {
                                continue
</span>                        }
                        if len(expected) == cap(expected) {
                                return res
</span>                        }
                        expected = append(expected, tok)
</span>                }
</span>
</span>                // If the default action is to accept or reduce, give up.
                if condExca[i+1] != 0 {
                        return res
                }
</span>        }

        for i, tok := range expected {
                if i == 0 {
                        res += ", expecting "
</span>                } else {
                        res += " or "
</span>                }
                res += condTokname(tok)
        }
        return res
}

func condlex1(lex condLexer, lval *condSymType) (char, token int) {
        token = 0
        char = lex.Lex(lval)
</span>        if char &lt;= 0 {
                token = condTok1[0]
                goto out
        }
</span>        if char &lt; len(condTok1) {
                token = condTok1[char]
                goto out
        }
        if char &gt;= condPrivate {
                if char &lt; condPrivate+len(condTok2) {
                        token = condTok2[char-condPrivate]
                        goto out
</span>                }
        }
</span>        for i := 0; i &lt; len(condTok3); i += 2 {
                token = condTok3[i+0]
</span>                if token == char {
                        token = condTok3[i+1]
</span>                        goto out
                }
        }
</span></span>
out:
        if token == 0 {
                token = condTok2[1] /* unknown char */
        }
        if condDebug &gt;= 3 {
                __yyfmt__.Printf("lex %s(%d)\n", condTokname(token), uint(char))
        }
        return char, token
}

func condParse(condlex condLexer) int {
        return condNewParser().Parse(condlex)
}

func (condrcvr *condParserImpl) Parse(condlex condLexer) int {
        var condn int
        var condVAL condSymType
        var condDollar []condSymType
        _ = condDollar // silence set and not used
        condS := condrcvr.stack[:]

        Nerrs := 0   /* number of errors */
        Errflag := 0 /* error recovery flag */
        condstate := 0
        condrcvr.char = -1
        condtoken := -1 // condrcvr.char translated into internal numbering
        defer func() {
                // Make sure we report no lookahead when not parsing.
                condstate = -1
                condrcvr.char = -1
                condtoken = -1
        }()
        condp := -1
        goto condstack

ret0:
        return 0

ret1:
        return 1

condstack:
        /* put a state and value onto the stack */
        if condDebug &gt;= 4 {
                __yyfmt__.Printf("char %v in %v\n", condTokname(condtoken), condStatname(condstate))
        }

        condp++
        if condp &gt;= len(condS) {
                nyys := make([]condSymType, len(condS)*2)
                copy(nyys, condS)
                condS = nyys
        }
        condS[condp] = condVAL
        condS[condp].yys = condstate

condnewstate:
        condn = condPact[condstate]
        if condn &lt;= condFlag {
                goto conddefault /* simple state */
        }
        if condrcvr.char &lt; 0 {
                condrcvr.char, condtoken = condlex1(condlex, &amp;condrcvr.lval)
        }
        condn += condtoken
        if condn &lt; 0 || condn &gt;= condLast {
                goto conddefault
        }
        condn = condAct[condn]
        if condChk[condn] == condtoken { /* valid shift */
                condrcvr.char = -1
                condtoken = -1
                condVAL = condrcvr.lval
                condstate = condn
                if Errflag &gt; 0 {
                        Errflag--
                }
                goto condstack
        }

conddefault:
        /* default state action */
        condn = condDef[condstate]
        if condn == -2 {
                if condrcvr.char &lt; 0 {
                        condrcvr.char, condtoken = condlex1(condlex, &amp;condrcvr.lval)
                }

                /* look through exception table */
                xi := 0
                for {
                        if condExca[xi+0] == -1 &amp;&amp; condExca[xi+1] == condstate {
                                break
                        }
                        xi += 2
                }
                for xi += 2; ; xi += 2 {
                        condn = condExca[xi+0]
                        if condn &lt; 0 || condn == condtoken {
                                break
                        }
                }
                condn = condExca[xi+1]
                if condn &lt; 0 {
                        goto ret0
                }
        }
        if condn == 0 {
                /* error ... attempt to resume parsing */
                switch Errflag {
                case 0: /* brand new error */
                        condlex.Error(condErrorMessage(condstate, condtoken))
                        Nerrs++
                        if condDebug &gt;= 1 {
                                __yyfmt__.Printf("%s", condStatname(condstate))
                                __yyfmt__.Printf(" saw %s\n", condTokname(condtoken))
                        }
                        fallthrough

                case 1, 2: /* incompletely recovered error ... try again */
                        Errflag = 3

                        /* find a state where "error" is a legal shift action */
                        for condp &gt;= 0 {
                                condn = condPact[condS[condp].yys] + condErrCode
                                if condn &gt;= 0 &amp;&amp; condn &lt; condLast {
                                        condstate = condAct[condn] /* simulate a shift of "error" */
                                        if condChk[condstate] == condErrCode {
                                                goto condstack
                                        }
                                }

                                /* the current p has no shift on "error", pop stack */
                                if condDebug &gt;= 2 {
                                        __yyfmt__.Printf("error recovery pops state %d\n", condS[condp].yys)
                                }
                                condp--
                        }
                        /* there is no state on the stack with an error shift ... abort */
                        goto ret1

                case 3: /* no shift yet; clobber input char */
                        if condDebug &gt;= 2 {
                                __yyfmt__.Printf("error recovery discards %s\n", condTokname(condtoken))
                        }
                        if condtoken == condEofCode {
                                goto ret1
                        }
                        condrcvr.char = -1
                        condtoken = -1
                        goto condnewstate /* try again in the same state */
                }
        }

        /* reduction by production condn */
        if condDebug &gt;= 2 {
                __yyfmt__.Printf("reduce %v in:\n\t%v\n", condn, condStatname(condstate))
        }

        condnt := condn
        condpt := condp
        _ = condpt // guard against "declared and not used"

        condp -= condR2[condn]
        // condp is now the index of $0. Perform the default action. Iff the
        // reduced production is ε, $1 is possibly out of range.
        if condp+1 &gt;= len(condS) {
                nyys := make([]condSymType, len(condS)*2)
                copy(nyys, condS)
                condS = nyys
        }
        condVAL = condS[condp+1]

        /* consult goto table to find next state */
        condn = condR1[condn]
        condg := condPgo[condn]
        condj := condg + condS[condp].yys + 1

        if condj &gt;= condLast {
                condstate = condAct[condg]
        } else {
                condstate = condAct[condj]
                if condChk[condstate] != -condn {
                        condstate = condAct[condg]
                }
        }
        // dummy call; replaced with literal code
        switch condnt {

        case 1:
                condDollar = condS[condpt-1 : condpt+1]
//line cond.y:45
                {
                        parseNode = condDollar[1].Node
                }
        case 2:
                condDollar = condS[condpt-3 : condpt+1]
//line cond.y:50
                {
                        condVAL.Node = &amp;ParenExpr{condDollar[2].Node.(Expr)}

                }
        case 3:
                condDollar = condS[condpt-3 : condpt+1]
//line cond.y:55
                {
                        condVAL.Node = &amp;BinaryExpr{condDollar[1].Node.(Expr), LAND, condDollar[3].Node.(Expr)}
                }
        case 4:
                condDollar = condS[condpt-3 : condpt+1]
//line cond.y:59
                {
                        condVAL.Node = &amp;BinaryExpr{condDollar[1].Node.(Expr), LOR, condDollar[3].Node.(Expr)}
                }
        case 5:
                condDollar = condS[condpt-2 : condpt+1]
//line cond.y:63
                {
                        condVAL.Node = &amp;UnaryExpr{condDollar[2].Node.(Expr), NOT, lastTokenPos}
                }
        case 6:
                condDollar = condS[condpt-1 : condpt+1]
//line cond.y:67
                {
                        condVAL.Node = condDollar[1].Node
                }
        case 7:
                condDollar = condS[condpt-1 : condpt+1]
//line cond.y:71
                {
                        condVAL.Node = condDollar[1].Node
                }
        case 8:
                condDollar = condS[condpt-4 : condpt+1]
//line cond.y:77
                {
                        condVAL.Node = &amp;CallExpr{condDollar[1].Node.(*Ident), condDollar[3].Node.(BasicLitList), lastPos}
                }
        case 9:
                condDollar = condS[condpt-3 : condpt+1]
//line cond.y:81
                {
                        condVAL.Node = &amp;CallExpr{condDollar[1].Node.(*Ident), nil, lastPos}
                }
        case 10:
                condDollar = condS[condpt-1 : condpt+1]
//line cond.y:87
                {
                        condVAL.Node = BasicLitList{condDollar[1].Node.(*BasicLit)}
                }
        case 11:
                condDollar = condS[condpt-3 : condpt+1]
//line cond.y:91
                {
                        condVAL.Node = append(condDollar[1].Node.(BasicLitList), condDollar[3].Node.(*BasicLit))
                }
        }
        goto condstack /* stack new state and value */
}
</pre>
		
		<pre class="file" id="file21" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// primitive condition implementation

package condition

import (
        "bytes"
        "fmt"
        "math/rand"
        "net"
        "regexp"
        "sort"
        "strconv"
        "strings"
        "time"
)

import (
        "github.com/bfenetworks/bfe/bfe_basic"
        "github.com/bfenetworks/bfe/bfe_basic/condition/parser"
        "github.com/bfenetworks/bfe/bfe_util"
        "github.com/bfenetworks/bfe/bfe_util/net_util"
        "github.com/spaolacci/murmur3"
)

const (
        HashMatcherBucketSize = 10000 // default hash bucket size for hash value matcher
)

type Fetcher interface {
        Fetch(req *bfe_basic.Request) (interface{}, error)
}

type Matcher interface {
        Match(interface{}) bool
}

// DefaultTrueCond always return true
type DefaultTrueCond struct{}

func (dt DefaultTrueCond) Match(req *bfe_basic.Request) bool <span class="cov0" title="0">{
        return true
}</span>

type PrimitiveCond struct {
        name    string
        node    *parser.CallExpr
        fetcher Fetcher
        matcher Matcher
}

func (p *PrimitiveCond) String() string <span class="cov8" title="1">{
        return p.node.String()
}</span>

func (p *PrimitiveCond) Match(req *bfe_basic.Request) bool <span class="cov8" title="1">{
        if req == nil || req.Session == nil || req.HttpRequest == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">fetched, err := p.fetcher.Fetch(req)
        if err != nil </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">r := p.matcher.Match(fetched)
        return r</span>
}

type HostFetcher struct{}

func (hf *HostFetcher) Fetch(req *bfe_basic.Request) (interface{}, error) <span class="cov8" title="1">{
        if req == nil || req.HttpRequest == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("fetcher: nil pointer")
        }</span>

        // ignore optional port in Host
        <span class="cov8" title="1">host := strings.SplitN(req.HttpRequest.Host, ":", 2)[0]
        return host, nil</span>
}

type HostTagFetcher struct{}

func (hf *HostTagFetcher) Fetch(req *bfe_basic.Request) (interface{}, error) <span class="cov8" title="1">{
        if req == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("fetcher: nil pointer")
        }</span>
        <span class="cov8" title="1">return req.Route.HostTag, nil</span>
}

type ProtoFetcher struct{}

func (pf *ProtoFetcher) Fetch(req *bfe_basic.Request) (interface{}, error) <span class="cov0" title="0">{
        if req == nil || req.HttpRequest == nil || req.Session == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("fetcher: nil pointer")
        }</span>

        <span class="cov0" title="0">return req.Protocol(), nil</span>
}

type MethodFetcher struct{}

func (mf *MethodFetcher) Fetch(req *bfe_basic.Request) (interface{}, error) <span class="cov0" title="0">{
        if req == nil || req.HttpRequest == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("fetcher: nil pointer")
        }</span>

        <span class="cov0" title="0">return req.HttpRequest.Method, nil</span>
}

type PortFetcher struct{}

func (pf *PortFetcher) Fetch(req *bfe_basic.Request) (interface{}, error) <span class="cov0" title="0">{
        if req == nil || req.HttpRequest == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("fetcher: nil pointer")
        }</span>

        <span class="cov0" title="0">port := "80"
        i := strings.Index(req.HttpRequest.Host, ":")
        if i &gt; 0 </span><span class="cov0" title="0">{
                port = req.HttpRequest.Host[i+1:]
        }</span>

        <span class="cov0" title="0">return port, nil</span>
}

type TagFetcher struct {
        key string
}

func (tf *TagFetcher) Fetch(req *bfe_basic.Request) (interface{}, error) <span class="cov0" title="0">{
        if req == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("fetcher: nil pointer")
        }</span>

        <span class="cov0" title="0">if req.Tags.TagTable == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">return req.Tags.TagTable[tf.key], nil</span>
}

type HasTagMatcher struct {
        value string
}

func (tm *HasTagMatcher) Match(v interface{}) bool <span class="cov0" title="0">{
        tags, ok := v.([]string)
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">for _, t := range tags </span><span class="cov0" title="0">{
                tag := strings.Split(t, ":")[0]
                if tag == tm.value </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

type UrlFetcher struct{}

func (uf *UrlFetcher) Fetch(req *bfe_basic.Request) (interface{}, error) <span class="cov0" title="0">{
        if req == nil || req.HttpRequest == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("fetcher: nil pointer")
        }</span>

        <span class="cov0" title="0">return req.HttpRequest.RequestURI, nil</span>
}

type PathFetcher struct{}

func (pf *PathFetcher) Fetch(req *bfe_basic.Request) (interface{}, error) <span class="cov0" title="0">{
        if req == nil || req.HttpRequest == nil || req.HttpRequest.URL == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("fetcher: nil pointer")
        }</span>

        <span class="cov0" title="0">return req.HttpRequest.URL.Path, nil</span>
}

type QueryKeyInFetcher struct {
        keys []string
}

func (qf *QueryKeyInFetcher) Fetch(req *bfe_basic.Request) (interface{}, error) <span class="cov0" title="0">{
        if req == nil || req.HttpRequest == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("fetcher: nil pointer")
        }</span>

        <span class="cov0" title="0">for _, key := range qf.keys </span><span class="cov0" title="0">{
                if _, ok := req.CachedQuery()[key]; ok </span><span class="cov0" title="0">{
                        return true, nil
                }</span>
        }
        <span class="cov0" title="0">return false, nil</span>
}

type QueryKeyPrefixInFetcher struct {
        keys []string
}

func (qf *QueryKeyPrefixInFetcher) Fetch(req *bfe_basic.Request) (interface{}, error) <span class="cov0" title="0">{
        if req == nil || req.HttpRequest == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("fetcher: nil pointer")
        }</span>

        <span class="cov0" title="0">ok := false
        for k := range req.CachedQuery() </span><span class="cov0" title="0">{
                if prefixIn(k, qf.keys) </span><span class="cov0" title="0">{
                        ok = true
                        break</span>
                }
        }
        <span class="cov0" title="0">return ok, nil</span>
}

type QueryValueFetcher struct {
        key string
}

// Fetch gets first query value for the given name
func (q *QueryValueFetcher) Fetch(req *bfe_basic.Request) (interface{}, error) <span class="cov0" title="0">{
        if req == nil || req.HttpRequest == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("fetcher: nil pointer")
        }</span>

        <span class="cov0" title="0">return req.CachedQuery().Get(q.key), nil</span>
}

type QueryExistMatcher struct{}

func (m *QueryExistMatcher) Match(req *bfe_basic.Request) bool <span class="cov0" title="0">{
        query := req.CachedQuery()

        return len(query) != 0
}</span>

type CookieKeyInFetcher struct {
        keys []string
}

func (c *CookieKeyInFetcher) Fetch(req *bfe_basic.Request) (interface{}, error) <span class="cov0" title="0">{
        if req == nil || req.HttpRequest == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("fetcher: nil pointer")
        }</span>

        <span class="cov0" title="0">for _, key := range c.keys </span><span class="cov0" title="0">{
                if _, ok := req.Cookie(key); ok </span><span class="cov0" title="0">{
                        return true, nil
                }</span>
        }

        <span class="cov0" title="0">return false, nil</span>
}

type CookieValueFetcher struct {
        key string
}

func (c *CookieValueFetcher) Fetch(req *bfe_basic.Request) (interface{}, error) <span class="cov0" title="0">{
        if req == nil || req.HttpRequest == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("fetcher: nil pointer")
        }</span>

        <span class="cov0" title="0">cookie, ok := req.Cookie(c.key)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("fetcher: cookie not found")
        }</span>

        <span class="cov0" title="0">return cookie.Value, nil</span>
}

type HeaderKeyInFetcher struct {
        keys []string
}

func (r *HeaderKeyInFetcher) Fetch(req *bfe_basic.Request) (interface{}, error) <span class="cov0" title="0">{
        if req == nil || req.HttpRequest == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("fetcher: nil pointer")
        }</span>

        <span class="cov0" title="0">for _, key := range r.keys </span><span class="cov0" title="0">{
                if val := req.HttpRequest.Header.Get(key); val != "" </span><span class="cov0" title="0">{
                        return true, nil
                }</span>
        }

        <span class="cov0" title="0">return false, nil</span>

}

type HeaderValueFetcher struct {
        key string
}

func (r *HeaderValueFetcher) Fetch(req *bfe_basic.Request) (interface{}, error) <span class="cov8" title="1">{
        if req == nil || req.HttpRequest == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("fetcher: nil pointer")
        }</span>

        <span class="cov8" title="1">return req.HttpRequest.Header.Get(r.key), nil</span>
}

type BypassMatcher struct{}

func (b *BypassMatcher) Match(v interface{}) bool <span class="cov0" title="0">{
        if b, ok := v.(bool); ok </span><span class="cov0" title="0">{
                return b
        }</span>

        <span class="cov0" title="0">return false</span>
}

type InMatcher struct {
        patterns []string
        foldCase bool
}

func (im *InMatcher) Match(v interface{}) bool <span class="cov8" title="1">{
        vs, ok := v.(string)
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">if im.foldCase </span><span class="cov8" title="1">{
                vs = strings.ToUpper(vs)
        }</span>

        <span class="cov8" title="1">return in(vs, im.patterns)</span>
}

type ExactMatcher struct {
        pattern  string
        foldCase bool
}

func (em *ExactMatcher) Match(v interface{}) bool <span class="cov0" title="0">{
        vs, ok := v.(string)
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">if em.foldCase </span><span class="cov0" title="0">{
                vs = strings.ToUpper(vs)
        }</span>
        <span class="cov0" title="0">return vs == em.pattern</span>
}

func NewExactMatcher(pattern string, foldCase bool) *ExactMatcher <span class="cov0" title="0">{
        p := pattern

        if foldCase </span><span class="cov0" title="0">{
                p = strings.ToUpper(p)
        }</span>

        <span class="cov0" title="0">return &amp;ExactMatcher{
                pattern:  p,
                foldCase: foldCase,
        }</span>
}

func toUpper(patterns []string) []string <span class="cov8" title="1">{
        upper := make([]string, len(patterns))

        for i, v := range patterns </span><span class="cov8" title="1">{
                upper[i] = strings.ToUpper(v)
        }</span>

        <span class="cov8" title="1">return upper</span>
}

func NewInMatcher(patterns string, foldCase bool) *InMatcher <span class="cov8" title="1">{
        p := strings.Split(patterns, "|")

        if foldCase </span><span class="cov8" title="1">{
                p = toUpper(p)
        }</span>

        <span class="cov8" title="1">sort.Strings(p)

        return &amp;InMatcher{
                patterns: p,
                foldCase: foldCase,
        }</span>
}

type IpInMatcher struct {
        patterns []net.IP
}

func (m *IpInMatcher) Match(v interface{}) bool <span class="cov8" title="1">{
        ip, ok := v.(net.IP)
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">ip = ip.To16()
        for _, p := range m.patterns </span><span class="cov8" title="1">{
                if p.Equal(ip) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func NewIpInMatcher(patterns string) (*IpInMatcher, error) <span class="cov8" title="1">{
        p := []net.IP{}
        ips := strings.Split(patterns, "|")
        for _, ipStr := range ips </span><span class="cov8" title="1">{
                // Note: net.ParseIP will return ip with 16 bytes
                ip := net.ParseIP(ipStr)
                if ip == nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("invalid IP addr string:%s", ipStr)
                }</span>
                <span class="cov8" title="1">p = append(p, ip)</span>
        }
        <span class="cov8" title="1">return &amp;IpInMatcher{
                patterns: p,
        }, nil</span>
}

type PrefixInMatcher struct {
        patterns []string
        foldCase bool
}

func (p *PrefixInMatcher) Match(v interface{}) bool <span class="cov0" title="0">{
        vs, ok := v.(string)
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if p.foldCase </span><span class="cov0" title="0">{
                vs = strings.ToUpper(vs)
        }</span>

        <span class="cov0" title="0">return prefixIn(vs, p.patterns)</span>
}

func NewPrefixInMatcher(patterns string, foldCase bool) *PrefixInMatcher <span class="cov0" title="0">{
        p := strings.Split(patterns, "|")

        if foldCase </span><span class="cov0" title="0">{
                p = toUpper(p)
        }</span>

        <span class="cov0" title="0">return &amp;PrefixInMatcher{
                patterns: p,
                foldCase: foldCase,
        }</span>
}

type PathElementPrefixMatcher struct {
        patterns []string
        foldCase bool
}

func (p *PathElementPrefixMatcher) Match(v interface{}) bool <span class="cov8" title="1">{
        vs, ok := v.(string)
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">if !strings.HasSuffix(vs, "/") </span><span class="cov8" title="1">{
                vs += "/"
        }</span>

        <span class="cov8" title="1">if p.foldCase </span><span class="cov8" title="1">{
                vs = strings.ToUpper(vs)
        }</span>

        <span class="cov8" title="1">return prefixIn(vs, p.patterns)</span>
}

func NewPathElementPrefixMatcher(patterns string, foldCase bool) *PathElementPrefixMatcher <span class="cov8" title="1">{
        p := strings.Split(patterns, "|")

        elementPatterns := make([]string, len(p))

        for i, v := range p </span><span class="cov8" title="1">{
                if !strings.HasSuffix(v, "/") </span><span class="cov8" title="1">{
                        v += "/"
                }</span>
                <span class="cov8" title="1">if foldCase </span><span class="cov8" title="1">{
                        elementPatterns[i] = strings.ToUpper(v)
                }</span> else<span class="cov0" title="0"> {
                        elementPatterns[i] = v
                }</span>

        }

        <span class="cov8" title="1">return &amp;PathElementPrefixMatcher{
                patterns: elementPatterns,
                foldCase: foldCase,
        }</span>
}

type SuffixInMatcher struct {
        patterns []string
        foldCase bool
}

func (p *SuffixInMatcher) Match(v interface{}) bool <span class="cov0" title="0">{
        vs, ok := v.(string)
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if p.foldCase </span><span class="cov0" title="0">{
                vs = strings.ToUpper(vs)
        }</span>

        <span class="cov0" title="0">return suffixIn(vs, p.patterns)</span>
}

func NewSuffixInMatcher(patterns string, foldCase bool) *SuffixInMatcher <span class="cov0" title="0">{
        p := strings.Split(patterns, "|")

        if foldCase </span><span class="cov0" title="0">{
                p = toUpper(p)
        }</span>

        <span class="cov0" title="0">return &amp;SuffixInMatcher{
                patterns: p,
                foldCase: foldCase,
        }</span>
}

type RegMatcher struct {
        regex *regexp.Regexp
}

func (p *RegMatcher) Match(v interface{}) bool <span class="cov0" title="0">{
        vs, ok := v.(string)
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return p.regex.MatchString(vs)</span>
}

func NewRegMatcher(regex *regexp.Regexp) *RegMatcher <span class="cov8" title="1">{
        return &amp;RegMatcher{
                regex: regex,
        }
}</span>

func in(v string, patterns []string) bool <span class="cov8" title="1">{
        i := sort.SearchStrings(patterns, v)
        return i &lt; len(patterns) &amp;&amp; patterns[i] == v
}</span>

func prefixIn(v string, patterns []string) bool <span class="cov8" title="1">{
        for _, pattern := range patterns </span><span class="cov8" title="1">{
                if strings.HasPrefix(v, pattern) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        <span class="cov8" title="1">return false</span>
}

func suffixIn(v string, patterns []string) bool <span class="cov0" title="0">{
        for _, pattern := range patterns </span><span class="cov0" title="0">{
                if strings.HasSuffix(v, pattern) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

type UAFetcher struct{}

func (uaf *UAFetcher) Fetch(req *bfe_basic.Request) (interface{}, error) <span class="cov0" title="0">{
        if req == nil || req.HttpRequest == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("fetcher: nil pointer")
        }</span>

        <span class="cov0" title="0">return req.HttpRequest.Header.Get("User-Agent"), nil</span>
}

type ResHeaderKeyInFetcher struct {
        keys []string
}

func (r *ResHeaderKeyInFetcher) Fetch(req *bfe_basic.Request) (interface{}, error) <span class="cov0" title="0">{
        if req == nil || req.HttpResponse == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("fetcher: nil pointer")
        }</span>

        <span class="cov0" title="0">for _, key := range r.keys </span><span class="cov0" title="0">{
                if val := req.HttpResponse.Header.Get(key); val != "" </span><span class="cov0" title="0">{
                        return true, nil
                }</span>
        }

        <span class="cov0" title="0">return false, nil</span>

}

type ResHeaderValueFetcher struct {
        key string
}

func (r *ResHeaderValueFetcher) Fetch(req *bfe_basic.Request) (interface{}, error) <span class="cov0" title="0">{
        if req == nil || req.HttpResponse == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("fetcher: nil pointer")
        }</span>

        <span class="cov0" title="0">return req.HttpResponse.Header.Get(r.key), nil</span>
}

type ResCodeFetcher struct{}

func (rf *ResCodeFetcher) Fetch(req *bfe_basic.Request) (interface{}, error) <span class="cov0" title="0">{
        if req == nil || req.HttpResponse == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("fetcher: nil pointer")
        }</span>

        <span class="cov0" title="0">return strconv.Itoa(req.HttpResponse.StatusCode), nil</span>
}

type TrustedCIpMatcher struct{}

func (m *TrustedCIpMatcher) Match(req *bfe_basic.Request) bool <span class="cov0" title="0">{
        return req.Session.TrustSource()
}</span>

type SecureProtoMatcher struct{}

func (m *SecureProtoMatcher) Match(req *bfe_basic.Request) bool <span class="cov0" title="0">{
        return req.Session.IsSecure
}</span>

// CIPFetcher fetches client addr
type CIPFetcher struct{}

func (ip *CIPFetcher) Fetch(req *bfe_basic.Request) (interface{}, error) <span class="cov0" title="0">{
        if req == nil || req.ClientAddr == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("fetcher: no clientAddr")
        }</span>

        <span class="cov0" title="0">return req.ClientAddr.IP, nil</span>
}

// SIPFetcher fetches remote socket addr
type SIPFetcher struct{}

func (ip *SIPFetcher) Fetch(req *bfe_basic.Request) (interface{}, error) <span class="cov0" title="0">{
        if req == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("fetcher: no req")
        }</span>

        <span class="cov0" title="0">ses := req.Session
        if ses == nil || ses.RemoteAddr == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("fetcher: no socket ip")
        }</span>

        <span class="cov0" title="0">return ses.RemoteAddr.IP, nil</span>
}

// VIPFetcher fetches vip addr
type VIPFetcher struct{}

func (ip *VIPFetcher) Fetch(req *bfe_basic.Request) (interface{}, error) <span class="cov8" title="1">{
        if req == nil || req.Session.Vip == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("fetcher: no vip")
        }</span>

        <span class="cov8" title="1">return req.Session.Vip, nil</span>
}

type IPMatcher struct {
        startIP net.IP
        endIP   net.IP
}

func NewIPMatcher(sIPStr string, eIPStr string) (*IPMatcher, error) <span class="cov8" title="1">{
        // convert ipStr to uint32
        sIP := net.ParseIP(sIPStr)
        if sIP == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid IP addr string:%s", sIPStr)
        }</span>

        <span class="cov8" title="1">eIP := net.ParseIP(eIPStr)
        if eIP == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid IP addr string:%s", eIPStr)
        }</span>

        <span class="cov8" title="1">if net_util.IsIPv4Address(sIPStr) != net_util.IsIPv4Address(eIPStr) </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("startIP[%s] and endIP[%s] has different addr type(IPv4/IPv6)", sIPStr, eIPStr)
        }</span>

        // endIP must &gt;= startIP
        <span class="cov8" title="1">if bytes.Compare(eIP, sIP) &lt; 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("startIP[%s] must &lt;= endIP[%s]", sIPStr, eIPStr)
        }</span>

        <span class="cov8" title="1">return &amp;IPMatcher{
                startIP: sIP,
                endIP:   eIP,
        }, nil</span>
}

func (ip *IPMatcher) Match(v interface{}) bool <span class="cov8" title="1">{
        ipAddr, ok := v.(net.IP)
        if !ok </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">ipAddr = ipAddr.To16()

        if bytes.Compare(ipAddr, ip.startIP) &lt; 0 </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">if bytes.Compare(ipAddr, ip.endIP) &gt; 0 </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">return true</span>
}

type HostMatcher struct {
        patterns []string
}

func (hm *HostMatcher) Match(v interface{}) bool <span class="cov8" title="1">{
        vs, ok := v.(string)
        if !ok </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">vs = strings.ToUpper(vs)

        return in(vs, hm.patterns)</span>
}

func checkHostAndToUpper(patterns []string) ([]string, error) <span class="cov8" title="1">{
        upper := make([]string, len(patterns))

        for i, v := range patterns </span><span class="cov8" title="1">{
                // port should not be included in host
                if strings.Contains(v, ":") </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("port should not be included in host(%s)", v)
                }</span>

                <span class="cov8" title="1">upper[i] = strings.ToUpper(v)</span>
        }

        <span class="cov8" title="1">return upper, nil</span>
}

func NewHostMatcher(patterns string) (*HostMatcher, error) <span class="cov8" title="1">{
        p := strings.Split(patterns, "|")

        p, err := checkHostAndToUpper(p)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">sort.Strings(p)

        return &amp;HostMatcher{
                patterns: p,
        }, nil</span>
}

type ContainMatcher struct {
        patterns []string
        foldCase bool
}

func NewContainMatcher(patterns string, foldCase bool) *ContainMatcher <span class="cov8" title="1">{
        p := strings.Split(patterns, "|")

        if foldCase </span><span class="cov8" title="1">{
                p = toUpper(p)
        }</span>

        <span class="cov8" title="1">return &amp;ContainMatcher{
                patterns: p,
                foldCase: foldCase,
        }</span>
}

func contain(v string, patterns []string) bool <span class="cov8" title="1">{
        for _, pattern := range patterns </span><span class="cov8" title="1">{
                if strings.Contains(v, pattern) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        <span class="cov8" title="1">return false</span>
}

func (cm *ContainMatcher) Match(v interface{}) bool <span class="cov8" title="1">{
        vs, ok := v.(string)
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">if cm.foldCase </span><span class="cov8" title="1">{
                vs = strings.ToUpper(vs)
        }</span>

        <span class="cov8" title="1">return contain(vs, cm.patterns)</span>
}

type HashValueMatcher struct {
        buckets     []bool
        insensitive bool
}

func (matcher *HashValueMatcher) Match(v interface{}) bool <span class="cov8" title="1">{
        var rawValue string

        switch value := v.(type) </span>{
        case string:<span class="cov8" title="1">
                rawValue = value</span>
        case net.IP:<span class="cov0" title="0">
                rawValue = value.String()</span>
        default:<span class="cov0" title="0">
                return false</span>
        }

        <span class="cov8" title="1">value := rawValue
        if matcher.insensitive </span><span class="cov8" title="1">{
                value = strings.ToLower(rawValue)
        }</span>

        <span class="cov8" title="1">bucket := GetHash([]byte(value), HashMatcherBucketSize)
        return matcher.buckets[bucket]</span>
}

// setHashBuckets returns the result of inserting one section of hash bucket number to buckets table
// section is one section of bucket number. e.g.: "20" or "0-99"
// buckets is destination bucket table to be inserted
func setHashBuckets(section string, buckets *[]bool) error <span class="cov8" title="1">{
        // split numbers
        start, end, err := parserHashSectionConf(section)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // set buckets
        <span class="cov8" title="1">for i := start; i &lt;= end; i++ </span><span class="cov8" title="1">{
                (*buckets)[i] = true
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// parserHashSectionConf returns start number, end number and parse result
func parserHashSectionConf(section string) (int, int, error) <span class="cov8" title="1">{
        // split numbers
        numbers := strings.Split(section, "-")
        if len(numbers) == 0 || len(numbers) &gt; 2 </span><span class="cov8" title="1">{
                return 0, 0, fmt.Errorf("hash value section %s length error", section)
        }</span>

        // checkt numbers
        <span class="cov8" title="1">var start, end int
        for i, numberRawStr := range numbers </span><span class="cov8" title="1">{
                numberStr := strings.ReplaceAll(numberRawStr, " ", "")
                number, err := strconv.Atoi(numberStr)
                if err != nil </span><span class="cov8" title="1">{
                        return 0, 0, fmt.Errorf("hash value check section %s number %s err %s",
                                section, numberStr, err.Error())
                }</span>

                <span class="cov8" title="1">if number &lt; 0 || number &gt;= HashMatcherBucketSize </span><span class="cov8" title="1">{
                        return 0, 0, fmt.Errorf("hash value check section %s number %s overlimit",
                                section, numberStr)
                }</span>

                <span class="cov8" title="1">if i == 0 </span><span class="cov8" title="1">{
                        start = number
                        end = number
                }</span>

                <span class="cov8" title="1">if i == 1 </span><span class="cov8" title="1">{
                        end = number
                        if end &lt; start </span><span class="cov8" title="1">{
                                return 0, 0, fmt.Errorf("hash value check section %s err, start is larger", section)
                        }</span>
                }
        }

        <span class="cov8" title="1">return start, end, nil</span>
}

func NewHashMatcher(patterns string, insensitive bool) (*HashValueMatcher, error) <span class="cov8" title="1">{
        buckets := make([]bool, HashMatcherBucketSize)

        sections := strings.Split(patterns, "|")
        for _, section := range sections </span><span class="cov8" title="1">{
                if err := setHashBuckets(section, &amp;buckets); err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">return &amp;HashValueMatcher{
                buckets:     buckets,
                insensitive: insensitive,
        }, nil</span>
}

func GetHash(value []byte, base uint) int <span class="cov8" title="1">{
        var hash uint64

        if value == nil </span><span class="cov0" title="0">{
                hash = uint64(rand.Uint32())
        }</span> else<span class="cov8" title="1"> {
                hash = murmur3.Sum64(value)
        }</span>

        <span class="cov8" title="1">return int(hash % uint64(base))</span>
}

// SniFetcher fetches serverName in tls
type SniFetcher struct{}

func (fetcher *SniFetcher) Fetch(req *bfe_basic.Request) (interface{}, error) <span class="cov8" title="1">{
        if req == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("fetcher: no req")
        }</span>

        <span class="cov8" title="1">ses := req.Session
        if ses == nil || !ses.IsSecure || ses.TlsState == nil || ses.TlsState.ServerName == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("fetcher: no sni")
        }</span>

        <span class="cov8" title="1">return req.Session.TlsState.ServerName, nil</span>
}

type ClientAuthMatcher struct{}

func (m *ClientAuthMatcher) Match(req *bfe_basic.Request) bool <span class="cov8" title="1">{
        if req == nil || req.Session == nil || !req.Session.IsSecure || req.Session.TlsState == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">return req.Session.TlsState.ClientAuth</span>
}

// ClientCANameFetcher fetches client CA name
type ClientCANameFetcher struct{}

func (fetcher *ClientCANameFetcher) Fetch(req *bfe_basic.Request) (interface{}, error) <span class="cov8" title="1">{
        if req == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("fetcher: no req")
        }</span>

        <span class="cov8" title="1">ses := req.Session
        if ses == nil || !ses.IsSecure || ses.TlsState == nil || !ses.TlsState.ClientAuth ||
                ses.TlsState.ClientCAName == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("fetcher: no client CA name")
        }</span>

        <span class="cov8" title="1">return req.Session.TlsState.ClientCAName, nil</span>
}

type ContextValueFetcher struct {
        key string
}

func (f *ContextValueFetcher) Fetch(req *bfe_basic.Request) (interface{}, error) <span class="cov8" title="1">{
        if req == nil || req.HttpRequest == nil || req.Context == nil || f.key == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("fetcher: nil pointer")
        }</span>

        <span class="cov8" title="1">return req.GetContext(f.key), nil</span>
}

// TimeMatcher is time range matcher
type TimeMatcher struct {
        startTime time.Time
        endTime   time.Time
}

func NewTimeMatcher(startTimeStr string, endTimeStr string) (*TimeMatcher, error) <span class="cov8" title="1">{
        startTime, err := bfe_util.ParseTime(startTimeStr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("startTime format invalid, err:%s", err.Error())
        }</span>
        <span class="cov8" title="1">endTime, err := bfe_util.ParseTime(endTimeStr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("endTime format invalid, err:%s", err.Error())
        }</span>
        <span class="cov8" title="1">if startTime.After(endTime) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("startTime[%s] must &lt;= endTime[%s]", startTimeStr, endTimeStr)
        }</span>
        <span class="cov8" title="1">return &amp;TimeMatcher{
                startTime: startTime,
                endTime:   endTime,
        }, nil</span>
}

func (t *TimeMatcher) Match(v interface{}) bool <span class="cov8" title="1">{
        tm, ok := v.(time.Time)
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if tm.Before(t.startTime) </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if tm.After(t.endTime) </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return true</span>
}

type BfeTimeFetcher struct{}

// Fetch returns a time in UTC+0 time zone.
func (f *BfeTimeFetcher) Fetch(req *bfe_basic.Request) (interface{}, error) <span class="cov0" title="0">{
        if req == nil || req.HttpRequest == nil </span><span class="cov0" title="0">{
                return time.Now().In(time.UTC), nil
        }</span>
        <span class="cov0" title="0">values, ok := req.HttpRequest.Header["X-Bfe-Debug-Time"]
        if !ok </span><span class="cov0" title="0">{
                return time.Now().In(time.UTC), nil
        }</span>
        <span class="cov0" title="0">debugTimeStr := values[0]
        debugTime, err := bfe_util.ParseTime(debugTimeStr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("debugTimeStr have invalid format, debugTimeStr:%s, :%s", debugTimeStr, err.Error())
        }</span>
        <span class="cov0" title="0">return debugTime, nil</span>
}

// PeriodicTimeMatcher is periodic time range matcher
type PeriodicTimeMatcher struct {
        startTime int // in seconds of a day
        endTime   int
        offset    int // timezone offset
}

// NewPeriodicTimeMatcher follows time string format: hhmmssZ, example 150405H, Z-&gt; timezone defined in bfe_util.TimeZoneMap
func NewPeriodicTimeMatcher(startTimeStr, endTimeStr, periodStr string) (*PeriodicTimeMatcher, error) <span class="cov8" title="1">{
        if periodStr != "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("periodStr is not supported, should not be set!")
        }</span>
        <span class="cov8" title="1">ts1, offset1, err := bfe_util.ParseTimeOfDay(startTimeStr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("startTime format invalid, err:%s", err.Error())
        }</span>
        <span class="cov8" title="1">startTime := ts1.Hour()*3600 + ts1.Minute()*60 + ts1.Second()
        ts2, offset2, err := bfe_util.ParseTimeOfDay(endTimeStr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("endTime format invalid, err:%s", err.Error())
        }</span>
        <span class="cov8" title="1">endTime := ts2.Hour()*3600 + ts2.Minute()*60 + ts2.Second()
        if startTime &gt; endTime </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("startTime[%s] must &lt;= endTime[%s]", startTimeStr, endTimeStr)
        }</span>
        <span class="cov8" title="1">if offset1 != offset2 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("timezone of startime and endtime should be same!")
        }</span>
        <span class="cov8" title="1">return &amp;PeriodicTimeMatcher{
                startTime: startTime,
                endTime:   endTime,
                offset:    offset1,
        }, nil</span>
}

func (t *PeriodicTimeMatcher) Match(v interface{}) bool <span class="cov8" title="1">{
        tm, ok := v.(time.Time)
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>
        // tm in UTC, convert it to correct time zone
        <span class="cov8" title="1">tm = tm.In(time.FixedZone("zone", t.offset))
        hour, minute, second := tm.Clock()
        seconds := hour*3600 + minute*60 + second
        return seconds &gt;= t.startTime &amp;&amp; seconds &lt;= t.endTime</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Package bfe_bufio implements buffered I/O.  It wraps an io.Reader or io.Writer
// object, creating another object (Reader or Writer) that also implements
// the interface but provides buffering and some help for textual I/O.
package bfe_bufio

import (
        "bytes"
        "errors"
        "io"
        "unicode/utf8"
)

import (
        "github.com/baidu/go-lib/log"
)

const (
        defaultBufSize = 4096
)

var (
        ErrInvalidUnreadByte = errors.New("bfe_bufio: invalid use of UnreadByte")
        ErrInvalidUnreadRune = errors.New("bfe_bufio: invalid use of UnreadRune")
        ErrBufferFull        = errors.New("bfe_bufio: buffer full")
        ErrNegativeCount     = errors.New("bfe_bufio: negative count")
)

// Buffered input.

// Reader implements buffering for an io.Reader object.
type Reader struct {
        buf          []byte
        rd           io.Reader
        r, w         int
        err          error
        lastByte     int
        lastRuneSize int

        TotalRead int // number of bytes total read
}

const minReadBufferSize = 16

// NewReaderSize returns a new Reader whose buffer has at least the specified
// size. If the argument io.Reader is already a Reader with large enough
// size, it returns the underlying Reader.
func NewReaderSize(rd io.Reader, size int) *Reader <span class="cov8" title="1">{
        // Is it already a Reader?
        b, ok := rd.(*Reader)
        if ok &amp;&amp; len(b.buf) &gt;= size </span><span class="cov8" title="1">{
                return b
        }</span>
        <span class="cov8" title="1">if size &lt; minReadBufferSize </span><span class="cov0" title="0">{
                size = minReadBufferSize
        }</span>
        <span class="cov8" title="1">r := new(Reader)
        r.reset(make([]byte, size), rd)
        return r</span>
}

// NewReader returns a new Reader whose buffer has the default size.
func NewReader(rd io.Reader) *Reader <span class="cov8" title="1">{
        return NewReaderSize(rd, defaultBufSize)
}</span>

// Reset discards any buffered data, resets all state, and switches
// the buffered reader to read from r.
func (b *Reader) Reset(r io.Reader) <span class="cov8" title="1">{
        b.reset(b.buf, r)
}</span>

func (b *Reader) reset(buf []byte, r io.Reader) <span class="cov8" title="1">{
        *b = Reader{
                buf:          buf,
                rd:           r,
                lastByte:     -1,
                lastRuneSize: -1,
                TotalRead:    0,
        }
}</span>

var errNegativeRead = errors.New("bfe_bufio: reader returned negative count from Read")

// fill reads a new chunk into the buffer.
func (b *Reader) fill() <span class="cov8" title="1">{
        // Slide existing data to beginning.
        if b.r &gt; 0 </span><span class="cov8" title="1">{
                copy(b.buf, b.buf[b.r:b.w])
                b.w -= b.r
                b.r = 0
        }</span>

        // Read new data.
        <span class="cov8" title="1">n, err := b.rd.Read(b.buf[b.w:])
        if n &lt; 0 </span><span class="cov8" title="1">{
                panic(errNegativeRead)</span>
        }

        <span class="cov8" title="1">if (b.w + n) &gt; len(b.buf) </span><span class="cov0" title="0">{
                log.Logger.Warn("bfe_bufio:reader.fill(),len(buf)=%d,b.r=%d,b.w=%d,n=%d\n",
                        len(b.buf), b.r, b.w, n)
        }</span>

        <span class="cov8" title="1">b.w += n
        if err != nil </span><span class="cov8" title="1">{
                b.err = err
        }</span>
}

func (b *Reader) readErr() error <span class="cov8" title="1">{
        err := b.err
        b.err = nil
        return err
}</span>

// Peek returns the next n bytes without advancing the reader. The bytes stop
// being valid at the next read call. If Peek returns fewer than n bytes, it
// also returns an error explaining why the read is short. The error is
// ErrBufferFull if n is larger than b's buffer size.
func (b *Reader) Peek(n int) ([]byte, error) <span class="cov8" title="1">{
        if n &lt; 0 </span><span class="cov0" title="0">{
                return nil, ErrNegativeCount
        }</span>
        <span class="cov8" title="1">if n &gt; len(b.buf) </span><span class="cov8" title="1">{
                return nil, ErrBufferFull
        }</span>
        <span class="cov8" title="1">for b.w-b.r &lt; n &amp;&amp; b.err == nil </span><span class="cov8" title="1">{
                b.fill()
        }</span>
        <span class="cov8" title="1">m := b.w - b.r
        if m &gt; n </span><span class="cov8" title="1">{
                m = n
        }</span>
        <span class="cov8" title="1">var err error
        if m &lt; n </span><span class="cov8" title="1">{
                err = b.readErr()
                if err == nil </span><span class="cov0" title="0">{
                        err = ErrBufferFull
                }</span>
        }
        <span class="cov8" title="1">return b.buf[b.r : b.r+m], err</span>
}

// Read reads data into p.
// It returns the number of bytes read into p.
// It calls Read at most once on the underlying Reader,
// hence n may be less than len(p).
// At EOF, the count will be zero and err will be io.EOF.
func (b *Reader) Read(p []byte) (n int, err error) <span class="cov8" title="1">{
        n = len(p)
        if n == 0 </span><span class="cov8" title="1">{
                return 0, b.readErr()
        }</span>
        <span class="cov8" title="1">if b.w == b.r </span><span class="cov8" title="1">{
                if b.err != nil </span><span class="cov8" title="1">{
                        return 0, b.readErr()
                }</span>
                <span class="cov8" title="1">if len(p) &gt;= len(b.buf) </span><span class="cov8" title="1">{
                        // Large read, empty buffer.
                        // Read directly into p to avoid copy.
                        n, b.err = b.rd.Read(p)
                        if n &gt; 0 </span><span class="cov8" title="1">{
                                b.lastByte = int(p[n-1])
                                b.lastRuneSize = -1

                                b.TotalRead += n
                        }</span>

                        <span class="cov8" title="1">return n, b.readErr()</span>
                }
                <span class="cov8" title="1">b.fill()
                if b.w == b.r </span><span class="cov8" title="1">{
                        return 0, b.readErr()
                }</span>
        }

        <span class="cov8" title="1">if n &gt; b.w-b.r </span><span class="cov8" title="1">{
                n = b.w - b.r
        }</span>

        <span class="cov8" title="1">if b.r &gt; len(b.buf) || (b.r+n) &gt; len(b.buf) </span><span class="cov0" title="0">{
                log.Logger.Warn("bfe_bufio:reader.Read(),len(buf)=%d,b.r=%d,b.w=%d,n=%d\n",
                        len(b.buf), b.r, b.w, n)
        }</span>

        <span class="cov8" title="1">copy(p[0:n], b.buf[b.r:])
        b.r += n
        b.lastByte = int(b.buf[b.r-1])
        b.lastRuneSize = -1

        b.TotalRead += n

        return n, nil</span>
}

// ReadByte reads and returns a single byte.
// If no byte is available, returns an error.
func (b *Reader) ReadByte() (c byte, err error) <span class="cov8" title="1">{
        b.lastRuneSize = -1
        for b.w == b.r </span><span class="cov8" title="1">{
                if b.err != nil </span><span class="cov8" title="1">{
                        return 0, b.readErr()
                }</span>
                <span class="cov8" title="1">b.fill()</span>
        }
        <span class="cov8" title="1">c = b.buf[b.r]
        b.r++
        b.lastByte = int(c)

        b.TotalRead += 1

        return c, nil</span>
}

// UnreadByte unreads the last byte.  Only the most recently read byte can be unread.
func (b *Reader) UnreadByte() error <span class="cov8" title="1">{
        b.lastRuneSize = -1
        if b.r == b.w &amp;&amp; b.lastByte &gt;= 0 </span><span class="cov0" title="0">{
                b.w = 1
                b.r = 0
                b.buf[0] = byte(b.lastByte)
                b.lastByte = -1

                if b.TotalRead &gt; 0 </span><span class="cov0" title="0">{
                        b.TotalRead -= 1
                }</span>

                <span class="cov0" title="0">return nil</span>
        }
        <span class="cov8" title="1">if b.r &lt;= 0 </span><span class="cov0" title="0">{
                return ErrInvalidUnreadByte
        }</span>
        <span class="cov8" title="1">b.r--
        b.lastByte = -1

        if b.TotalRead &gt; 0 </span><span class="cov8" title="1">{
                b.TotalRead -= 1
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// ReadRune reads a single UTF-8 encoded Unicode character and returns the
// rune and its size in bytes. If the encoded rune is invalid, it consumes one byte
// and returns unicode.ReplacementChar (U+FFFD) with a size of 1.
func (b *Reader) ReadRune() (r rune, size int, err error) <span class="cov8" title="1">{
        for b.r+utf8.UTFMax &gt; b.w &amp;&amp; !utf8.FullRune(b.buf[b.r:b.w]) &amp;&amp; b.err == nil </span><span class="cov8" title="1">{
                b.fill()
        }</span>
        <span class="cov8" title="1">b.lastRuneSize = -1
        if b.r == b.w </span><span class="cov8" title="1">{
                return 0, 0, b.readErr()
        }</span>
        <span class="cov8" title="1">r, size = rune(b.buf[b.r]), 1
        if r &gt;= 0x80 </span><span class="cov8" title="1">{
                r, size = utf8.DecodeRune(b.buf[b.r:b.w])
        }</span>
        <span class="cov8" title="1">b.r += size
        b.lastByte = int(b.buf[b.r-1])
        b.lastRuneSize = size

        b.TotalRead += size

        return r, size, nil</span>
}

// UnreadRune unreads the last rune.  If the most recent read operation on
// the buffer was not a ReadRune, UnreadRune returns an error.  (In this
// regard it is stricter than UnreadByte, which will unread the last byte
// from any read operation.)
func (b *Reader) UnreadRune() error <span class="cov8" title="1">{
        if b.lastRuneSize &lt; 0 || b.r == 0 </span><span class="cov8" title="1">{
                return ErrInvalidUnreadRune
        }</span>
        <span class="cov8" title="1">b.r -= b.lastRuneSize

        if b.TotalRead &gt;= b.lastRuneSize </span><span class="cov8" title="1">{
                b.TotalRead -= b.lastRuneSize
        }</span>

        <span class="cov8" title="1">b.lastByte = -1
        b.lastRuneSize = -1

        return nil</span>
}

// Buffered returns the number of bytes that can be read from the current buffer.
func (b *Reader) Buffered() int <span class="cov8" title="1">{ return b.w - b.r }</span>

// ReadSlice reads until the first occurrence of delim in the input,
// returning a slice pointing at the bytes in the buffer.
// The bytes stop being valid at the next read.
// If ReadSlice encounters an error before finding a delimiter,
// it returns all the data in the buffer and the error itself (often io.EOF).
// ReadSlice fails with error ErrBufferFull if the buffer fills without a delim.
// Because the data returned from ReadSlice will be overwritten
// by the next I/O operation, most clients should use
// ReadBytes or ReadString instead.
// ReadSlice returns err != nil if and only if line does not end in delim.
func (b *Reader) ReadSlice(delim byte) (line []byte, err error) <span class="cov8" title="1">{
        // Look in buffer.
        if i := bytes.IndexByte(b.buf[b.r:b.w], delim); i &gt;= 0 </span><span class="cov8" title="1">{
                line1 := b.buf[b.r : b.r+i+1]
                b.r += i + 1

                b.TotalRead += i + 1

                return line1, nil
        }</span>

        // Read more into buffer, until buffer fills or we find delim.
        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                if b.err != nil </span><span class="cov8" title="1">{
                        line := b.buf[b.r:b.w]

                        b.TotalRead += b.w - b.r

                        b.r = b.w
                        return line, b.readErr()
                }</span>

                <span class="cov8" title="1">n := b.Buffered()
                b.fill()

                // Search new part of buffer
                if i := bytes.IndexByte(b.buf[n:b.w], delim); i &gt;= 0 </span><span class="cov8" title="1">{
                        line := b.buf[0 : n+i+1]
                        b.r = n + i + 1

                        b.TotalRead += i + 1

                        return line, nil
                }</span>

                // Buffer is full?
                <span class="cov8" title="1">if b.Buffered() &gt;= len(b.buf) </span><span class="cov8" title="1">{
                        b.TotalRead += len(b.buf)

                        b.r = b.w
                        return b.buf, ErrBufferFull
                }</span>
        }
}

// ReadLine is a low-level line-reading primitive. Most callers should use
// ReadBytes('\n') or ReadString('\n') instead or use a Scanner.
//
// ReadLine tries to return a single line, not including the end-of-line bytes.
// If the line was too long for the buffer then isPrefix is set and the
// beginning of the line is returned. The rest of the line will be returned
// from future calls. isPrefix will be false when returning the last fragment
// of the line. The returned buffer is only valid until the next call to
// ReadLine. ReadLine either returns a non-nil line or it returns an error,
// never both.
//
// The text returned from ReadLine does not include the line end ("\r\n" or "\n").
// No indication or error is given if the input ends without a final line end.
func (b *Reader) ReadLine() (line []byte, isPrefix bool, err error) <span class="cov8" title="1">{
        line, err = b.ReadSlice('\n')
        if err == ErrBufferFull </span><span class="cov8" title="1">{
                // Handle the case where "\r\n" straddles the buffer.
                if len(line) &gt; 0 &amp;&amp; line[len(line)-1] == '\r' </span><span class="cov8" title="1">{
                        // Put the '\r' back on buf and drop it from line.
                        // Let the next call to ReadLine check for "\r\n".
                        if b.r == 0 </span><span class="cov0" title="0">{
                                // should be unreachable
                                panic("bfe_bufio: tried to rewind past start of buffer")</span>
                        }
                        <span class="cov8" title="1">b.r--
                        line = line[:len(line)-1]</span>
                }
                <span class="cov8" title="1">return line, true, nil</span>
        }

        <span class="cov8" title="1">if len(line) == 0 </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov8" title="1">{
                        line = nil
                }</span>
                <span class="cov8" title="1">return</span>
        }
        <span class="cov8" title="1">err = nil

        if line[len(line)-1] == '\n' </span><span class="cov8" title="1">{
                drop := 1
                if len(line) &gt; 1 &amp;&amp; line[len(line)-2] == '\r' </span><span class="cov8" title="1">{
                        drop = 2
                }</span>
                <span class="cov8" title="1">line = line[:len(line)-drop]</span>
        }
        <span class="cov8" title="1">return</span>
}

// ReadBytes reads until the first occurrence of delim in the input,
// returning a slice containing the data up to and including the delimiter.
// If ReadBytes encounters an error before finding a delimiter,
// it returns the data read before the error and the error itself (often io.EOF).
// ReadBytes returns err != nil if and only if the returned data does not end in
// delim.
// For simple uses, a Scanner may be more convenient.
func (b *Reader) ReadBytes(delim byte) (line []byte, err error) <span class="cov8" title="1">{
        // Use ReadSlice to look for array,
        // accumulating full buffers.
        var frag []byte
        var full [][]byte
        err = nil

        for </span><span class="cov8" title="1">{
                var e error
                frag, e = b.ReadSlice(delim)
                if e == nil </span><span class="cov8" title="1">{ // got final fragment
                        break</span>
                }
                <span class="cov8" title="1">if e != ErrBufferFull </span><span class="cov8" title="1">{ // unexpected error
                        err = e
                        break</span>
                }

                // Make a copy of the buffer.
                <span class="cov8" title="1">buf := make([]byte, len(frag))
                copy(buf, frag)
                full = append(full, buf)</span>
        }

        // Allocate new buffer to hold the full pieces and the fragment.
        <span class="cov8" title="1">n := 0
        for i := range full </span><span class="cov8" title="1">{
                n += len(full[i])
        }</span>
        <span class="cov8" title="1">n += len(frag)

        // Copy full pieces and fragment in.
        buf := make([]byte, n)
        n = 0
        for i := range full </span><span class="cov8" title="1">{
                n += copy(buf[n:], full[i])
        }</span>
        <span class="cov8" title="1">copy(buf[n:], frag)
        return buf, err</span>
}

// ReadString reads until the first occurrence of delim in the input,
// returning a string containing the data up to and including the delimiter.
// If ReadString encounters an error before finding a delimiter,
// it returns the data read before the error and the error itself (often io.EOF).
// ReadString returns err != nil if and only if the returned data does not end in
// delim.
// For simple uses, a Scanner may be more convenient.
func (b *Reader) ReadString(delim byte) (line string, err error) <span class="cov8" title="1">{
        bytes, err := b.ReadBytes(delim)
        line = string(bytes)
        return line, err
}</span>

// WriteTo implements io.WriterTo.
func (b *Reader) WriteTo(w io.Writer) (n int64, err error) <span class="cov8" title="1">{
        n, err = b.writeBuf(w)
        if err != nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">if r, ok := b.rd.(io.WriterTo); ok </span><span class="cov8" title="1">{
                m, err := r.WriteTo(w)

                if m &gt; 0 </span><span class="cov8" title="1">{
                        b.TotalRead += int(m)
                }</span>

                <span class="cov8" title="1">n += m
                return n, err</span>
        }

        <span class="cov8" title="1">for b.fill(); b.r &lt; b.w; b.fill() </span><span class="cov8" title="1">{
                m, err := b.writeBuf(w)
                n += m
                if err != nil </span><span class="cov0" title="0">{
                        return n, err
                }</span>
        }

        <span class="cov8" title="1">if b.err == io.EOF </span><span class="cov8" title="1">{
                b.err = nil
        }</span>

        <span class="cov8" title="1">return n, b.readErr()</span>
}

// writeBuf writes the Reader's buffer to the writer.
func (b *Reader) writeBuf(w io.Writer) (int64, error) <span class="cov8" title="1">{
        n, err := w.Write(b.buf[b.r:b.w])
        b.r += n

        if n &gt; 0 </span><span class="cov8" title="1">{
                b.TotalRead += n
        }</span>

        <span class="cov8" title="1">return int64(n), err</span>
}

// buffered output

// Writer implements buffering for an io.Writer object.
// If an error occurs writing to a Writer, no more data will be
// accepted and all subsequent writes will return the error.
// After all data has been written, the client should call the
// Flush method to guarantee all data has been forwarded to
// the underlying io.Writer.
type Writer struct {
        err error
        buf []byte
        n   int
        wr  io.Writer

        TotalWrite int // number of bytes total write
}

// NewWriterSize returns a new Writer whose buffer has at least the specified
// size. If the argument io.Writer is already a Writer with large enough
// size, it returns the underlying Writer.
func NewWriterSize(w io.Writer, size int) *Writer <span class="cov8" title="1">{
        // Is it already a Writer?
        b, ok := w.(*Writer)
        if ok &amp;&amp; len(b.buf) &gt;= size </span><span class="cov8" title="1">{
                return b
        }</span>
        <span class="cov8" title="1">if size &lt;= 0 </span><span class="cov0" title="0">{
                size = defaultBufSize
        }</span>
        <span class="cov8" title="1">return &amp;Writer{
                buf:        make([]byte, size),
                wr:         w,
                TotalWrite: 0,
        }</span>
}

// NewWriter returns a new Writer whose buffer has the default size.
func NewWriter(w io.Writer) *Writer <span class="cov8" title="1">{
        return NewWriterSize(w, defaultBufSize)
}</span>

// Reset discards any unflushed buffered data, clears any error, and
// resets b to write its output to w.
func (b *Writer) Reset(w io.Writer) <span class="cov8" title="1">{
        b.err = nil
        b.n = 0
        b.wr = w
        b.TotalWrite = 0
}</span>

// Flush writes any buffered data to the underlying io.Writer.
func (b *Writer) Flush() error <span class="cov8" title="1">{
        err := b.flush()
        return err
}</span>

func (b *Writer) flush() error <span class="cov8" title="1">{
        if b.err != nil </span><span class="cov8" title="1">{
                return b.err
        }</span>
        <span class="cov8" title="1">if b.n == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">n, err := b.wr.Write(b.buf[0:b.n])
        if n &lt; b.n &amp;&amp; err == nil </span><span class="cov8" title="1">{
                err = io.ErrShortWrite
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                if n &gt; 0 &amp;&amp; n &lt; b.n </span><span class="cov8" title="1">{
                        copy(b.buf[0:b.n-n], b.buf[n:b.n])
                }</span>
                <span class="cov8" title="1">b.n -= n
                b.err = err
                return err</span>
        }
        <span class="cov8" title="1">b.n = 0
        return nil</span>
}

// Available returns how many bytes are unused in the buffer.
func (b *Writer) Available() int <span class="cov8" title="1">{ return len(b.buf) - b.n }</span>

// Buffered returns the number of bytes that have been written into the current buffer.
func (b *Writer) Buffered() int <span class="cov8" title="1">{ return b.n }</span>

// Write writes the contents of p into the buffer.
// It returns the number of bytes written.
// If nn &lt; len(p), it also returns an error explaining
// why the write is short.
func (b *Writer) Write(p []byte) (nn int, err error) <span class="cov8" title="1">{
        for len(p) &gt; b.Available() &amp;&amp; b.err == nil </span><span class="cov8" title="1">{
                var n int
                if b.Buffered() == 0 </span><span class="cov8" title="1">{
                        // Large write, empty buffer.
                        // Write directly from p to avoid copy.
                        n, b.err = b.wr.Write(p)
                }</span> else<span class="cov0" title="0"> {
                        n = copy(b.buf[b.n:], p)
                        b.n += n
                        b.flush()
                }</span>
                <span class="cov8" title="1">nn += n
                p = p[n:]</span>
        }
        <span class="cov8" title="1">if b.err != nil </span><span class="cov0" title="0">{
                b.TotalWrite += nn
                return nn, b.err
        }</span>
        <span class="cov8" title="1">n := copy(b.buf[b.n:], p)
        b.n += n
        nn += n

        b.TotalWrite += nn

        return nn, nil</span>
}

// WriteByte writes a single byte.
func (b *Writer) WriteByte(c byte) error <span class="cov8" title="1">{
        if b.err != nil </span><span class="cov0" title="0">{
                return b.err
        }</span>
        <span class="cov8" title="1">if b.Available() &lt;= 0 &amp;&amp; b.flush() != nil </span><span class="cov0" title="0">{
                return b.err
        }</span>
        <span class="cov8" title="1">b.buf[b.n] = c
        b.n++
        b.TotalWrite++
        return nil</span>
}

// WriteRune writes a single Unicode code point, returning
// the number of bytes written and any error.
func (b *Writer) WriteRune(r rune) (size int, err error) <span class="cov8" title="1">{
        if r &lt; utf8.RuneSelf </span><span class="cov8" title="1">{
                err = b.WriteByte(byte(r))
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov8" title="1">return 1, nil</span>
        }
        <span class="cov8" title="1">if b.err != nil </span><span class="cov0" title="0">{
                return 0, b.err
        }</span>
        <span class="cov8" title="1">n := b.Available()
        if n &lt; utf8.UTFMax </span><span class="cov0" title="0">{
                if b.flush(); b.err != nil </span><span class="cov0" title="0">{
                        return 0, b.err
                }</span>
                <span class="cov0" title="0">n = b.Available()
                if n &lt; utf8.UTFMax </span><span class="cov0" title="0">{
                        // Can only happen if buffer is silly small.
                        return b.WriteString(string(r))
                }</span>
        }
        <span class="cov8" title="1">size = utf8.EncodeRune(b.buf[b.n:], r)

        b.TotalWrite += size

        b.n += size
        return size, nil</span>
}

// WriteString writes a string.
// It returns the number of bytes written.
// If the count is less than len(s), it also returns an error explaining
// why the write is short.
func (b *Writer) WriteString(s string) (int, error) <span class="cov8" title="1">{
        nn := 0
        for len(s) &gt; b.Available() &amp;&amp; b.err == nil </span><span class="cov8" title="1">{
                n := copy(b.buf[b.n:], s)
                b.n += n
                nn += n
                s = s[n:]
                b.flush()
        }</span>
        <span class="cov8" title="1">if b.err != nil </span><span class="cov0" title="0">{
                b.TotalWrite += nn
                return nn, b.err
        }</span>
        <span class="cov8" title="1">n := copy(b.buf[b.n:], s)
        b.n += n
        nn += n
        b.TotalWrite += nn
        return nn, nil</span>
}

// ReadFrom implements io.ReaderFrom.
func (b *Writer) ReadFrom(r io.Reader) (n int64, err error) <span class="cov8" title="1">{
        if b.Buffered() == 0 </span><span class="cov8" title="1">{
                if w, ok := b.wr.(io.ReaderFrom); ok </span><span class="cov8" title="1">{
                        n, err = w.ReadFrom(r)
                        b.TotalWrite += int(n)
                        return n, err
                }</span>
        }
        <span class="cov8" title="1">var m int
        for </span><span class="cov8" title="1">{
                if b.Available() == 0 </span><span class="cov8" title="1">{
                        if err1 := b.flush(); err1 != nil </span><span class="cov8" title="1">{
                                return n, err1
                        }</span>
                }
                <span class="cov8" title="1">m, err = r.Read(b.buf[b.n:])
                if m == 0 </span><span class="cov8" title="1">{
                        break</span>
                }

                <span class="cov8" title="1">b.n += m

                if b.n &gt; len(b.buf) </span><span class="cov0" title="0">{
                        log.Logger.Warn("bfe_bufio:Writer.ReadFrom(),len(buf)=%d,b.n=%d,m=%d\n",
                                len(b.buf), b.n, m)
                }</span>

                <span class="cov8" title="1">n += int64(m)
                if err != nil </span><span class="cov8" title="1">{
                        break</span>
                }
        }
        <span class="cov8" title="1">if err == io.EOF </span><span class="cov8" title="1">{
                // If we filled the buffer exactly, flush pre-emptively.
                if b.Available() == 0 </span><span class="cov8" title="1">{
                        err = b.flush()
                }</span> else<span class="cov8" title="1"> {
                        err = nil
                }</span>
        }
        <span class="cov8" title="1">b.TotalWrite += int(n)
        return n, err</span>
}

// buffered input and output

// ReadWriter stores pointers to a Reader and a Writer.
// It implements io.ReadWriter.
type ReadWriter struct {
        *Reader
        *Writer
}

// NewReadWriter allocates a new ReadWriter that dispatches to r and w.
func NewReadWriter(r *Reader, w *Writer) *ReadWriter <span class="cov0" title="0">{
        return &amp;ReadWriter{r, w}
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// load cluster conf from json file

package cluster_conf

import (
        "errors"
        "fmt"
        "os"
        "strings"
)

import (
        "github.com/bfenetworks/bfe/bfe_util/json"
)

// RetryLevels
const (
        RetryConnect = 0 // retry if connect backend fail
        RetryGet     = 1 // retry if forward GET request fail (plus RetryConnect)
)

// DefaultTimeout
const (
        DefaultReadClientTimeout      = 30000
        DefaultWriteClientTimeout     = 60000
        DefaultReadClientAgainTimeout = 60000
)

// HashStrategy for subcluster-level load balance (GSLB).
// Note:
//  - CLIENTID is a special request header which represents a unique client,
//    eg. baidu id, passport id, device id etc.
const (
        ClientIdOnly      = iota // use CLIENTID to hash
        ClientIpOnly             // use CLIENTIP to hash
        ClientIdPreferred        // use CLIENTID to hash, otherwise use CLIENTIP
        RequestURI               // use request URI to hash
)

// BALANCE_MODE used for GslbBasicConf.
const (
        BalanceModeWrr = "WRR" // weighted round robin
        BalanceModeWlc = "WLC" // weighted least connection
)

const (
        // AnyStatusCode is a special status code used in health-check.
        // If AnyStatusCode is used, any status code is accepted for health-check response.
        AnyStatusCode = 0
)

// BackendCheck is conf of backend check
type BackendCheck struct {
        Schem         *string // protocol for health check (HTTP/TCP)
        Uri           *string // uri used in health check
        Host          *string // if check request use special host header
        StatusCode    *int    // default value is 200
        FailNum       *int    // unhealthy threshold (consecutive failures of check request)
        SuccNum       *int    // healthy threshold (consecutive successes of normal request)
        CheckTimeout  *int    // timeout for health check, in ms
        CheckInterval *int    // interval of health check, in ms
}

// FCGIConf are FastCGI related configurations
type FCGIConf struct {
        EnvVars map[string]string // the vars which will send to backend
        Root    string            // the server root
}

// BackendBasic is conf of backend basic
type BackendBasic struct {
        Protocol                 *string // backend protocol
        TimeoutConnSrv           *int    // timeout for connect backend, in ms
        TimeoutResponseHeader    *int    // timeout for read header from backend, in ms
        MaxIdleConnsPerHost      *int    // max idle conns for each backend
        MaxConnsPerHost          *int    // max conns for each backend (zero means unrestricted)
        RetryLevel               *int    // retry level if request fail
        SlowStartTime            *int    // time for backend increases the weight to the full value, in seconds
        OutlierDetectionHttpCode *string // outlier detection http status code
        // protocol specific configurations
        FCGIConf *FCGIConf
}

type HashConf struct {
        // HashStrategy is hash strategy for subcluster-level load balance.
        // ClientIdOnly, ClientIpOnly, ClientIdPreferred, RequestURI.
        HashStrategy *int

        // HashHeader is an optional request header which represents a unique client.
        // format for speicial cookie header is "Cookie:Key".
        // eg, Dueros-Device-Id, Cookie:BAIDUID, Cookie:PASSPORTID, etc
        HashHeader *string

        // SessionSticky enable sticky session (ensures that all requests
        // from the user during the session are sent to the same backend)
        SessionSticky *bool
}

// GslbBasicConf is basic conf for Gslb
type GslbBasicConf struct {
        CrossRetry *int // retry cross sub clusters
        RetryMax   *int // inner cluster retry
        HashConf   *HashConf

        BalanceMode *string // balanceMode, default WRR
}

// ClusterBasicConf is basic conf for cluster.
type ClusterBasicConf struct {
        TimeoutReadClient      *int // timeout for read client body in ms
        TimeoutWriteClient     *int // timeout for write response to client
        TimeoutReadClientAgain *int // timeout for read client again in ms

        ReqWriteBufferSize  *int  // write buffer size for request in byte
        ReqFlushInterval    *int  // interval to flush request in ms. if zero, disable periodic flush
        ResFlushInterval    *int  // interval to flush response in ms. if zero, disable periodic flush
        CancelOnClientClose *bool // cancel blocking operation on server if client connection disconnected
}

// ClusterConf is conf of cluster.
type ClusterConf struct {
        BackendConf  *BackendBasic     // backend's basic conf
        CheckConf    *BackendCheck     // how to check backend
        GslbBasic    *GslbBasicConf    // gslb basic conf for cluster
        ClusterBasic *ClusterBasicConf // basic conf for cluster
}

type ClusterToConf map[string]ClusterConf

// BfeClusterConf is conf of all bfe cluster.
type BfeClusterConf struct {
        Version *string // version of config
        Config  *ClusterToConf
}

// BackendBasicCheck check BackendBasic config.
func BackendBasicCheck(conf *BackendBasic) error <span class="cov8" title="1">{
        if conf.Protocol == nil </span><span class="cov8" title="1">{
                defaultProtocol := "http"
                conf.Protocol = &amp;defaultProtocol
        }</span>
        <span class="cov8" title="1">*conf.Protocol = strings.ToLower(*conf.Protocol)
        switch *conf.Protocol </span>{
        case "http", "tcp", "ws", "fcgi", "h2c":<span class="cov8" title="1"></span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("protocol only support http/tcp/ws/fcgi/h2c, but is:%s", *conf.Protocol)</span>
        }

        <span class="cov8" title="1">if conf.TimeoutConnSrv == nil </span><span class="cov0" title="0">{
                defaultTimeConnSrv := 2000
                conf.TimeoutConnSrv = &amp;defaultTimeConnSrv
        }</span>

        <span class="cov8" title="1">if conf.TimeoutResponseHeader == nil </span><span class="cov0" title="0">{
                defaultTimeoutResponseHeader := 60000
                conf.TimeoutResponseHeader = &amp;defaultTimeoutResponseHeader
        }</span>

        <span class="cov8" title="1">if conf.MaxIdleConnsPerHost == nil </span><span class="cov8" title="1">{
                defaultIdle := 2
                conf.MaxIdleConnsPerHost = &amp;defaultIdle
        }</span>

        <span class="cov8" title="1">if conf.MaxConnsPerHost == nil || *conf.MaxConnsPerHost &lt; 0 </span><span class="cov8" title="1">{
                defaultConns := 0
                conf.MaxConnsPerHost = &amp;defaultConns
        }</span>

        <span class="cov8" title="1">if conf.RetryLevel == nil </span><span class="cov8" title="1">{
                retryLevel := RetryConnect
                conf.RetryLevel = &amp;retryLevel
        }</span>

        <span class="cov8" title="1">if conf.OutlierDetectionHttpCode == nil </span><span class="cov8" title="1">{
                outlierDetectionCode := ""
                conf.OutlierDetectionHttpCode = &amp;outlierDetectionCode
        }</span> else<span class="cov0" title="0"> {
                httpCode := *conf.OutlierDetectionHttpCode
                httpCode = strings.ToLower(httpCode)
                conf.OutlierDetectionHttpCode = &amp;httpCode
        }</span>

        <span class="cov8" title="1">if conf.SlowStartTime == nil </span><span class="cov8" title="1">{
                defaultSlowStartTime := 0
                conf.SlowStartTime = &amp;defaultSlowStartTime
        }</span>

        <span class="cov8" title="1">if conf.FCGIConf == nil </span><span class="cov8" title="1">{
                defaultFCGIConf := new(FCGIConf)
                defaultFCGIConf.EnvVars = make(map[string]string)
                defaultFCGIConf.Root = ""
                conf.FCGIConf = defaultFCGIConf
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// checkStatusCode checks status code
func checkStatusCode(statusCode int) error <span class="cov8" title="1">{
        // Note: meaning for status code
        //  - 100~599: for status code of that value
        //  - 0b00001: for 1xx; 0b00010: for 2xx; ... ; 0b10000: for 5xx
        //  - 0b00110: for 2xx or 3xx
        //  - 0: for any status code

        // normal status code
        if statusCode &gt;= 100 &amp;&amp; statusCode &lt;= 599 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // special status code
        <span class="cov8" title="1">if statusCode &gt;= 0 &amp;&amp; statusCode &lt;= 31 </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">return errors.New("status code should be 100~599 (normal), 0~31 (special)")</span>
}

// convertStatusCode convert status code to string
func convertStatusCode(statusCode int) string <span class="cov0" title="0">{
        // normal status code
        if statusCode &gt;= 100 &amp;&amp; statusCode &lt;= 599 </span><span class="cov0" title="0">{
                return fmt.Sprintf("%d", statusCode)
        }</span>

        // any status code
        <span class="cov0" title="0">if statusCode == AnyStatusCode </span><span class="cov0" title="0">{
                return "ANY"
        }</span>

        // wildcard status code
        <span class="cov0" title="0">if statusCode &gt;= 1 &amp;&amp; statusCode &lt;= 31 </span><span class="cov0" title="0">{
                var codeStr string
                for i := 0; i &lt; 5; i++ </span><span class="cov0" title="0">{
                        if statusCode&gt;&gt;uint(i)&amp;1 != 0 </span><span class="cov0" title="0">{
                                codeStr += fmt.Sprintf("%dXX ", i+1)
                        }</span>
                }
                <span class="cov0" title="0">return codeStr</span>
        }

        <span class="cov0" title="0">return fmt.Sprintf("INVALID %d", statusCode)</span>
}

func MatchStatusCode(statusCodeGet int, statusCodeExpect int) (bool, error) <span class="cov0" title="0">{
        // for normal status code
        if statusCodeExpect &gt;= 100 &amp;&amp; statusCodeExpect &lt;= 599 </span><span class="cov0" title="0">{
                if statusCodeGet == statusCodeExpect </span><span class="cov0" title="0">{
                        return true, nil
                }</span>
        }

        // for any status code
        <span class="cov0" title="0">if statusCodeExpect == AnyStatusCode </span><span class="cov0" title="0">{
                return true, nil
        }</span>

        // for wildcard status code
        <span class="cov0" title="0">if statusCodeExpect &gt;= 1 &amp;&amp; statusCodeExpect &lt;= 31 </span><span class="cov0" title="0">{
                statusCodeWildcard := 1 &lt;&lt; uint(statusCodeGet/100-1) // eg. 2xx is 0b00010, 3xx is 0b00100
                if statusCodeExpect&amp;statusCodeWildcard != 0 </span><span class="cov0" title="0">{
                        return true, nil
                }</span>
        }

        <span class="cov0" title="0">return false, fmt.Errorf("response statusCode[%d], while expect[%s]",
                statusCodeGet, convertStatusCode(statusCodeExpect))</span>
}

// BackendCheckCheck check BackendCheck config.
func BackendCheckCheck(conf *BackendCheck) error <span class="cov8" title="1">{
        if conf.Schem == nil </span><span class="cov8" title="1">{
                // set default schem to http
                schem := "http"
                conf.Schem = &amp;schem
        }</span>

        <span class="cov8" title="1">if conf.Uri == nil </span><span class="cov8" title="1">{
                uri := "/health_check"
                conf.Uri = &amp;uri
        }</span>

        <span class="cov8" title="1">if conf.Host == nil </span><span class="cov8" title="1">{
                host := ""
                conf.Host = &amp;host
        }</span>

        <span class="cov8" title="1">if conf.StatusCode == nil </span><span class="cov8" title="1">{
                statusCode := 0
                conf.StatusCode = &amp;statusCode
        }</span>

        <span class="cov8" title="1">if conf.FailNum == nil </span><span class="cov0" title="0">{
                failNum := 5
                conf.FailNum = &amp;failNum
        }</span>

        <span class="cov8" title="1">if conf.CheckInterval == nil </span><span class="cov0" title="0">{
                checkInterval := 1000
                conf.CheckInterval = &amp;checkInterval
        }</span>

        <span class="cov8" title="1">if conf.SuccNum == nil </span><span class="cov8" title="1">{
                succNum := 1
                conf.SuccNum = &amp;succNum
        }</span>

        <span class="cov8" title="1">if *conf.Schem != "http" &amp;&amp; *conf.Schem != "tcp" </span><span class="cov8" title="1">{
                return errors.New("schem for BackendCheck should be http/tcp")
        }</span>

        <span class="cov8" title="1">if *conf.Schem == "http" </span><span class="cov8" title="1">{
                if !strings.HasPrefix(*conf.Uri, "/") </span><span class="cov0" title="0">{
                        return errors.New("Uri should be start with '/'")
                }</span>

                <span class="cov8" title="1">if err := checkStatusCode(*conf.StatusCode); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">if *conf.SuccNum &lt; 1 </span><span class="cov0" title="0">{
                return errors.New("SuccNum should be bigger than 0")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GslbBasicConfCheck check GslbBasicConf config.
func GslbBasicConfCheck(conf *GslbBasicConf) error <span class="cov8" title="1">{
        if conf.CrossRetry == nil </span><span class="cov0" title="0">{
                defaultCrossRetry := 0
                conf.CrossRetry = &amp;defaultCrossRetry
        }</span>

        <span class="cov8" title="1">if conf.RetryMax == nil </span><span class="cov0" title="0">{
                defaultRetryMax := 2
                conf.RetryMax = &amp;defaultRetryMax
        }</span>

        <span class="cov8" title="1">if conf.HashConf == nil </span><span class="cov8" title="1">{
                conf.HashConf = &amp;HashConf{}
        }</span>

        <span class="cov8" title="1">if conf.BalanceMode == nil </span><span class="cov8" title="1">{
                defaultBalMode := BalanceModeWrr
                conf.BalanceMode = &amp;defaultBalMode
        }</span>

        <span class="cov8" title="1">if err := HashConfCheck(conf.HashConf); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // check balanceMode
        <span class="cov8" title="1">*conf.BalanceMode = strings.ToUpper(*conf.BalanceMode)
        switch *conf.BalanceMode </span>{
        case BalanceModeWrr:<span class="cov8" title="1"></span>
        case BalanceModeWlc:<span class="cov0" title="0"></span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported bal mode %s", *conf.BalanceMode)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// HashConfCheck check HashConf config.
func HashConfCheck(conf *HashConf) error <span class="cov8" title="1">{
        if conf.HashStrategy == nil </span><span class="cov8" title="1">{
                defaultStrategy := ClientIpOnly
                conf.HashStrategy = &amp;defaultStrategy
        }</span>

        <span class="cov8" title="1">if conf.SessionSticky == nil </span><span class="cov8" title="1">{
                defaultSessionSticky := false
                conf.SessionSticky = &amp;defaultSessionSticky
        }</span>

        <span class="cov8" title="1">if *conf.HashStrategy != ClientIdOnly &amp;&amp;
                *conf.HashStrategy != ClientIpOnly &amp;&amp;
                *conf.HashStrategy != ClientIdPreferred &amp;&amp;
                *conf.HashStrategy != RequestURI </span><span class="cov0" title="0">{
                return fmt.Errorf("HashStrategy[%d] must be [%d], [%d], [%d] or [%d]",
                        *conf.HashStrategy, ClientIdOnly, ClientIpOnly, ClientIdPreferred, RequestURI)
        }</span>
        <span class="cov8" title="1">if *conf.HashStrategy == ClientIdOnly || *conf.HashStrategy == ClientIdPreferred </span><span class="cov0" title="0">{
                if conf.HashHeader == nil || len(*conf.HashHeader) == 0 </span><span class="cov0" title="0">{
                        return errors.New("no HashHeader")
                }</span>
                <span class="cov0" title="0">if cookieKey, ok := GetCookieKey(*conf.HashHeader); ok &amp;&amp; len(cookieKey) == 0 </span><span class="cov0" title="0">{
                        return errors.New("invalid HashHeader")
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// ClusterBasicConfCheck check ClusterBasicConf.
func ClusterBasicConfCheck(conf *ClusterBasicConf) error <span class="cov8" title="1">{
        if conf.TimeoutReadClient == nil </span><span class="cov0" title="0">{
                timeoutReadClient := DefaultReadClientTimeout
                conf.TimeoutReadClient = &amp;timeoutReadClient
        }</span>

        <span class="cov8" title="1">if conf.TimeoutWriteClient == nil </span><span class="cov0" title="0">{
                timeoutWriteClient := DefaultWriteClientTimeout
                conf.TimeoutWriteClient = &amp;timeoutWriteClient
        }</span>

        <span class="cov8" title="1">if conf.TimeoutReadClientAgain == nil </span><span class="cov0" title="0">{
                timeoutReadClientAgain := DefaultReadClientAgainTimeout
                conf.TimeoutReadClientAgain = &amp;timeoutReadClientAgain
        }</span>

        <span class="cov8" title="1">if conf.ReqWriteBufferSize == nil </span><span class="cov8" title="1">{
                reqWriteBufferSize := 512
                conf.ReqWriteBufferSize = &amp;reqWriteBufferSize
        }</span>

        <span class="cov8" title="1">if conf.ReqFlushInterval == nil </span><span class="cov8" title="1">{
                reqFlushInterval := 0
                conf.ReqFlushInterval = &amp;reqFlushInterval
        }</span>

        <span class="cov8" title="1">if conf.ResFlushInterval == nil </span><span class="cov8" title="1">{
                resFlushInterval := -1
                conf.ResFlushInterval = &amp;resFlushInterval
        }</span>

        <span class="cov8" title="1">if conf.CancelOnClientClose == nil </span><span class="cov8" title="1">{
                cancelOnClientClose := false
                conf.CancelOnClientClose = &amp;cancelOnClientClose
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// ClusterConfCheck check ClusterConf.
func ClusterConfCheck(conf *ClusterConf) error <span class="cov8" title="1">{
        var err error

        // check BackendConf
        if conf.BackendConf == nil </span><span class="cov0" title="0">{
                conf.BackendConf = &amp;BackendBasic{}
        }</span>
        <span class="cov8" title="1">err = BackendBasicCheck(conf.BackendConf)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("BackendConf:%s", err.Error())
        }</span>

        // check CheckConf
        <span class="cov8" title="1">if conf.CheckConf == nil </span><span class="cov0" title="0">{
                conf.CheckConf = &amp;BackendCheck{}
        }</span>
        <span class="cov8" title="1">err = BackendCheckCheck(conf.CheckConf)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("CheckConf:%s", err.Error())
        }</span>

        // check GslbBasic
        <span class="cov8" title="1">if conf.GslbBasic == nil </span><span class="cov0" title="0">{
                conf.GslbBasic = &amp;GslbBasicConf{}
        }</span>
        <span class="cov8" title="1">err = GslbBasicConfCheck(conf.GslbBasic)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("GslbBasic:%s", err.Error())
        }</span>

        // check ClusterBasic
        <span class="cov8" title="1">if conf.ClusterBasic == nil </span><span class="cov0" title="0">{
                conf.ClusterBasic = &amp;ClusterBasicConf{}
        }</span>
        <span class="cov8" title="1">err = ClusterBasicConfCheck(conf.ClusterBasic)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ClusterBasic:%s", err.Error())
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// ClusterToConfCheck check ClusterToConf.
func ClusterToConfCheck(conf ClusterToConf) error <span class="cov8" title="1">{
        for clusterName, clusterConf := range conf </span><span class="cov8" title="1">{
                err := ClusterConfCheck(&amp;clusterConf)
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("conf for %s:%s", clusterName, err.Error())
                }</span>
                <span class="cov8" title="1">conf[clusterName] = clusterConf</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// BfeClusterConfCheck check integrity of config
func BfeClusterConfCheck(conf *BfeClusterConf) error <span class="cov8" title="1">{
        if conf == nil </span><span class="cov0" title="0">{
                return errors.New("nil BfeClusterConf")
        }</span>
        <span class="cov8" title="1">if conf.Version == nil </span><span class="cov0" title="0">{
                return errors.New("no Version")
        }</span>

        <span class="cov8" title="1">if conf.Config == nil </span><span class="cov0" title="0">{
                return errors.New("no Config")
        }</span>

        <span class="cov8" title="1">err := ClusterToConfCheck(*conf.Config)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("BfeClusterConf.Config:%s", err.Error())
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func GetCookieKey(header string) (string, bool) <span class="cov0" title="0">{
        i := strings.Index(header, ":")
        if i &lt; 0 </span><span class="cov0" title="0">{
                return "", false
        }</span>
        <span class="cov0" title="0">return strings.TrimSpace(header[i+1:]), true</span>
}

func (conf *BfeClusterConf) LoadAndCheck(filename string) (string, error) <span class="cov8" title="1">{
        /* open the file    */
        file, err := os.Open(filename)

        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        /* decode the file  */
        <span class="cov8" title="1">decoder := json.NewDecoder(file)
        defer file.Close()

        if err := decoder.Decode(&amp;conf); err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        /* check conf   */
        <span class="cov8" title="1">if err := BfeClusterConfCheck(conf); err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">return *(conf.Version), nil</span>
}

// ClusterConfLoad load config of cluster conf from file
func ClusterConfLoad(filename string) (BfeClusterConf, error) <span class="cov8" title="1">{
        var config BfeClusterConf
        if _, err := config.LoadAndCheck(filename); err != nil </span><span class="cov8" title="1">{
                return config, fmt.Errorf("%s", err)
        }</span>

        <span class="cov8" title="1">return config, nil</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// load cluster table from json file

package cluster_table_conf

import (
        "errors"
        "fmt"
        "io/ioutil"
        "math/rand"
        "os"
        "reflect"
        "sort"
)

import (
        "github.com/bfenetworks/bfe/bfe_util/json"
)

// BackendConf is conf of backend
type BackendConf struct {
        Name   *string // e.g., "a-05.a"
        Addr   *string // e.g., "10.26.35.33"
        Port   *int    // e.g., 8000
        Weight *int    // weight in load balance, e.g., 10
}

func (b *BackendConf) AddrInfo() string <span class="cov0" title="0">{
        return fmt.Sprintf("%s:%d", *b.Addr, *b.Port)
}</span>

type SubClusterBackend []*BackendConf
type ClusterBackend map[string]SubClusterBackend
type AllClusterBackend map[string]ClusterBackend

func (s SubClusterBackend) Len() int <span class="cov0" title="0">{ return len(s) }</span>
func (s SubClusterBackend) Less(i, j int) bool <span class="cov0" title="0">{
        if *s[i].Addr != *s[j].Addr </span><span class="cov0" title="0">{
                return *s[i].Addr &lt; *s[j].Addr
        }</span>

        <span class="cov0" title="0">return *s[i].Port &lt; *s[j].Port</span>
}
func (s SubClusterBackend) Swap(i, j int) <span class="cov0" title="0">{ s[i], s[j] = s[j], s[i] }</span>

// Sort sorted backends by addr and port
func (s SubClusterBackend) Sort() <span class="cov0" title="0">{
        sort.Sort(s)
}</span>

// Shuffle random shuffle backends
func (s SubClusterBackend) Shuffle() <span class="cov0" title="0">{
        for i := len(s) - 1; i &gt; 1; i-- </span><span class="cov0" title="0">{
                j := rand.Intn(i + 1)
                s[i], s[j] = s[j], s[i]
        }</span>
}

// Sort sortes all the backends in allClusterBackend
func (allClusterBackend AllClusterBackend) Sort() <span class="cov0" title="0">{
        for _, clusterBackend := range allClusterBackend </span><span class="cov0" title="0">{
                for _, backends := range clusterBackend </span><span class="cov0" title="0">{
                        backends.Sort()
                }</span>
        }
}

// Shuffle shuffles all the backends in allClusterBackend
func (allClusterBackend AllClusterBackend) Shuffle() <span class="cov0" title="0">{
        for _, clusterBackend := range allClusterBackend </span><span class="cov0" title="0">{
                for _, backends := range clusterBackend </span><span class="cov0" title="0">{
                        backends.Shuffle()
                }</span>
        }
}

func (allClusterBackend AllClusterBackend) HasDiff(compared AllClusterBackend) bool <span class="cov0" title="0">{
        if len(allClusterBackend) != len(compared) </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">for cluster, clusterBackend := range allClusterBackend </span><span class="cov0" title="0">{
                comparedClusterBackend, ok := compared[cluster]
                if !ok </span><span class="cov0" title="0">{
                        return true
                }</span>

                <span class="cov0" title="0">if clusterBackend.HasDiff(comparedClusterBackend) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

// IsSub Compare two AllClusterBackend, return true if compared contains  all cluster
// in allClusterBackend, and there cluster has same ClusterBackend value.
func (allClusterBackend AllClusterBackend) IsSub(compared AllClusterBackend) bool <span class="cov0" title="0">{
        for cluster, clusterBackend := range allClusterBackend </span><span class="cov0" title="0">{
                comparedClusterBackend, ok := compared[cluster]
                if !ok </span><span class="cov0" title="0">{
                        return false
                }</span>

                <span class="cov0" title="0">if !clusterBackend.IsSame(comparedClusterBackend) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return true</span>
}

func (clusterBackend ClusterBackend) HasDiff(compared ClusterBackend) bool <span class="cov0" title="0">{
        return !reflect.DeepEqual(clusterBackend, compared)
}</span>

func (clusterBackend ClusterBackend) IsSame(compared ClusterBackend) bool <span class="cov0" title="0">{
        return !clusterBackend.HasDiff(compared)
}</span>

// ClusterTableConf is conf of cluster
type ClusterTableConf struct {
        Version *string // version of config
        Config  *AllClusterBackend
}

// BackendConfCheck check BackendConf config
func BackendConfCheck(conf *BackendConf) error <span class="cov8" title="1">{
        if conf.Name == nil </span><span class="cov0" title="0">{
                return errors.New("no Name")
        }</span>

        <span class="cov8" title="1">if conf.Addr == nil </span><span class="cov0" title="0">{
                return errors.New("no Addr")
        }</span>

        <span class="cov8" title="1">if conf.Port == nil </span><span class="cov0" title="0">{
                return errors.New("no Port")
        }</span>

        <span class="cov8" title="1">if conf.Weight == nil </span><span class="cov0" title="0">{
                return errors.New("no Weight")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (conf *AllClusterBackend) Check() error <span class="cov0" title="0">{
        return AllClusterBackendCheck(conf)
}</span>

func (s *SubClusterBackend) Check() error <span class="cov8" title="1">{
        availBackend := false
        for index, backendConf := range *s </span><span class="cov8" title="1">{
                err := BackendConfCheck(backendConf)

                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("%d %s", index, err)
                }</span>

                <span class="cov8" title="1">if *backendConf.Weight &gt; 0 </span><span class="cov8" title="1">{
                        availBackend = true
                }</span>
        }

        <span class="cov8" title="1">if !availBackend </span><span class="cov0" title="0">{
                return fmt.Errorf("no avail backend")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// AllClusterBackendCheck check AllClusterBackend config
func AllClusterBackendCheck(conf *AllClusterBackend) error <span class="cov8" title="1">{
        for clusterName, clusterBackend := range *conf </span><span class="cov8" title="1">{
                for subClusterName, subClusterBackend := range clusterBackend </span><span class="cov8" title="1">{
                        if err := subClusterBackend.Check(); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("%s %s %s", clusterName, subClusterName, err)
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

// ClusterTableConfCheck check ClusterTableConf config
func ClusterTableConfCheck(conf ClusterTableConf) error <span class="cov8" title="1">{
        if conf.Version == nil </span><span class="cov0" title="0">{
                return errors.New("no Version")
        }</span>

        <span class="cov8" title="1">if conf.Config == nil </span><span class="cov0" title="0">{
                return errors.New("no Config")
        }</span>

        <span class="cov8" title="1">err := AllClusterBackendCheck(conf.Config)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ClusterTableConf.Config:%s", err.Error())
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// ClusterTableLoad loads config of cluster table from file
func ClusterTableLoad(filename string) (ClusterTableConf, error) <span class="cov8" title="1">{
        var config ClusterTableConf

        /* open the file    */
        file, err1 := os.Open(filename)

        if err1 != nil </span><span class="cov0" title="0">{
                return config, err1
        }</span>

        /* decode the file  */
        <span class="cov8" title="1">decoder := json.NewDecoder(file)

        err2 := decoder.Decode(&amp;config)
        file.Close()

        if err2 != nil </span><span class="cov0" title="0">{
                return config, err2
        }</span>

        // check config
        <span class="cov8" title="1">err3 := ClusterTableConfCheck(config)
        if err3 != nil </span><span class="cov0" title="0">{
                return config, err3
        }</span>

        <span class="cov8" title="1">return config, nil</span>
}

// ClusterTableDump dumps conf to file
func ClusterTableDump(conf ClusterTableConf, filename string) error <span class="cov0" title="0">{
        // marshal to json
        confJson, err := json.Marshal(conf)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // dump to file
        <span class="cov0" title="0">err = ioutil.WriteFile(filename, confJson, 0644)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// load cluster conf from json file

package gslb_conf

import (
        "errors"
        "fmt"
        "os"
        "reflect"
)

import (
        "github.com/bfenetworks/bfe/bfe_util/json"
)

var (
        ErrGslbNoHostname = errors.New("no HostName")
        ErrGslbNoTs       = errors.New("no Ts")
)

// GslbClusterConf is gslb conf for one cluster
type GslbClusterConf map[string]int // sub_cluster_name =&gt; weight

// GslbClustersConf is gslb conf for multiple clusters
type GslbClustersConf map[string]GslbClusterConf // cluster_name =&gt; conf

// GslbConf is conf of GSLB
type GslbConf struct {
        Clusters *GslbClustersConf // gslb conf for multiple clusters

        // hostname of gslb scheduler,
        // e.g., "gslb-sch.example.com"
        Hostname *string
        Ts       *string // timestamp, e.g., "20140516151616"
}

func (gslb GslbClustersConf) HasDiff(compared GslbClustersConf) bool <span class="cov0" title="0">{
        if len(gslb) != len(compared) </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">for cluster, gslbClusterConf := range gslb </span><span class="cov0" title="0">{
                comparedGslbClusterConf, ok := (compared)[cluster]
                if !ok </span><span class="cov0" title="0">{
                        return true
                }</span>

                <span class="cov0" title="0">if gslbClusterConf.HasDiff(comparedGslbClusterConf) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

// IsSub compare two GslbConf and return true if compared contains all cluster in gslbConf
// and cluster has same GslbClusterConf.
func (gslbConf GslbConf) IsSub(compared GslbConf) bool <span class="cov0" title="0">{
        for cluster, gslbClusterConf := range *gslbConf.Clusters </span><span class="cov0" title="0">{
                comparedGslbClusterConf, ok := (*compared.Clusters)[cluster]
                if !ok </span><span class="cov0" title="0">{
                        return false
                }</span>

                <span class="cov0" title="0">if !gslbClusterConf.IsSame(comparedGslbClusterConf) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return true</span>
}

// Check check GslbClusterConf conf.
func (conf GslbClusterConf) Check() error <span class="cov8" title="1">{
        total := 0
        for _, weight := range conf </span><span class="cov8" title="1">{
                if weight &gt; 0 </span><span class="cov8" title="1">{
                        total += weight
                }</span>
        }

        // total &lt;= 0, no available subcluster
        <span class="cov8" title="1">if total &lt;= 0 </span><span class="cov0" title="0">{
                return errors.New("GslbClusterConf Check , total weight &lt;= 0")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (conf GslbClusterConf) IsSame(compared GslbClusterConf) bool <span class="cov0" title="0">{
        return !conf.HasDiff(compared)
}</span>

func (conf GslbClusterConf) HasDiff(compared GslbClusterConf) bool <span class="cov0" title="0">{
        return !reflect.DeepEqual(conf, compared)
}</span>

func (conf GslbClustersConf) Check() error <span class="cov8" title="1">{
        for cluster, clusterConf := range conf </span><span class="cov8" title="1">{
                if err := clusterConf.Check(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("[%s] check conf err [%s]", cluster, err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (conf *GslbConf) Check() error <span class="cov0" title="0">{
        return GslbConfCheck(*conf)
}</span>

func GslbConfNilCheck(conf GslbConf) error <span class="cov8" title="1">{
        if conf.Clusters == nil </span><span class="cov0" title="0">{
                return errors.New("no Clusters")
        }</span>

        <span class="cov8" title="1">if conf.Hostname == nil </span><span class="cov0" title="0">{
                return ErrGslbNoHostname
        }</span>

        <span class="cov8" title="1">if conf.Ts == nil </span><span class="cov0" title="0">{
                return ErrGslbNoTs
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GslbConfCheck check GslbConf.
func GslbConfCheck(conf GslbConf) error <span class="cov8" title="1">{
        if err := GslbConfNilCheck(conf); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Check Nil: %s", err)
        }</span>

        <span class="cov8" title="1">if err := conf.Clusters.Check(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Clusters check err %s", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GslbConfLoad load gslb config from file.
func GslbConfLoad(filename string) (GslbConf, error) <span class="cov8" title="1">{
        var config GslbConf

        /* open the file    */
        file, err1 := os.Open(filename)
        if err1 != nil </span><span class="cov0" title="0">{
                return config, err1
        }</span>

        /* decode the file  */
        <span class="cov8" title="1">decoder := json.NewDecoder(file)
        err2 := decoder.Decode(&amp;config)
        file.Close()
        if err2 != nil </span><span class="cov8" title="1">{
                return config, err2
        }</span>

        // check config
        <span class="cov8" title="1">err3 := GslbConfCheck(config)
        if err3 != nil </span><span class="cov0" title="0">{
                return config, err3
        }</span>

        <span class="cov8" title="1">return config, nil</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package bfe_conf

import (
        gcfg "gopkg.in/gcfg.v1"
)

type BfeConfig struct {
        // basic server config
        Server ConfigBasic

        // basic https config
        HttpsBasic ConfigHttpsBasic

        // session cache config
        SessionCache ConfigSessionCache

        // session cache config
        SessionTicket ConfigSessionTicket
}

func SetDefaultConf(conf *BfeConfig) <span class="cov8" title="1">{
        conf.Server.SetDefaultConf()
        conf.HttpsBasic.SetDefaultConf()
        conf.SessionCache.SetDefaultConf()
        conf.SessionTicket.SetDefaultConf()
}</span>

// BfeConfigLoad loads config from config file.
// NOTICE: some value will be modified when not set or out of range!!
func BfeConfigLoad(filePath string, confRoot string) (BfeConfig, error) <span class="cov8" title="1">{
        var cfg BfeConfig
        var err error

        SetDefaultConf(&amp;cfg)

        // read config from file
        err = gcfg.ReadFileInto(&amp;cfg, filePath)
        if err != nil </span><span class="cov0" title="0">{
                return cfg, err
        }</span>

        <span class="cov8" title="1">if err = cfg.Server.Check(confRoot); err != nil </span><span class="cov0" title="0">{
                return cfg, err
        }</span>

        <span class="cov8" title="1">if err = cfg.HttpsBasic.Check(confRoot); err != nil </span><span class="cov0" title="0">{
                return cfg, err
        }</span>

        <span class="cov8" title="1">if err = cfg.SessionCache.Check(confRoot); err != nil </span><span class="cov0" title="0">{
                return cfg, err
        }</span>

        <span class="cov8" title="1">if err = cfg.SessionTicket.Check(confRoot); err != nil </span><span class="cov0" title="0">{
                return cfg, err
        }</span>

        <span class="cov8" title="1">return cfg, nil</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package bfe_conf

import (
        "fmt"
        "strings"
)

import (
        "github.com/baidu/go-lib/log"
)

import (
        "github.com/bfenetworks/bfe/bfe_util"
)

const (
        BalancerProxy = "PROXY" // layer4 balancer working in PROXY mode (eg. F5, Ctrix, ELB etc)
        BalancerNone  = "NONE"  // layer4 balancer not used
)

const (
        // LibrarySuffix defines BFE plugin's file suffix.
        LibrarySuffix = ".so"
)

type ConfigBasic struct {
        HttpPort       int  // listen port for http
        HttpsPort      int  // listen port for https
        MonitorPort    int  // web server port for monitor
        MaxCpus        int  // number of max cpus to use
        AcceptNum      int  // number of accept goroutine for each listener, default 1
        MonitorEnabled bool // web server for monitor enable or not

        // settings of layer-4 load balancer
        Layer4LoadBalancer string

        // settings of communicate with http client
        TlsHandshakeTimeout     int  // tls handshake timeout, in seconds
        ClientReadTimeout       int  // read timeout, in seconds
        ClientWriteTimeout      int  // read timeout, in seconds
        GracefulShutdownTimeout int  // graceful shutdown timeout, in seconds
        MaxHeaderBytes          int  // max header length in bytes in request
        MaxHeaderUriBytes       int  // max URI(in header) length in bytes in request
        MaxProxyHeaderBytes     int  // max header length in bytes in Proxy protocol
        KeepAliveEnabled        bool // if false, client connection is shutdown disregard of http headers

        Modules []string // modules to load
        Plugins []string // plugins to load

        // location of data files for bfe_route
        HostRuleConf  string // path of host_rule.data
        VipRuleConf   string // path of vip_rule.data
        RouteRuleConf string // path of route_rule.data

        // location of other data files
        ClusterTableConf string // path of cluster_table.data
        GslbConf         string // path of gslb.data
        ClusterConf      string // path of cluster_conf.data
        NameConf         string // path of name_conf.data

        // interval
        MonitorInterval int // interval for getting diff of proxy-state

        DebugServHttp    bool // whether open server http debug log
        DebugBfeRoute    bool // whether open bferoute debug log
        DebugBal         bool // whether open bal debug log
        DebugHealthCheck bool // whether open health check debug log
}

func (cfg *ConfigBasic) SetDefaultConf() <span class="cov8" title="1">{
        cfg.HttpPort = 8080
        cfg.HttpsPort = 8443
        cfg.MonitorPort = 8421
        cfg.MonitorEnabled = true
        cfg.MaxCpus = 0

        cfg.TlsHandshakeTimeout = 30
        cfg.ClientReadTimeout = 60
        cfg.ClientWriteTimeout = 60
        cfg.GracefulShutdownTimeout = 10
        cfg.MaxHeaderBytes = 1048576
        cfg.MaxHeaderUriBytes = 8192
        cfg.KeepAliveEnabled = true

        cfg.HostRuleConf = "server_data_conf/host_rule.data"
        cfg.VipRuleConf = "server_data_conf/vip_rule.data"
        cfg.RouteRuleConf = "server_data_conf/route_rule.data"

        cfg.ClusterTableConf = "cluster_conf/cluster_table.data"
        cfg.GslbConf = "cluster_conf/gslb.data"
        cfg.ClusterConf = "server_data_conf/cluster_conf.data"
        cfg.NameConf = "server_data_conf/name_conf.data"

        cfg.MonitorInterval = 20
}</span>

func (cfg *ConfigBasic) Check(confRoot string) error <span class="cov8" title="1">{
        return ConfBasicCheck(cfg, confRoot)
}</span>

func ConfBasicCheck(cfg *ConfigBasic, confRoot string) error <span class="cov8" title="1">{
        var err error

        // check basic conf
        err = basicConfCheck(cfg)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // check data file conf
        <span class="cov8" title="1">err = dataFileConfCheck(cfg, confRoot)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func basicConfCheck(cfg *ConfigBasic) error <span class="cov8" title="1">{
        // check HttpPort
        if cfg.HttpPort &lt; 1 || cfg.HttpPort &gt; 65535 </span><span class="cov8" title="1">{
                return fmt.Errorf("HttpPort[%d] should be in [1, 65535]",
                        cfg.HttpPort)
        }</span>

        // check HttpsPort
        <span class="cov8" title="1">if cfg.HttpsPort &lt; 1 || cfg.HttpsPort &gt; 65535 </span><span class="cov0" title="0">{
                return fmt.Errorf("HttpsPort[%d] should be in [1, 65535]",
                        cfg.HttpsPort)
        }</span>

        // check MonitorPort if MonitorEnabled enabled
        <span class="cov8" title="1">if cfg.MonitorEnabled &amp;&amp; (cfg.MonitorPort &lt; 1 || cfg.MonitorPort &gt; 65535) </span><span class="cov8" title="1">{
                return fmt.Errorf("MonitorPort[%d] should be in [1, 65535]",
                        cfg.MonitorPort)
        }</span>

        // check MaxCpus
        <span class="cov8" title="1">if cfg.MaxCpus &lt; 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("MaxCpus[%d] is too small", cfg.MaxCpus)
        }</span>

        // check Layer4LoadBalancer
        <span class="cov8" title="1">if err := checkLayer4LoadBalancer(cfg); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // check AcceptNum
        <span class="cov8" title="1">if cfg.AcceptNum &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("AcceptNum[%d] is too small", cfg.AcceptNum)
        }</span> else<span class="cov8" title="1"> if cfg.AcceptNum == 0 </span><span class="cov8" title="1">{
                cfg.AcceptNum = 1
        }</span>

        // check TlsHandshakeTimeout
        <span class="cov8" title="1">if cfg.TlsHandshakeTimeout &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("TlsHandshakeTimeout[%d] should &gt; 0", cfg.TlsHandshakeTimeout)
        }</span>
        <span class="cov8" title="1">if cfg.TlsHandshakeTimeout &gt; 1200 </span><span class="cov0" title="0">{
                return fmt.Errorf("TlsHandshakeTimeout[%d] should &lt;= 1200", cfg.TlsHandshakeTimeout)
        }</span>

        // check ClientReadTimeout
        <span class="cov8" title="1">if cfg.ClientReadTimeout &lt;= 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("ClientReadTimeout[%d] should &gt; 0", cfg.ClientReadTimeout)
        }</span>

        // check ClientWriteTimeout
        <span class="cov8" title="1">if cfg.ClientWriteTimeout &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("ClientWriteTimeout[%d] should &gt; 0", cfg.ClientWriteTimeout)
        }</span>

        // check GracefulShutdownTimeout
        <span class="cov8" title="1">if cfg.GracefulShutdownTimeout &lt;= 0 || cfg.GracefulShutdownTimeout &gt; 300 </span><span class="cov0" title="0">{
                return fmt.Errorf("GracefulShutdownTimeout[%d] should be (0, 300]", cfg.GracefulShutdownTimeout)
        }</span>

        // check MonitorInterval
        <span class="cov8" title="1">if cfg.MonitorInterval &lt;= 0 </span><span class="cov0" title="0">{
                // not set, use default value
                log.Logger.Warn("MonitorInterval not set, use default value(20)")
                cfg.MonitorInterval = 20
        }</span> else<span class="cov8" title="1"> if cfg.MonitorInterval &gt; 60 </span><span class="cov0" title="0">{
                log.Logger.Warn("MonitorInterval[%d] &gt; 60, use 60", cfg.MonitorInterval)
                cfg.MonitorInterval = 60
        }</span> else<span class="cov8" title="1"> {
                if 60%cfg.MonitorInterval &gt; 0 </span><span class="cov8" title="1">{
                        return fmt.Errorf("MonitorInterval[%d] can not divide 60", cfg.MonitorInterval)
                }</span>

                <span class="cov8" title="1">if cfg.MonitorInterval &lt; 20 </span><span class="cov0" title="0">{
                        return fmt.Errorf("MonitorInterval[%d] is too small(&lt;20)", cfg.MonitorInterval)
                }</span>
        }

        // check MaxHeaderUriBytes
        <span class="cov8" title="1">if cfg.MaxHeaderUriBytes &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("MaxHeaderUriBytes[%d] should &gt; 0", cfg.MaxHeaderUriBytes)
        }</span>

        // check MaxHeaderBytes
        <span class="cov8" title="1">if cfg.MaxHeaderBytes &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("MaxHeaderHeaderBytes[%d] should &gt; 0", cfg.MaxHeaderBytes)
        }</span>

        // check Plugins
        <span class="cov8" title="1">if err := checkPlugins(cfg); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("plugins[%v] check failed. err: %s", cfg.Plugins, err.Error())
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func checkLayer4LoadBalancer(cfg *ConfigBasic) error <span class="cov8" title="1">{
        if len(cfg.Layer4LoadBalancer) == 0 </span><span class="cov8" title="1">{
                cfg.Layer4LoadBalancer = BalancerNone // default NONE
        }</span>

        <span class="cov8" title="1">switch cfg.Layer4LoadBalancer </span>{
        case BalancerProxy:<span class="cov0" title="0">
                return nil</span>
        case BalancerNone:<span class="cov8" title="1">
                return nil</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("Layer4LoadBalancer[%s] should be PROXY/NONE", cfg.Layer4LoadBalancer)</span>
        }
}

func checkPlugins(cfg *ConfigBasic) error <span class="cov8" title="1">{
        plugins := []string{}
        for _, pluginPath := range cfg.Plugins </span><span class="cov0" title="0">{
                pluginPath = strings.TrimSpace(pluginPath)
                if pluginPath == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">if !strings.HasSuffix(pluginPath, LibrarySuffix) </span><span class="cov0" title="0">{
                        pluginPath += LibrarySuffix
                }</span>
                <span class="cov0" title="0">plugins = append(plugins, pluginPath)</span>
        }
        <span class="cov8" title="1">cfg.Plugins = plugins

        return nil</span>
}

func dataFileConfCheck(cfg *ConfigBasic, confRoot string) error <span class="cov8" title="1">{
        // check HostRuleConf
        if cfg.HostRuleConf == "" </span><span class="cov8" title="1">{
                cfg.HostRuleConf = "server_data_conf/host_rule.data"
                log.Logger.Warn("HostRuleConf not set, use default value [%s]", cfg.HostRuleConf)
        }</span>
        <span class="cov8" title="1">cfg.HostRuleConf = bfe_util.ConfPathProc(cfg.HostRuleConf, confRoot)

        // check VipRuleConf
        if cfg.VipRuleConf == "" </span><span class="cov8" title="1">{
                cfg.VipRuleConf = "server_data_conf/vip_rule.data"
                log.Logger.Warn("VipRuleConf not set, use default value [%s]", cfg.VipRuleConf)
        }</span>
        <span class="cov8" title="1">cfg.VipRuleConf = bfe_util.ConfPathProc(cfg.VipRuleConf, confRoot)

        // check RouteRuleConf
        if cfg.RouteRuleConf == "" </span><span class="cov8" title="1">{
                cfg.RouteRuleConf = "server_data_conf/route_rule.data"
                log.Logger.Warn("RouteRuleConf not set, use default value [%s]", cfg.RouteRuleConf)
        }</span>
        <span class="cov8" title="1">cfg.RouteRuleConf = bfe_util.ConfPathProc(cfg.RouteRuleConf, confRoot)

        // check ClusterTableConf
        if cfg.ClusterTableConf == "" </span><span class="cov8" title="1">{
                cfg.ClusterTableConf = "cluster_conf/cluster_table.data"
                log.Logger.Warn("ClusterTableConf not set, use default value [%s]", cfg.ClusterTableConf)
        }</span>
        <span class="cov8" title="1">cfg.ClusterTableConf = bfe_util.ConfPathProc(cfg.ClusterTableConf, confRoot)

        // check GslbConf
        if cfg.GslbConf == "" </span><span class="cov8" title="1">{
                cfg.GslbConf = "cluster_conf/gslb.data"
                log.Logger.Warn("GslbConf not set, use default value [%s]", cfg.GslbConf)
        }</span>
        <span class="cov8" title="1">cfg.GslbConf = bfe_util.ConfPathProc(cfg.GslbConf, confRoot)

        // check ClusterConf
        if cfg.ClusterConf == "" </span><span class="cov8" title="1">{
                cfg.ClusterConf = "server_data_conf/cluster_conf.data"
                log.Logger.Warn("ClusterConf not set, use default value [%s]", cfg.ClusterConf)
        }</span>
        <span class="cov8" title="1">cfg.ClusterConf = bfe_util.ConfPathProc(cfg.ClusterConf, confRoot)

        // check NameConf (optional)
        if cfg.NameConf == "" </span><span class="cov8" title="1">{
                log.Logger.Warn("NameConf not set, ignore optional name conf")
        }</span> else<span class="cov8" title="1"> {
                cfg.NameConf = bfe_util.ConfPathProc(cfg.NameConf, confRoot)
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package bfe_conf

import (
        "crypto/x509"
        "fmt"
        "io/ioutil"
        "strings"
)

import (
        "github.com/baidu/go-lib/log"
)

import (
        "github.com/bfenetworks/bfe/bfe_tls"
        "github.com/bfenetworks/bfe/bfe_util"
)

var TlsVersionMap = map[string]uint16{
        "VersionSSL30": bfe_tls.VersionSSL30,
        "VersionTLS10": bfe_tls.VersionTLS10,
        "VersionTLS11": bfe_tls.VersionTLS11,
        "VersionTLS12": bfe_tls.VersionTLS12,
}

var CurvesMap = map[string]bfe_tls.CurveID{
        "CurveP256": bfe_tls.CurveP256,
        "CurveP384": bfe_tls.CurveP384,
        "CurveP521": bfe_tls.CurveP521,
}

var CipherSuitesMap = map[string]uint16{
        "TLS_RSA_WITH_RC4_128_SHA":                      bfe_tls.TLS_RSA_WITH_RC4_128_SHA,
        "TLS_RSA_WITH_3DES_EDE_CBC_SHA":                 bfe_tls.TLS_RSA_WITH_3DES_EDE_CBC_SHA,
        "TLS_RSA_WITH_AES_128_CBC_SHA":                  bfe_tls.TLS_RSA_WITH_AES_128_CBC_SHA,
        "TLS_RSA_WITH_AES_256_CBC_SHA":                  bfe_tls.TLS_RSA_WITH_AES_256_CBC_SHA,
        "TLS_ECDHE_ECDSA_WITH_RC4_128_SHA":              bfe_tls.TLS_ECDHE_ECDSA_WITH_RC4_128_SHA,
        "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA":          bfe_tls.TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA,
        "TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA":          bfe_tls.TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA,
        "TLS_ECDHE_RSA_WITH_RC4_128_SHA":                bfe_tls.TLS_ECDHE_RSA_WITH_RC4_128_SHA,
        "TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA":           bfe_tls.TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA,
        "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA":            bfe_tls.TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,
        "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA":            bfe_tls.TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,
        "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256":         bfe_tls.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
        "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256":       bfe_tls.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
        "TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256":   bfe_tls.TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256,
        "TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256": bfe_tls.TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256,
}

const (
        EquivCipherSep = "|" // separator for equivalent ciphers string
)

type ConfigHttpsBasic struct {
        ServerCertConf string // config for server cert and key
        TlsRuleConf    string // config for server tls rule

        CipherSuites     []string // supported cipher suites
        CurvePreferences []string // curve preference

        MaxTlsVersion string // max tls version supported
        MinTlsVersion string // min tls version supported

        EnableSslv2ClientHello bool // support sslv2 client hello for backward compatibility

        ClientCABaseDir  string // client root CAs base directory
        ClientCRLBaseDir string // client cert CRL base directory
}

// SetDefaultConf sets default value of ConfigHttpsBasic.
// Note: DO NOT initialize multi-value fields (eg. CipherSuites/CurvePreferences)
func (cfg *ConfigHttpsBasic) SetDefaultConf() <span class="cov8" title="1">{
        cfg.ServerCertConf = "tls_conf/server_cert_conf.data"
        cfg.TlsRuleConf = "tls_conf/tls_rule_conf.data"
        cfg.EnableSslv2ClientHello = true
        cfg.ClientCABaseDir = "tls_conf/client_ca"
        cfg.ClientCRLBaseDir = "tls_conf/client_crl"
}</span>

func (cfg *ConfigHttpsBasic) Check(confRoot string) error <span class="cov8" title="1">{
        err := certConfCheck(cfg, confRoot)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">err = certRuleCheck(cfg, confRoot)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">err = clientCABaseDirCheck(cfg, confRoot)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">err = cipherSuitesCheck(cfg)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">err = curvePreferencesCheck(cfg)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">err = tlsVersionCheck(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">err = clientCRLConfCheck(cfg, confRoot)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func clientCRLConfCheck(cfg *ConfigHttpsBasic, confRoot string) error <span class="cov8" title="1">{
        if len(cfg.ClientCRLBaseDir) == 0 </span><span class="cov0" title="0">{
                cfg.ClientCRLBaseDir = "tls_conf/client_crl"
                log.Logger.Warn("ClientCRLBaseDir not set, use default value [%s]", cfg.ClientCRLBaseDir)
        }</span>

        <span class="cov8" title="1">cfg.ClientCRLBaseDir = bfe_util.ConfPathProc(cfg.ClientCRLBaseDir, confRoot)
        return nil</span>
}

func certConfCheck(cfg *ConfigHttpsBasic, confRoot string) error <span class="cov8" title="1">{
        if cfg.ServerCertConf == "" </span><span class="cov0" title="0">{
                cfg.ServerCertConf = "tls_conf/server_cert_conf.data"
                log.Logger.Warn("ServerCertConf not set, use default value [%s]", cfg.ServerCertConf)
        }</span>
        <span class="cov8" title="1">cfg.ServerCertConf = bfe_util.ConfPathProc(cfg.ServerCertConf, confRoot)
        return nil</span>
}

func cipherSuitesCheck(cfg *ConfigHttpsBasic) error <span class="cov8" title="1">{
        if len(cfg.CipherSuites) == 0 </span><span class="cov8" title="1">{
                cfg.CipherSuites = []string{
                        "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256|TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256",
                        "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256|TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256",
                        "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256|TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256",
                        "TLS_ECDHE_RSA_WITH_RC4_128_SHA",
                        "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA",
                        "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA",
                        "TLS_RSA_WITH_RC4_128_SHA",
                        "TLS_RSA_WITH_AES_128_CBC_SHA",
                        "TLS_RSA_WITH_AES_256_CBC_SHA",
                }
                log.Logger.Warn("CipherSuites not set, use default value %v", cfg.CipherSuites)
        }</span>

        <span class="cov8" title="1">for _, cipherGroup := range cfg.CipherSuites </span><span class="cov8" title="1">{
                ciphers := strings.Split(cipherGroup, EquivCipherSep)
                for _, cipher := range ciphers </span><span class="cov8" title="1">{
                        if _, ok := CipherSuitesMap[cipher]; !ok </span><span class="cov8" title="1">{
                                return fmt.Errorf("cipher (%s) not support", cipher)
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

func curvePreferencesCheck(cfg *ConfigHttpsBasic) error <span class="cov8" title="1">{
        if len(cfg.CurvePreferences) == 0 </span><span class="cov8" title="1">{
                cfg.CurvePreferences = []string{
                        "CurveP256",
                }
                log.Logger.Warn("CurvePreferences not set, use default value %v", cfg.CurvePreferences)
        }</span>

        <span class="cov8" title="1">for _, curve := range cfg.CurvePreferences </span><span class="cov8" title="1">{
                if _, ok := CurvesMap[curve]; !ok </span><span class="cov8" title="1">{
                        return fmt.Errorf("curve (%s) not support", curve)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func certRuleCheck(cfg *ConfigHttpsBasic, confRoot string) error <span class="cov8" title="1">{
        if cfg.TlsRuleConf == "" </span><span class="cov8" title="1">{
                cfg.TlsRuleConf = "tls_conf/tls_rule_conf.data"
                log.Logger.Warn("TlsRuleConf not set, use default value [%s]", cfg.TlsRuleConf)
        }</span>
        <span class="cov8" title="1">cfg.TlsRuleConf = bfe_util.ConfPathProc(cfg.TlsRuleConf, confRoot)
        return nil</span>
}

func clientCABaseDirCheck(cfg *ConfigHttpsBasic, confRoot string) error <span class="cov8" title="1">{
        if cfg.ClientCABaseDir == "" </span><span class="cov0" title="0">{
                cfg.ClientCABaseDir = "tls_conf/client_ca"
                log.Logger.Warn("ClientCABaseDir not set, use default value [%s]", cfg.ClientCABaseDir)
        }</span>
        <span class="cov8" title="1">cfg.ClientCABaseDir = bfe_util.ConfPathProc(cfg.ClientCABaseDir, confRoot)
        return nil</span>
}

func tlsVersionCheck(cfg *ConfigHttpsBasic) error <span class="cov8" title="1">{
        if len(cfg.MaxTlsVersion) == 0 </span><span class="cov8" title="1">{
                cfg.MaxTlsVersion = "VersionTLS12"
        }</span>
        <span class="cov8" title="1">if len(cfg.MinTlsVersion) == 0 </span><span class="cov8" title="1">{
                cfg.MinTlsVersion = "VersionSSL30"
        }</span>

        <span class="cov8" title="1">maxTlsVer, ok := TlsVersionMap[cfg.MaxTlsVersion]
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("Max TLS version(%s) not support", cfg.MaxTlsVersion)
        }</span>
        <span class="cov8" title="1">minTlsVer, ok := TlsVersionMap[cfg.MinTlsVersion]
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("Min TLS version(%s) not support", cfg.MinTlsVersion)
        }</span>

        <span class="cov8" title="1">if maxTlsVer &lt; minTlsVer </span><span class="cov0" title="0">{
                return fmt.Errorf("Max TLS version should not less than Min TLS version")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// LoadClientCAFile loads client ca certificate in PEM format
func LoadClientCAFile(path string) (*x509.CertPool, error) <span class="cov0" title="0">{
        roots := x509.NewCertPool()
        data, err := ioutil.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">roots.AppendCertsFromPEM(data)
        return roots, nil</span>
}

func GetCurvePreferences(curveConf []string) ([]bfe_tls.CurveID, error) <span class="cov0" title="0">{
        curvePreferences := make([]bfe_tls.CurveID, 0, len(curveConf))
        for _, curveStr := range curveConf </span><span class="cov0" title="0">{
                curve, ok := CurvesMap[curveStr]
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("ellptic curve (%s) not support", curveStr)
                }</span>
                <span class="cov0" title="0">curvePreferences = append(curvePreferences, curve)</span>
        }
        <span class="cov0" title="0">return curvePreferences, nil</span>
}

func GetCipherSuites(cipherConf []string) ([]uint16, []uint16, error) <span class="cov0" title="0">{
        cipherSuites := make([]uint16, 0, len(cipherConf))
        cipherSuitesPriority := make([]uint16, 0, len(cipherConf))

        for i, cipherGroup := range cipherConf </span><span class="cov0" title="0">{
                ciphers := strings.Split(cipherGroup, EquivCipherSep)
                for _, cipher := range ciphers </span><span class="cov0" title="0">{
                        cipherSuite, ok := CipherSuitesMap[cipher]
                        if !ok </span><span class="cov0" title="0">{
                                return nil, nil, fmt.Errorf("ciphersuite (%s) not support", cipher)
                        }</span>
                        <span class="cov0" title="0">cipherSuites = append(cipherSuites, cipherSuite)
                        cipherSuitesPriority = append(cipherSuitesPriority, uint16(i))</span>
                }
        }

        <span class="cov0" title="0">return cipherSuites, cipherSuitesPriority, nil</span>
}

func GetTlsVersion(cfg *ConfigHttpsBasic) (maxVer, minVer uint16) <span class="cov0" title="0">{
        maxTlsVersion, ok := TlsVersionMap[cfg.MaxTlsVersion]
        if !ok </span><span class="cov0" title="0">{
                maxTlsVersion = bfe_tls.VersionTLS12
        }</span>

        <span class="cov0" title="0">minTlsVersion, ok := TlsVersionMap[cfg.MinTlsVersion]
        if !ok </span><span class="cov0" title="0">{
                minTlsVersion = bfe_tls.VersionSSL30
        }</span>

        <span class="cov0" title="0">return maxTlsVersion, minTlsVersion</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package bfe_conf

import (
        "fmt"
        "strings"
)

type ConfigSessionCache struct {
        // disable tls session cache or not
        SessionCacheDisabled bool

        // address for redis servers
        Servers string

        // prefix for cache key
        KeyPrefix string

        // config for connection (ms)
        ConnectTimeout int
        ReadTimeout    int
        WriteTimeout   int

        // max idle connections in pool
        MaxIdle int

        // expire time for tls session state (s)
        SessionExpire int
}

func (cfg *ConfigSessionCache) SetDefaultConf() <span class="cov8" title="1">{
        cfg.SessionCacheDisabled = true
        cfg.KeyPrefix = "bfe"
        cfg.ConnectTimeout = 50
        cfg.WriteTimeout = 50
        cfg.MaxIdle = 20
        cfg.SessionExpire = 3600
}</span>

func (cfg *ConfigSessionCache) Check(confRoot string) error <span class="cov8" title="1">{
        if cfg.SessionCacheDisabled </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return ConfSessionCacheCheck(cfg, confRoot)</span>
}

func ConfSessionCacheCheck(cfg *ConfigSessionCache, confRoot string) error <span class="cov8" title="1">{
        // check servers
        names := strings.Split(cfg.Servers, ",")
        if len(cfg.Servers) == 0 || len(names) &lt; 1 </span><span class="cov8" title="1">{
                return fmt.Errorf("Servers[%s] invalid server names", cfg.Servers)
        }</span>

        // check ReadTimeout
        <span class="cov8" title="1">if cfg.ReadTimeout &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("ReadTimeout[%d] should &gt; 0", cfg.ReadTimeout)
        }</span>

        // check WriteTimeout
        <span class="cov8" title="1">if cfg.WriteTimeout &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("WriteTimeout[%d] should &gt; 0", cfg.WriteTimeout)
        }</span>

        // check MaxIdle
        <span class="cov8" title="1">if cfg.MaxIdle &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("MaxIdle[%d] should &gt; 0", cfg.MaxIdle)
        }</span>

        // check SessionExpire
        <span class="cov8" title="1">if cfg.SessionExpire &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("SessionExpire[%d] should &gt; 0", cfg.SessionExpire)
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package bfe_conf

import (
        "github.com/baidu/go-lib/log"
)

import (
        "github.com/bfenetworks/bfe/bfe_util"
)

type ConfigSessionTicket struct {
        // disable session cache or not
        SessionTicketsDisabled bool

        // session ticket key (in hex format)
        SessionTicketKeyFile string
}

func (cfg *ConfigSessionTicket) SetDefaultConf() <span class="cov8" title="1">{
        cfg.SessionTicketsDisabled = true
        cfg.SessionTicketKeyFile = "tls_conf/session_ticket_key.data"
}</span>

func (cfg *ConfigSessionTicket) Check(confRoot string) error <span class="cov8" title="1">{
        if cfg.SessionTicketsDisabled </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">return ConfSessionTicketCheck(cfg, confRoot)</span>
}

func ConfSessionTicketCheck(cfg *ConfigSessionTicket, confRoot string) error <span class="cov8" title="1">{
        // check session ticket key
        if cfg.SessionTicketKeyFile == "" </span><span class="cov0" title="0">{
                log.Logger.Warn("SessionTicketKeyFile not set, use default value")
                cfg.SessionTicketKeyFile = "tls_conf/server_ticket_key.data"
        }</span>
        <span class="cov8" title="1">cfg.SessionTicketKeyFile = bfe_util.ConfPathProc(cfg.SessionTicketKeyFile, confRoot)

        return nil</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// load host table from json file

package host_rule_conf

import (
        "errors"
        "fmt"
        "os"
)

import (
        "github.com/bfenetworks/bfe/bfe_util/json"
)

type HostnameList []string // list of hostname
type HostTagList []string  // list of host-tag

type HostTagToHost map[string]*HostnameList   // host-tag =&gt; hosts
type ProductToHostTag map[string]*HostTagList // product =&gt; host-tags

type Host2HostTag map[string]string    // hostname =&gt; host-tag
type HostTag2Product map[string]string // host-tag =&gt; product

type HostTableConf struct {
        Version        *string           // version of the config
        DefaultProduct *string           // default product
        Hosts          *HostTagToHost    // host-tag =&gt; hosts
        HostTags       *ProductToHostTag // product =&gt; host-tags
}

type HostConf struct {
        Version        string          // version of the config
        DefaultProduct string          // default product
        HostMap        Host2HostTag    // hostname =&gt; host-tag
        HostTagMap     HostTag2Product // host-tag =&gt; product
}

func (conf *HostTableConf) LoadAndCheck(filename string) (string, error) <span class="cov8" title="1">{
        // open the file
        file, err := os.Open(filename)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        // decode the file
        decoder := json.NewDecoder(file)
        if err := decoder.Decode(conf); err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        // check config
        <span class="cov8" title="1">if err := HostTableConfCheck(*conf); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">return *(conf.Version), nil</span>
}

// HostTableConfCheck check HostTableConf config
func HostTableConfCheck(conf HostTableConf) error <span class="cov8" title="1">{
        if conf.Version == nil </span><span class="cov0" title="0">{
                return errors.New("no Version")
        }</span>

        <span class="cov8" title="1">if conf.Hosts == nil </span><span class="cov0" title="0">{
                return errors.New("no Hosts")
        }</span>

        <span class="cov8" title="1">if conf.HostTags == nil </span><span class="cov0" title="0">{
                return errors.New("no HostTags")
        }</span>

        // check config for each product
        <span class="cov8" title="1">for product, hostTagList := range *conf.HostTags </span><span class="cov8" title="1">{
                if hostTagList == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("no HostTagList for %s", product)
                }</span>
        }

        // check config for each host-tag
        <span class="cov8" title="1">for hostTag, hostnameList := range *conf.Hosts </span><span class="cov8" title="1">{
                if hostnameList == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("no HostnameList for %s", hostTag)
                }</span>

                <span class="cov8" title="1">find := false
        HOST_TAG_CHECK:
                // check host-tag in Hosts should exist in HostTags
                for _, hostTagList := range *conf.HostTags </span><span class="cov8" title="1">{
                        for _, ht := range *hostTagList </span><span class="cov8" title="1">{
                                if ht == hostTag </span><span class="cov8" title="1">{
                                        find = true
                                        break HOST_TAG_CHECK</span>
                                }
                        }
                }

                <span class="cov8" title="1">if !find </span><span class="cov0" title="0">{
                        return fmt.Errorf("hostTag[%s] in Hosts should also exist in HostTags!", hostTag)
                }</span>
        }

        // if default product is set, defaultProduct must exist in HostTags
        <span class="cov8" title="1">if conf.DefaultProduct != nil </span><span class="cov0" title="0">{
                hostTags := *conf.HostTags
                _, ok := hostTags[*conf.DefaultProduct]
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("defaultProruct[%s], must exist in HostTags", *conf.DefaultProduct)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// HostRuleConfLoad loads config of host table from file.
func HostRuleConfLoad(filename string) (HostConf, error) <span class="cov8" title="1">{
        var conf HostConf
        var config HostTableConf

        if _, err := config.LoadAndCheck(filename); err != nil </span><span class="cov8" title="1">{
                return conf, err
        }</span>

        // convert HostTagToHost to Host2HostTag
        <span class="cov8" title="1">host2HostTag := make(Host2HostTag)

        for hostTag, hostnameList := range *config.Hosts </span><span class="cov8" title="1">{
                for _, hostName := range *hostnameList </span><span class="cov8" title="1">{
                        if host2HostTag[hostName] != "" </span><span class="cov0" title="0">{
                                return conf, fmt.Errorf("host duplicate for %s", hostName)
                        }</span>
                        <span class="cov8" title="1">host2HostTag[hostName] = hostTag</span>
                }
        }

        // convert ProductToHostTag to HostTag2Product
        <span class="cov8" title="1">hostTag2Product := make(HostTag2Product)

        for product, hostTagList := range *config.HostTags </span><span class="cov8" title="1">{
                for _, hostTag := range *hostTagList </span><span class="cov8" title="1">{
                        hostTag2Product[hostTag] = product
                }</span>
        }

        // convert default product
        <span class="cov8" title="1">if config.DefaultProduct != nil </span><span class="cov0" title="0">{
                conf.DefaultProduct = *config.DefaultProduct
        }</span>

        <span class="cov8" title="1">conf.Version = *config.Version
        conf.HostMap = host2HostTag
        conf.HostTagMap = hostTag2Product

        return conf, nil</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// trees for matching basic route rule : (host+path) -&gt; clusterName

package route_rule_conf

import (
        "fmt"
        "strings"
)

import (
        "github.com/armon/go-radix"
)

import (
        "github.com/bfenetworks/bfe/bfe_util/string_reverse"
)

const (
        treeMatchExact    = iota // index to exact match tree
        treeMatchWildcard        // index to wildcard match tree
        treeMatchTypeNum         // index to exact match tree
)

type hostTrees [treeMatchTypeNum]*radix.Tree // trees for host match
type pathTrees [treeMatchTypeNum]*radix.Tree // trees for path match

// BasicRouteRuleTree implements radix trees for host+path matching
// hostTree (key:hostname, value:pathTree)
// pathTree (key:path, value:clusterName)
type BasicRouteRuleTree struct {
        hosts hostTrees
}

func NewBasicRouteRuleTree() *BasicRouteRuleTree <span class="cov8" title="1">{
        return &amp;BasicRouteRuleTree{
                hosts: [treeMatchTypeNum]*radix.Tree{radix.New(), radix.New()},
        }
}</span>

// Insert adds a new basic route rule into BasicRouteRuleTree
// key: hostname, value: pathTrees
func (r *BasicRouteRuleTree) Insert(ruleConf *BasicRouteRuleFile) error <span class="cov8" title="1">{
        if len(ruleConf.Hostname) == 0 </span><span class="cov8" title="1">{
                ruleConf.Hostname = append(ruleConf.Hostname, "*")
        }</span>

        <span class="cov8" title="1">if len(ruleConf.Path) == 0 </span><span class="cov8" title="1">{
                ruleConf.Path = append(ruleConf.Path, "*")
        }</span>

        <span class="cov8" title="1">for _, host := range ruleConf.Hostname </span><span class="cov8" title="1">{
                if host == "" </span><span class="cov8" title="1">{
                        // not allow
                        return fmt.Errorf("hostname is empty string")
                }</span>

                <span class="cov8" title="1">pathTree := r.hosts.insert(host)
                for _, path := range ruleConf.Path </span><span class="cov8" title="1">{
                        if err := pathTree.insert(path, *ruleConf.ClusterName); err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// insert adds a new node in hostTrees, key: hostname, value: pathTrees
// return node's value: pathTrees
func (ht *hostTrees) insert(host string) pathTrees <span class="cov8" title="1">{
        var treeType int
        var key string

        // remove * from wildcard host
        // *.bar.foo.com -&gt; .bar.foo.com
        if host[0] == '*' </span><span class="cov8" title="1">{
                key = host[1:]
                treeType = treeMatchWildcard
        }</span> else<span class="cov8" title="1"> {
                key = host
                treeType = treeMatchExact
        }</span>

        // call ReverseFqdnHost reverse hostname
        // for case insensitive comparing, convert the reversed hostname to uppercase
        // .bar.foo.com -&gt; MOC.OOF.RAB.
        <span class="cov8" title="1">key = strings.ToUpper(string_reverse.ReverseFqdnHost(key))

        // return pathTree if already existed
        if value, found := ht[treeType].Get(key); found </span><span class="cov8" title="1">{
                return value.(pathTrees)
        }</span>

        // no host found, insert new node
        <span class="cov8" title="1">value := pathTrees{radix.New(), radix.New()}
        ht[treeType].Insert(key, value)

        return value</span>
}

// get returns pathTree for hostname
func (ht *hostTrees) get(host string) (pathTrees, bool) <span class="cov8" title="1">{
        // convert key to uppercase for case insensitive comparing
        // baz.bar.foo.com -&gt; MOC.OOF.RAB.ZAB
        key := strings.ToUpper(string_reverse.ReverseFqdnHost(host))

        //exact match firstly
        if value, found := ht[treeMatchExact].Get(key); found </span><span class="cov8" title="1">{
                return value.(pathTrees), true
        }</span>

        // try wildcard match if exact match fail
        // note: * only match one label in hostname.
        // For example: *.aaa.com can match with bbb.aaa.com, but can't match with ccc.bbb.aaa.com
        <span class="cov8" title="1">if matchedPrefix, value, found := ht[treeMatchWildcard].LongestPrefix(key); found </span><span class="cov8" title="1">{

                // get remaining(unmatched) part of a hostname without prefix
                // For example:
                //                 wildcard host *.bar.foo.com, key in tree would be MOC.OOF.RAB.
                //                 to host baz.bar.foo.com, key for matching would be MOC.OOF.RAB.ZAB
                //                 so, in this case, remainingPart = ZAB
                remainingPart := strings.TrimPrefix(key, matchedPrefix)

                // the remaining part should not contain "."
                // if the remaining part contain ".", it means '*' matches multiple labels in hostname, which is not allowed
                if strings.Contains(remainingPart, ".") </span><span class="cov8" title="1">{
                        // not matched, try again to match empty string "", which match any hostname
                        if value, found := ht[treeMatchWildcard].Get(""); found </span><span class="cov8" title="1">{
                                // matched with ""
                                return value.(pathTrees), true
                        }</span>
                } else<span class="cov8" title="1"> {
                        // matched with wildcard host
                        return value.(pathTrees), true
                }</span>
        }

        <span class="cov8" title="1">return pathTrees{}, false</span>
}

// insert adds a new node in pathTree
// key : path, value: clusterName
func (pt *pathTrees) insert(path, cluster string) error <span class="cov8" title="1">{
        var treeType int
        var key string

        if len(path) == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("empth path is not allowed")
        }</span>

        <span class="cov8" title="1">if path[len(path)-1] == '*' </span><span class="cov8" title="1">{
                // wildcard path, remove trailing *
                key = path[:len(path)-1]

                // append slash if no trailing one
                // /foo, /foo/ or /foo/bar can match with /foo*, but /foobar can not
                if len(key) &gt; 0 &amp;&amp; key[len(key)-1] != '/' </span><span class="cov8" title="1">{
                        key = key + "/"
                }</span>
                <span class="cov8" title="1">treeType = treeMatchWildcard</span>
        } else<span class="cov8" title="1"> {
                key = path
                treeType = treeMatchExact
        }</span>

        <span class="cov8" title="1">if old, updated := pt[treeType].Insert(key, cluster); updated </span><span class="cov8" title="1">{
                // if key exist, return error
                return fmt.Errorf("path[%s] is duplicated in same host, existing cluster: %s", path, old)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// get returns node's value (cluster name) referenced by a path
func (pt *pathTrees) get(path string) (string, bool) <span class="cov8" title="1">{
        // exact match firstly
        if value, found := pt[treeMatchExact].Get(path); found </span><span class="cov8" title="1">{
                return value.(string), true
        }</span>

        // append trailing slash
        <span class="cov8" title="1">if len(path) &gt; 0 &amp;&amp; path[len(path)-1] != '/' </span><span class="cov8" title="1">{
                path = path + "/"
        }</span>

        // wildcard match
        <span class="cov8" title="1">if _, value, found := pt[treeMatchWildcard].LongestPrefix(path); found </span><span class="cov8" title="1">{
                return value.(string), true
        }</span>

        <span class="cov8" title="1">return "", false</span>
}

// Get returns cluster name by host and path
func (r *BasicRouteRuleTree) Get(host, path string) (string, bool) <span class="cov8" title="1">{
        // match host to get pathTree
        pathTree, found := r.hosts.get(host)
        if !found </span><span class="cov8" title="1">{
                return "", false
        }</span>

        // match path
        <span class="cov8" title="1">return pathTree.get(path)</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// load route table from json file

package route_rule_conf

import (
        "errors"
        "fmt"
        "os"
        "strings"
)

import (
        "github.com/bfenetworks/bfe/bfe_basic/condition"
        "github.com/bfenetworks/bfe/bfe_util/json"
)

const (
        AdvancedMode = "ADVANCED_MODE"
)

// BasicRouteRule is for host+path routing
// [host, path] -&gt; cluster
type BasicRouteRule struct {
        Hostname    []string
        Path        []string
        ClusterName string
}

// AdvancedRouteRule is composed by a condition and cluster to serve
type AdvancedRouteRule struct {
        Cond        condition.Condition
        ClusterName string
}

type BasicRouteRuleFile struct {
        Hostname    []string
        Path        []string
        ClusterName *string
}

type AdvancedRouteRuleFile struct {
        Cond        *string
        ClusterName *string
}

type BasicRouteRules []BasicRouteRule
type AdvancedRouteRules []AdvancedRouteRule

type BasicRouteRuleFiles []BasicRouteRuleFile
type AdvancedRouteRuleFiles []AdvancedRouteRuleFile

type ProductBasicRouteRule map[string]BasicRouteRules
type ProductBasicRouteTree map[string]*BasicRouteRuleTree
type ProductAdvancedRouteRule map[string]AdvancedRouteRules

type ProductAdvancedRouteRuleFile map[string]AdvancedRouteRuleFiles
type ProductBasicRouteRuleFile map[string]BasicRouteRuleFiles

type RouteTableFile struct {
        Version *string // version of the config

        // product =&gt; rules (basic rule)
        BasicRule *ProductBasicRouteRuleFile

        // product =&gt; rules (advanced rule)
        ProductRule *ProductAdvancedRouteRuleFile
}

type RouteTableConf struct {
        Version         string // version of the config
        BasicRuleMap    ProductBasicRouteRule
        BasicRuleTree   ProductBasicRouteTree
        AdvancedRuleMap ProductAdvancedRouteRule
}

func Convert(fileConf *RouteTableFile) (*RouteTableConf, error) <span class="cov8" title="1">{
        if fileConf.Version == nil </span><span class="cov0" title="0">{
                return nil, errors.New("no Version")
        }</span>

        <span class="cov8" title="1">if fileConf.BasicRule == nil &amp;&amp; fileConf.ProductRule == nil </span><span class="cov0" title="0">{
                return nil, errors.New("no product rule")
        }</span>

        // convert basic rule
        <span class="cov8" title="1">productBasicRules, productRuleTree, err := convertBasicRule(fileConf.BasicRule)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // convert advanced rule
        <span class="cov8" title="1">productAdvancedRules, err := convertAdvancedRule(fileConf.ProductRule)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">conf := &amp;RouteTableConf{
                BasicRuleMap:    productBasicRules,
                BasicRuleTree:   productRuleTree,
                AdvancedRuleMap: productAdvancedRules,
        }

        conf.Version = *fileConf.Version

        return conf, nil</span>
}

func convertAdvancedRule(ProductRule *ProductAdvancedRouteRuleFile) (ProductAdvancedRouteRule, error) <span class="cov8" title="1">{
        productRules := make(ProductAdvancedRouteRule)
        if ProductRule == nil </span><span class="cov8" title="1">{
                return productRules, nil
        }</span>

        // convert advanced rule
        <span class="cov8" title="1">for product, ruleFiles := range *ProductRule </span><span class="cov8" title="1">{
                rules := make(AdvancedRouteRules, len(ruleFiles))
                for i, ruleFile := range ruleFiles </span><span class="cov8" title="1">{
                        if ruleFile.ClusterName == nil </span><span class="cov0" title="0">{
                                return nil, errors.New("no cluster name")
                        }</span>

                        <span class="cov8" title="1">if ruleFile.Cond == nil </span><span class="cov0" title="0">{
                                return nil, errors.New("no cond")
                        }</span>

                        <span class="cov8" title="1">rules[i].ClusterName = *ruleFile.ClusterName
                        cond, err := condition.Build(*ruleFile.Cond)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("error build [%s] [%s]", *ruleFile.Cond, err)
                        }</span>
                        <span class="cov8" title="1">rules[i].Cond = cond</span>
                }

                <span class="cov8" title="1">productRules[product] = rules</span>
        }
        <span class="cov8" title="1">return productRules, nil</span>
}

func convertBasicRule(ProductRule *ProductBasicRouteRuleFile) (ProductBasicRouteRule, ProductBasicRouteTree, error) <span class="cov8" title="1">{
        productRuleMap := make(ProductBasicRouteRule)
        productRuleTree := make(ProductBasicRouteTree)

        if ProductRule == nil </span><span class="cov8" title="1">{
                return productRuleMap, productRuleTree, nil
        }</span>

        <span class="cov8" title="1">for product, ruleFiles := range *ProductRule </span><span class="cov8" title="1">{
                ruleTrees := NewBasicRouteRuleTree()
                ruleList := make(BasicRouteRules, len(ruleFiles))

                for i, ruleFile := range ruleFiles </span><span class="cov8" title="1">{

                        if ruleFile.ClusterName == nil </span><span class="cov0" title="0">{
                                return nil, nil, fmt.Errorf("no cluster name in basic route rule for (%s, %d)", product, i)
                        }</span>

                        <span class="cov8" title="1">if len(ruleFile.Hostname) == 0 &amp;&amp; len(ruleFile.Path) == 0 </span><span class="cov8" title="1">{
                                return nil, nil, fmt.Errorf("no hostname or path in basic route rule for (%s, %d)", product, i)
                        }</span>

                        <span class="cov8" title="1">for _, host := range ruleFile.Hostname </span><span class="cov8" title="1">{
                                if err := checkHostInBasicRule(host); err != nil </span><span class="cov8" title="1">{
                                        return nil, nil, fmt.Errorf("host[%s] is invalid for (%s, %d), err: %s ", host, product, i, err.Error())
                                }</span>
                        }

                        <span class="cov8" title="1">for _, path := range ruleFile.Path </span><span class="cov8" title="1">{
                                if err := checkPathInBasicRule(path); err != nil </span><span class="cov8" title="1">{
                                        return nil, nil, fmt.Errorf("path[%s] is invalid (%s, %d), err: %s ", path, product, i, err.Error())
                                }</span>
                        }

                        <span class="cov8" title="1">ruleList[i].Hostname = ruleFile.Hostname
                        ruleList[i].Path = ruleFile.Path
                        ruleList[i].ClusterName = *ruleFile.ClusterName

                        if err := ruleTrees.Insert(&amp;ruleFile); err != nil </span><span class="cov0" title="0">{
                                return nil, nil, err
                        }</span>
                }
                <span class="cov8" title="1">productRuleMap[product] = ruleList
                productRuleTree[product] = ruleTrees</span>
        }

        <span class="cov8" title="1">return productRuleMap, productRuleTree, nil</span>
}

// checkHostInBasicRule verify host's wildcard pattern
// only one * is allowed, eg: *.foo.com
func checkHostInBasicRule(host string) error <span class="cov8" title="1">{
        if host == "" </span><span class="cov0" title="0">{
                return errors.New("hostname is nil or empty")
        }</span>

        <span class="cov8" title="1">if strings.Count(host, "*") &gt; 1 </span><span class="cov8" title="1">{
                return errors.New("only one * is allowed in a hostname")
        }</span>

        <span class="cov8" title="1">if strings.Count(host, "*") == 1 </span><span class="cov8" title="1">{
                if host != "*" &amp;&amp; !strings.HasPrefix(host, "*.") </span><span class="cov8" title="1">{
                        return errors.New("format error in wildcard host")
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// checkPathInBasicRule verify path's wildcard pattern
// only one * at end of path is allowed
func checkPathInBasicRule(path string) error <span class="cov8" title="1">{
        if path == "" </span><span class="cov0" title="0">{
                return errors.New("path is nil or empty")
        }</span>
        <span class="cov8" title="1">if strings.Count(path, "*") &gt; 1 </span><span class="cov8" title="1">{
                return errors.New("only one * is allowed in path")
        }</span>

        <span class="cov8" title="1">if strings.Count(path, "*") == 1 &amp;&amp; path[len(path)-1] != '*' </span><span class="cov0" title="0">{
                return errors.New("* must appear as last character of path")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (conf *RouteTableConf) LoadAndCheck(filename string) (string, error) <span class="cov8" title="1">{
        var fileConf RouteTableFile

        // open file
        file, err := os.Open(filename)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        // decode the file
        decoder := json.NewDecoder(file)
        if err := decoder.Decode(&amp;fileConf); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">pConf, err := Convert(&amp;fileConf)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">*conf = *pConf

        return conf.Version, nil</span>
}

// RouteConfLoad loads config of route table from file.
func RouteConfLoad(filename string) (*RouteTableConf, error) <span class="cov8" title="1">{
        var conf RouteTableConf
        if _, err := conf.LoadAndCheck(filename); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;conf, nil</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// load host table from json file

package vip_rule_conf

import (
        "errors"
        "fmt"
        "net"
        "os"
)

import (
        "github.com/bfenetworks/bfe/bfe_util/json"
)

type VipList []string // list of vips

type Product2Vip map[string]VipList // product =&gt; vip list

type Vip2Product map[string]string // vip =&gt; product

type VipTableConf struct {
        Version string      // version of the config
        Vips    Product2Vip // product =&gt; vip list
}

type VipConf struct {
        Version string      // version of the config
        VipMap  Vip2Product // vip =&gt; product
}

func (conf *VipTableConf) LoadAndCheck(filename string) (string, error) <span class="cov8" title="1">{
        // open the file
        file, err := os.Open(filename)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        // decode the file
        decoder := json.NewDecoder(file)
        if err := decoder.Decode(conf); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // check config
        <span class="cov8" title="1">if err := VipTableConfCheck(conf); err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">return conf.Version, nil</span>
}

func VipTableConfCheck(conf *VipTableConf) error <span class="cov8" title="1">{
        if conf.Version == "" </span><span class="cov0" title="0">{
                return errors.New("no Version")
        }</span>

        // check config for each product
        <span class="cov8" title="1">for product, vipList := range conf.Vips </span><span class="cov8" title="1">{
                var formattedVipList VipList
                for _, vip := range vipList </span><span class="cov8" title="1">{
                        ip := net.ParseIP(vip)
                        if ip == nil </span><span class="cov8" title="1">{
                                return fmt.Errorf("invalid vip %s for %s", vip, product)
                        }</span>

                        <span class="cov8" title="1">formattedVipList = append(formattedVipList, ip.String())</span>
                }
                <span class="cov8" title="1">conf.Vips[product] = formattedVipList</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// VipRuleConfLoad loads config of vip table from file.
func VipRuleConfLoad(filename string) (VipConf, error) <span class="cov8" title="1">{
        var vipConf VipConf

        // load vip config
        var config VipTableConf
        if _, err := config.LoadAndCheck(filename); err != nil </span><span class="cov8" title="1">{
                return vipConf, err
        }</span>

        // convert from VipTableConf
        <span class="cov8" title="1">vipConf.Version = config.Version
        vipConf.VipMap = make(Vip2Product)
        for product, viplist := range config.Vips </span><span class="cov8" title="1">{
                for _, vip := range viplist </span><span class="cov8" title="1">{
                        vipConf.VipMap[vip] = product
                }</span>
        }

        <span class="cov8" title="1">return vipConf, nil</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package session_ticket_key_conf

import (
        "encoding/hex"
        "fmt"
        "io/ioutil"
        "os"
        "time"
)

import (
        "github.com/baidu/go-lib/log"
        "github.com/bfenetworks/bfe/bfe_util/json"
)

const (
        RawSessionTicketKeySize = 48 // bytes
)

// SessionTicketKeyConf is session ticket key config.
type SessionTicketKeyConf struct {
        Version          string // version of config
        SessionTicketKey string // session ticket key (hex encode)
}

// SessionTicketKeyConfCheck check integrity of config.
func SessionTicketKeyConfCheck(conf SessionTicketKeyConf) error <span class="cov8" title="1">{
        if len(conf.Version) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("no Version")
        }</span>

        <span class="cov8" title="1">key, err := hex.DecodeString(conf.SessionTicketKey)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("session ticket key %s(%s)", err.Error(), conf.SessionTicketKey)
        }</span>
        <span class="cov8" title="1">if len(key) != RawSessionTicketKeySize </span><span class="cov0" title="0">{
                return fmt.Errorf("session ticket key should be 96 bytes hex string (%s)", conf.SessionTicketKey)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// rawSessionTicketKeyLoad loads session ticket key from file in raw format (48 bytes binary file).
func rawSessionTicketKeyLoad(filename string) (SessionTicketKeyConf, error) <span class="cov0" title="0">{
        var config SessionTicketKeyConf

        data, err := ioutil.ReadFile(filename)
        if err != nil </span><span class="cov0" title="0">{
                return config, err
        }</span>

        <span class="cov0" title="0">if len(data) != RawSessionTicketKeySize </span><span class="cov0" title="0">{
                return config, fmt.Errorf("invalid session ticket key(%d)", len(data))
        }</span>

        <span class="cov0" title="0">config.Version = time.Now().String()
        config.SessionTicketKey = fmt.Sprintf("%x", data)
        return config, nil</span>
}

// SessionTicketKeyConfLoad load session ticket key from file.
func SessionTicketKeyConfLoad(filename string) (SessionTicketKeyConf, error) <span class="cov8" title="1">{
        var config SessionTicketKeyConf

        // open the file
        file, err := os.Open(filename)
        if err != nil </span><span class="cov8" title="1">{
                return config, err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        // decode the file
        decoder := json.NewDecoder(file)
        err = decoder.Decode(&amp;config)
        if err != nil </span><span class="cov0" title="0">{
                log.Logger.Info("Load SessionTicketKey json file fail, fallback to raw format(%s)", err)
                if config, err = rawSessionTicketKeyLoad(filename); err != nil </span><span class="cov0" title="0">{
                        return config, err
                }</span>
        }

        // check conf
        <span class="cov8" title="1">err = SessionTicketKeyConfCheck(config)
        if err != nil </span><span class="cov8" title="1">{
                return config, err
        }</span>

        <span class="cov8" title="1">return config, nil</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package tls_rule_conf

import (
        "crypto/x509"
        "crypto/x509/pkix"
        "fmt"
        "io/ioutil"
        "net"
        "net/url"
        "os"
        "path/filepath"
        "strconv"
        "strings"
)

import (
        "github.com/baidu/go-lib/log"
)

import (
        "github.com/bfenetworks/bfe/bfe_config/bfe_conf"
        "github.com/bfenetworks/bfe/bfe_config/bfe_tls_conf/server_cert_conf"
        "github.com/bfenetworks/bfe/bfe_tls"
        "github.com/bfenetworks/bfe/bfe_util/json"
)

// Notes about `NextProtos`:
//  * NextProtos represents an ordered list of application level protocol items
//
//  * protocol item format: "protocol[;level=0;mcs=200;isw=65535;rate=100]"
//    - valid protocol should be h2, spdy/3.1, http/1.1, others are not supported
//
//    - level means protocol negotiation level and should be [0, 2]
//      + level is optional and is PROTO_OPTIONAL by default
//      + if level &gt; PROTO_OPTIONAL, rate should be 100
//      + if level is PROTO_MANDATORY, NextProtos should not contain other items
//
//    - rate means presence rate for that protocol and should be [0,100]
//      + rate is optional and is 100 by default
//      + rate for http/1.1 should always be 100
//
//    - mcs means max concurrent streams per conn and should be &gt; 0
//      + mcs is optional and is 200 by default
//
//    - isw means initial stream window size for server
//          + isw is optional and is 65535 by default
//          + valid isw should be [65535, 262144] for current implemention
//
// Notes about `SniConf`:
//  * SniConf represents an optional list of server names (hostname)
//  * When vip of incoming conn is missing or unknown:
//   - If SniConf is configured, server will select tls rule conf by name (from tls sni extension)
//   - Even through SniConf is not configured, server will try to select cert by name
//
// Notes about`ClientCAName`:
//  * The CA certificate file is &lt;ClientCAName&gt;.crt under ClientCABaseDir configured in bfe.conf

// application level protocols over tls
const (
        HTTP11 = "http/1.1" // https (http/1.1 over tls) protocol
        HTTP2  = "h2"       // http2 protocol
        SPDY31 = "spdy/3.1" // spdy/3.1 protocol
        STREAM = "stream"
)

var validNextProtos = []string{HTTP11, HTTP2, SPDY31, STREAM}

// negotiation level for protocols
const (
        PROTO_OPTIONAL    = 0 // proto is negotiatory, may be disabled if needed
        PROTO_NEGOTISTORY = 1 // proto is negotiatory, must not be disabled
        PROTO_MANDATORY   = 2 // proto is mandatory
)

type TlsRuleConf struct {
        VipConf       []string // list of vips for product
        SniConf       []string // list of hostnames for product (optional)
        CertName      string   // name of certificate
        NextProtos    []string // next protos over TLS
        Grade         string   // tls grade for product
        ClientAuth    bool     // require tls client auth
        ClientCAName  string   // client CA certificate name
        Chacha20      bool     // enable chacha20-poly1305 cipher suites
        DynamicRecord bool     // enable dynamic record size
}

type TlsRuleMap map[string]*TlsRuleConf // product -&gt; pointer to tls rule conf

const (
        ProxyProtocolDisabled  = 0
        ProxyProtocolV1Enabled = 1
        ProxyProtocolV2Enabled = 2
)

type NextProtosParams struct {
        Level int // protocol negotiation level
        Mcs   int // max concurrent stream per conn
        Isw   int // initial stream window for server
        Rate  int // presence rate while level is PROTO_OPTIONAL
        PP    int // proxy protocol to backend, 0: disable, 1: enable v1 pp, 2: enable v2 pp
}

func GetDefaultNextProtosParams() NextProtosParams <span class="cov8" title="1">{
        return NextProtosParams{
                Level: PROTO_OPTIONAL,
                Mcs:   200,
                Isw:   65535,
                Rate:  100,
                PP:    0,
        }
}</span>

type BfeTlsRuleConf struct {
        Version              string // version of config
        Config               TlsRuleMap
        DefaultNextProtos    []string
        DefaultChacha20      bool
        DefaultDynamicRecord bool
}

func TlsRuleConfCheck(conf *TlsRuleConf) error <span class="cov8" title="1">{
        if len(conf.CertName) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("no CertName")
        }</span>

        <span class="cov8" title="1">if err := checkNextProtos(conf.NextProtos); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">conf.Grade = strings.ToUpper(conf.Grade)
        if !checkGrade(conf) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid tls grade: %s, currently only A+,A,B,C supported", conf.Grade)
        }</span>

        <span class="cov8" title="1">if conf.ClientAuth &amp;&amp; len(conf.ClientCAName) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("ClientAuth enabled, but ClientCAName is empty")
        }</span>

        <span class="cov8" title="1">for i, vip := range conf.VipConf </span><span class="cov8" title="1">{
                vaddr := net.ParseIP(vip)
                if vaddr == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid vip (%d) %s", i, vip)
                }</span>
                <span class="cov8" title="1">conf.VipConf[i] = vaddr.String()</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func checkNextProtos(nextProtos []string) error <span class="cov8" title="1">{
        if len(nextProtos) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">allProtos := make(map[string]bool)
        for _, proto := range nextProtos </span><span class="cov8" title="1">{
                if err := CheckValidProto(proto); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid proto (%s) in NextProtos: %s", proto, err)
                }</span>
                <span class="cov8" title="1">if allProtos[proto] </span><span class="cov0" title="0">{
                        return fmt.Errorf("found duplicated proto: %s", nextProtos)
                }</span>
                <span class="cov8" title="1">allProtos[proto] = true</span>
        }

        <span class="cov8" title="1">if checkMandatory(nextProtos) </span><span class="cov8" title="1">{
                if len(nextProtos) != 1 </span><span class="cov0" title="0">{
                        return fmt.Errorf("should contain 1 protos if level=2 (eg. proto mandatory): %s", nextProtos)
                }</span>
        } else<span class="cov8" title="1"> {
                if !checkContainHTTP(nextProtos) </span><span class="cov0" title="0">{
                        return fmt.Errorf("no \"http/1.1\" in nonempty NextProtos")
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func checkGrade(conf *TlsRuleConf) bool <span class="cov8" title="1">{
        if conf.Grade == "" </span><span class="cov8" title="1">{
                // set default grade to C
                conf.Grade = bfe_tls.GradeC
        }</span>

        <span class="cov8" title="1">switch conf.Grade </span>{
        case bfe_tls.GradeAPlus, bfe_tls.GradeA, bfe_tls.GradeB, bfe_tls.GradeC:<span class="cov8" title="1">
                return true</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

func CheckValidProto(protoConf string) error <span class="cov8" title="1">{
        // parse proto and params
        proto, params, err := ParseNextProto(protoConf)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("proto format invalid: %s", err)
        }</span>

        // check negotiation level
        <span class="cov8" title="1">if params.Level &lt; PROTO_OPTIONAL || params.Level &gt; PROTO_MANDATORY </span><span class="cov0" title="0">{
                return fmt.Errorf("proto level should be [0, 2]")
        }</span>

        // check max concurrent requests
        <span class="cov8" title="1">if params.Mcs &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("proto mcs should &gt; 0")
        }</span>

        // check initial stream window
        <span class="cov8" title="1">if params.Isw &lt; 65535 || params.Isw &gt; 262144 </span><span class="cov0" title="0">{
                return fmt.Errorf("proto isw should be [65535, 262144]")
        }</span>

        // check presence rate
        <span class="cov8" title="1">if params.Rate &lt; 0 || params.Rate &gt; 100 </span><span class="cov0" title="0">{
                return fmt.Errorf("proto rate should be [0, 100]")
        }</span>
        <span class="cov8" title="1">if params.Level &gt; PROTO_OPTIONAL &amp;&amp; params.Rate != 100 </span><span class="cov0" title="0">{
                return fmt.Errorf("proto rate should be 100 if level &gt; 0")
        }</span>
        <span class="cov8" title="1">if proto == HTTP11 &amp;&amp; params.Rate != 100 </span><span class="cov0" title="0">{
                return fmt.Errorf("proto rate for http/1.1 should be 100")
        }</span>

        // check proxy protocol
        <span class="cov8" title="1">if params.PP &lt; ProxyProtocolDisabled || params.PP &gt; ProxyProtocolV2Enabled </span><span class="cov0" title="0">{
                return fmt.Errorf("proto pp should be [%d, %d]", ProxyProtocolDisabled, ProxyProtocolV2Enabled)
        }</span>
        <span class="cov8" title="1">if params.PP != ProxyProtocolDisabled &amp;&amp; proto != STREAM </span><span class="cov0" title="0">{
                return fmt.Errorf("param pp is only available for %s proto", STREAM)
        }</span>

        // check next proto
        <span class="cov8" title="1">for _, validProto := range validNextProtos </span><span class="cov8" title="1">{
                if proto == validProto </span><span class="cov8" title="1">{
                        return nil
                }</span>
        }
        <span class="cov0" title="0">return fmt.Errorf("proto not valid or not support")</span>
}

func ParseNextProto(protoConf string) (proto string, params NextProtosParams, err error) <span class="cov8" title="1">{
        // Note: replace ';' separator by '&amp;'
        // Go 1.17 refuse ';' in query string (see https://github.com/golang/go/issues/25192)
        // For forward compatibility, proto accept both "a=b;c=d" and "a=b&amp;c=d" now.
        protoConf = strings.ReplaceAll(protoConf, ";", "&amp;")

        items := strings.SplitN(protoConf, "&amp;", 2)
        if len(items) == 1 </span><span class="cov8" title="1">{ // eg: h2
                proto = protoConf
                params = GetDefaultNextProtosParams()
        }</span> else<span class="cov8" title="1"> if len(items) == 2 </span><span class="cov8" title="1">{ // eg: h2;level=0;mcs=200;rate=100
                proto = items[0]
                params, err = parseProtoParams(items[1])
        }</span> else<span class="cov0" title="0"> {
                err = fmt.Errorf("empty next proto")
        }</span>
        <span class="cov8" title="1">return</span>
}

func parseProtoParams(protoConf string) (params NextProtosParams, err error) <span class="cov8" title="1">{
        params = GetDefaultNextProtosParams()

        conf, err := url.ParseQuery(protoConf)
        if err != nil </span><span class="cov0" title="0">{
                return params, fmt.Errorf("invalid proto params: %s", protoConf)
        }</span>

        <span class="cov8" title="1">for key, vals := range conf </span><span class="cov8" title="1">{
                if len(vals) != 1 </span><span class="cov0" title="0">{
                        return params, fmt.Errorf("invalid proto params: %s", protoConf)
                }</span>

                <span class="cov8" title="1">switch key </span>{
                case "level":<span class="cov8" title="1">
                        if params.Level, err = strconv.Atoi(vals[0]); err != nil </span><span class="cov0" title="0">{
                                return params, fmt.Errorf("invalid level: %s", vals[0])
                        }</span>
                case "mcs":<span class="cov0" title="0">
                        if params.Mcs, err = strconv.Atoi(vals[0]); err != nil </span><span class="cov0" title="0">{
                                return params, fmt.Errorf("invalid mcs: %s", vals[0])
                        }</span>
                case "isw":<span class="cov0" title="0">
                        if params.Isw, err = strconv.Atoi(vals[0]); err != nil </span><span class="cov0" title="0">{
                                return params, fmt.Errorf("invalid isw: %s", vals[0])
                        }</span>
                case "rate":<span class="cov8" title="1">
                        if params.Rate, err = strconv.Atoi(vals[0]); err != nil </span><span class="cov0" title="0">{
                                return params, fmt.Errorf("invalid rate: %s", vals[0])
                        }</span>
                case "pp":<span class="cov8" title="1">
                        if params.PP, err = strconv.Atoi(vals[0]); err != nil </span><span class="cov0" title="0">{
                                return params, fmt.Errorf("invalid pp: %s", vals[0])
                        }</span>
                default:<span class="cov0" title="0">
                        return params, fmt.Errorf("unknown params: %s", key)</span>
                }
        }
        <span class="cov8" title="1">return params, nil</span>
}

func checkMandatory(nextProtos []string) bool <span class="cov8" title="1">{
        for _, protoConf := range nextProtos </span><span class="cov8" title="1">{
                _, params, _ := ParseNextProto(protoConf)
                if params.Level == PROTO_MANDATORY </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func checkContainHTTP(nextProtos []string) bool <span class="cov8" title="1">{
        for _, protoConf := range nextProtos </span><span class="cov8" title="1">{
                nextProto, _, _ := ParseNextProto(protoConf)
                if nextProto == HTTP11 </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func checkVip(ruleMap TlsRuleMap) error <span class="cov8" title="1">{
        allVip := make(map[string]bool)
        for product, rule := range ruleMap </span><span class="cov8" title="1">{
                for i, vip := range rule.VipConf </span><span class="cov8" title="1">{
                        if allVip[vip] </span><span class="cov0" title="0">{
                                return fmt.Errorf("found duplicated vip (%s:%d) %s", product, i, vip)
                        }</span>
                        <span class="cov8" title="1">allVip[vip] = true</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

func checkSniConf(ruleMap TlsRuleMap) error <span class="cov8" title="1">{
        allName := make(map[string]bool)
        for product, rule := range ruleMap </span><span class="cov8" title="1">{
                for i, name := range rule.SniConf </span><span class="cov0" title="0">{
                        if allName[name] </span><span class="cov0" title="0">{
                                return fmt.Errorf("found duplicated name (%s:%d) %s", product, i, name)
                        }</span>
                        <span class="cov0" title="0">allName[name] = true</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

func BfeTlsRuleConfCheck(conf *BfeTlsRuleConf) error <span class="cov8" title="1">{
        if len(conf.Version) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("no Version")
        }</span>

        <span class="cov8" title="1">if conf.Config == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("no Config")
        }</span>

        <span class="cov8" title="1">for product, rule := range conf.Config </span><span class="cov8" title="1">{
                if err := TlsRuleConfCheck(rule); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("BfeTlsRuleConfCheck(): %s wrong rule %s", product, err)
                }</span>
        }

        <span class="cov8" title="1">if err := checkVip(conf.Config); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if err := checkSniConf(conf.Config); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if err := checkNextProtos(conf.DefaultNextProtos); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// CheckTlsConf check integrity of tls rule conf and cert conf.
func CheckTlsConf(certConf map[string]*bfe_tls.Certificate, ruleMap TlsRuleMap) error <span class="cov0" title="0">{
        for _, ruleConf := range ruleMap </span><span class="cov0" title="0">{
                // check whether cert specified in ruleConf exists
                cert, ok := certConf[ruleConf.CertName]
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("certificate %s not exist", ruleConf.CertName)
                }</span>

                // check whether name specified in ruleConf matches cert
                <span class="cov0" title="0">certNames := server_cert_conf.GetNamesForCert(cert)
                for _, name := range ruleConf.SniConf </span><span class="cov0" title="0">{
                        if !MatchCertNames(certNames, name) </span><span class="cov0" title="0">{
                                return fmt.Errorf("%s not included in certificate %s", name, ruleConf.CertName)
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// MatchCertNames check whether host matches names in cert.
func MatchCertNames(certNames []string, host string) bool <span class="cov0" title="0">{
        for _, cname := range certNames </span><span class="cov0" title="0">{
                if MatchHostnames(cname, host) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// MatchHostnames check whether host matches pattern.
func MatchHostnames(pattern, host string) bool <span class="cov0" title="0">{
        if len(pattern) == 0 || len(host) == 0 </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">patternParts := strings.Split(pattern, ".")
        hostParts := strings.Split(host, ".")

        if len(patternParts) != len(hostParts) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">for i, patternPart := range patternParts </span><span class="cov0" title="0">{
                if patternPart == "*" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if patternPart != hostParts[i] </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return true</span>
}

func GetClientCACertificate(clientCADir string, clientCAName string) (*x509.CertPool, error) <span class="cov8" title="1">{
        clientCAFile := filepath.Join(clientCADir, clientCAName+".crt")

        // load and init client ca certificates
        return bfe_conf.LoadClientCAFile(clientCAFile)
}</span>

// ClientCALoad load client CA certificates.
func ClientCALoad(tlsRuleMap TlsRuleMap, clientCADir string) (map[string]*x509.CertPool, error) <span class="cov8" title="1">{
        clientCAMap := make(map[string]*x509.CertPool)
        for productName, rule := range tlsRuleMap </span><span class="cov8" title="1">{
                if !rule.ClientAuth </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">_, ok := clientCAMap[rule.ClientCAName]
                if !ok </span><span class="cov8" title="1">{
                        roots, err := GetClientCACertificate(clientCADir, rule.ClientCAName)
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, fmt.Errorf("product[%s] GetClientCACertificate() err: %v", productName, err)
                        }</span>

                        <span class="cov8" title="1">clientCAMap[rule.ClientCAName] = roots</span>
                }
        }

        <span class="cov8" title="1">return clientCAMap, nil</span>
}

func getCientCRL(clientCRLDir, clientCAName string) ([]*pkix.CertificateList, error) <span class="cov0" title="0">{
        clientCRLSubDir := filepath.Join(clientCRLDir, clientCAName)
        crlFiles, err := ioutil.ReadDir(clientCRLSubDir)
        if err != nil </span><span class="cov0" title="0">{
                log.Logger.Debug("ioutil.ReadDir %s failed: %v", clientCRLSubDir, err)
                return nil, nil
        }</span>

        <span class="cov0" title="0">var crls []*pkix.CertificateList
        for _, crlFile := range crlFiles </span><span class="cov0" title="0">{
                if crlFile.IsDir() </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">if !strings.HasSuffix(crlFile.Name(), ".crl") </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">crlFilePath := filepath.Join(clientCRLSubDir, crlFile.Name())
                fileContent, err := ioutil.ReadFile(crlFilePath)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("read crl %s failed, %v", crlFilePath, err)
                }</span>

                <span class="cov0" title="0">crl, err := x509.ParseCRL(fileContent)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("parse crl %s failed, %v", crlFilePath, err)
                }</span>

                <span class="cov0" title="0">log.Logger.Debug("read %s success", crlFile.Name())
                crls = append(crls, crl)</span>
        }
        <span class="cov0" title="0">return crls, nil</span>
}

func ClientCRLLoad(clientCAMap map[string]*x509.CertPool, clientCRLDir string) (map[string]*bfe_tls.CRLPool, error) <span class="cov0" title="0">{
        f, err := os.Stat(clientCRLDir)
        if err != nil || !f.IsDir() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ClientCRLBaseDir %s not exists", clientCRLDir)
        }</span>

        <span class="cov0" title="0">clientCRLPoolMap := make(map[string]*bfe_tls.CRLPool)
        for clientCAName := range clientCAMap </span><span class="cov0" title="0">{
                crls, err := getCientCRL(clientCRLDir, clientCAName)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">if crls == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">crlPool := bfe_tls.NewCRLPool()
                for _, crl := range crls </span><span class="cov0" title="0">{
                        if err := crlPool.AddCRL(crl); err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("client_ca %s read crl: %v", clientCAName, err)
                        }</span>
                }

                <span class="cov0" title="0">clientCRLPoolMap[clientCAName] = crlPool</span>
        }

        <span class="cov0" title="0">return clientCRLPoolMap, nil</span>
}

// TlsRuleConfLoad load config of rule from file.
func TlsRuleConfLoad(filename string) (BfeTlsRuleConf, error) <span class="cov8" title="1">{
        var config BfeTlsRuleConf

        // open the file
        file, err := os.Open(filename)
        if err != nil </span><span class="cov8" title="1">{
                return config, err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        // decode the file
        decoder := json.NewDecoder(file)
        err = decoder.Decode(&amp;config)
        if err != nil </span><span class="cov0" title="0">{
                return config, err
        }</span>

        // check conf
        <span class="cov8" title="1">err = BfeTlsRuleConfCheck(&amp;config)
        if err != nil </span><span class="cov0" title="0">{
                return config, err
        }</span>

        <span class="cov8" title="1">return config, nil</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Copyright 2010 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package bfe_fcgi

import (
        "fmt"
        "net"
        "reflect"
)

type ConnectError struct {
        Addr string
        Err  error
}

func (e ConnectError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("ConnectError: %s, %s", e.Err.Error(), e.Addr)
}</span>

type WriteRequestError struct {
        Err error
}

func (e WriteRequestError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("WriteRequestError: %s", e.Err.Error())
}</span>

func (e WriteRequestError) CheckTargetError(addr net.Addr) bool <span class="cov0" title="0">{
        if err, ok := e.Err.(*net.OpError); ok </span><span class="cov0" title="0">{
                return reflect.DeepEqual(err.Addr, addr)
        }</span>
        <span class="cov0" title="0">return false</span>
}

type ReadRespHeaderError struct {
        Err error
}

func (e ReadRespHeaderError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("ReadRespHeaderError: %s", e.Err.Error())
}</span>
</pre>
		
		<pre class="file" id="file38" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Copyright 2012 Junqing Tan &lt;ivan@mysqlab.net&gt; and The Go Authors
// Use of client source code is governed by a BSD-style
// Part of source code is from Go fcgi package

package bfe_fcgi

import (
        "bytes"
        "encoding/binary"
        "errors"
        "io"
        "io/ioutil"
        "mime/multipart"
        "net"
        "net/http/httputil"
        "net/url"
        "os"
        "path/filepath"
        "strconv"
        "strings"
        "sync"
        "time"
)

import (
        bufio "github.com/bfenetworks/bfe/bfe_bufio"
        http "github.com/bfenetworks/bfe/bfe_http"
        "github.com/bfenetworks/bfe/bfe_net/textproto"
)

// FCGIListenSockFileNo describes listen socket file number.
const FCGIListenSockFileNo uint8 = 0

// FCGIHeaderLen describes header length.
const FCGIHeaderLen uint8 = 8

// Version1 describes the version.
const Version1 uint8 = 1

// FCGINullRequestID describes the null request ID.
const FCGINullRequestID uint8 = 0

// FCGIKeepConn describes keep connection mode.
const FCGIKeepConn uint8 = 1

const doubleCRLF = "\r\n\r\n"

const (
        // FCGIBeginRequest is the begin request flag.
        FCGIBeginRequest uint8 = iota + 1

        // FCGIAbortRequest is the abort request flag.
        FCGIAbortRequest

        // FCGIEndRequest is the end request flag.
        FCGIEndRequest

        // FCGIParams is the parameters flag.
        FCGIParams

        // FCGIStdin is the standard input flag.
        FCGIStdin

        // FCGIStdout is the standard output flag.
        FCGIStdout

        // FCGIStderr is the standard error flag.
        FCGIStderr

        // FCGIData is the data flag.
        FCGIData

        // FCGIGetValues is the get values flag.
        FCGIGetValues

        // FCGIGetValuesResult is the get values result flag.
        FCGIGetValuesResult

        // FCGIUnknownType is the unknown type flag.
        FCGIUnknownType

        // FCGIMaxType is the maximum type flag.
        FCGIMaxType = FCGIUnknownType
)

const (
        // FCGIResponder is the responder flag.
        FCGIResponder uint8 = iota + 1

        // FCGIAuthorizer is the authorizer flag.
        FCGIAuthorizer

        // FCGIFilter is the filter flag.
        FCGIFilter
)

const (
        // FCGIRequestComplete is the completed request flag.
        FCGIRequestComplete uint8 = iota

        // FCGICantMpxConn is the multiplexed connections flag.
        FCGICantMpxConn

        // FCGIOverLoaded is the overloaded flag.
        FCGIOverLoaded

        // FCGIUnknownRole is the unknown role flag.
        FCGIUnknownRole
)

const (
        // FCGIMaxConns is the maximum connections flag.
        FCGIMaxConns string = "MAX_CONNS"

        // FCGIMaxReqs is the maximum requests flag.
        FCGIMaxReqs string = "MAX_REQS"

        // FCGIMpxsConns is the multiplex connections flag.
        FCGIMpxsConns string = "MPXS_CONNS"
)

const (
        maxWrite = 65500 // 65530 may work, but for compatibility
        maxPad   = 255
)

type header struct {
        Version       uint8
        Type          uint8
        Id            uint16
        ContentLength uint16
        PaddingLength uint8
        Reserved      uint8
}

// for padding so we don't have to allocate all the time
// not synchronized because we don't care what the contents are
var pad [maxPad]byte

func (h *header) init(recType uint8, reqId uint16, contentLength int) <span class="cov8" title="1">{
        h.Version = 1
        h.Type = recType
        h.Id = reqId
        h.ContentLength = uint16(contentLength)
        h.PaddingLength = uint8(-contentLength &amp; 7)
}</span>

type record struct {
        h    header
        rbuf []byte
}

func (rec *record) read(r io.Reader) (buf []byte, err error) <span class="cov8" title="1">{
        if err = binary.Read(r, binary.BigEndian, &amp;rec.h); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if rec.h.Version != 1 </span><span class="cov0" title="0">{
                err = errors.New("fcgi: invalid header version")
                return
        }</span>
        <span class="cov8" title="1">if rec.h.Type == FCGIEndRequest </span><span class="cov0" title="0">{
                err = io.EOF
                return
        }</span>
        <span class="cov8" title="1">n := int(rec.h.ContentLength) + int(rec.h.PaddingLength)
        if len(rec.rbuf) &lt; n </span><span class="cov8" title="1">{
                rec.rbuf = make([]byte, n)
        }</span>
        <span class="cov8" title="1">if _, err = io.ReadFull(r, rec.rbuf[:n]); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">buf = rec.rbuf[:int(rec.h.ContentLength)]

        return</span>
}

// FCGIClient implements a FastCGI client, which is a standard for
// interfacing external applications with Web servers.
type FCGIClient struct {
        mutex     sync.Mutex
        rwc       io.ReadWriteCloser
        h         header
        buf       bytes.Buffer
        keepAlive bool
        reqId     uint16
}

// Dial connects to the fcgi responder at the specified network address.
// See func net.Dial for a description of the network and address parameters.
func Dial(network, address string) (fcgi *FCGIClient, err error) <span class="cov8" title="1">{
        var conn net.Conn

        conn, err = net.Dial(network, address)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">fcgi = &amp;FCGIClient{
                rwc:       conn,
                keepAlive: false,
                reqId:     1,
        }

        return</span>
}

// Close closes fcgi connection
func (client *FCGIClient) Close() <span class="cov8" title="1">{
        client.rwc.Close()
}</span>

func (client *FCGIClient) writeRecord(recType uint8, content []byte) (err error) <span class="cov8" title="1">{
        client.mutex.Lock()
        defer client.mutex.Unlock()
        client.buf.Reset()
        client.h.init(recType, client.reqId, len(content))
        if err := binary.Write(&amp;client.buf, binary.BigEndian, client.h); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if _, err := client.buf.Write(content); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if _, err := client.buf.Write(pad[:client.h.PaddingLength]); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">_, err = client.rwc.Write(client.buf.Bytes())
        return err</span>
}

func (client *FCGIClient) writeBeginRequest(role uint16, flags uint8) error <span class="cov8" title="1">{
        b := [8]byte{byte(role &gt;&gt; 8), byte(role), flags}
        return client.writeRecord(FCGIBeginRequest, b[:])
}</span>

func (client *FCGIClient) writeEndRequest(appStatus int, protocolStatus uint8) error <span class="cov0" title="0">{
        b := make([]byte, 8)
        binary.BigEndian.PutUint32(b, uint32(appStatus))
        b[4] = protocolStatus
        return client.writeRecord(FCGIEndRequest, b)
}</span>

func (client *FCGIClient) writePairs(recType uint8, pairs map[string]string) error <span class="cov8" title="1">{
        w := newWriter(client, recType)
        b := make([]byte, 8)
        nn := 0
        for k, v := range pairs </span><span class="cov8" title="1">{
                m := 8 + len(k) + len(v)
                if m &gt; maxWrite </span><span class="cov0" title="0">{
                        // param data size exceed 65535 bytes"
                        vl := maxWrite - 8 - len(k)
                        v = v[:vl]
                }</span>
                <span class="cov8" title="1">n := encodeSize(b, uint32(len(k)))
                n += encodeSize(b[n:], uint32(len(v)))
                m = n + len(k) + len(v)
                if (nn + m) &gt; maxWrite </span><span class="cov0" title="0">{
                        w.Flush()
                        nn = 0
                }</span>
                <span class="cov8" title="1">nn += m
                if _, err := w.Write(b[:n]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if _, err := w.WriteString(k); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if _, err := w.WriteString(v); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">w.Close()
        return nil</span>
}

func readSize(s []byte) (uint32, int) <span class="cov0" title="0">{
        if len(s) == 0 </span><span class="cov0" title="0">{
                return 0, 0
        }</span>
        <span class="cov0" title="0">size, n := uint32(s[0]), 1
        if size&amp;(1&lt;&lt;7) != 0 </span><span class="cov0" title="0">{
                if len(s) &lt; 4 </span><span class="cov0" title="0">{
                        return 0, 0
                }</span>
                <span class="cov0" title="0">n = 4
                size = binary.BigEndian.Uint32(s)
                size &amp;^= 1 &lt;&lt; 31</span>
        }
        <span class="cov0" title="0">return size, n</span>
}

func readString(s []byte, size uint32) string <span class="cov0" title="0">{
        if size &gt; uint32(len(s)) </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return string(s[:size])</span>
}

func encodeSize(b []byte, size uint32) int <span class="cov8" title="1">{
        if size &gt; 127 </span><span class="cov0" title="0">{
                size |= 1 &lt;&lt; 31
                binary.BigEndian.PutUint32(b, size)
                return 4
        }</span>
        <span class="cov8" title="1">b[0] = byte(size)
        return 1</span>
}

// bufWriter encapsulates bufio.Writer but also closes the underlying stream when
// Closed.
type bufWriter struct {
        closer io.Closer
        *bufio.Writer
}

func (w *bufWriter) Close() error <span class="cov8" title="1">{
        if err := w.Writer.Flush(); err != nil </span><span class="cov0" title="0">{
                w.closer.Close()
                return err
        }</span>
        <span class="cov8" title="1">return w.closer.Close()</span>
}

func newWriter(c *FCGIClient, recType uint8) *bufWriter <span class="cov8" title="1">{
        s := &amp;streamWriter{c: c, recType: recType}
        w := bufio.NewWriterSize(s, maxWrite)
        return &amp;bufWriter{s, w}
}</span>

// streamWriter abstracts out the separation of a stream into discrete records.
// It only writes maxWrite bytes at a time.
type streamWriter struct {
        c       *FCGIClient
        recType uint8
}

func (w *streamWriter) Write(p []byte) (int, error) <span class="cov8" title="1">{
        nn := 0
        for len(p) &gt; 0 </span><span class="cov8" title="1">{
                n := len(p)
                if n &gt; maxWrite </span><span class="cov8" title="1">{
                        n = maxWrite
                }</span>
                <span class="cov8" title="1">if err := w.c.writeRecord(w.recType, p[:n]); err != nil </span><span class="cov0" title="0">{
                        return nn, err
                }</span>
                <span class="cov8" title="1">nn += n
                p = p[n:]</span>
        }
        <span class="cov8" title="1">return nn, nil</span>
}

func (w *streamWriter) Close() error <span class="cov8" title="1">{
        // send empty record to close the stream
        return w.c.writeRecord(w.recType, nil)
}</span>

type streamReader struct {
        c   *FCGIClient
        buf []byte
}

func (w *streamReader) Read(p []byte) (n int, err error) <span class="cov8" title="1">{
        if len(p) &gt; 0 </span><span class="cov8" title="1">{
                if len(w.buf) == 0 </span><span class="cov8" title="1">{
                        rec := &amp;record{}
                        w.buf, err = rec.read(w.c.rwc)
                        if err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                }

                <span class="cov8" title="1">n = len(p)
                if n &gt; len(w.buf) </span><span class="cov8" title="1">{
                        n = len(w.buf)
                }</span>
                <span class="cov8" title="1">copy(p, w.buf[:n])
                w.buf = w.buf[n:]</span>
        }

        <span class="cov8" title="1">return</span>
}

// Do made the request and returns a io.Reader that translates the data read
// from fcgi responder out of fcgi packet before returning it.
func (client *FCGIClient) Do(p map[string]string, req io.Reader) (r io.Reader, err error) <span class="cov8" title="1">{
        err = client.writeBeginRequest(uint16(FCGIResponder), 0)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">err = client.writePairs(FCGIParams, p)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">body := newWriter(client, FCGIStdin)
        if req != nil </span><span class="cov8" title="1">{
                io.Copy(body, req)
        }</span>
        <span class="cov8" title="1">body.Close()

        r = &amp;streamReader{c: client}
        return</span>
}

// Request returns a HTTP Response with Header and Body
// from fcgi responder
func (client *FCGIClient) Request(p map[string]string, req io.Reader) (resp *http.Response, err error) <span class="cov8" title="1">{
        r, err := client.Do(p, req)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">rb := bufio.NewReader(r)
        tp := textproto.NewReader(rb)
        resp = new(http.Response)

        // Parse the response headers.
        mimeHeader, err := tp.ReadMIMEHeader()
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">resp.Header = http.Header(mimeHeader)

        // Parse the response status
        status := resp.Header.Get("Status")
        if status != "" </span><span class="cov8" title="1">{
                statusParts := strings.SplitN(status, " ", 2)
                resp.StatusCode, err = strconv.Atoi(statusParts[0])
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov8" title="1">if len(statusParts) &gt; 1 </span><span class="cov8" title="1">{
                        resp.Status = statusParts[1]
                }</span>
        } else<span class="cov0" title="0"> {
                resp.StatusCode = http.StatusOK
        }</span>

        // TODO: fixTransferEncoding ?
        <span class="cov8" title="1">resp.TransferEncoding = resp.Header["Transfer-Encoding"]
        resp.ContentLength, _ = strconv.ParseInt(resp.Header.Get("Content-Length"), 10, 64)

        if chunked(resp.TransferEncoding) </span><span class="cov0" title="0">{
                resp.Body = ioutil.NopCloser(httputil.NewChunkedReader(rb))
        }</span> else<span class="cov8" title="1"> {
                resp.Body = ioutil.NopCloser(rb)
        }</span>

        <span class="cov8" title="1">return</span>
}

// Get issues a GET request to the fcgi responder.
func (client *FCGIClient) Get(p map[string]string) (resp *http.Response, err error) <span class="cov8" title="1">{
        p["REQUEST_METHOD"] = "GET"
        p["CONTENT_LENGTH"] = "0"

        return client.Request(p, nil)
}</span>

// Head issues a HEAD request to the fcgi responder.
func (c *FCGIClient) Head(p map[string]string) (resp *http.Response, err error) <span class="cov8" title="1">{
        p["REQUEST_METHOD"] = "HEAD"
        p["CONTENT_LENGTH"] = "0"

        return c.Request(p, nil)
}</span>

// Options issues an OPTIONS request to the fcgi responder.
func (c *FCGIClient) Options(p map[string]string) (resp *http.Response, err error) <span class="cov8" title="1">{
        p["REQUEST_METHOD"] = "OPTIONS"
        p["CONTENT_LENGTH"] = "0"

        return c.Request(p, nil)
}</span>

// Post issues a Post request to the fcgi responder. with request body
// in the format that bodyType specified
func (client *FCGIClient) Post(p map[string]string, bodyType string, body io.Reader, l int) (resp *http.Response, err error) <span class="cov8" title="1">{
        if len(p["REQUEST_METHOD"]) == 0 || p["REQUEST_METHOD"] == "GET" </span><span class="cov0" title="0">{
                p["REQUEST_METHOD"] = "POST"
        }</span>
        <span class="cov8" title="1">p["CONTENT_LENGTH"] = strconv.Itoa(l)
        if len(bodyType) &gt; 0 </span><span class="cov8" title="1">{
                p["CONTENT_TYPE"] = bodyType
        }</span> else<span class="cov8" title="1"> {
                p["CONTENT_TYPE"] = "application/x-www-form-urlencoded"
        }</span>

        <span class="cov8" title="1">return client.Request(p, body)</span>
}

// PostForm issues a POST to the fcgi responder, with form
// as a string key to a list values (url.Values)
func (client *FCGIClient) PostForm(p map[string]string, data url.Values) (resp *http.Response, err error) <span class="cov8" title="1">{
        body := bytes.NewReader([]byte(data.Encode()))
        return client.Post(p, "application/x-www-form-urlencoded", body, body.Len())
}</span>

// PostFile issues a POST to the fcgi responder in multipart(RFC 2046) standard,
// with form as a string key to a list values (url.Values),
// and/or with file as a string key to a list file path.
func (client *FCGIClient) PostFile(p map[string]string, data url.Values, file map[string]string) (resp *http.Response, err error) <span class="cov0" title="0">{
        buf := &amp;bytes.Buffer{}
        writer := multipart.NewWriter(buf)
        bodyType := writer.FormDataContentType()

        for key, val := range data </span><span class="cov0" title="0">{
                for _, v0 := range val </span><span class="cov0" title="0">{
                        err = writer.WriteField(key, v0)
                        if err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                }
        }

        <span class="cov0" title="0">for key, val := range file </span><span class="cov0" title="0">{
                fd, e := os.Open(val)
                if e != nil </span><span class="cov0" title="0">{
                        return nil, e
                }</span>
                <span class="cov0" title="0">defer fd.Close()

                part, e := writer.CreateFormFile(key, filepath.Base(val))
                if e != nil </span><span class="cov0" title="0">{
                        return nil, e
                }</span>
                <span class="cov0" title="0">_, err = io.Copy(part, fd)</span>
        }

        <span class="cov0" title="0">err = writer.Close()
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">return client.Post(p, bodyType, buf, buf.Len())</span>
}

// SetReadTimeout sets the read timeout for future calls that read from the
// fcgi responder. A zero value for t means no timeout will be set.
func (c *FCGIClient) SetReadTimeout(t time.Duration) error <span class="cov0" title="0">{
        if conn, ok := c.rwc.(net.Conn); ok &amp;&amp; t != 0 </span><span class="cov0" title="0">{
                return conn.SetReadDeadline(time.Now().Add(t))
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// SetWriteTimeout sets the write timeout for future calls that send data to
// the fcgi responder. A zero value for t means no timeout will be set.
func (c *FCGIClient) SetWriteTimeout(t time.Duration) error <span class="cov0" title="0">{
        if conn, ok := c.rwc.(net.Conn); ok &amp;&amp; t != 0 </span><span class="cov0" title="0">{
                return conn.SetWriteDeadline(time.Now().Add(t))
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Checks whether chunked is part of the encodings stack
func chunked(te []string) bool <span class="cov8" title="1">{ return len(te) &gt; 0 &amp;&amp; te[0] == "chunked" }</span>
</pre>
		
		<pre class="file" id="file39" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package bfe_fcgi

import (
        "fmt"
        "io"
        "io/ioutil"
        "net"
        "net/http/httputil"
        "path/filepath"
        "strconv"
        "strings"
)

import (
        bufio "github.com/bfenetworks/bfe/bfe_bufio"
        http "github.com/bfenetworks/bfe/bfe_http"
        "github.com/bfenetworks/bfe/bfe_net/textproto"
)

// Transport facilitates FastCGI communication.
type Transport struct {
        // Root is the fastcgi root directory. Defaults to the root
        // directory of the parent virtual host.
        Root string

        // EnvVars is the extra environment variables.
        EnvVars map[string]string
}

func (t *Transport) RoundTrip(req *http.Request) (*http.Response, error) <span class="cov8" title="1">{
        buildMetaValsAndMethod(req, t.Root, t.EnvVars)

        metaData := map[string]string{}
        for k, vs := range req.Header </span><span class="cov8" title="1">{
                metaData[strings.ToUpper(k)] = strings.Join(vs, ",")
        }</span>

        <span class="cov8" title="1">client, err := Dial("tcp", req.URL.Host)
        if err != nil </span><span class="cov0" title="0">{
                return nil, ConnectError{
                        Addr: req.URL.Host,
                        Err:  err,
                }
        }</span>

        <span class="cov8" title="1">reader, err := client.Do(metaData, req.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, WriteRequestError{
                        Err: err,
                }
        }</span>

        <span class="cov8" title="1">rsp, err := readResponse(reader, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, ReadRespHeaderError{
                        Err: err,
                }
        }</span>
        <span class="cov8" title="1">return rsp, nil</span>
}

func buildMetaValsAndMethod(r *http.Request, root string, envVars map[string]string) <span class="cov8" title="1">{
        ip, port := r.RemoteAddr, ""
        if idx := strings.LastIndex(r.RemoteAddr, ":"); idx &gt; -1 </span><span class="cov0" title="0">{
                ip = r.RemoteAddr[:idx]
                port = r.RemoteAddr[idx+1:]
        }</span>
        <span class="cov8" title="1">ip = strings.Replace(ip, "[", "", 1)
        ip = strings.Replace(ip, "]", "", 1)

        fpath := r.URL.Path

        docURI, pathInfo, scriptName := fpath, "", fpath
        scriptName = strings.TrimSuffix(scriptName, pathInfo)
        scriptFilename := filepath.Join(root, scriptName)

        reqHost, reqPort, err := net.SplitHostPort(r.Host)
        if err != nil </span><span class="cov8" title="1">{
                reqHost = r.Host
        }</span>

        <span class="cov8" title="1">metaHeader := http.Header{}
        metaHeader.Add("GATEWAY_INTERFACE", "CGI/1.1")
        metaHeader.Add("SERVER_SOFTWARE", "BFE")

        metaHeader.Add("AUTH_TYPE", "")
        metaHeader.Add("CONTENT_LENGTH", r.Header.Get("Content-Length"))
        metaHeader.Add("CONTENT_TYPE", r.Header.Get("Content-Type"))
        metaHeader.Add("PATH_INFO", pathInfo)
        metaHeader.Add("QUERY_STRING", r.URL.RawQuery)
        metaHeader.Add("REMOTE_ADDR", ip)
        metaHeader.Add("REMOTE_HOST", ip)
        metaHeader.Add("REMOTE_PORT", port)
        metaHeader.Add("REMOTE_IDENT", "")
        metaHeader.Add("REMOTE_USER", "")
        metaHeader.Add("REQUEST_METHOD", r.Method)
        metaHeader.Add("REQUEST_SCHEME", r.URL.Scheme)
        metaHeader.Add("SERVER_NAME", reqHost)
        metaHeader.Add("SERVER_PORT", reqPort)
        metaHeader.Add("SERVER_PROTOCOL", r.Proto)

        metaHeader.Add("DOCUMENT_ROOT", root)
        metaHeader.Add("DOCUMENT_URI", docURI)
        metaHeader.Add("HTTP_HOST", r.Host)
        metaHeader.Add("REQUEST_URI", r.URL.RequestURI())
        metaHeader.Add("SCRIPT_FILENAME", scriptFilename)
        metaHeader.Add("SCRIPT_NAME", scriptName)

        if metaHeader.Get("PATH_INFO") == "" </span><span class="cov8" title="1">{
                metaHeader.Add("PATH_INFO", filepath.Join(root, pathInfo))
        }</span>

        // add config
        <span class="cov8" title="1">for key, value := range envVars </span><span class="cov0" title="0">{
                metaHeader.Set(key, value)
        }</span>

        // https://tools.ietf.org/html/rfc3875#section-4.1.18
        <span class="cov8" title="1">for key, val := range r.Header </span><span class="cov0" title="0">{
                header := strings.ReplaceAll(strings.ToUpper(key), "-", "_")
                metaHeader.Add("HTTP_"+header, strings.Join(val, ", "))
        }</span>

        // build Method
        <span class="cov8" title="1">metaHeader.Set("REQUEST_METHOD", r.Method)
        metaHeader.Set("CONTENT_LENGTH", fmt.Sprintf("%d", r.ContentLength))
        contentType := r.Header.Get("Content-Type")
        if contentType == "" </span><span class="cov8" title="1">{
                contentType = "application/x-www-form-urlencoded"
        }</span>
        <span class="cov8" title="1">metaHeader.Set("CONTENT_TYPE", contentType)

        r.Header = metaHeader</span>
}

func readResponse(reader io.Reader, req *http.Request) (*http.Response, error) <span class="cov8" title="1">{
        rb := bufio.NewReader(reader)
        tp := textproto.NewReader(rb)
        resp := &amp;http.Response{
                Request: req,
        }

        // Parse the response headers.
        mimeHeader, err := tp.ReadMIMEHeader()
        if err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">resp.Header = http.Header(mimeHeader)

        if resp.Header.Get("Status") != "" </span><span class="cov0" title="0">{
                statusParts := strings.SplitN(resp.Header.Get("Status"), " ", 2)
                resp.StatusCode, err = strconv.Atoi(statusParts[0])
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">if len(statusParts) &gt; 1 </span><span class="cov0" title="0">{
                        resp.Status = statusParts[1]
                }</span>
        } else<span class="cov8" title="1"> {
                resp.StatusCode = http.StatusOK
        }</span>

        // TODO: fixTransferEncoding ?
        <span class="cov8" title="1">resp.TransferEncoding = resp.Header["Transfer-Encoding"]
        resp.ContentLength, _ = strconv.ParseInt(resp.Header.Get("Content-Length"), 10, 64)

        if chunked(resp.TransferEncoding) </span><span class="cov0" title="0">{
                resp.Body = ioutil.NopCloser(httputil.NewChunkedReader(rb))
        }</span> else<span class="cov8" title="1"> {
                resp.Body = ioutil.NopCloser(rb)
        }</span>
        <span class="cov8" title="1">return resp, nil</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// The wire protocol for HTTP's "chunked" Transfer-Encoding.

package bfe_http

import (
        "errors"
        "fmt"
        "io"
)

import (
        "github.com/bfenetworks/bfe/bfe_bufio"
)

const maxLineLength = 4096 // assumed &lt;= bufio.defaultBufSize

var ErrLineTooLong = errors.New("header line too long")

// newChunkedReader returns a new chunkedReader that translates the data read from r
// out of HTTP "chunked" format before returning it.
// The chunkedReader returns io.EOF when the final 0-length chunk is read.
//
// newChunkedReader is not needed by normal applications. The http package
// automatically decodes chunking when reading response bodies.
func newChunkedReader(r io.Reader) io.Reader <span class="cov8" title="1">{
        br, ok := r.(*bfe_bufio.Reader)
        if !ok </span><span class="cov8" title="1">{
                br = bfe_bufio.NewReader(r)
        }</span>
        <span class="cov8" title="1">return &amp;chunkedReader{r: br}</span>
}

type chunkedReader struct {
        r   *bfe_bufio.Reader
        n   uint64 // unread bytes in chunk
        err error
        buf [2]byte
}

func (cr *chunkedReader) beginChunk() <span class="cov8" title="1">{
        // chunk-size CRLF
        var line []byte
        line, cr.err = readLine(cr.r)
        if cr.err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">cr.n, cr.err = parseHexUint(line)
        if cr.err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if cr.n == 0 </span><span class="cov8" title="1">{
                cr.err = io.EOF
        }</span>
}

func (cr *chunkedReader) Read(b []uint8) (n int, err error) <span class="cov8" title="1">{
        if cr.err != nil </span><span class="cov8" title="1">{
                return 0, cr.err
        }</span>
        <span class="cov8" title="1">if cr.n == 0 </span><span class="cov8" title="1">{
                cr.beginChunk()
                if cr.err != nil </span><span class="cov8" title="1">{
                        return 0, cr.err
                }</span>
        }
        <span class="cov8" title="1">if uint64(len(b)) &gt; cr.n </span><span class="cov8" title="1">{
                b = b[0:cr.n]
        }</span>
        <span class="cov8" title="1">n, cr.err = cr.r.Read(b)
        cr.n -= uint64(n)
        if cr.n == 0 &amp;&amp; cr.err == nil </span><span class="cov8" title="1">{
                // end of chunk (CRLF)
                if _, cr.err = io.ReadFull(cr.r, cr.buf[:]); cr.err == nil </span><span class="cov8" title="1">{
                        if cr.buf[0] != '\r' || cr.buf[1] != '\n' </span><span class="cov0" title="0">{
                                cr.err = errors.New("malformed chunked encoding")
                        }</span>
                }
        }
        <span class="cov8" title="1">return n, cr.err</span>
}

// Read a line of bytes (up to \n) from b.
// Give up if the line exceeds maxLineLength.
// The returned bytes are a pointer into storage in
// the bufio, so they are only valid until the next bufio read.
func readLine(b *bfe_bufio.Reader) (p []byte, err error) <span class="cov8" title="1">{
        if p, err = b.ReadSlice('\n'); err != nil </span><span class="cov0" title="0">{
                // We always know when EOF is coming.
                // If the caller asked for a line, there should be a line.
                if err == io.EOF </span><span class="cov0" title="0">{
                        err = io.ErrUnexpectedEOF
                }</span> else<span class="cov0" title="0"> if err == bfe_bufio.ErrBufferFull </span><span class="cov0" title="0">{
                        err = ErrLineTooLong
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov8" title="1">if len(p) &gt;= maxLineLength </span><span class="cov0" title="0">{
                return nil, ErrLineTooLong
        }</span>
        <span class="cov8" title="1">return trimTrailingWhitespace(p), nil</span>
}

func trimTrailingWhitespace(b []byte) []byte <span class="cov8" title="1">{
        for len(b) &gt; 0 &amp;&amp; isASCIISpace(b[len(b)-1]) </span><span class="cov8" title="1">{
                b = b[:len(b)-1]
        }</span>
        <span class="cov8" title="1">return b</span>
}

func isASCIISpace(b byte) bool <span class="cov8" title="1">{
        return b == ' ' || b == '\t' || b == '\n' || b == '\r'
}</span>

// newChunkedWriter returns a new chunkedWriter that translates writes into HTTP
// "chunked" format before writing them to w. Closing the returned chunkedWriter
// sends the final 0-length chunk that marks the end of the stream.
//
// newChunkedWriter is not needed by normal applications. The http
// package adds chunking automatically if handlers don't set a
// Content-Length header. Using newChunkedWriter inside a handler
// would result in double chunking or chunking with a Content-Length
// length, both of which are wrong.
func newChunkedWriter(w io.Writer) io.WriteCloser <span class="cov8" title="1">{
        return &amp;chunkedWriter{w}
}</span>

// Writing to chunkedWriter translates to writing in HTTP chunked Transfer
// Encoding wire format to the underlying Wire chunkedWriter.
type chunkedWriter struct {
        Wire io.Writer
}

// Write the contents of data as one chunk to Wire.
// NOTE: Note that the corresponding chunk-writing procedure in Conn.Write has
// a bug since it does not check for success of io.WriteString
func (cw *chunkedWriter) Write(data []byte) (n int, err error) <span class="cov8" title="1">{

        // Don't send 0-length data. It looks like EOF for chunked encoding.
        if len(data) == 0 </span><span class="cov0" title="0">{
                return 0, nil
        }</span>

        <span class="cov8" title="1">if _, err = fmt.Fprintf(cw.Wire, "%x\r\n", len(data)); err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov8" title="1">if n, err = cw.Wire.Write(data); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if n != len(data) </span><span class="cov0" title="0">{
                err = io.ErrShortWrite
                return
        }</span>
        <span class="cov8" title="1">_, err = io.WriteString(cw.Wire, "\r\n")

        return</span>
}

func (cw *chunkedWriter) Close() error <span class="cov8" title="1">{
        _, err := io.WriteString(cw.Wire, "0\r\n")
        return err
}</span>

func parseHexUint(v []byte) (n uint64, err error) <span class="cov8" title="1">{
        for _, b := range v </span><span class="cov8" title="1">{
                n &lt;&lt;= 4
                switch </span>{
                case '0' &lt;= b &amp;&amp; b &lt;= '9':<span class="cov8" title="1">
                        b -= '0'</span>
                case 'a' &lt;= b &amp;&amp; b &lt;= 'f':<span class="cov8" title="1">
                        b = b - 'a' + 10</span>
                case 'A' &lt;= b &amp;&amp; b &lt;= 'F':<span class="cov0" title="0">
                        b = b - 'A' + 10</span>
                default:<span class="cov8" title="1">
                        return 0, errors.New("invalid byte in chunk length")</span>
                }
                <span class="cov8" title="1">n |= uint64(b)</span>
        }
        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// HTTP client. See RFC 2616.
//
// This is the high-level Client interface.
// The low-level implementation is in transport.go.

package bfe_http

import (
        "encoding/base64"
        "errors"
        "io"
        "strings"
)

import (
        "github.com/baidu/go-lib/log"
)

// RoundTripper is an interface representing the ability to execute a
// single HTTP transaction, obtaining the Response for a given Request.
//
// A RoundTripper must be safe for concurrent use by multiple
// goroutines.
type RoundTripper interface {
        // RoundTrip executes a single HTTP transaction, returning
        // the Response for the request req.  RoundTrip should not
        // attempt to interpret the response.  In particular,
        // RoundTrip must return err == nil if it obtained a response,
        // regardless of the response's HTTP status code.  A non-nil
        // err should be reserved for failure to obtain a response.
        // Similarly, RoundTrip should not attempt to handle
        // higher-level protocol details such as redirects,
        // authentication, or cookies.
        //
        // RoundTrip should not modify the request, except for
        // consuming and closing the Body. The request's URL and
        // Header fields are guaranteed to be initialized.
        RoundTrip(*Request) (*Response, error)
}

// Given a string of the form "host", "host:port", or "[ipv6::address]:port",
// return true if the string includes a port.
func hasPort(s string) bool <span class="cov0" title="0">{ return strings.LastIndex(s, ":") &gt; strings.LastIndex(s, "]") }</span>

// Used in Send to implement io.ReadCloser by bundling together the
// bufio.Reader through which we read the response, and the underlying
// network connection.
type readClose struct {
        io.Reader
        io.Closer
}

// send issues an HTTP request.
// Caller should close resp.Body when done reading from it.
func send(req *Request, t RoundTripper) (resp *Response, err error) <span class="cov0" title="0">{
        if t == nil </span><span class="cov0" title="0">{
                t = DefaultTransport
                if t == nil </span><span class="cov0" title="0">{
                        err = errors.New("http: no Client.Transport or DefaultTransport")
                        return
                }</span>
        }

        <span class="cov0" title="0">if req.URL == nil </span><span class="cov0" title="0">{
                return nil, errors.New("http: nil Request.URL")
        }</span>

        <span class="cov0" title="0">if req.RequestURI != "" </span><span class="cov0" title="0">{
                return nil, errors.New("http: Request.RequestURI can't be set in client requests.")
        }</span>

        // Most the callers of send (Get, Post, et al) don't need
        // Headers, leaving it uninitialized.  We guarantee to the
        // Transport that this has been initialized, though.
        <span class="cov0" title="0">if req.Header == nil </span><span class="cov0" title="0">{
                req.Header = make(Header)
        }</span>

        <span class="cov0" title="0">if u := req.URL.User; u != nil </span><span class="cov0" title="0">{
                username := u.Username()
                password, _ := u.Password()
                req.Header.Set("Authorization", "Basic "+basicAuth(username, password))
        }</span>
        <span class="cov0" title="0">resp, err = t.RoundTrip(req)
        if err != nil </span><span class="cov0" title="0">{
                if resp != nil </span><span class="cov0" title="0">{
                        log.Logger.Warn("RoundTripper returned a response &amp; error; ignoring response")
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return resp, nil</span>
}

// See 2 (end of page 4) http://www.ietf.org/rfc/rfc2617.txt
// "To receive authorization, the client sends the userid and password,
// separated by a single colon (":") character, within a base64
// encoded string in the credentials."
// It is not meant to be urlencoded.
func basicAuth(username, password string) string <span class="cov8" title="1">{
        auth := username + ":" + password
        return base64.StdEncoding.EncodeToString([]byte(auth))
}</span>

// True if the specified HTTP status code is one for which the Get utility should
// automatically redirect.
func shouldRedirectGet(statusCode int) bool <span class="cov0" title="0">{
        switch statusCode </span>{
        case StatusMovedPermanently, StatusFound, StatusSeeOther, StatusTemporaryRedirect:<span class="cov0" title="0">
                return true</span>
        }
        <span class="cov0" title="0">return false</span>
}

// True if the specified HTTP status code is one for which the Post utility should
// automatically redirect.
func shouldRedirectPost(statusCode int) bool <span class="cov0" title="0">{
        switch statusCode </span>{
        case StatusFound, StatusSeeOther:<span class="cov0" title="0">
                return true</span>
        }
        <span class="cov0" title="0">return false</span>
}

func defaultCheckRedirect(req *Request, via []*Request) error <span class="cov0" title="0">{
        if len(via) &gt;= 10 </span><span class="cov0" title="0">{
                return errors.New("stopped after 10 redirects")
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Copyright 2010 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package bfe_http

import (
        "errors"
        "fmt"
        "io"
        "log"
        "net"
        "reflect"
        "sync"
        "sync/atomic"
        "time"
)

import (
        "github.com/baidu/go-lib/gotrack"
        slog "github.com/baidu/go-lib/log"
)

import (
        bufio "github.com/bfenetworks/bfe/bfe_bufio"
        tls "github.com/bfenetworks/bfe/bfe_tls"
)

// DefaultMaxHeaderBytes is the maximum permitted size of the headers in an HTTP request.
// This can be overridden by setting config.MaxHeaderBytes.
const DefaultMaxHeaderBytes = 1 &lt;&lt; 20 // 1 MB

// DefaultMaxHeaderUriBytes is the maximum permitted size of URI in headers in an HTTP request.
// This can be overridden by setting config.MaxHeaderUriBytes.
const DefaultMaxHeaderUriBytes = 8 * 1024

var ErrBodyNotAllowed = errors.New("http: request method or response status code does not allow body")

// A Server defines parameters for running an HTTP server.
// The zero value for Server is a valid configuration.
type Server struct {
        Addr                    string        // TCP address to listen on, ":http" if empty
        Handler                 Handler       // handler to invoke, http.DefaultServeMux if nil
        ReadTimeout             time.Duration // maximum duration before timing out read of the request
        WriteTimeout            time.Duration // maximum duration before timing out write of the response
        TlsHandshakeTimeout     time.Duration // maximum duration before timing out handshake
        GracefulShutdownTimeout time.Duration // maximum duration before timing out graceful shutdown
        MaxHeaderBytes          int           // maximum size of request headers, DefaultMaxHeaderBytes if 0
        MaxHeaderUriBytes       int           // max URI(in header) length in bytes in request
        TLSConfig               *tls.Config   // optional TLS config, used by ListenAndServeTLS

        // TLSNextProto optionally specifies a function to take over
        // ownership of the provided TLS connection when an NPN
        // protocol upgrade has occurred.  The map key is the protocol
        // name negotiated. The Handler argument should be used to
        // handle HTTP requests and will initialize the Request's TLS
        // and RemoteAddr if not already set.  The connection is
        // automatically closed when the function returns.
        TLSNextProto map[string]func(*Server, *tls.Conn, Handler)

        // HTTPNextProto optionally specifies a function to take over
        // ownership of the http connection when an HTTP Upgrade has
        // occurred. The map key is the protocol name negotiated (eg
        // websocket, h2c)
        HTTPNextProto map[string]func(*Server, ResponseWriter, *Request)

        // ConnState specifies an optional callback function that is
        // called when a client connection changes state. See the
        // ConnState type and associated constants for details.
        ConnState func(net.Conn, ConnState)

        // ErrorLog specifies an optional logger for errors accepting
        // connections and unexpected behavior from handlers.
        // If nil, logging goes to os.Stderr via the log package's
        // standard logger.
        ErrorLog *log.Logger

        disableKeepAlives int32 // accessed atomically.

        // CloseNotifyCh allow detecting when the server in graceful shutdown state
        CloseNotifyCh chan bool
}

func (s *Server) DoKeepAlives() bool <span class="cov0" title="0">{
        return atomic.LoadInt32(&amp;s.disableKeepAlives) == 0
}</span>

// SetKeepAlivesEnabled controls whether HTTP keep-alives are enabled.
// By default, keep-alives are always enabled. Only very
// resource-constrained environments or servers in the process of
// shutting down should disable them.
func (s *Server) SetKeepAlivesEnabled(v bool) <span class="cov0" title="0">{
        if v </span><span class="cov0" title="0">{
                atomic.StoreInt32(&amp;s.disableKeepAlives, 0)
        }</span> else<span class="cov0" title="0"> {
                atomic.StoreInt32(&amp;s.disableKeepAlives, 1)
        }</span>
}

// A ConnState represents the state of a client connection to a server.
// It's used by the optional Server.ConnState hook.
type ConnState int

const (
        // StateNew represents a new connection that is expected to
        // send a request immediately. Connections begin at this
        // state and then transition to either StateActive or
        // StateClosed.
        StateNew ConnState = iota

        // StateActive represents a connection that has read 1 or more
        // bytes of a request. The Server.ConnState hook for
        // StateActive fires before the request has entered a handler
        // and doesn't fire again until the request has been
        // handled. After the request is handled, the state
        // transitions to StateClosed, StateHijacked, or StateIdle.
        StateActive

        // StateIdle represents a connection that has finished
        // handling a request and is in the keep-alive state, waiting
        // for a new request. Connections transition from StateIdle
        // to either StateActive or StateClosed.
        StateIdle

        // StateHijacked represents a hijacked connection.
        // This is a terminal state. It does not transition to StateClosed.
        StateHijacked

        // StateClosed represents a closed connection.
        // This is a terminal state. Hijacked connections do not
        // transition to StateClosed.
        StateClosed
)

var stateName = map[ConnState]string{
        StateNew:      "new",
        StateActive:   "active",
        StateIdle:     "idle",
        StateHijacked: "hijacked",
        StateClosed:   "closed",
}

func (c ConnState) String() string <span class="cov0" title="0">{
        return stateName[c]
}</span>

// The Handler Objects implementing the Handler interface can be
// registered to serve a particular path or subtree
// in the HTTP server.
//
// ServeHTTP should write reply headers and data to the ResponseWriter
// and then return.  Returning signals that the request is finished
// and that the HTTP server can move on to the next request on
// the connection.
type Handler interface {
        ServeHTTP(ResponseWriter, *Request)
}

// The Flusher interface is implemented by ResponseWriters that allow
// an HTTP handler to flush buffered data to the client.
//
// Note that even for ResponseWriters that support Flush,
// if the client is connected through an HTTP proxy,
// the buffered data may not reach the client until the response
// completes.
type Flusher interface {
        // Flush sends any buffered data to the client.
        Flush() error
}

type Hijacker interface {
        // Hijack lets the caller take over the connection.
        // After a call to Hijack the HTTP server library
        // will not do anything else with the connection.
        //
        // It becomes the caller's responsibility to manage
        // and close the connection.
        //
        // The returned net.Conn may have read or write deadlines
        // already set, depending on the configuration of the
        // Server. It is the caller's responsibility to set
        // or clear those deadlines as needed.
        //
        // The returned bufio.Reader may contain unprocessed buffered
        // data from the client.
        Hijack() (net.Conn, *bufio.ReadWriter, error)
}

// The CloseNotifier interface is implemented by ResponseWriters which
// allow detecting when the underlying connection has gone away.
//
// This mechanism can be used to cancel long operations on the server
// if the client has disconnected before the response is ready.
type CloseNotifier interface {
        // CloseNotify returns a channel that receives a single value
        // when the client connection has gone away.
        CloseNotify() &lt;-chan bool
}

// The HandlerFunc type is an adapter to allow the use of
// ordinary functions as HTTP handlers.  If f is a function
// with the appropriate signature, HandlerFunc(f) is a
// Handler object that calls f.
type HandlerFunc func(ResponseWriter, *Request)

// ServeHTTP calls f(w, r).
func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) <span class="cov0" title="0">{
        f(w, r)
}</span>

type WriteFlusher interface {
        io.Writer
        Flusher
}

type MaxLatencyWriter struct {
        dst     WriteFlusher
        latency time.Duration
        err     error
        done    chan bool

        // onExitFlushLoop is a callback set by tests to detect the state of the
        // flushLoop() goroutine.
        onExitFlushLoop func()

        lk sync.Mutex // protects Write + Flush
}

func NewMaxLatencyWriter(dst WriteFlusher, latency time.Duration,
        onExitFlushLoop func()) *MaxLatencyWriter <span class="cov0" title="0">{
        m := new(MaxLatencyWriter)
        m.dst = dst
        m.latency = latency
        m.done = make(chan bool)
        m.onExitFlushLoop = onExitFlushLoop
        return m
}</span>

func (m *MaxLatencyWriter) Write(p []byte) (int, error) <span class="cov0" title="0">{
        m.lk.Lock()
        n, err := m.dst.Write(p)
        m.lk.Unlock()

        return n, err
}</span>

func (m *MaxLatencyWriter) Flush() error <span class="cov0" title="0">{
        m.lk.Lock()
        defer m.lk.Unlock()

        if m.err != nil </span><span class="cov0" title="0">{
                return m.err
        }</span>

        <span class="cov0" title="0">m.err = m.dst.Flush()
        return m.err</span>
}

func (m *MaxLatencyWriter) FlushLoop() <span class="cov0" title="0">{
        t := time.NewTicker(m.latency)

        defer func() </span><span class="cov0" title="0">{
                if err := recover(); err != nil </span><span class="cov0" title="0">{
                        slog.Logger.Warn("panic:MaxLatencyWriter.FlushLoop():%v\n%s", err, gotrack.CurrentStackTrace(0))
                        state.HttpPanicClientFlushLoop.Inc(1)
                }</span>
                <span class="cov0" title="0">t.Stop()</span>
        }()

        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-m.done:<span class="cov0" title="0">
                        if m.onExitFlushLoop != nil </span><span class="cov0" title="0">{
                                m.onExitFlushLoop()
                        }</span>
                        <span class="cov0" title="0">return</span>
                case &lt;-t.C:<span class="cov0" title="0">
                        m.Flush()</span>
                }
        }
}

func (m *MaxLatencyWriter) Stop() <span class="cov0" title="0">{
        m.done &lt;- true
}</span>

// Error replies to the request with the specified error message and HTTP code.
// The error message should be plain text.
func Error(w ResponseWriter, error string, code int) <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "text/plain; charset=utf-8")
        w.WriteHeader(code)
        fmt.Fprintln(w, error)
}</span>

type ConnectError struct {
        Addr string
        Err  error
}

func (e ConnectError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("ConnectError: %s, %s", e.Err.Error(), e.Addr)
}</span>

type WriteRequestError struct {
        Err error
}

func (e WriteRequestError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("WriteRequestError: %s", e.Err.Error())
}</span>

func (e WriteRequestError) CheckTargetError(addr net.Addr) bool <span class="cov0" title="0">{
        if err, ok := e.Err.(*net.OpError); ok </span><span class="cov0" title="0">{
                return reflect.DeepEqual(err.Addr, addr)
        }</span>
        <span class="cov0" title="0">return false</span>
}

type RespHeaderTimeoutError struct{}

func (e RespHeaderTimeoutError) Error() string <span class="cov0" title="0">{
        return "RespHeaderTimeoutError: timeout awaiting response headers"
}</span>

type ReadRespHeaderError struct {
        Err error
}

func (e ReadRespHeaderError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("ReadRespHeaderError: %s", e.Err.Error())
}</span>

type TransportBrokenError struct{}

func (e TransportBrokenError) Error() string <span class="cov0" title="0">{
        return "TransportBrokenError: transport closed before response was received"
}</span>

type FlowLimiter interface {
        // AcceptConn check whether current connection should be accept or not
        AcceptConn() bool

        // AcceptRequest check whether current request should be accept or not
        AcceptRequest() bool
}

// CloseWatcher can be used to cancel long operations on the server
// if the client has disconnected.
type CloseWatcher struct {
        notifier CloseNotifier // notify if the underlying connection has gone away.
        onClose  func()
        done     chan bool
}

func NewCloseWatcher(notifier CloseNotifier, onClose func()) *CloseWatcher <span class="cov0" title="0">{
        w := new(CloseWatcher)
        w.notifier = notifier
        w.onClose = onClose
        w.done = make(chan bool)

        return w
}</span>

func (w *CloseWatcher) WatchLoop() <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                if err := recover(); err != nil </span><span class="cov0" title="0">{
                        slog.Logger.Warn("panic:CloseWatcher.WatchLoop():%v\n%s", err, gotrack.CurrentStackTrace(0))
                        state.HttpPanicClientWatchLoop.Inc(1)
                }</span>
        }()

        <span class="cov0" title="0">closeCh := w.notifier.CloseNotify()
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-closeCh:<span class="cov0" title="0">
                        slog.Logger.Debug("CloseWatcher found client conn disconnected, fire onClose()")
                        if w.onClose != nil </span><span class="cov0" title="0">{
                                state.HttpCancelOnClientClose.Inc(1)
                                w.onClose()
                        }</span>
                case &lt;-w.done:<span class="cov0" title="0">
                        return</span>
                }
        }
}

func (w *CloseWatcher) Stop() <span class="cov0" title="0">{
        w.done &lt;- true
}</span>

// Peeker is common interface for peeking data
type Peeker interface {
        Peek(n int) ([]byte, error)
}

func CopyHeader(dst, src Header) <span class="cov0" title="0">{
        for k, vv := range src </span><span class="cov0" title="0">{
                for _, v := range vv </span><span class="cov0" title="0">{
                        dst.Add(k, v)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file43" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package bfe_http

import (
        "bytes"
        "net"
        "strconv"
        "strings"
        "time"
)

import (
        "github.com/baidu/go-lib/log"
)

// This implementation is done according to RFC 6265:
//
//    http://tools.ietf.org/html/rfc6265

// A Cookie represents an HTTP cookie as sent in the Set-Cookie header of an
// HTTP response or the Cookie header of an HTTP request.
type Cookie struct {
        Name       string
        Value      string
        Path       string
        Domain     string
        Expires    time.Time
        RawExpires string

        // MaxAge=0 means no 'Max-Age' attribute specified.
        // MaxAge&lt;0 means delete cookie now, equivalently 'Max-Age: 0'
        // MaxAge&gt;0 means Max-Age attribute present and given in seconds
        MaxAge   int
        Secure   bool
        HttpOnly bool
        SameSite SameSite
        Raw      string
        Unparsed []string // Raw text of unparsed attribute-value pairs
}

type CookieMap map[string]*Cookie

// SameSite allows a server to define a cookie attribute making it impossible for
// the browser to send this cookie along with cross-site requests. The main
// goal is to mitigate the risk of cross-origin information leakage, and provide
// some protection against cross-site request forgery attacks.
//
// See https://tools.ietf.org/html/draft-ietf-httpbis-cookie-same-site-00 for details.
type SameSite int

const (
        SameSiteDefaultMode SameSite = iota + 1
        SameSiteLaxMode
        SameSiteStrictMode
        SameSiteNoneMode
)

// if disableSanitize is true, when read cookie value, no sanitize is performed
var disableSanitize = false

func SetDisableSanitize(disabled bool) <span class="cov8" title="1">{
        disableSanitize = disabled
}</span>

// CookieMapGet parse cookies(slice) to req.Route.CookieMap(map)
func CookieMapGet(cookies []*Cookie) CookieMap <span class="cov0" title="0">{
        cookieMap := make(CookieMap, len(cookies))

        for _, cookie := range cookies </span><span class="cov0" title="0">{
                // if more than one cookies have the same key,
                // only the first cookie will be saved in CookieMap
                _, ok := cookieMap[cookie.Name]

                if !ok </span><span class="cov0" title="0">{
                        cookieMap[cookie.Name] = cookie
                }</span>
        }
        <span class="cov0" title="0">return cookieMap</span>
}

func (cm CookieMap) Get(key string) (*Cookie, bool) <span class="cov0" title="0">{
        if cm == nil </span><span class="cov0" title="0">{
                return nil, false
        }</span>

        <span class="cov0" title="0">val, ok := cm[key]
        return val, ok</span>
}

// http://tools.ietf.org/html/rfc6265#section-5.2.1 only specify an algorithm to parse a cookie-date
// According to https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie, Expires format should be HTTP-date
// Preferred syntax: &lt;day-name&gt;, &lt;day&gt; &lt;month&gt; &lt;year&gt; &lt;hour&gt;:&lt;minute&gt;:&lt;second&gt; GMT
// However, there are some obsolete formats, specified in https://tools.ietf.org/html/rfc7231#section-7.1.1.2
func parseExpireTime(val string) (time.Time, bool) <span class="cov8" title="1">{
        // preferred format
        exptime, err := time.Parse(TimeFormat, val)
        if err == nil </span><span class="cov0" title="0">{
                return exptime.UTC(), true
        }</span>
        <span class="cov8" title="1">exptime, err = time.Parse("Mon, 02-Jan-06 15:04:05 GMT", val)
        if err == nil </span><span class="cov8" title="1">{
                return exptime.UTC(), true
        }</span>
        <span class="cov8" title="1">exptime, err = time.Parse(time.RFC1123, val)
        if err == nil </span><span class="cov0" title="0">{
                return exptime.UTC(), true
        }</span>
        // set-cookie expire format of php version: Sun, 07-May-2028 10:53:08 GMT
        <span class="cov8" title="1">exptime, err = time.Parse("Mon, 02-Jan-2006 15:04:05 MST", val)
        if err == nil </span><span class="cov8" title="1">{
                return exptime.UTC(), true
        }</span>
        <span class="cov0" title="0">return time.Time{}, false</span>
}

// readSetCookies parses all "Set-Cookie" values from
// the header h and returns the successfully parsed Cookies.
func readSetCookies(h Header) []*Cookie <span class="cov8" title="1">{
        cookies := []*Cookie{}
        for _, line := range h["Set-Cookie"] </span><span class="cov8" title="1">{
                parts := strings.Split(strings.TrimSpace(line), ";")
                if len(parts) == 1 &amp;&amp; parts[0] == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">parts[0] = strings.TrimSpace(parts[0])
                j := strings.Index(parts[0], "=")
                if j &lt; 0 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">name, value := parts[0][:j], parts[0][j+1:]
                if !isCookieNameValid(name) </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">value, success := parseCookieValue(value)
                if !success </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">c := &amp;Cookie{
                        Name:  name,
                        Value: value,
                        Raw:   line,
                }
                for i := 1; i &lt; len(parts); i++ </span><span class="cov8" title="1">{
                        parts[i] = strings.TrimSpace(parts[i])
                        if len(parts[i]) == 0 </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov8" title="1">attr, val := parts[i], ""
                        if j := strings.Index(attr, "="); j &gt;= 0 </span><span class="cov8" title="1">{
                                attr, val = attr[:j], attr[j+1:]
                        }</span>
                        <span class="cov8" title="1">lowerAttr := strings.ToLower(attr)
                        parseCookieValueFn := parseCookieValue
                        if lowerAttr == "expires" </span><span class="cov8" title="1">{
                                parseCookieValueFn = parseCookieExpiresValue
                        }</span>
                        <span class="cov8" title="1">val, success = parseCookieValueFn(val)
                        if !success </span><span class="cov0" title="0">{
                                c.Unparsed = append(c.Unparsed, parts[i])
                                continue</span>
                        }
                        <span class="cov8" title="1">switch lowerAttr </span>{
                        case "samesite":<span class="cov8" title="1">
                                lowerVal := strings.ToLower(val)
                                switch lowerVal </span>{
                                case "lax":<span class="cov8" title="1">
                                        c.SameSite = SameSiteLaxMode</span>
                                case "strict":<span class="cov8" title="1">
                                        c.SameSite = SameSiteStrictMode</span>
                                case "none":<span class="cov8" title="1">
                                        c.SameSite = SameSiteNoneMode</span>
                                default:<span class="cov8" title="1">
                                        c.SameSite = SameSiteDefaultMode</span>
                                }
                                <span class="cov8" title="1">continue</span>
                        case "secure":<span class="cov8" title="1">
                                c.Secure = true
                                continue</span>
                        case "httponly":<span class="cov8" title="1">
                                c.HttpOnly = true
                                continue</span>
                        case "domain":<span class="cov8" title="1">
                                c.Domain = val
                                // TODO: Add domain parsing
                                continue</span>
                        case "max-age":<span class="cov8" title="1">
                                secs, err := strconv.Atoi(val)
                                if err != nil || secs != 0 &amp;&amp; val[0] == '0' </span><span class="cov0" title="0">{
                                        break</span>
                                }
                                <span class="cov8" title="1">if secs &lt;= 0 </span><span class="cov0" title="0">{
                                        c.MaxAge = -1
                                }</span> else<span class="cov8" title="1"> {
                                        c.MaxAge = secs
                                }</span>
                                <span class="cov8" title="1">continue</span>
                        case "expires":<span class="cov8" title="1">
                                c.RawExpires = val
                                // if parse failed, will add to Unparsed
                                exp, ok := parseExpireTime(val)
                                if ok </span><span class="cov8" title="1">{
                                        c.Expires = exp
                                        continue</span>
                                }
                        case "path":<span class="cov8" title="1">
                                c.Path = val
                                // TODO: Add path parsing
                                continue</span>
                        }
                        <span class="cov8" title="1">c.Unparsed = append(c.Unparsed, parts[i])</span>
                }
                <span class="cov8" title="1">cookies = append(cookies, c)</span>
        }
        <span class="cov8" title="1">return cookies</span>
}

// SetCookie adds a Set-Cookie header to the provided ResponseWriter's headers.
func SetCookie(w ResponseWriter, cookie *Cookie) <span class="cov8" title="1">{
        w.Header().Add("Set-Cookie", cookie.String())
}</span>

// String returns the serialization of the cookie for use in a Cookie
// header (if only Name and Value are set) or a Set-Cookie response
// header (if other fields are set).
func (c *Cookie) String() string <span class="cov8" title="1">{
        var b bytes.Buffer
        b.WriteString(sanitizeCookieName(c.Name))
        b.WriteRune('=')
        b.WriteString(sanitizeCookieValue(c.Value))
        if len(c.Path) &gt; 0 </span><span class="cov8" title="1">{
                b.WriteString("; Path=")
                b.WriteString(sanitizeCookiePath(c.Path))
        }</span>
        <span class="cov8" title="1">if len(c.Domain) &gt; 0 </span><span class="cov8" title="1">{
                if validCookieDomain(c.Domain) </span><span class="cov8" title="1">{
                        // A c.Domain containing illegal characters is not
                        // sanitized but simply dropped which turns the cookie
                        // into a host-only cookie. A leading dot is okay
                        // but won't be sent.
                        d := c.Domain
                        if d[0] == '.' </span><span class="cov8" title="1">{
                                d = d[1:]
                        }</span>
                        <span class="cov8" title="1">b.WriteString("; Domain=")
                        b.WriteString(d)</span>
                } else<span class="cov8" title="1"> {
                        log.Logger.Warn("net/http: invalid Cookie.Domain %q; dropping domain attribute",
                                c.Domain)
                }</span>
        }
        <span class="cov8" title="1">if validCookieExpires(c.Expires) </span><span class="cov8" title="1">{
                b.WriteString("; Expires=")
                b2 := b.Bytes()
                b.Reset()
                b.Write(c.Expires.UTC().AppendFormat(b2, TimeFormat))
        }</span>
        <span class="cov8" title="1">if c.MaxAge &gt; 0 </span><span class="cov8" title="1">{
                b.WriteString("; Max-Age=")
                b2 := b.Bytes()
                b.Reset()
                b.Write(strconv.AppendInt(b2, int64(c.MaxAge), 10))
        }</span> else<span class="cov8" title="1"> if c.MaxAge &lt; 0 </span><span class="cov0" title="0">{
                b.WriteString("; Max-Age=0")
        }</span>
        <span class="cov8" title="1">if c.HttpOnly </span><span class="cov0" title="0">{
                b.WriteString("; HttpOnly")
        }</span>
        <span class="cov8" title="1">if c.Secure </span><span class="cov0" title="0">{
                b.WriteString("; Secure")
        }</span>
        <span class="cov8" title="1">switch c.SameSite </span>{
        case SameSiteDefaultMode:<span class="cov8" title="1">
                b.WriteString("; SameSite")</span>
        case SameSiteNoneMode:<span class="cov8" title="1">
                b.WriteString("; SameSite=None")</span>
        case SameSiteLaxMode:<span class="cov8" title="1">
                b.WriteString("; SameSite=Lax")</span>
        case SameSiteStrictMode:<span class="cov8" title="1">
                b.WriteString("; SameSite=Strict")</span>
        }
        <span class="cov8" title="1">return b.String()</span>
}

// validCookieExpires returns whether v is a valid cookie expires-value.
func validCookieExpires(t time.Time) bool <span class="cov8" title="1">{
        // IETF RFC 6265 Section 5.1.1.5, the year must not be less than 1601
        return t.Year() &gt;= 1601
}</span>

// readCookies parses all "Cookie" values from the header h and
// returns the successfully parsed Cookies.
//
// if filter isn't empty, only cookies of that name are returned
func readCookies(h Header, filter string) []*Cookie <span class="cov8" title="1">{
        lines := h["Cookie"]
        if len(lines) == 0 </span><span class="cov0" title="0">{
                return []*Cookie{}
        }</span>

        <span class="cov8" title="1">cookies := make([]*Cookie, 0, len(lines)+strings.Count(lines[0], ";"))

        for _, line := range lines </span><span class="cov8" title="1">{
                line = strings.TrimSpace(line)

                var part string
                for len(line) &gt; 0 </span><span class="cov8" title="1">{
                        if splitIndex := strings.Index(line, ";"); splitIndex &gt; 0 </span><span class="cov8" title="1">{
                                part, line = line[:splitIndex], line[splitIndex+1:]
                        }</span> else<span class="cov8" title="1"> {
                                part, line = line, ""
                        }</span>
                        <span class="cov8" title="1">part = strings.TrimSpace(part)
                        if len(part) == 0 </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">name, val := part, ""
                        if j := strings.Index(name, "="); j &gt;= 0 </span><span class="cov8" title="1">{
                                name, val = name[:j], name[j+1:]
                        }</span>
                        <span class="cov8" title="1">if !isCookieNameValid(name) </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">if filter != "" &amp;&amp; filter != name </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">val, success := parseCookieValue(val)
                        if !success </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">cookies = append(cookies, &amp;Cookie{Name: name, Value: val})</span>
                }
        }
        <span class="cov8" title="1">return cookies</span>
}

// validCookieDomain returns whether v is a valid cookie domain-value.
func validCookieDomain(v string) bool <span class="cov8" title="1">{
        if isCookieDomainName(v) </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">if net.ParseIP(v) != nil &amp;&amp; !strings.Contains(v, ":") </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">return false</span>
}

// isCookieDomainName returns whether s is a valid domain name or a valid
// domain name with a leading dot '.'.  It is almost a direct copy of
// package net's isDomainName.
func isCookieDomainName(s string) bool <span class="cov8" title="1">{
        if len(s) == 0 </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if len(s) &gt; 255 </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">if s[0] == '.' </span><span class="cov8" title="1">{
                // A cookie a domain attribute may start with a leading dot.
                s = s[1:]
        }</span>
        <span class="cov8" title="1">last := byte('.')
        ok := false // Ok once we've seen a letter.
        partlen := 0
        for i := 0; i &lt; len(s); i++ </span><span class="cov8" title="1">{
                c := s[i]
                switch </span>{
                default:<span class="cov8" title="1">
                        return false</span>
                case 'a' &lt;= c &amp;&amp; c &lt;= 'z' || 'A' &lt;= c &amp;&amp; c &lt;= 'Z':<span class="cov8" title="1">
                        // No '_' allowed here (in contrast to package net).
                        ok = true
                        partlen++</span>
                case '0' &lt;= c &amp;&amp; c &lt;= '9':<span class="cov8" title="1">
                        // fine
                        partlen++</span>
                case c == '-':<span class="cov8" title="1">
                        // Byte before dash cannot be dot.
                        if last == '.' </span><span class="cov0" title="0">{
                                return false
                        }</span>
                        <span class="cov8" title="1">partlen++</span>
                case c == '.':<span class="cov8" title="1">
                        // Byte before dot cannot be dot, dash.
                        if last == '.' || last == '-' </span><span class="cov8" title="1">{
                                return false
                        }</span>
                        <span class="cov8" title="1">if partlen &gt; 63 || partlen == 0 </span><span class="cov0" title="0">{
                                return false
                        }</span>
                        <span class="cov8" title="1">partlen = 0</span>
                }
                <span class="cov8" title="1">last = c</span>
        }
        <span class="cov8" title="1">if last == '-' || partlen &gt; 63 </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">return ok</span>
}

var cookieNameSanitizer = strings.NewReplacer("\n", "-", "\r", "-")

func sanitizeCookieName(n string) string <span class="cov8" title="1">{
        return cookieNameSanitizer.Replace(n)
}</span>

// http://tools.ietf.org/html/rfc6265#section-4.1.1
// cookie-value      = *cookie-octet / ( DQUOTE *cookie-octet DQUOTE )
// cookie-octet      = %x21 / %x23-2B / %x2D-3A / %x3C-5B / %x5D-7E
//           ; US-ASCII characters excluding CTLs,
//           ; whitespace DQUOTE, comma, semicolon,
//           ; and backslash
func sanitizeCookieValue(v string) string <span class="cov8" title="1">{
        if disableSanitize </span><span class="cov8" title="1">{
                return v
        }</span>

        <span class="cov8" title="1">return sanitizeOrWarn("Cookie.Value", validCookieValueByte, v)</span>
}

func validCookieValueByte(b byte) bool <span class="cov8" title="1">{
        return 0x20 &lt; b &amp;&amp; b &lt; 0x7f &amp;&amp; b != '"' &amp;&amp; b != ',' &amp;&amp; b != ';' &amp;&amp; b != '\\'
}</span>

// path-av           = "Path=" path-value
// path-value        = &lt;any CHAR except CTLs or ";"&gt;
func sanitizeCookiePath(v string) string <span class="cov8" title="1">{
        return sanitizeOrWarn("Cookie.Path", validCookiePathByte, v)
}</span>

func validCookiePathByte(b byte) bool <span class="cov8" title="1">{
        return 0x20 &lt;= b &amp;&amp; b &lt; 0x7f &amp;&amp; b != ';'
}</span>

func sanitizeOrWarn(fieldName string, valid func(byte) bool, v string) string <span class="cov8" title="1">{
        ok := true
        for i := 0; i &lt; len(v); i++ </span><span class="cov8" title="1">{
                if valid(v[i]) </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">log.Logger.Warn("net/http: invalid byte %q in %s; dropping invalid bytes",
                        v[i], fieldName)
                ok = false
                break</span>
        }
        <span class="cov8" title="1">if ok </span><span class="cov8" title="1">{
                return v
        }</span>
        <span class="cov8" title="1">buf := make([]byte, 0, len(v))
        for i := 0; i &lt; len(v); i++ </span><span class="cov8" title="1">{
                if b := v[i]; valid(b) </span><span class="cov8" title="1">{
                        buf = append(buf, b)
                }</span>
        }
        <span class="cov8" title="1">return string(buf)</span>
}

func unquoteCookieValue(v string) string <span class="cov8" title="1">{
        if len(v) &gt; 1 &amp;&amp; v[0] == '"' &amp;&amp; v[len(v)-1] == '"' </span><span class="cov0" title="0">{
                return v[1 : len(v)-1]
        }</span>
        <span class="cov8" title="1">return v</span>
}

func isCookieByte(c byte) bool <span class="cov8" title="1">{
        switch </span>{
        case c == 0x21, 0x23 &lt;= c &amp;&amp; c &lt;= 0x2b, 0x2d &lt;= c &amp;&amp; c &lt;= 0x3a,
                0x3c &lt;= c &amp;&amp; c &lt;= 0x5b, 0x5d &lt;= c &amp;&amp; c &lt;= 0x7e:<span class="cov8" title="1">
                return true</span>
        }
        <span class="cov8" title="1">return false</span>
}

func isCookieExpiresByte(c byte) (ok bool) <span class="cov8" title="1">{
        return isCookieByte(c) || c == ',' || c == ' '
}</span>

func parseCookieValue(raw string) (string, bool) <span class="cov8" title="1">{
        if disableSanitize </span><span class="cov8" title="1">{
                return raw, true
        }</span>

        <span class="cov8" title="1">return parseCookieValueUsing(raw, isCookieByte)</span>
}

func parseCookieExpiresValue(raw string) (string, bool) <span class="cov8" title="1">{
        return parseCookieValueUsing(raw, isCookieExpiresByte)
}</span>

func parseCookieValueUsing(raw string, validByte func(byte) bool) (string, bool) <span class="cov8" title="1">{
        raw = unquoteCookieValue(raw)
        for i := 0; i &lt; len(raw); i++ </span><span class="cov8" title="1">{
                if !validByte(raw[i]) </span><span class="cov0" title="0">{
                        return "", false
                }</span>
        }
        <span class="cov8" title="1">return raw, true</span>
}

func isCookieNameValid(raw string) bool <span class="cov8" title="1">{
        return strings.IndexFunc(raw, isNotToken) &lt; 0
}</span>
</pre>
		
		<pre class="file" id="file44" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Copyright 2010 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package bfe_http

import (
        "io"
        "sort"
        "strings"
        "time"
)

import (
        "github.com/bfenetworks/bfe/bfe_net/textproto"
)

// TimeFormat is the time format to use with
// time.Parse and time.Time.Format when parsing
// or generating times in HTTP headers.
// It is like time.RFC1123 but hard codes GMT as the time zone.
const TimeFormat = "Mon, 02 Jan 2006 15:04:05 GMT"

// A Header represents the key-value pairs in an HTTP header.
type Header map[string][]string

// Add adds the key, value pair to the header.
// It appends to any existing values associated with key.
func (h Header) Add(key, value string) <span class="cov8" title="1">{
        textproto.MIMEHeader(h).Add(key, value)
}</span>

// Set sets the header entries associated with key to
// the single element value.  It replaces any existing
// values associated with key.
func (h Header) Set(key, value string) <span class="cov8" title="1">{
        textproto.MIMEHeader(h).Set(key, value)
}</span>

// Get gets the first value associated with the given key.
// If there are no values associated with the key, Get returns "".
// To access multiple values of a key, access the map directly
// with CanonicalHeaderKey.
func (h Header) Get(key string) string <span class="cov8" title="1">{
        return textproto.MIMEHeader(h).Get(key)
}</span>

// Values returns all values associated with the given key.
// It is case-insensitive; textproto.CanonicalMIMEHeaderKey is
// used to canonicalize the provided key. To use non-canonical
// keys, access the map directly.
// The returned slice is not a copy.
func (h Header) Values(key string) []string <span class="cov0" title="0">{
        return textproto.MIMEHeader(h).Values(key)
}</span>

// GetDirect gets the value associated with the given key
// in CanonicalHeaderKey form.
func (h Header) GetDirect(key string) string <span class="cov8" title="1">{
        if v := h[key]; len(v) &gt; 0 </span><span class="cov8" title="1">{
                return v[0]
        }</span>
        <span class="cov8" title="1">return ""</span>
}

// Del deletes the values associated with key.
func (h Header) Del(key string) <span class="cov8" title="1">{
        textproto.MIMEHeader(h).Del(key)
}</span>

// Write writes a header in wire format.
func (h Header) Write(w io.Writer) error <span class="cov0" title="0">{
        return h.WriteSubset(w, nil)
}</span>

func (h Header) Clone() Header <span class="cov0" title="0">{
        h2 := make(Header, len(h))
        for k, vv := range h </span><span class="cov0" title="0">{
                vv2 := make([]string, len(vv))
                copy(vv2, vv)
                h2[k] = vv2
        }</span>
        <span class="cov0" title="0">return h2</span>
}

// Keys get all keys from header
func (h Header) Keys() []string <span class="cov0" title="0">{
        keys := make([]string, 0, len(h))
        for key := range h </span><span class="cov0" title="0">{
                keys = append(keys, key)
        }</span>
        <span class="cov0" title="0">return keys</span>
}

var timeFormats = []string{
        TimeFormat,
        time.RFC850,
        time.ANSIC,
}

// ParseTime parses a time header (such as the Date: header),
// trying each of the three formats allowed by HTTP/1.1:
// TimeFormat, time.RFC850, and time.ANSIC.
func ParseTime(text string) (t time.Time, err error) <span class="cov8" title="1">{
        for _, layout := range timeFormats </span><span class="cov8" title="1">{
                t, err = time.Parse(layout, text)
                if err == nil </span><span class="cov8" title="1">{
                        return
                }</span>
        }
        <span class="cov8" title="1">return</span>
}

var headerNewlineToSpace = strings.NewReplacer("\n", " ", "\r", " ")

type writeStringer interface {
        WriteString(string) (int, error)
}

// stringWriter implements WriteString on a Writer.
type stringWriter struct {
        w io.Writer
}

func (w stringWriter) WriteString(s string) (n int, err error) <span class="cov0" title="0">{
        return w.w.Write([]byte(s))
}</span>

type keyValues struct {
        key    string
        values []string
}

// A headerSorter implements sort.Interface by sorting a []keyValues
// by key. It's used as a pointer, so it can fit in a sort.Interface
// interface value without allocation.
type headerSorter struct {
        kvs []keyValues
}

func (s *headerSorter) Len() int           <span class="cov8" title="1">{ return len(s.kvs) }</span>
func (s *headerSorter) Swap(i, j int)      <span class="cov8" title="1">{ s.kvs[i], s.kvs[j] = s.kvs[j], s.kvs[i] }</span>
func (s *headerSorter) Less(i, j int) bool <span class="cov8" title="1">{ return s.kvs[i].key &lt; s.kvs[j].key }</span>

// TODO: convert this to a sync.Cache (issue 4720)
var headerSorterCache = make(chan *headerSorter, 8)

// sortedKeyValues returns h's keys sorted in the returned kvs
// slice. The headerSorter used to sort is also returned, for possible
// return to headerSorterCache.
func (h Header) sortedKeyValues(exclude map[string]bool) (kvs []keyValues, hs *headerSorter) <span class="cov8" title="1">{
        select </span>{
        case hs = &lt;-headerSorterCache:<span class="cov8" title="1"></span>
        default:<span class="cov8" title="1">
                hs = new(headerSorter)</span>
        }
        <span class="cov8" title="1">if cap(hs.kvs) &lt; len(h) </span><span class="cov8" title="1">{
                hs.kvs = make([]keyValues, 0, len(h))
        }</span>
        <span class="cov8" title="1">kvs = hs.kvs[:0]
        for k, vv := range h </span><span class="cov8" title="1">{
                if !exclude[k] </span><span class="cov8" title="1">{
                        kvs = append(kvs, keyValues{k, vv})
                }</span>
        }
        <span class="cov8" title="1">hs.kvs = kvs
        sort.Sort(hs)
        return kvs, hs</span>
}

// WriteSubset writes a header in wire format.
// If exclude is not nil, keys where exclude[key] == true are not written.
func (h Header) WriteSubset(w io.Writer, exclude map[string]bool) error <span class="cov8" title="1">{
        ws, ok := w.(writeStringer)
        if !ok </span><span class="cov8" title="1">{
                ws = stringWriter{w}
        }</span>
        <span class="cov8" title="1">kvs, sorter := h.sortedKeyValues(exclude)
        for _, kv := range kvs </span><span class="cov8" title="1">{
                for _, v := range kv.values </span><span class="cov8" title="1">{
                        v = headerNewlineToSpace.Replace(v)
                        v = textproto.TrimString(v)
                        for _, s := range []string{kv.key, ": ", v, "\r\n"} </span><span class="cov8" title="1">{
                                if _, err := ws.WriteString(s); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">select </span>{
        case headerSorterCache &lt;- sorter:<span class="cov8" title="1"></span>
        default:<span class="cov0" title="0"></span>
        }
        <span class="cov8" title="1">return nil</span>
}

// writeSubsetWithoutSort writes a header in wire format.
// If exclude is not nil, keys where exclude[key] == true are not written.
func (h Header) writeSubsetWithoutSort(w io.Writer, exclude map[string]bool) error <span class="cov0" title="0">{
        ws, ok := w.(writeStringer)
        if !ok </span><span class="cov0" title="0">{
                ws = stringWriter{w}
        }</span>

        <span class="cov0" title="0">for k, vv := range h </span><span class="cov0" title="0">{
                if exclude[k] </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">for _, v := range vv </span><span class="cov0" title="0">{
                        v = headerNewlineToSpace.Replace(v)
                        v = textproto.TrimString(v)

                        for _, s := range []string{k, ": ", v, "\r\n"} </span><span class="cov0" title="0">{
                                if _, err := ws.WriteString(s); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// CanonicalHeaderKey returns the canonical format of the
// header key s.  The canonicalization converts the first
// letter and any letter following a hyphen to upper case;
// the rest are converted to lowercase.  For example, the
// canonical key for "accept-encoding" is "Accept-Encoding".
func CanonicalHeaderKey(s string) string <span class="cov0" title="0">{ return textproto.CanonicalMIMEHeaderKey(s) }</span>

// HasToken reports whether token appears with v, ASCII
// case-insensitive, with space or comma boundaries.
// token must be all lowercase.
// v may contain mixed cased.
func HasToken(v, token string) bool <span class="cov8" title="1">{
        if len(token) &gt; len(v) || token == "" </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if v == token </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">for sp := 0; sp &lt;= len(v)-len(token); sp++ </span><span class="cov8" title="1">{
                // Check that first character is good.
                // The token is ASCII, so checking only a single byte
                // is sufficient.  We skip this potential starting
                // position if both the first byte and its potential
                // ASCII uppercase equivalent (b|0x20) don't match.
                // False positives ('^' =&gt; '~') are caught by EqualFold.
                if b := v[sp]; b != token[0] &amp;&amp; b|0x20 != token[0] </span><span class="cov8" title="1">{
                        continue</span>
                }
                // Check that start pos is on a valid token boundary.
                <span class="cov8" title="1">if sp &gt; 0 &amp;&amp; !isTokenBoundary(v[sp-1]) </span><span class="cov8" title="1">{
                        continue</span>
                }
                // Check that end pos is on a valid token boundary.
                <span class="cov8" title="1">if endPos := sp + len(token); endPos != len(v) &amp;&amp; !isTokenBoundary(v[endPos]) </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if strings.EqualFold(v[sp:sp+len(token)], token) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func isTokenBoundary(b byte) bool <span class="cov8" title="1">{
        return b == ' ' || b == ',' || b == '\t'
}</span>
</pre>
		
		<pre class="file" id="file45" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package bfe_http

// This file deals with lexical matters of HTTP

var isTokenTable = [127]bool{
        '!':  true,
        '#':  true,
        '$':  true,
        '%':  true,
        '&amp;':  true,
        '\'': true,
        '*':  true,
        '+':  true,
        '-':  true,
        '.':  true,
        '0':  true,
        '1':  true,
        '2':  true,
        '3':  true,
        '4':  true,
        '5':  true,
        '6':  true,
        '7':  true,
        '8':  true,
        '9':  true,
        'A':  true,
        'B':  true,
        'C':  true,
        'D':  true,
        'E':  true,
        'F':  true,
        'G':  true,
        'H':  true,
        'I':  true,
        'J':  true,
        'K':  true,
        'L':  true,
        'M':  true,
        'N':  true,
        'O':  true,
        'P':  true,
        'Q':  true,
        'R':  true,
        'S':  true,
        'T':  true,
        'U':  true,
        'W':  true,
        'V':  true,
        'X':  true,
        'Y':  true,
        'Z':  true,
        '^':  true,
        '_':  true,
        '`':  true,
        'a':  true,
        'b':  true,
        'c':  true,
        'd':  true,
        'e':  true,
        'f':  true,
        'g':  true,
        'h':  true,
        'i':  true,
        'j':  true,
        'k':  true,
        'l':  true,
        'm':  true,
        'n':  true,
        'o':  true,
        'p':  true,
        'q':  true,
        'r':  true,
        's':  true,
        't':  true,
        'u':  true,
        'v':  true,
        'w':  true,
        'x':  true,
        'y':  true,
        'z':  true,
        '|':  true,
        '~':  true,
}

func isToken(r rune) bool <span class="cov8" title="1">{
        i := int(r)
        return i &lt; len(isTokenTable) &amp;&amp; isTokenTable[i]
}</span>

func isNotToken(r rune) bool <span class="cov8" title="1">{
        return !isToken(r)
}</span>
</pre>
		
		<pre class="file" id="file46" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// HTTP Request reading and parsing.

package bfe_http

import (
        "bytes"
        "encoding/base64"
        "errors"
        "fmt"
        "io"
        "io/ioutil"
        "mime"
        "mime/multipart"
        "net"
        "net/url"
        "strconv"
        "strings"
        "sync"
        "time"
)

import (
        "github.com/bfenetworks/bfe/bfe_bufio"
        "github.com/bfenetworks/bfe/bfe_net/textproto"
        "github.com/bfenetworks/bfe/bfe_tls"
)

const (
        maxValueLength   = 4096
        maxHeaderLines   = 1024
        chunkSize        = 4 &lt;&lt; 10  // 4 KB chunks
        defaultMaxMemory = 32 &lt;&lt; 20 // 32 MB
        MaxUriSize       = 1024 * 64
)

// ErrMissingFile is returned by FormFile when the provided file field name
// is either not present in the request or not a file field.
var ErrMissingFile = errors.New("http: no such file")

// ProtocolError is the error found during HTTP request parsing.
type ProtocolError struct {
        ErrorString string
}

func (err *ProtocolError) Error() string <span class="cov0" title="0">{ return err.ErrorString }</span>

var (
        ErrHeaderTooLong        = &amp;ProtocolError{"header too long"}
        ErrShortBody            = &amp;ProtocolError{"entity body too short"}
        ErrNotSupported         = &amp;ProtocolError{"feature not supported"}
        ErrUnexpectedTrailer    = &amp;ProtocolError{"trailer header without chunked transfer encoding"}
        ErrMissingContentLength = &amp;ProtocolError{"missing ContentLength in HEAD response"}
        ErrNotMultipart         = &amp;ProtocolError{"request Content-Type isn't multipart/form-data"}
        ErrMissingBoundary      = &amp;ProtocolError{"no multipart boundary param in Content-Type"}
)

type badStringError struct {
        what string
        str  string
}

func (e *badStringError) Error() string <span class="cov0" title="0">{ return fmt.Sprintf("%s %q", e.what, e.str) }</span>

// Headers that Request.Write handles itself and should be skipped.
var reqWriteExcludeHeader = map[string]bool{
        "Host":              true, // not in Header map anyway
        "Content-Length":    true,
        "Transfer-Encoding": true,
        "Trailer":           true,
}

// A Request represents an HTTP request received by a server
// or to be sent by a client.
type Request struct {
        Method string // GET, POST, PUT, etc.

        // URL is created from the URI supplied on the Request-Line
        // as stored in RequestURI.
        //
        // For most requests, fields other than Path and RawQuery
        // will be empty. (See RFC 2616, Section 5.1.2)
        URL *url.URL

        // The protocol version for incoming requests.
        // Outgoing requests always use HTTP/1.1.
        Proto      string // "HTTP/1.0"
        ProtoMajor int    // 1
        ProtoMinor int    // 0

        // A header maps request lines to their values.
        // If the header says
        //
        //        accept-encoding: gzip, deflate
        //        Accept-Language: en-us
        //        Connection: keep-alive
        //
        // then
        //
        //        Header = map[string][]string{
        //                "Accept-Encoding": {"gzip, deflate"},
        //                "Accept-Language": {"en-us"},
        //                "Connection": {"keep-alive"},
        //        }
        //
        // HTTP defines that header names are case-insensitive.
        // The request parser implements this by canonicalizing the
        // name, making the first character and any characters
        // following a hyphen uppercase and the rest lowercase.
        Header Header

        // a headerKeys represents keys of header in original order
        HeaderKeys textproto.MIMEKeys

        // Body is the request's body.
        //
        // For client requests, a nil body means the request has no
        // body, such as a GET request. The HTTP Client's Transport
        // is responsible for calling the Close method.
        //
        // For server requests, the Request Body is always non-nil
        // but will return EOF immediately when no body is present.
        // The Server will close the request body. The ServeHTTP
        // Handler does not need to.
        Body io.ReadCloser

        // ContentLength records the length of the associated content.
        // The value -1 indicates that the length is unknown.
        // Values &gt;= 0 indicate that the given number of bytes may
        // be read from Body.
        // For outgoing requests, a value of 0 means unknown if Body is not nil.
        ContentLength int64

        // TransferEncoding lists the transfer encodings from outermost to
        // innermost. An empty list denotes the "identity" encoding.
        // TransferEncoding can usually be ignored; chunked encoding is
        // automatically added and removed as necessary when sending and
        // receiving requests.
        TransferEncoding []string

        // Close indicates whether to close the connection after
        // replying to this request.
        Close bool

        // The host on which the URL is sought.
        // Per RFC 2616, this is either the value of the Host: header
        // or the host name given in the URL itself.
        // It may be of the form "host:port".
        Host string

        // Form contains the parsed form data, including both the URL
        // field's query parameters and the POST or PUT form data.
        // This field is only available after ParseForm is called.
        // The HTTP client ignores Form and uses Body instead.
        Form url.Values

        // PostForm contains the parsed form data from POST or PUT
        // body parameters.
        // This field is only available after ParseForm is called.
        // The HTTP client ignores PostForm and uses Body instead.
        PostForm url.Values

        // MultipartForm is the parsed multipart form, including file uploads.
        // This field is only available after ParseMultipartForm is called.
        // The HTTP client ignores MultipartForm and uses Body instead.
        MultipartForm *multipart.Form

        // Trailer maps trailer keys to values.  Like for Header, if the
        // response has multiple trailer lines with the same key, they will be
        // concatenated, delimited by commas.
        // For server requests, Trailer is only populated after Body has been
        // closed or fully consumed.
        // Trailer support is only partially complete.
        Trailer Header

        // RemoteAddr allows HTTP servers and other software to record
        // the network address that sent the request, usually for
        // logging. This field is not filled in by ReadRequest and
        // has no defined format. The HTTP server in this package
        // sets RemoteAddr to an "IP:port" address before invoking a
        // handler.
        // This field is ignored by the HTTP client.
        RemoteAddr string

        // RequestURI is the unmodified Request-URI of the
        // Request-Line (RFC 2616, Section 5.1) as sent by the client
        // to a server. Usually the URL field should be used instead.
        // It is an error to set this field in an HTTP client request.
        RequestURI string

        // TLS allows HTTP servers and other software to record
        // information about the TLS connection on which the request
        // was received. This field is not filled in by ReadRequest.
        // The HTTP server in this package sets the field for
        // TLS-enabled connections before invoking a handler;
        // otherwise it leaves the field nil.
        // This field is ignored by the HTTP client.
        TLS *bfe_tls.ConnectionState

        // State allows HTTP server and other software to record
        // information about the request. This filed may be not filled.
        State *RequestState
}

type RequestState struct {
        // SerialNumber identify Nth request on one connection
        // this field of first request is 1, second is 2, and so on
        SerialNumber uint32

        // Conn is the connection from which request arrived
        Conn net.Conn

        // StartTime is the time when the first byte of request header was
        // received. StartTime may be approximate.
        StartTime time.Time

        // ConnectBackendStart is the time when start get a connection
        ConnectBackendStart time.Time

        // ConnectBackendEnd is the time when got a connection(may got from connection pool)
        ConnectBackendEnd time.Time

        // HeaderSize is the size of the request header.
        HeaderSize uint32

        // BodySize is the size of request body.
        BodySize uint32
}

// ProtoAtLeast reports whether the HTTP protocol used
// in the request is at least major.minor.
func (r *Request) ProtoAtLeast(major, minor int) bool <span class="cov8" title="1">{
        return r.ProtoMajor &gt; major ||
                r.ProtoMajor == major &amp;&amp; r.ProtoMinor &gt;= minor
}</span>

// UserAgent returns the client's User-Agent, if sent in the request.
func (r *Request) UserAgent() string <span class="cov0" title="0">{
        return r.Header.Get("User-Agent")
}</span>

// Cookies parses and returns the HTTP cookies sent with the request.
func (r *Request) Cookies() []*Cookie <span class="cov0" title="0">{
        return readCookies(r.Header, "")
}</span>

var ErrNoCookie = errors.New("http: named cookie not present")

// Cookie returns the named cookie provided in the request or
// ErrNoCookie if not found.
func (r *Request) Cookie(name string) (*Cookie, error) <span class="cov0" title="0">{
        for _, c := range readCookies(r.Header, name) </span><span class="cov0" title="0">{
                return c, nil
        }</span>
        <span class="cov0" title="0">return nil, ErrNoCookie</span>
}

// AddCookie adds a cookie to the request.  Per RFC 6265 section 5.4,
// AddCookie does not attach more than one Cookie header field.  That
// means all cookies, if any, are written into the same line,
// separated by semicolon.
func (r *Request) AddCookie(c *Cookie) <span class="cov8" title="1">{
        s := fmt.Sprintf("%s=%s", sanitizeCookieName(c.Name), sanitizeCookieValue(c.Value))
        if c := r.Header.Get("Cookie"); c != "" </span><span class="cov8" title="1">{
                r.Header.Set("Cookie", c+"; "+s)
        }</span> else<span class="cov8" title="1"> {
                r.Header.Set("Cookie", s)
        }</span>
}

// Referer returns the referring URL, if sent in the request.
//
// Referer is misspelled as in the request itself, a mistake from the
// earliest days of HTTP.  This value can also be fetched from the
// Header map as Header["Referer"]; the benefit of making it available
// as a method is that the compiler can diagnose programs that use the
// alternate (correct English) spelling req.Referrer() but cannot
// diagnose programs that use Header["Referrer"].
func (r *Request) Referer() string <span class="cov0" title="0">{
        return r.Header.Get("Referer")
}</span>

// multipartByReader is a sentinel value.
// Its presence in Request.MultipartForm indicates that parsing of the request
// body has been handed off to a MultipartReader instead of ParseMultipartFrom.
var multipartByReader = &amp;multipart.Form{
        Value: make(map[string][]string),
        File:  make(map[string][]*multipart.FileHeader),
}

// MultipartReader returns a MIME multipart reader if this is a
// multipart/form-data POST request, else returns nil and an error.
// Use this function instead of ParseMultipartForm to
// process the request body as a stream.
func (r *Request) MultipartReader() (*multipart.Reader, error) <span class="cov8" title="1">{
        if r.MultipartForm == multipartByReader </span><span class="cov8" title="1">{
                return nil, errors.New("http: MultipartReader called twice")
        }</span>
        <span class="cov8" title="1">if r.MultipartForm != nil </span><span class="cov0" title="0">{
                return nil, errors.New("http: multipart handled by ParseMultipartForm")
        }</span>
        <span class="cov8" title="1">r.MultipartForm = multipartByReader
        return r.multipartReader()</span>
}

func (r *Request) multipartReader() (*multipart.Reader, error) <span class="cov8" title="1">{
        v := r.Header.Get("Content-Type")
        if v == "" </span><span class="cov8" title="1">{
                return nil, ErrNotMultipart
        }</span>
        <span class="cov8" title="1">d, params, err := mime.ParseMediaType(v)
        if err != nil || d != "multipart/form-data" </span><span class="cov8" title="1">{
                return nil, ErrNotMultipart
        }</span>
        <span class="cov8" title="1">boundary, ok := params["boundary"]
        if !ok </span><span class="cov0" title="0">{
                return nil, ErrMissingBoundary
        }</span>
        <span class="cov8" title="1">return multipart.NewReader(r.Body, boundary), nil</span>
}

// Return value if nonempty, def otherwise.
func valueOrDefault(value, def string) string <span class="cov8" title="1">{
        if value != "" </span><span class="cov8" title="1">{
                return value
        }</span>
        <span class="cov0" title="0">return def</span>
}

// Write writes an HTTP/1.1 request -- header and body -- in wire format.
// This method consults the following fields of the request:
//        Host
//        URL
//        Method (defaults to "GET")
//        Header
//        ContentLength
//        TransferEncoding
//        Body
//
// If Body is present, Content-Length is &lt;= 0 and TransferEncoding
// hasn't been set to "identity", Write adds "Transfer-Encoding:
// chunked" to the header. Body is closed after it is sent.
func (r *Request) Write(w io.Writer) error <span class="cov8" title="1">{
        return r.write(w, false, nil)
}</span>

// WriteProxy is like Write but writes the request in the form
// expected by an HTTP proxy.  In particular, WriteProxy writes the
// initial Request-URI line of the request with an absolute URI, per
// section 5.1.2 of RFC 2616, including the scheme and host.
// In either case, WriteProxy also writes a Host header, using
// either r.Host or r.URL.Host.
func (r *Request) WriteProxy(w io.Writer) error <span class="cov8" title="1">{
        return r.write(w, true, nil)
}</span>

// extraHeaders may be nil
func (req *Request) write(w io.Writer, usingProxy bool, extraHeaders Header) error <span class="cov8" title="1">{
        host := req.Host
        if host == "" </span><span class="cov8" title="1">{
                if req.URL == nil </span><span class="cov0" title="0">{
                        return errors.New("http: Request.Write on Request with no Host or URL set")
                }</span>
                <span class="cov8" title="1">host = req.URL.Host</span>
        }

        <span class="cov8" title="1">ruri := req.URL.RequestURI()
        if usingProxy &amp;&amp; req.URL.Scheme != "" &amp;&amp; req.URL.Opaque == "" </span><span class="cov8" title="1">{
                ruri = req.URL.Scheme + "://" + host + ruri
        }</span> else<span class="cov8" title="1"> if req.Method == MethodConnect &amp;&amp; req.URL.Path == "" </span><span class="cov0" title="0">{
                // CONNECT requests normally give just the host and port, not a full URL.
                ruri = host
        }</span> else<span class="cov8" title="1"> {
                // use req.RequestUri instead of req.URL.RequestURI() (decoded/encoded)
                // to be compatible with non-standard web server ONLY WHEN URL not changed since
                // ReadRequest()
                rawurl, err := url.ParseRequestURI(req.RequestURI)
                if err == nil &amp;&amp; rawurl.RequestURI() == ruri </span><span class="cov0" title="0">{
                        if rawurl.Scheme == "" &amp;&amp; rawurl.Host == "" &amp;&amp; rawurl.Opaque == "" </span><span class="cov0" title="0">{
                                // if RequestUri contains Scheme Host Opaque, no replace
                                ruri = req.RequestURI
                        }</span>
                }
        }
        // TODO(bradfitz): escape at least newlines in ruri?

        // Wrap the writer in a bufio Writer if it's not already buffered.
        // Don't always call NewWriter, as that forces a bytes.Buffer
        // and other small bufio Writers to have a minimum 4k buffer
        // size.
        <span class="cov8" title="1">var bw *bfe_bufio.Writer

        switch w.(type) </span>{
        case io.ByteWriter:<span class="cov8" title="1">
                break</span>
        case *MaxLatencyWriter:<span class="cov0" title="0">
                break</span>
        default:<span class="cov0" title="0">
                bw = bfe_bufio.NewWriter(w)
                w = bw</span>
        }

        <span class="cov8" title="1">fmt.Fprintf(w, "%s %s HTTP/1.1\r\n", valueOrDefault(req.Method, "GET"), ruri)

        // Header lines
        fmt.Fprintf(w, "Host: %s\r\n", host)

        // Process Body,ContentLength,Close,Trailer
        tw, err := newTransferWriter(req)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">err = tw.WriteHeader(w)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // TODO: split long values?  (If so, should share code with Conn.Write)
        <span class="cov8" title="1">err = req.Header.WriteSubset(w, reqWriteExcludeHeader)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if extraHeaders != nil </span><span class="cov0" title="0">{
                err = extraHeaders.Write(w)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">io.WriteString(w, "\r\n")

        // flush req header immediately if w if a buffered writer.
        // in case that the backend read timeout setting is too short,
        // and body receiving from client is too slow, so until backend timeout the buffer is not fulfilled
        // and the backend may close the connection
        if rbw, ok := w.(Flusher); ok </span><span class="cov0" title="0">{
                err = rbw.Flush()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Write body and trailer
        <span class="cov8" title="1">n, err := tw.WriteBody(w)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">req.State.BodySize = uint32(n)

        if bw != nil </span><span class="cov0" title="0">{
                return bw.Flush()
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// ParseHTTPVersion parses a HTTP version string.
// "HTTP/1.0" returns (1, 0, true).
func ParseHTTPVersion(vers string) (major, minor int, ok bool) <span class="cov8" title="1">{
        const Big = 1000000 // arbitrary upper bound
        switch vers </span>{
        case "HTTP/1.1":<span class="cov8" title="1">
                return 1, 1, true</span>
        case "HTTP/1.0":<span class="cov8" title="1">
                return 1, 0, true</span>
        }
        <span class="cov8" title="1">if !strings.HasPrefix(vers, "HTTP/") </span><span class="cov8" title="1">{
                return 0, 0, false
        }</span>
        <span class="cov8" title="1">dot := strings.Index(vers, ".")
        if dot &lt; 0 </span><span class="cov8" title="1">{
                return 0, 0, false
        }</span>
        <span class="cov8" title="1">major, err := strconv.Atoi(vers[5:dot])
        if err != nil || major &lt; 0 || major &gt; Big </span><span class="cov8" title="1">{
                return 0, 0, false
        }</span>
        <span class="cov8" title="1">minor, err = strconv.Atoi(vers[dot+1:])
        if err != nil || minor &lt; 0 || minor &gt; Big </span><span class="cov8" title="1">{
                return 0, 0, false
        }</span>
        <span class="cov8" title="1">return major, minor, true</span>
}

// NewRequest returns a new Request given a method, URL, and optional body.
//
// If the provided body is also an io.Closer, the returned
// Request.Body is set to body and will be closed by the Client
// methods Do, Post, and PostForm, and Transport.RoundTrip.
func NewRequest(method, urlStr string, body io.Reader) (*Request, error) <span class="cov8" title="1">{
        u, err := url.Parse(urlStr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">rc, ok := body.(io.ReadCloser)
        if !ok &amp;&amp; body != nil </span><span class="cov8" title="1">{
                rc = ioutil.NopCloser(body)
        }</span>
        <span class="cov8" title="1">req := &amp;Request{
                Method:     method,
                URL:        u,
                Proto:      "HTTP/1.1",
                ProtoMajor: 1,
                ProtoMinor: 1,
                Header:     make(Header),
                Body:       rc,
                Host:       u.Host,
        }
        if body != nil </span><span class="cov8" title="1">{
                switch v := body.(type) </span>{
                case *bytes.Buffer:<span class="cov8" title="1">
                        req.ContentLength = int64(v.Len())</span>
                case *bytes.Reader:<span class="cov8" title="1">
                        req.ContentLength = int64(v.Len())</span>
                case *strings.Reader:<span class="cov8" title="1">
                        req.ContentLength = int64(v.Len())</span>
                }
        }

        <span class="cov8" title="1">return req, nil</span>
}

// BasicAuth returns the username and password provided in the request's
// Authorization header, if the request uses HTTP Basic Authentication.
// See RFC 2617, Section 2.
func (r *Request) BasicAuth() (username, password string, ok bool) <span class="cov8" title="1">{
        auth := r.Header.Get("Authorization")
        if auth == "" </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">return parseBasicAuth(auth)</span>
}

// parseBasicAuth parses an HTTP Basic Authentication string.
// "Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==" returns ("Aladdin", "open sesame", true).
func parseBasicAuth(auth string) (username, password string, ok bool) <span class="cov8" title="1">{
        const prefix = "Basic "
        // Case-insensitive prefix match. See Issue 22736.
        if len(auth) &lt; len(prefix) || !strings.EqualFold(auth[:len(prefix)], prefix) </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">c, err := base64.StdEncoding.DecodeString(auth[len(prefix):])
        if err != nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">cs := string(c)
        s := strings.IndexByte(cs, ':')
        if s &lt; 0 </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">return cs[:s], cs[s+1:], true</span>
}

// SetBasicAuth sets the request's Authorization header to use HTTP
// Basic Authentication with the provided username and password.
//
// With HTTP Basic Authentication the provided username and password
// are not encrypted.
func (r *Request) SetBasicAuth(username, password string) <span class="cov8" title="1">{
        r.Header.Set("Authorization", "Basic "+basicAuth(username, password))
}</span>

// parseRequestLine parses "GET /foo HTTP/1.1" into its three parts.
func parseRequestLine(line string) (method, requestURI, proto string, ok bool) <span class="cov8" title="1">{
        s1 := strings.Index(line, " ")
        s2 := strings.Index(line[s1+1:], " ")
        if s1 &lt; 0 || s2 &lt; 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">s2 += s1 + 1
        return line[:s1], line[s1+1 : s2], line[s2+1:], true</span>
}

var textprotoReaderCache sync.Pool

func newTextprotoReader(br *bfe_bufio.Reader) *textproto.Reader <span class="cov8" title="1">{
        r := textprotoReaderCache.Get()
        if r != nil </span><span class="cov8" title="1">{
                tr := r.(*textproto.Reader)
                tr.R = br
                return tr
        }</span>

        <span class="cov8" title="1">return textproto.NewReader(br)</span>
}

func putTextprotoReader(r *textproto.Reader) <span class="cov8" title="1">{
        r.R = nil
        textprotoReaderCache.Put(r)
}</span>

// ReadRequest reads and parses a request from b.
func ReadRequest(b *bfe_bufio.Reader, maxUriBytes int) (req *Request, err error) <span class="cov8" title="1">{
        totalRead := b.TotalRead

        tp := newTextprotoReader(b)
        req = new(Request)
        req.State = new(RequestState)

        // First line: GET /index.html HTTP/1.0
        var s string
        if s, err = tp.ReadLine(); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // mark start as time of reading out first line
        <span class="cov8" title="1">req.State.StartTime = time.Now()

        defer func() </span><span class="cov8" title="1">{
                putTextprotoReader(tp)
                if err == io.EOF </span><span class="cov8" title="1">{
                        err = io.ErrUnexpectedEOF
                }</span>
        }()

        <span class="cov8" title="1">var ok bool
        req.Method, req.RequestURI, req.Proto, ok = parseRequestLine(s)
        if !ok </span><span class="cov0" title="0">{
                return nil, &amp;badStringError{"malformed HTTP request", s}
        }</span>
        <span class="cov8" title="1">rawurl := req.RequestURI

        if len(rawurl) &gt; maxUriBytes </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("exceed maxUriBytes:%d", len(rawurl))
        }</span>

        <span class="cov8" title="1">if req.ProtoMajor, req.ProtoMinor, ok = ParseHTTPVersion(req.Proto); !ok </span><span class="cov0" title="0">{
                return nil, &amp;badStringError{"malformed HTTP version", req.Proto}
        }</span>

        // CONNECT requests are used two different ways, and neither uses a full URL:
        // The standard use is to tunnel HTTPS through an HTTP proxy.
        // It looks like "CONNECT www.google.com:443 HTTP/1.1", and the parameter is
        // just the authority section of a URL. This information should go in req.URL.Host.
        //
        // The net/rpc package also uses CONNECT, but there the parameter is a path
        // that starts with a slash. It can be parsed with the regular URL parser,
        // and the path will end up in req.URL.Path, where it needs to be in order for
        // RPC to work.
        <span class="cov8" title="1">justAuthority := req.Method == MethodConnect &amp;&amp; !strings.HasPrefix(rawurl, "/")
        if justAuthority </span><span class="cov8" title="1">{
                rawurl = "http://" + rawurl
        }</span>

        <span class="cov8" title="1">if req.URL, err = url.ParseRequestURI(rawurl); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if justAuthority </span><span class="cov8" title="1">{
                // Strip the bogus "http://" back off.
                req.URL.Scheme = ""
        }</span>

        // Subsequent lines: Key: value.
        <span class="cov8" title="1">mimeHeader, headerKeys, err := tp.ReadMIMEHeaderAndKeys()
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">req.Header = Header(mimeHeader)
        req.HeaderKeys = headerKeys

        // RFC2616: Must treat
        //        GET /index.html HTTP/1.1
        //        Host: www.google.com
        // and
        //        GET http://www.google.com/index.html HTTP/1.1
        //        Host: doesntmatter
        // the same.  In the second case, any Host line is ignored.
        req.Host = req.URL.Host
        if req.Host == "" </span><span class="cov8" title="1">{
                req.Host = req.Header.GetDirect("Host")
        }</span>
        <span class="cov8" title="1">delete(req.Header, "Host")

        fixPragmaCacheControl(req.Header)

        // TODO: Parse specific header values:
        //        Accept
        //        Accept-Encoding
        //        Accept-Language
        //        Authorization
        //        Cache-Control
        //        Connection
        //        Date
        //        Expect
        //        From
        //        If-Match
        //        If-Modified-Since
        //        If-None-Match
        //        If-Range
        //        If-Unmodified-Since
        //        Max-Forwards
        //        Proxy-Authorization
        //        Referer [sic]
        //        TE (transfer-codings)
        //        Trailer
        //        Transfer-Encoding
        //        Upgrade
        //        User-Agent
        //        Via
        //        Warning

        req.State.HeaderSize = uint32(b.TotalRead - totalRead)

        err = readTransfer(req, b)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return req, nil</span>
}

// MaxBytesReader is similar to io.LimitReader but is intended for
// limiting the size of incoming request bodies. In contrast to
// io.LimitReader, MaxBytesReader's result is a ReadCloser, returns a
// non-EOF error for a Read beyond the limit, and Closes the
// underlying reader when its Close method is called.
//
// MaxBytesReader prevents clients from accidentally or maliciously
// sending a large request and wasting server resources.
func MaxBytesReader(w ResponseWriter, r io.ReadCloser, n int64) io.ReadCloser <span class="cov0" title="0">{
        return &amp;maxBytesReader{w: w, r: r, n: n}
}</span>

type maxBytesReader struct {
        w       ResponseWriter
        r       io.ReadCloser // underlying reader
        n       int64         // max bytes remaining
        stopped bool
}

func (l *maxBytesReader) Read(p []byte) (n int, err error) <span class="cov0" title="0">{
        if l.n &lt;= 0 </span><span class="cov0" title="0">{
                if !l.stopped </span><span class="cov0" title="0">{
                        l.stopped = true
                        //                        if res, ok := l.w.(*response); ok {
                        //                                res.requestTooLarge()
                        //                        }
                }</span>
                <span class="cov0" title="0">return 0, errors.New("http: request body too large")</span>
        }
        <span class="cov0" title="0">if int64(len(p)) &gt; l.n </span><span class="cov0" title="0">{
                p = p[:l.n]
        }</span>
        <span class="cov0" title="0">n, err = l.r.Read(p)
        l.n -= int64(n)
        return</span>
}

func (l *maxBytesReader) Close() error <span class="cov0" title="0">{
        return l.r.Close()
}</span>

func copyValues(dst, src url.Values) <span class="cov8" title="1">{
        for k, vs := range src </span><span class="cov8" title="1">{
                for _, value := range vs </span><span class="cov8" title="1">{
                        dst.Add(k, value)
                }</span>
        }
}

func parsePostForm(r *Request) (vs url.Values, err error) <span class="cov8" title="1">{
        if r.Body == nil </span><span class="cov8" title="1">{
                err = errors.New("missing form body")
                return
        }</span>
        <span class="cov8" title="1">ct := r.Header.Get("Content-Type")
        ct, _, err = mime.ParseMediaType(ct)
        switch </span>{
        case ct == "application/x-www-form-urlencoded":<span class="cov8" title="1">
                var reader io.Reader = r.Body
                maxFormSize := int64(1&lt;&lt;63 - 1)
                if _, ok := r.Body.(*maxBytesReader); !ok </span><span class="cov8" title="1">{
                        maxFormSize = int64(10 &lt;&lt; 20) // 10 MB is a lot of text.
                        reader = io.LimitReader(r.Body, maxFormSize+1)
                }</span>
                <span class="cov8" title="1">b, e := ioutil.ReadAll(reader)
                if e != nil </span><span class="cov0" title="0">{
                        if err == nil </span><span class="cov0" title="0">{
                                err = e
                        }</span>
                        <span class="cov0" title="0">break</span>
                }
                <span class="cov8" title="1">if int64(len(b)) &gt; maxFormSize </span><span class="cov0" title="0">{
                        err = errors.New("http: POST too large")
                        return
                }</span>
                <span class="cov8" title="1">vs, e = url.ParseQuery(string(b))
                if err == nil </span><span class="cov8" title="1">{
                        err = e
                }</span>
        case ct == "multipart/form-data":<span class="cov8" title="1"></span>
                // handled by ParseMultipartForm (which is calling us, or should be)
                // TODO(bradfitz): there are too many possible
                // orders to call too many functions here.
                // Clean this up and write more tests.
                // request_test.go contains the start of this,
                // in TestRequestMultipartCallOrder.
        }
        <span class="cov8" title="1">return</span>
}

// ParseForm parses the raw query from the URL and updates r.Form.
//
// For POST or PUT requests, it also parses the request body as a form and
// put the results into both r.PostForm and r.Form.
// POST and PUT body parameters take precedence over URL query string values
// in r.Form.
//
// If the request Body's size has not already been limited by MaxBytesReader,
// the size is capped at 10MB.
//
// ParseMultipartForm calls ParseForm automatically.
// It is idempotent.
func (r *Request) ParseForm() error <span class="cov8" title="1">{
        var err error
        if r.PostForm == nil </span><span class="cov8" title="1">{
                if r.Method == MethodPost || r.Method == MethodPut </span><span class="cov8" title="1">{
                        r.PostForm, err = parsePostForm(r)
                }</span>
                <span class="cov8" title="1">if r.PostForm == nil </span><span class="cov8" title="1">{
                        r.PostForm = make(url.Values)
                }</span>
        }
        <span class="cov8" title="1">if r.Form == nil </span><span class="cov8" title="1">{
                if len(r.PostForm) &gt; 0 </span><span class="cov8" title="1">{
                        r.Form = make(url.Values)
                        copyValues(r.Form, r.PostForm)
                }</span>
                <span class="cov8" title="1">var newValues url.Values
                if r.URL != nil </span><span class="cov8" title="1">{
                        var e error
                        newValues, e = url.ParseQuery(r.URL.RawQuery)
                        if err == nil </span><span class="cov8" title="1">{
                                err = e
                        }</span>
                }
                <span class="cov8" title="1">if newValues == nil </span><span class="cov8" title="1">{
                        newValues = make(url.Values)
                }</span>
                <span class="cov8" title="1">if r.Form == nil </span><span class="cov8" title="1">{
                        r.Form = newValues
                }</span> else<span class="cov8" title="1"> {
                        copyValues(r.Form, newValues)
                }</span>
        }
        <span class="cov8" title="1">return err</span>
}

// ParseMultipartForm parses a request body as multipart/form-data.
// The whole request body is parsed and up to a total of maxMemory bytes of
// its file parts are stored in memory, with the remainder stored on
// disk in temporary files.
// ParseMultipartForm calls ParseForm if necessary.
// After one call to ParseMultipartForm, subsequent calls have no effect.
func (r *Request) ParseMultipartForm(maxMemory int64) error <span class="cov8" title="1">{
        if r.MultipartForm == multipartByReader </span><span class="cov8" title="1">{
                return errors.New("http: multipart handled by MultipartReader")
        }</span>
        <span class="cov8" title="1">if r.Form == nil </span><span class="cov8" title="1">{
                err := r.ParseForm()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">if r.MultipartForm != nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">mr, err := r.multipartReader()
        if err == ErrNotMultipart </span><span class="cov8" title="1">{
                return nil
        }</span> else<span class="cov8" title="1"> if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">f, err := mr.ReadForm(maxMemory)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">for k, v := range f.Value </span><span class="cov8" title="1">{
                r.Form[k] = append(r.Form[k], v...)
        }</span>
        <span class="cov8" title="1">r.MultipartForm = f

        return nil</span>
}

// FormValue returns the first value for the named component of the query.
// POST and PUT body parameters take precedence over URL query string values.
// FormValue calls ParseMultipartForm and ParseForm if necessary.
// To access multiple values of the same key use ParseForm.
func (r *Request) FormValue(key string) string <span class="cov8" title="1">{
        if r.Form == nil </span><span class="cov8" title="1">{
                r.ParseMultipartForm(defaultMaxMemory)
        }</span>
        <span class="cov8" title="1">if vs := r.Form[key]; len(vs) &gt; 0 </span><span class="cov8" title="1">{
                return vs[0]
        }</span>
        <span class="cov8" title="1">return ""</span>
}

// PostFormValue returns the first value for the named component of the POST
// or PUT request body. URL query parameters are ignored.
// PostFormValue calls ParseMultipartForm and ParseForm if necessary.
func (r *Request) PostFormValue(key string) string <span class="cov8" title="1">{
        if r.PostForm == nil </span><span class="cov0" title="0">{
                r.ParseMultipartForm(defaultMaxMemory)
        }</span>
        <span class="cov8" title="1">if vs := r.PostForm[key]; len(vs) &gt; 0 </span><span class="cov8" title="1">{
                return vs[0]
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// FormFile returns the first file for the provided form key.
// FormFile calls ParseMultipartForm and ParseForm if necessary.
func (r *Request) FormFile(key string) (multipart.File, *multipart.FileHeader, error) <span class="cov8" title="1">{
        if r.MultipartForm == multipartByReader </span><span class="cov0" title="0">{
                return nil, nil, errors.New("http: multipart handled by MultipartReader")
        }</span>
        <span class="cov8" title="1">if r.MultipartForm == nil </span><span class="cov8" title="1">{
                err := r.ParseMultipartForm(defaultMaxMemory)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, err
                }</span>
        }
        <span class="cov8" title="1">if r.MultipartForm != nil &amp;&amp; r.MultipartForm.File != nil </span><span class="cov8" title="1">{
                if fhs := r.MultipartForm.File[key]; len(fhs) &gt; 0 </span><span class="cov8" title="1">{
                        f, err := fhs[0].Open()
                        return f, fhs[0], err
                }</span>
        }
        <span class="cov8" title="1">return nil, nil, ErrMissingFile</span>
}

func (r *Request) ExpectsContinue() bool <span class="cov0" title="0">{
        return HasToken(r.Header.GetDirect("Expect"), "100-continue")
}</span>

func (r *Request) WantsHttp10KeepAlive() bool <span class="cov0" title="0">{
        if r.ProtoMajor != 1 || r.ProtoMinor != 0 </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return HasToken(r.Header.GetDirect("Connection"), "keep-alive")</span>
}

func (r *Request) WantsClose() bool <span class="cov0" title="0">{
        return HasToken(r.Header.GetDirect("Connection"), "close")
}</span>

func (r *Request) closeBody() <span class="cov0" title="0">{
        if r.Body != nil </span><span class="cov0" title="0">{
                r.Body.Close()
        }</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// HTTP Response reading and parsing.

package bfe_http

import (
        "errors"
        "io"
        "net/http"
        "net/url"
        "strconv"
        "strings"
)

import (
        "github.com/bfenetworks/bfe/bfe_bufio"
        "github.com/bfenetworks/bfe/bfe_net/textproto"
        "github.com/bfenetworks/bfe/bfe_tls"
)

var respExcludeHeader = map[string]bool{
        "Content-Length":    true,
        "Transfer-Encoding": true,
        "Trailer":           true,
}

// The SignCalculator interface is used to calculate signature for response
type SignCalculator interface {
        CalcSign(feature string) string
}

// Response represents the response from an HTTP request.
//
type Response struct {
        Status     string // e.g. "200 OK"
        StatusCode int    // e.g. 200
        Proto      string // e.g. "HTTP/1.0"
        ProtoMajor int    // e.g. 1
        ProtoMinor int    // e.g. 0

        // Header maps header keys to values.  If the response had multiple
        // headers with the same key, they may be concatenated, with comma
        // delimiters.  (Section 4.2 of RFC 2616 requires that multiple headers
        // be semantically equivalent to a comma-delimited sequence.) Values
        // duplicated by other fields in this struct (e.g., ContentLength) are
        // omitted from Header.
        //
        // Keys in the map are canonicalized (see CanonicalHeaderKey).
        Header Header

        // Body represents the response body.
        //
        // The http Client and Transport guarantee that Body is always
        // non-nil, even on responses without a body or responses with
        // a zero-lengthed body.
        //
        // The Body is automatically dechunked if the server replied
        // with a "chunked" Transfer-Encoding.
        Body io.ReadCloser

        // ContentLength records the length of the associated content.  The
        // value -1 indicates that the length is unknown.  Unless Request.Method
        // is "HEAD", values &gt;= 0 indicate that the given number of bytes may
        // be read from Body.
        ContentLength int64

        // Contains transfer encodings from outer-most to inner-most. Value is
        // nil, means that "identity" encoding is used.
        TransferEncoding []string

        // Signer calculate signature for response
        Signer SignCalculator

        // Close records whether the header directed that the connection be
        // closed after reading Body.  The value is advice for clients: neither
        // ReadResponse nor Response.Write ever closes a connection.
        Close bool

        // Trailer maps trailer keys to values, in the same
        // format as the header.
        Trailer Header

        H2Trailer *http.Header

        // The Request that was sent to obtain this Response.
        // Request's Body is nil (having already been consumed).
        // This is only populated for Client requests.
        Request *Request

        // TLS contains information about the TLS connection on which the
        // response was received. It is nil for unencrypted responses.
        // The pointer is shared between responses and should not be
        // modified.
        TLS *bfe_tls.ConnectionState
}

// Cookies parses and returns the cookies set in the Set-Cookie headers.
func (r *Response) Cookies() []*Cookie <span class="cov0" title="0">{
        return readSetCookies(r.Header)
}</span>

var ErrNoLocation = errors.New("http: no Location header in response")

// Location returns the URL of the response's "Location" header,
// if present.  Relative redirects are resolved relative to
// the Response's Request.  ErrNoLocation is returned if no
// Location header is present.
func (r *Response) Location() (*url.URL, error) <span class="cov8" title="1">{
        lv := r.Header.Get("Location")
        if lv == "" </span><span class="cov8" title="1">{
                return nil, ErrNoLocation
        }</span>
        <span class="cov8" title="1">if r.Request != nil &amp;&amp; r.Request.URL != nil </span><span class="cov8" title="1">{
                return r.Request.URL.Parse(lv)
        }</span>
        <span class="cov0" title="0">return url.Parse(lv)</span>
}

// ReadResponse reads and returns an HTTP response from r.
// The req parameter optionally specifies the Request that corresponds
// to this Response. If nil, a GET request is assumed.
// Clients must call resp.Body.Close when finished reading resp.Body.
// After that call, clients can inspect resp.Trailer to find key/value
// pairs included in the response trailer.
func ReadResponse(r *bfe_bufio.Reader, req *Request) (*Response, error) <span class="cov8" title="1">{
        tp := textproto.NewReader(r)
        resp := &amp;Response{
                Request: req,
        }

        // Parse the first line of the response.
        line, err := tp.ReadLine()
        if err != nil </span><span class="cov0" title="0">{
                if err == io.EOF </span><span class="cov0" title="0">{
                        err = io.ErrUnexpectedEOF
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov8" title="1">f := strings.SplitN(line, " ", 3)
        if len(f) &lt; 2 </span><span class="cov0" title="0">{
                return nil, &amp;badStringError{"malformed HTTP response", line}
        }</span>
        <span class="cov8" title="1">reasonPhrase := ""
        if len(f) &gt; 2 </span><span class="cov8" title="1">{
                reasonPhrase = f[2]
        }</span>
        <span class="cov8" title="1">resp.Status = f[1] + " " + reasonPhrase
        resp.StatusCode, err = strconv.Atoi(f[1])
        if err != nil </span><span class="cov0" title="0">{
                return nil, &amp;badStringError{"malformed HTTP status code", f[1]}
        }</span>

        <span class="cov8" title="1">resp.Proto = f[0]
        var ok bool
        if resp.ProtoMajor, resp.ProtoMinor, ok = ParseHTTPVersion(resp.Proto); !ok </span><span class="cov0" title="0">{
                return nil, &amp;badStringError{"malformed HTTP version", resp.Proto}
        }</span>

        // Parse the response headers.
        <span class="cov8" title="1">mimeHeader, err := tp.ReadMIMEHeader()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">resp.Header = Header(mimeHeader)

        fixPragmaCacheControl(resp.Header)

        err = readTransfer(resp, r)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return resp, nil</span>
}

// RFC2616: Should treat
//        Pragma: no-cache
// like
//        Cache-Control: no-cache
func fixPragmaCacheControl(header Header) <span class="cov8" title="1">{
        if hp, ok := header["Pragma"]; ok &amp;&amp; len(hp) &gt; 0 &amp;&amp; hp[0] == "no-cache" </span><span class="cov0" title="0">{
                if _, presentcc := header["Cache-Control"]; !presentcc </span><span class="cov0" title="0">{
                        header["Cache-Control"] = []string{"no-cache"}
                }</span>
        }
}

// ProtoAtLeast reports whether the HTTP protocol used
// in the response is at least major.minor.
func (r *Response) ProtoAtLeast(major, minor int) bool <span class="cov8" title="1">{
        return r.ProtoMajor &gt; major ||
                r.ProtoMajor == major &amp;&amp; r.ProtoMinor &gt;= minor
}</span>

// Writes the response (header, body and trailer) in wire format. This method
// consults the following fields of the response:
//
//  StatusCode
//  ProtoMajor
//  ProtoMinor
//  Request.Method
//  TransferEncoding
//  Trailer
//  Body
//  ContentLength
//  Header, values for non-canonical keys will have unpredictable behavior
//
func (r *Response) Write(w io.Writer) error <span class="cov8" title="1">{

        // Status line
        text := r.Status
        if text == "" </span><span class="cov8" title="1">{
                var ok bool
                text, ok = StatusText[r.StatusCode]
                if !ok </span><span class="cov0" title="0">{
                        text = "status code " + strconv.Itoa(r.StatusCode)
                }</span>
        }
        <span class="cov8" title="1">protoMajor, protoMinor := strconv.Itoa(r.ProtoMajor), strconv.Itoa(r.ProtoMinor)
        statusCode := strconv.Itoa(r.StatusCode) + " "
        text = strings.TrimPrefix(text, statusCode)
        io.WriteString(w, "HTTP/"+protoMajor+"."+protoMinor+" "+statusCode+text+"\r\n")

        // Process Body,ContentLength,Close,Trailer
        tw, err := newTransferWriter(r)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">err = tw.WriteHeader(w)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Rest of header
        <span class="cov8" title="1">err = r.Header.WriteSubset(w, respExcludeHeader)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // End-of-header
        <span class="cov8" title="1">io.WriteString(w, "\r\n")

        // Write body and trailer
        _, err = tw.WriteBody(w)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Success
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Copyright 2011 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package bfe_http

import (
        "bytes"
        "encoding/binary"
)

// The algorithm uses at most sniffLen bytes to make its decision.
const sniffLen = 512

// DetectContentType implements the algorithm described
// at http://mimesniff.spec.whatwg.org/ to determine the
// Content-Type of the given data.  It considers at most the
// first 512 bytes of data.  DetectContentType always returns
// a valid MIME type: if it cannot determine a more specific one, it
// returns "application/octet-stream".
func DetectContentType(data []byte) string <span class="cov0" title="0">{
        if len(data) &gt; sniffLen </span><span class="cov0" title="0">{
                data = data[:sniffLen]
        }</span>

        // Index of the first non-whitespace byte in data.
        <span class="cov0" title="0">firstNonWS := 0
        for ; firstNonWS &lt; len(data) &amp;&amp; isWS(data[firstNonWS]); firstNonWS++ </span>{<span class="cov0" title="0">
        }</span>

        <span class="cov0" title="0">for _, sig := range sniffSignatures </span><span class="cov0" title="0">{
                if ct := sig.match(data, firstNonWS); ct != "" </span><span class="cov0" title="0">{
                        return ct
                }</span>
        }

        <span class="cov0" title="0">return "application/octet-stream"</span> // fallback
}

func isWS(b byte) bool <span class="cov0" title="0">{
        return bytes.IndexByte([]byte("\t\n\x0C\r "), b) != -1
}</span>

type sniffSig interface {
        // match returns the MIME type of the data, or "" if unknown.
        match(data []byte, firstNonWS int) string
}

// Data matching the table in section 6.
var sniffSignatures = []sniffSig{
        htmlSig("&lt;!DOCTYPE HTML"),
        htmlSig("&lt;HTML"),
        htmlSig("&lt;HEAD"),
        htmlSig("&lt;SCRIPT"),
        htmlSig("&lt;IFRAME"),
        htmlSig("&lt;H1"),
        htmlSig("&lt;DIV"),
        htmlSig("&lt;FONT"),
        htmlSig("&lt;TABLE"),
        htmlSig("&lt;A"),
        htmlSig("&lt;STYLE"),
        htmlSig("&lt;TITLE"),
        htmlSig("&lt;B"),
        htmlSig("&lt;BODY"),
        htmlSig("&lt;BR"),
        htmlSig("&lt;P"),
        htmlSig("&lt;!--"),

        &amp;maskedSig{mask: []byte("\xFF\xFF\xFF\xFF\xFF"), pat: []byte("&lt;?xml"), skipWS: true, ct: "text/xml; charset=utf-8"},

        &amp;exactSig{[]byte("%PDF-"), "application/pdf"},
        &amp;exactSig{[]byte("%!PS-Adobe-"), "application/postscript"},

        // UTF BOMs.
        &amp;maskedSig{mask: []byte("\xFF\xFF\x00\x00"), pat: []byte("\xFE\xFF\x00\x00"), ct: "text/plain; charset=utf-16be"},
        &amp;maskedSig{mask: []byte("\xFF\xFF\x00\x00"), pat: []byte("\xFF\xFE\x00\x00"), ct: "text/plain; charset=utf-16le"},
        &amp;maskedSig{mask: []byte("\xFF\xFF\xFF\x00"), pat: []byte("\xEF\xBB\xBF\x00"), ct: "text/plain; charset=utf-8"},

        &amp;exactSig{[]byte("GIF87a"), "image/gif"},
        &amp;exactSig{[]byte("GIF89a"), "image/gif"},
        &amp;exactSig{[]byte("\x89\x50\x4E\x47\x0D\x0A\x1A\x0A"), "image/png"},
        &amp;exactSig{[]byte("\xFF\xD8\xFF"), "image/jpeg"},
        &amp;exactSig{[]byte("BM"), "image/bmp"},
        &amp;maskedSig{
                mask: []byte("\xFF\xFF\xFF\xFF\x00\x00\x00\x00\xFF\xFF\xFF\xFF\xFF\xFF"),
                pat:  []byte("RIFF\x00\x00\x00\x00WEBPVP"),
                ct:   "image/webp",
        },
        &amp;exactSig{[]byte("\x00\x00\x01\x00"), "image/vnd.microsoft.icon"},
        &amp;exactSig{[]byte("\x4F\x67\x67\x53\x00"), "application/ogg"},
        &amp;maskedSig{
                mask: []byte("\xFF\xFF\xFF\xFF\x00\x00\x00\x00\xFF\xFF\xFF\xFF"),
                pat:  []byte("RIFF\x00\x00\x00\x00WAVE"),
                ct:   "audio/wave",
        },
        &amp;exactSig{[]byte("\x1A\x45\xDF\xA3"), "video/webm"},
        &amp;exactSig{[]byte("\x52\x61\x72\x20\x1A\x07\x00"), "application/x-rar-compressed"},
        &amp;exactSig{[]byte("\x50\x4B\x03\x04"), "application/zip"},
        &amp;exactSig{[]byte("\x1F\x8B\x08"), "application/x-gzip"},

        // TODO(dsymonds): Re-enable this when the spec is sorted w.r.t. MP4.
        //mp4Sig(0),

        textSig(0), // should be last
}

type exactSig struct {
        sig []byte
        ct  string
}

func (e *exactSig) match(data []byte, firstNonWS int) string <span class="cov0" title="0">{
        if bytes.HasPrefix(data, e.sig) </span><span class="cov0" title="0">{
                return e.ct
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type maskedSig struct {
        mask, pat []byte
        skipWS    bool
        ct        string
}

func (m *maskedSig) match(data []byte, firstNonWS int) string <span class="cov0" title="0">{
        if m.skipWS </span><span class="cov0" title="0">{
                data = data[firstNonWS:]
        }</span>
        <span class="cov0" title="0">if len(data) &lt; len(m.mask) </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">for i, mask := range m.mask </span><span class="cov0" title="0">{
                db := data[i] &amp; mask
                if db != m.pat[i] </span><span class="cov0" title="0">{
                        return ""
                }</span>
        }
        <span class="cov0" title="0">return m.ct</span>
}

type htmlSig []byte

func (h htmlSig) match(data []byte, firstNonWS int) string <span class="cov0" title="0">{
        data = data[firstNonWS:]
        if len(data) &lt; len(h)+1 </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">for i, b := range h </span><span class="cov0" title="0">{
                db := data[i]
                if 'A' &lt;= b &amp;&amp; b &lt;= 'Z' </span><span class="cov0" title="0">{
                        db &amp;= 0xDF
                }</span>
                <span class="cov0" title="0">if b != db </span><span class="cov0" title="0">{
                        return ""
                }</span>
        }
        // Next byte must be space or right angle bracket.
        <span class="cov0" title="0">if db := data[len(h)]; db != ' ' &amp;&amp; db != '&gt;' </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return "text/html; charset=utf-8"</span>
}

type mp4Sig int

func (mp4Sig) match(data []byte, firstNonWS int) string <span class="cov0" title="0">{
        // c.f. section 6.1.
        if len(data) &lt; 8 </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">boxSize := int(binary.BigEndian.Uint32(data[:4]))
        if boxSize%4 != 0 || len(data) &lt; boxSize </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">if !bytes.Equal(data[4:8], []byte("ftyp")) </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">for st := 8; st &lt; boxSize; st += 4 </span><span class="cov0" title="0">{
                if st == 12 </span><span class="cov0" title="0">{
                        // minor version number
                        continue</span>
                }
                <span class="cov0" title="0">seg := string(data[st : st+3])
                switch seg </span>{
                case "mp4", "iso", "M4V", "M4P", "M4B":<span class="cov0" title="0">
                        return "video/mp4"</span>
                        /* The remainder are not in the spec.
                        case "M4A":
                                return "audio/mp4"
                        case "3gp":
                                return "video/3gpp"
                        case "jp2":
                                return "image/jp2" // JPEG 2000
                        */
                }
        }
        <span class="cov0" title="0">return ""</span>
}

type textSig int

func (textSig) match(data []byte, firstNonWS int) string <span class="cov0" title="0">{
        // c.f. section 5, step 4.
        for _, b := range data[firstNonWS:] </span><span class="cov0" title="0">{
                switch </span>{
                case 0x00 &lt;= b &amp;&amp; b &lt;= 0x08,
                        b == 0x0B,
                        0x0E &lt;= b &amp;&amp; b &lt;= 0x1A,
                        0x1C &lt;= b &amp;&amp; b &lt;= 0x1F:<span class="cov0" title="0">
                        return ""</span>
                }
        }
        <span class="cov0" title="0">return "text/plain; charset=utf-8"</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// internal state of http

package bfe_http

import (
        "github.com/baidu/go-lib/web-monitor/metrics"
)

type HttpState struct {
        HttpBackendConnAll       *metrics.Counter
        HttpBackendConnSucc      *metrics.Counter
        HttpBackendReqAll        *metrics.Counter
        HttpBackendReqSucc       *metrics.Counter
        HttpCancelOnClientClose  *metrics.Counter
        HttpPanicBackendRead     *metrics.Counter
        HttpPanicBackendWrite    *metrics.Counter
        HttpPanicClientFlushLoop *metrics.Counter
        HttpPanicClientWatchLoop *metrics.Counter
}

var state HttpState

func GetHttpState() *HttpState <span class="cov0" title="0">{
        return &amp;state
}</span>
</pre>
		
		<pre class="file" id="file50" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package bfe_http

// HTTP status codes, defined in RFC 2616.
const (
        StatusContinue           = 100
        StatusSwitchingProtocols = 101

        StatusOK                   = 200
        StatusCreated              = 201
        StatusAccepted             = 202
        StatusNonAuthoritativeInfo = 203
        StatusNoContent            = 204
        StatusResetContent         = 205
        StatusPartialContent       = 206

        StatusMultipleChoices   = 300
        StatusMovedPermanently  = 301
        StatusFound             = 302
        StatusSeeOther          = 303
        StatusNotModified       = 304
        StatusUseProxy          = 305
        StatusTemporaryRedirect = 307

        StatusBadRequest                   = 400
        StatusUnauthorized                 = 401
        StatusPaymentRequired              = 402
        StatusForbidden                    = 403
        StatusNotFound                     = 404
        StatusMethodNotAllowed             = 405
        StatusNotAcceptable                = 406
        StatusProxyAuthRequired            = 407
        StatusRequestTimeout               = 408
        StatusConflict                     = 409
        StatusGone                         = 410
        StatusLengthRequired               = 411
        StatusPreconditionFailed           = 412
        StatusRequestEntityTooLarge        = 413
        StatusRequestURITooLong            = 414
        StatusUnsupportedMediaType         = 415
        StatusRequestedRangeNotSatisfiable = 416
        StatusExpectationFailed            = 417
        StatusTeapot                       = 418

        StatusInternalServerError     = 500
        StatusNotImplemented          = 501
        StatusBadGateway              = 502
        StatusServiceUnavailable      = 503
        StatusGatewayTimeout          = 504
        StatusHTTPVersionNotSupported = 505

        // New HTTP status codes from RFC 6585. Not exported yet in Go 1.1.
        // See discussion at https://codereview.appspot.com/7678043/
        statusPreconditionRequired          = 428
        statusTooManyRequests               = 429
        statusRequestHeaderFieldsTooLarge   = 431
        statusNetworkAuthenticationRequired = 511
)

var StatusText = map[int]string{
        StatusContinue:           "Continue",
        StatusSwitchingProtocols: "Switching Protocols",

        StatusOK:                   "OK",
        StatusCreated:              "Created",
        StatusAccepted:             "Accepted",
        StatusNonAuthoritativeInfo: "Non-Authoritative Information",
        StatusNoContent:            "No Content",
        StatusResetContent:         "Reset Content",
        StatusPartialContent:       "Partial Content",

        StatusMultipleChoices:   "Multiple Choices",
        StatusMovedPermanently:  "Moved Permanently",
        StatusFound:             "Found",
        StatusSeeOther:          "See Other",
        StatusNotModified:       "Not Modified",
        StatusUseProxy:          "Use Proxy",
        StatusTemporaryRedirect: "Temporary Redirect",

        StatusBadRequest:                   "Bad Request",
        StatusUnauthorized:                 "Unauthorized",
        StatusPaymentRequired:              "Payment Required",
        StatusForbidden:                    "Forbidden",
        StatusNotFound:                     "Not Found",
        StatusMethodNotAllowed:             "Method Not Allowed",
        StatusNotAcceptable:                "Not Acceptable",
        StatusProxyAuthRequired:            "Proxy Authentication Required",
        StatusRequestTimeout:               "Request Timeout",
        StatusConflict:                     "Conflict",
        StatusGone:                         "Gone",
        StatusLengthRequired:               "Length Required",
        StatusPreconditionFailed:           "Precondition Failed",
        StatusRequestEntityTooLarge:        "Request Entity Too Large",
        StatusRequestURITooLong:            "Request URI Too Long",
        StatusUnsupportedMediaType:         "Unsupported Media Type",
        StatusRequestedRangeNotSatisfiable: "Requested Range Not Satisfiable",
        StatusExpectationFailed:            "Expectation Failed",
        StatusTeapot:                       "I'm a teapot",

        StatusInternalServerError:     "Internal Server Error",
        StatusNotImplemented:          "Not Implemented",
        StatusBadGateway:              "Bad Gateway",
        StatusServiceUnavailable:      "Service Unavailable",
        StatusGatewayTimeout:          "Gateway Timeout",
        StatusHTTPVersionNotSupported: "HTTP Version Not Supported",

        statusPreconditionRequired:          "Precondition Required",
        statusTooManyRequests:               "Too Many Requests",
        statusRequestHeaderFieldsTooLarge:   "Request Header Fields Too Large",
        statusNetworkAuthenticationRequired: "Network Authentication Required",
}

// StatusTextGet returns a text for the HTTP status code. It returns the empty
// string if the code is unknown.
func StatusTextGet(code int) string <span class="cov0" title="0">{
        return StatusText[code]
}</span>
</pre>
		
		<pre class="file" id="file51" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package bfe_http

import (
        "bytes"
        "errors"
        "fmt"
        "io"
        "io/ioutil"
        "strconv"
        "strings"
        "sync"
)

import (
        "github.com/bfenetworks/bfe/bfe_bufio"
        "github.com/bfenetworks/bfe/bfe_net/textproto"
)

// transferWriter inspects the fields of a user-supplied Request or Response,
// sanitizes them without changing the user object and provides methods for
// writing the respective header, body and trailer in wire format.
type transferWriter struct {
        Method           string
        Body             io.Reader
        BodyCloser       io.Closer
        ResponseToHEAD   bool
        Close            bool
        ContentLength    int64 // -1 means unknown, 0 means exactly none
        TransferEncoding []string
        Header           Header
        Trailer          Header
}

func newTransferWriter(r interface{}) (t *transferWriter, err error) <span class="cov8" title="1">{
        t = &amp;transferWriter{}

        // Extract relevant fields
        atLeastHTTP11 := false
        switch rr := r.(type) </span>{
        case *Request:<span class="cov8" title="1">
                if rr.ContentLength != 0 &amp;&amp; rr.Body == nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("http: Request.ContentLength=%d with nil Body", rr.ContentLength)
                }</span>
                <span class="cov8" title="1">t.Method = rr.Method
                t.Body = rr.Body
                t.BodyCloser = rr.Body
                t.ContentLength = rr.ContentLength
                t.Close = rr.Close
                t.TransferEncoding = rr.TransferEncoding
                t.Header = rr.Header
                t.Trailer = rr.Trailer
                atLeastHTTP11 = rr.ProtoAtLeast(1, 1)
                if t.Body != nil &amp;&amp; len(t.TransferEncoding) == 0 &amp;&amp; atLeastHTTP11 </span><span class="cov8" title="1">{
                        if t.ContentLength == 0 </span><span class="cov8" title="1">{
                                // Test to see if it's actually zero or just unset.
                                var buf [1]byte
                                n, _ := io.ReadFull(t.Body, buf[:])
                                if n == 1 </span><span class="cov8" title="1">{
                                        // Oh, guess there is data in this Body Reader after all.
                                        // The ContentLength field just wasn't set.
                                        // Stich the Body back together again, re-attaching our
                                        // consumed byte.
                                        t.ContentLength = -1
                                        t.Body = io.MultiReader(bytes.NewBuffer(buf[:]), t.Body)
                                }</span> else<span class="cov8" title="1"> {
                                        // Body is actually empty.
                                        t.Body = nil
                                        t.BodyCloser = nil
                                }</span>
                        }
                        <span class="cov8" title="1">if t.ContentLength &lt; 0 </span><span class="cov8" title="1">{
                                t.TransferEncoding = []string{"chunked"}
                        }</span>
                }
        case *Response:<span class="cov8" title="1">
                if rr.Request != nil </span><span class="cov8" title="1">{
                        t.Method = rr.Request.Method
                }</span>
                <span class="cov8" title="1">t.Body = rr.Body
                t.BodyCloser = rr.Body
                t.ContentLength = rr.ContentLength
                t.Close = rr.Close
                t.TransferEncoding = rr.TransferEncoding
                t.Header = rr.Header
                t.Trailer = rr.Trailer
                atLeastHTTP11 = rr.ProtoAtLeast(1, 1)
                t.ResponseToHEAD = noBodyExpected(t.Method)</span>
        }

        // Sanitize Body,ContentLength,TransferEncoding
        <span class="cov8" title="1">if t.ResponseToHEAD </span><span class="cov8" title="1">{
                t.Body = nil
                if chunked(t.TransferEncoding) </span><span class="cov8" title="1">{
                        t.ContentLength = -1
                }</span>
        } else<span class="cov8" title="1"> {
                if !atLeastHTTP11 || t.Body == nil </span><span class="cov8" title="1">{
                        t.TransferEncoding = nil
                }</span>
                <span class="cov8" title="1">if chunked(t.TransferEncoding) </span><span class="cov8" title="1">{
                        t.ContentLength = -1
                }</span> else<span class="cov8" title="1"> if t.Body == nil </span><span class="cov8" title="1">{ // no chunking, no body
                        t.ContentLength = 0
                }</span>
        }

        // Sanitize Trailer
        <span class="cov8" title="1">if !chunked(t.TransferEncoding) </span><span class="cov8" title="1">{
                t.Trailer = nil
        }</span>

        <span class="cov8" title="1">return t, nil</span>
}

func noBodyExpected(requestMethod string) bool <span class="cov8" title="1">{
        return requestMethod == MethodHead
}</span>

func (t *transferWriter) shouldSendContentLength() bool <span class="cov8" title="1">{
        if chunked(t.TransferEncoding) </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if t.ContentLength &gt; 0 </span><span class="cov8" title="1">{
                return true
        }</span>

        // contentLength is 0, but have Content-Length in origin header
        // Some backends expect a Content-Length header
        <span class="cov8" title="1">if t.ContentLength == 0 &amp;&amp; t.Header.Get("Content-Length") != "" </span><span class="cov8" title="1">{
                if t.Method == "GET" || t.Method == "HEAD" </span><span class="cov8" title="1">{
                        return false
                }</span>
                <span class="cov0" title="0">return true</span>
        }

        <span class="cov8" title="1">return false</span>
}

func (t *transferWriter) WriteHeader(w io.Writer) (err error) <span class="cov8" title="1">{
        if t.Close </span><span class="cov8" title="1">{
                _, err = io.WriteString(w, "Connection: close\r\n")
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        // Write Content-Length and/or Transfer-Encoding whose values are a
        // function of the sanitized field triple (Body, ContentLength,
        // TransferEncoding)
        <span class="cov8" title="1">if t.shouldSendContentLength() </span><span class="cov8" title="1">{
                io.WriteString(w, "Content-Length: ")
                _, err = io.WriteString(w, strconv.FormatInt(t.ContentLength, 10)+"\r\n")
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
        } else<span class="cov8" title="1"> if chunked(t.TransferEncoding) </span><span class="cov8" title="1">{
                _, err = io.WriteString(w, "Transfer-Encoding: chunked\r\n")
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        // Write Trailer header
        <span class="cov8" title="1">if t.Trailer != nil </span><span class="cov0" title="0">{
                // TODO: At some point, there should be a generic mechanism for
                // writing long headers, using HTTP line splitting
                io.WriteString(w, "Trailer: ")
                needComma := false
                for k := range t.Trailer </span><span class="cov0" title="0">{
                        k = CanonicalHeaderKey(k)
                        switch k </span>{
                        case "Transfer-Encoding", "Trailer", "Content-Length":<span class="cov0" title="0">
                                return &amp;badStringError{"invalid Trailer key", k}</span>
                        }
                        <span class="cov0" title="0">if needComma </span><span class="cov0" title="0">{
                                io.WriteString(w, ",")
                        }</span>
                        <span class="cov0" title="0">io.WriteString(w, k)
                        needComma = true</span>
                }
                <span class="cov0" title="0">_, err = io.WriteString(w, "\r\n")</span>
        }

        <span class="cov8" title="1">return</span>
}

func (t *transferWriter) WriteBody(w io.Writer) (ncopy int64, err error) <span class="cov8" title="1">{
        // Write body
        if t.Body != nil </span><span class="cov8" title="1">{

                if chunked(t.TransferEncoding) </span><span class="cov8" title="1">{
                        cw := newChunkedWriter(w)
                        _, err = io.Copy(cw, t.Body)
                        if err == nil </span><span class="cov8" title="1">{
                                err = cw.Close()
                        }</span>
                } else<span class="cov8" title="1"> if t.ContentLength == -1 </span><span class="cov8" title="1">{
                        ncopy, err = io.Copy(w, t.Body)
                }</span> else<span class="cov8" title="1"> {
                        ncopy, err = io.Copy(w, io.LimitReader(t.Body, t.ContentLength))
                        if err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov8" title="1">var nextra int64
                        nextra, err = io.Copy(ioutil.Discard, t.Body)
                        ncopy += nextra</span>
                }
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov8" title="1">if err = t.BodyCloser.Close(); err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        <span class="cov8" title="1">if !t.ResponseToHEAD &amp;&amp; t.ContentLength != -1 &amp;&amp; t.ContentLength != ncopy </span><span class="cov8" title="1">{
                err = fmt.Errorf("http: Request.ContentLength=%d with Body length %d",
                        t.ContentLength, ncopy)
                return
        }</span>

        // TODO(petar): Place trailer writer code here.
        <span class="cov8" title="1">if chunked(t.TransferEncoding) </span><span class="cov8" title="1">{
                // Last chunk, empty trailer
                _, err = io.WriteString(w, "\r\n")
        }</span>

        <span class="cov8" title="1">return</span>
}

type transferReader struct {
        // Input
        Header        Header
        StatusCode    int
        RequestMethod string
        ProtoMajor    int
        ProtoMinor    int
        // Output
        Body             io.ReadCloser
        ContentLength    int64
        TransferEncoding []string
        Close            bool
        Trailer          Header
}

// bodyAllowedForStatus reports whether a given response status code
// permits a body.  See RFC2616, section 4.4.
func bodyAllowedForStatus(status int) bool <span class="cov8" title="1">{
        switch </span>{
        case status &gt;= StatusContinue &amp;&amp; status &lt;= 199:<span class="cov0" title="0">
                return false</span>
        case status == StatusNoContent:<span class="cov0" title="0">
                return false</span>
        case status == StatusNotModified:<span class="cov0" title="0">
                return false</span>
        }
        <span class="cov8" title="1">return true</span>
}

// msg is *Request or *Response.
func readTransfer(msg interface{}, r *bfe_bufio.Reader) (err error) <span class="cov8" title="1">{
        t := &amp;transferReader{RequestMethod: MethodGet}

        // Unify input
        isResponse := false
        switch rr := msg.(type) </span>{
        case *Response:<span class="cov8" title="1">
                t.Header = rr.Header
                t.StatusCode = rr.StatusCode
                t.ProtoMajor = rr.ProtoMajor
                t.ProtoMinor = rr.ProtoMinor
                t.Close = shouldClose(t.ProtoMajor, t.ProtoMinor, t.Header)
                isResponse = true
                if rr.Request != nil </span><span class="cov8" title="1">{
                        t.RequestMethod = rr.Request.Method
                }</span>
        case *Request:<span class="cov8" title="1">
                t.Header = rr.Header
                t.RequestMethod = rr.Method
                t.ProtoMajor = rr.ProtoMajor
                t.ProtoMinor = rr.ProtoMinor
                // Transfer semantics for Requests are exactly like those for
                // Responses with status code 200, responding to a GET method
                t.StatusCode = StatusOK</span>
        default:<span class="cov0" title="0">
                panic("unexpected type")</span>
        }

        // Default to HTTP/1.1
        <span class="cov8" title="1">if t.ProtoMajor == 0 &amp;&amp; t.ProtoMinor == 0 </span><span class="cov0" title="0">{
                t.ProtoMajor, t.ProtoMinor = 1, 1
        }</span>

        // Transfer encoding, content length
        <span class="cov8" title="1">t.TransferEncoding, err = fixTransferEncoding(isResponse, t.RequestMethod, t.Header)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">realLength, err := fixLength(isResponse, t.StatusCode, t.RequestMethod, t.Header, t.TransferEncoding)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if isResponse &amp;&amp; t.RequestMethod == MethodHead </span><span class="cov8" title="1">{
                if n, err := parseContentLength(t.Header.GetDirect("Content-Length")); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span> else<span class="cov8" title="1"> {
                        t.ContentLength = n
                }</span>
        } else<span class="cov8" title="1"> {
                t.ContentLength = realLength
        }</span>

        // Trailer
        <span class="cov8" title="1">t.Trailer, err = fixTrailer(t.Header, t.TransferEncoding)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // If there is no Content-Length or chunked Transfer-Encoding on a *Response
        // and the status is not 1xx, 204 or 304, then the body is unbounded.
        // See RFC2616, section 4.4.
        <span class="cov8" title="1">switch msg.(type) </span>{
        case *Response:<span class="cov8" title="1">
                if realLength == -1 &amp;&amp;
                        !chunked(t.TransferEncoding) &amp;&amp;
                        bodyAllowedForStatus(t.StatusCode) </span><span class="cov8" title="1">{
                        // Unbounded body.
                        t.Close = true
                }</span>
        }

        // Prepare body reader.  ContentLength &lt; 0 means chunked encoding
        // or close connection when finished, since multipart is not supported yet
        <span class="cov8" title="1">switch </span>{
        case chunked(t.TransferEncoding):<span class="cov8" title="1">
                if noBodyExpected(t.RequestMethod) </span><span class="cov8" title="1">{
                        t.Body = EofReader
                }</span> else<span class="cov8" title="1"> {
                        t.Body = &amp;body{src: newChunkedReader(r), hdr: msg, r: r, closing: t.Close}
                }</span>
        case realLength == 0:<span class="cov8" title="1">
                t.Body = EofReader</span>
        case realLength &gt; 0:<span class="cov8" title="1">
                // weiwei02: set r for peek data from body
                t.Body = &amp;body{src: io.LimitReader(r, realLength), r: r, closing: t.Close}</span>
        default:<span class="cov8" title="1">
                // realLength &lt; 0, i.e. "Content-Length" not mentioned in header
                if t.Close </span><span class="cov8" title="1">{
                        // Close semantics (i.e. HTTP/1.0)
                        t.Body = &amp;body{src: r, closing: t.Close}
                }</span> else<span class="cov0" title="0"> {
                        // Persistent connection (i.e. HTTP/1.1)
                        t.Body = EofReader
                }</span>
        }

        // Unify output
        <span class="cov8" title="1">switch rr := msg.(type) </span>{
        case *Request:<span class="cov8" title="1">
                rr.Body = t.Body
                rr.ContentLength = t.ContentLength
                rr.TransferEncoding = t.TransferEncoding
                rr.Close = t.Close
                rr.Trailer = t.Trailer</span>
        case *Response:<span class="cov8" title="1">
                rr.Body = t.Body
                rr.ContentLength = t.ContentLength
                rr.TransferEncoding = t.TransferEncoding
                rr.Close = t.Close
                rr.Trailer = t.Trailer</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// Checks whether chunked is part of the encodings stack
func chunked(te []string) bool <span class="cov8" title="1">{ return len(te) &gt; 0 &amp;&amp; te[0] == "chunked" }</span>

// Checks whether the encoding is explicitly "identity".
func isIdentity(te []string) bool <span class="cov0" title="0">{ return len(te) == 1 &amp;&amp; te[0] == "identity" }</span>

// Sanitize transfer encoding
func fixTransferEncoding(isResponse bool, requestMethod string, header Header) ([]string, error) <span class="cov8" title="1">{
        raw, present := header["Transfer-Encoding"]
        if !present </span><span class="cov8" title="1">{
                return nil, nil
        }</span>

        <span class="cov8" title="1">delete(header, "Transfer-Encoding")

        encodings := strings.Split(raw[0], ",")
        te := make([]string, 0, len(encodings))
        // TODO: Even though we only support "identity" and "chunked"
        // encodings, the loop below is designed with foresight. One
        // invariant that must be maintained is that, if present,
        // chunked encoding must always come first.
        for _, encoding := range encodings </span><span class="cov8" title="1">{
                encoding = strings.ToLower(strings.TrimSpace(encoding))
                // "identity" encoding is not recorded
                if encoding == "identity" </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov8" title="1">if encoding != "chunked" </span><span class="cov0" title="0">{
                        return nil, &amp;badStringError{"unsupported transfer encoding", encoding}
                }</span>
                <span class="cov8" title="1">te = te[0 : len(te)+1]
                te[len(te)-1] = encoding</span>
        }
        <span class="cov8" title="1">if len(te) &gt; 1 </span><span class="cov0" title="0">{
                return nil, &amp;badStringError{"too many transfer encodings", strings.Join(te, ",")}
        }</span>
        <span class="cov8" title="1">if len(te) &gt; 0 </span><span class="cov8" title="1">{
                // RFC 7230 3.3.2 says "A sender MUST NOT send a
                // Content-Length header field in any message that
                // contains a Transfer-Encoding header field."
                //
                // but also:
                // "If a message is received with both a
                // Transfer-Encoding and a Content-Length header
                // field, the Transfer-Encoding overrides the
                // Content-Length. Such a message might indicate an
                // attempt to perform request smuggling (Section 9.5)
                // or response splitting (Section 9.4) and ought to be
                // handled as an error. A sender MUST remove the
                // received Content-Length field prior to forwarding
                // such a message downstream."
                //
                // Reportedly, these appear in the wild.
                delete(header, "Content-Length")
                return te, nil
        }</span>

        <span class="cov0" title="0">return nil, nil</span>
}

// Determine the expected body length, using RFC 2616 Section 4.4. This
// function is not a method, because ultimately it should be shared by
// ReadResponse and ReadRequest.
func fixLength(isResponse bool, status int, requestMethod string, header Header, te []string) (int64, error) <span class="cov8" title="1">{
        isRequest := !isResponse
        contentLens := header["Content-Length"]

        // Hardening against HTTP request smuggling
        if len(contentLens) &gt; 1 </span><span class="cov0" title="0">{
                // Per RFC 7230 Section 3.3.2, prevent multiple
                // Content-Length headers if they differ in value.
                // If there are dups of the value, remove the dups.
                // See Issue 16490.
                first := textproto.TrimString(contentLens[0])
                for _, ct := range contentLens[1:] </span><span class="cov0" title="0">{
                        if first != textproto.TrimString(ct) </span><span class="cov0" title="0">{
                                return 0, fmt.Errorf("http: message cannot contain multiple Content-Length headers; got %q", contentLens)
                        }</span>
                }

                // deduplicate Content-Length
                <span class="cov0" title="0">header.Del("Content-Length")
                header.Add("Content-Length", first)

                contentLens = header["Content-Length"]</span>
        }

        // Logic based on response type or status
        <span class="cov8" title="1">if noBodyExpected(requestMethod) </span><span class="cov8" title="1">{
                // For HTTP requests, as part of hardening against request
                // smuggling (RFC 7230), don't allow a Content-Length header for
                // methods which don't permit bodies. As an exception, allow
                // exactly one Content-Length header if its value is "0".
                if isRequest &amp;&amp; len(contentLens) &gt; 0 &amp;&amp; !(len(contentLens) == 1 &amp;&amp; contentLens[0] == "0") </span><span class="cov0" title="0">{
                        return 0, fmt.Errorf("http: method cannot contain a Content-Length; got %q", contentLens)
                }</span>
                <span class="cov8" title="1">return 0, nil</span>
        }
        <span class="cov8" title="1">if status/100 == 1 </span><span class="cov0" title="0">{
                return 0, nil
        }</span>
        <span class="cov8" title="1">switch status </span>{
        case StatusNoContent, StatusNotModified:<span class="cov8" title="1">
                return 0, nil</span>
        }

        // Logic based on Transfer-Encoding
        <span class="cov8" title="1">if chunked(te) </span><span class="cov8" title="1">{
                return -1, nil
        }</span>

        // Logic based on Content-Length
        <span class="cov8" title="1">var cl string
        if len(contentLens) == 1 </span><span class="cov8" title="1">{
                cl = textproto.TrimString(contentLens[0])
        }</span>
        <span class="cov8" title="1">if cl != "" </span><span class="cov8" title="1">{
                n, err := parseContentLength(cl)
                if err != nil </span><span class="cov0" title="0">{
                        return -1, err
                }</span>
                <span class="cov8" title="1">return n, nil</span>
        } else<span class="cov8" title="1"> {
                header.Del("Content-Length")
        }</span>

        <span class="cov8" title="1">if !isResponse </span><span class="cov8" title="1">{
                // RFC 2616 neither explicitly permits nor forbids an
                // entity-body on a GET request so we permit one if
                // declared, but we default to 0 here (not -1 below)
                // if there's no mention of a body.
                // Likewise, all other request methods are assumed to have
                // no body if neither Transfer-Encoding chunked nor a
                // Content-Length are set.
                return 0, nil
        }</span>

        // Body-EOF logic based on other methods (like closing, or chunked coding)
        <span class="cov8" title="1">return -1, nil</span>
}

// Determine whether to hang up after sending a request and body, or
// receiving a response and body
// 'header' is the request headers
func shouldClose(major, minor int, header Header) bool <span class="cov8" title="1">{
        if major &lt; 1 </span><span class="cov0" title="0">{
                return true
        }</span> else<span class="cov8" title="1"> if major == 1 &amp;&amp; minor == 0 </span><span class="cov8" title="1">{
                return !strings.Contains(strings.ToLower(header.GetDirect("Connection")), "keep-alive")
        }</span> else<span class="cov8" title="1"> {
                // TODO: Should split on commas, toss surrounding white space,
                // and check each field.
                if strings.ToLower(header.GetDirect("Connection")) == "close" </span><span class="cov8" title="1">{
                        header.Del("Connection")
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// Parse the trailer header
func fixTrailer(header Header, te []string) (Header, error) <span class="cov8" title="1">{
        raw := header.GetDirect("Trailer")
        if raw == "" </span><span class="cov8" title="1">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">header.Del("Trailer")
        trailer := make(Header)
        keys := strings.Split(raw, ",")
        for _, key := range keys </span><span class="cov0" title="0">{
                key = CanonicalHeaderKey(strings.TrimSpace(key))
                switch key </span>{
                case "Transfer-Encoding", "Trailer", "Content-Length":<span class="cov0" title="0">
                        return nil, &amp;badStringError{"bad trailer key", key}</span>
                }
                <span class="cov0" title="0">trailer.Del(key)</span>
        }
        <span class="cov0" title="0">if len(trailer) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">if !chunked(te) </span><span class="cov0" title="0">{
                // Trailer and no chunking
                return nil, ErrUnexpectedTrailer
        }</span>
        <span class="cov0" title="0">return trailer, nil</span>
}

// body turns a Reader into a ReadCloser.
// Close ensures that the body has been fully read
// and then reads the trailer if necessary.
type body struct {
        src     io.Reader
        hdr     interface{}       // non-nil (Response or Request) value means read trailer
        r       *bfe_bufio.Reader // underlying wire-format reader for the trailer
        closing bool              // is the connection to be closed after reading body?

        mu     sync.Mutex // guards closed, and calls to Read and Close
        closed bool
}

// ErrBodyReadAfterClose is returned when reading a Request or Response
// Body after the body has been closed. This typically happens when the body is
// read after an HTTP Handler calls WriteHeader or Write on its
// ResponseWriter.
var ErrBodyReadAfterClose = errors.New("http: invalid Read on closed Body")

func (b *body) Read(p []byte) (n int, err error) <span class="cov8" title="1">{
        b.mu.Lock()
        defer b.mu.Unlock()
        if b.closed </span><span class="cov0" title="0">{
                return 0, ErrBodyReadAfterClose
        }</span>
        <span class="cov8" title="1">return b.readLocked(p)</span>
}

// Must hold b.mu.
func (b *body) readLocked(p []byte) (n int, err error) <span class="cov8" title="1">{
        n, err = b.src.Read(p)

        if err == io.EOF </span><span class="cov8" title="1">{
                // Chunked case. Read the trailer.
                if b.hdr != nil </span><span class="cov8" title="1">{
                        if e := b.readTrailer(); e != nil </span><span class="cov8" title="1">{
                                err = e
                        }</span>
                        <span class="cov8" title="1">b.hdr = nil</span>
                } else<span class="cov8" title="1"> {
                        // If the server declared the Content-Length, our body is a LimitedReader
                        // and we need to check whether this EOF arrived early.
                        if lr, ok := b.src.(*io.LimitedReader); ok &amp;&amp; lr.N &gt; 0 </span><span class="cov8" title="1">{
                                err = io.ErrUnexpectedEOF
                        }</span>
                }
        }

        <span class="cov8" title="1">return n, err</span>
}

var (
        singleCRLF = []byte("\r\n")
        doubleCRLF = []byte("\r\n\r\n")
)

func seeUpcomingDoubleCRLF(r *bfe_bufio.Reader) bool <span class="cov8" title="1">{
        for peekSize := 4; ; peekSize++ </span><span class="cov8" title="1">{
                // This loop stops when Peek returns an error,
                // which it does when r's buffer has been filled.
                buf, err := r.Peek(peekSize)
                if bytes.HasSuffix(buf, doubleCRLF) </span><span class="cov8" title="1">{
                        return true
                }</span>
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        break</span>
                }
        }
        <span class="cov0" title="0">return false</span>
}

var errTrailerEOF = errors.New("http: unexpected EOF reading trailer")

func (b *body) readTrailer() error <span class="cov8" title="1">{
        // The common case, since nobody uses trailers.
        buf, err := b.r.Peek(2)
        if bytes.Equal(buf, singleCRLF) </span><span class="cov8" title="1">{
                b.r.ReadByte()
                b.r.ReadByte()
                return nil
        }</span>
        <span class="cov8" title="1">if len(buf) &lt; 2 </span><span class="cov8" title="1">{
                return errTrailerEOF
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Make sure there's a header terminator coming up, to prevent
        // a DoS with an unbounded size Trailer.  It's not easy to
        // slip in a LimitReader here, as textproto.NewReader requires
        // a concrete *bufio.Reader.  Also, we can't get all the way
        // back up to our conn's LimitedReader that *might* be backing
        // this bufio.Reader.  Instead, a hack: we iteratively Peek up
        // to the bufio.Reader's max size, looking for a double CRLF.
        // This limits the trailer to the underlying buffer size, typically 4kB.
        <span class="cov8" title="1">if !seeUpcomingDoubleCRLF(b.r) </span><span class="cov0" title="0">{
                return errors.New("http: suspiciously long trailer after chunked body")
        }</span>

        <span class="cov8" title="1">hdr, err := textproto.NewReader(b.r).ReadMIMEHeader()
        if err != nil </span><span class="cov0" title="0">{
                if err == io.EOF </span><span class="cov0" title="0">{
                        return errTrailerEOF
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov8" title="1">switch rr := b.hdr.(type) </span>{
        case *Request:<span class="cov8" title="1">
                rr.Trailer = Header(hdr)</span>
        case *Response:<span class="cov0" title="0">
                rr.Trailer = Header(hdr)</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// note: add peek function for waf to process body
// peek from underlying buf reader
func (b *body) Peek(n int) ([]byte, error) <span class="cov0" title="0">{
        return b.r.Peek(n)
}</span>

func (b *body) Close() error <span class="cov8" title="1">{
        b.mu.Lock()
        defer b.mu.Unlock()
        if b.closed </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">var err error
        switch </span>{
        case b.hdr == nil &amp;&amp; b.closing:<span class="cov8" title="1"></span>
                // no trailer and closing the connection next.
                // no point in reading to EOF.
        default:<span class="cov8" title="1">
                // Fully consume the body, which will also lead to us reading
                // the trailer headers after the body, if present.
                _, err = io.Copy(ioutil.Discard, bodyLocked{b})</span>
        }
        <span class="cov8" title="1">b.closed = true
        return err</span>
}

// bodyLocked is a io.Reader reading from a *body when its mutex is
// already held.
type bodyLocked struct {
        b *body
}

func (bl bodyLocked) Read(p []byte) (n int, err error) <span class="cov8" title="1">{
        if bl.b.closed </span><span class="cov0" title="0">{
                return 0, ErrBodyReadAfterClose
        }</span>
        <span class="cov8" title="1">return bl.b.readLocked(p)</span>
}

// parseContentLength trims whitespace from s and returns -1 if no value
// is set, or the value if it's &gt;= 0.
func parseContentLength(cl string) (int64, error) <span class="cov8" title="1">{
        cl = strings.TrimSpace(cl)
        if cl == "" </span><span class="cov8" title="1">{
                return -1, nil
        }</span>
        <span class="cov8" title="1">n, err := strconv.ParseInt(cl, 10, 64)
        if err != nil || n &lt; 0 </span><span class="cov0" title="0">{
                return 0, &amp;badStringError{"bad Content-Length", cl}
        }</span>
        <span class="cov8" title="1">return n, nil</span>

}
</pre>
		
		<pre class="file" id="file52" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Copyright 2011 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// HTTP client implementation. See RFC 2616.
//
// This is the low-level Transport implementation of RoundTripper.
// The high-level interface is in client.go.

package bfe_http

import (
        "compress/gzip"
        "errors"
        "fmt"
        "io"
        "net"
        "net/url"
        "os"
        "strings"
        "sync"
        "time"
)

import (
        "github.com/baidu/go-lib/gotrack"
        "github.com/baidu/go-lib/log"
)

import (
        "github.com/bfenetworks/bfe/bfe_bufio"
        "github.com/bfenetworks/bfe/bfe_tls"
)

// DefaultTransport is the default implementation of Transport and is
// used by DefaultClient. It establishes network connections as needed
// and caches them for reuse by subsequent calls. It uses HTTP proxies
// as directed by the $HTTP_PROXY and $NO_PROXY (or $http_proxy and
// $no_proxy) environment variables.
var DefaultTransport RoundTripper = &amp;Transport{Proxy: ProxyFromEnvironment}

// DefaultMaxIdleConnsPerHost is the default value of Transport's
// MaxIdleConnsPerHost.
const DefaultMaxIdleConnsPerHost = 2

// Transport is an implementation of RoundTripper that supports http,
// https, and http proxies (for either http or https with CONNECT).
// Transport can also cache connections for future re-use.
type Transport struct {
        idleMu     sync.Mutex
        idleConn   map[string][]*persistConn
        idleConnCh map[string]chan *persistConn
        reqMu      sync.Mutex
        reqConn    map[*Request]*persistConn
        altMu      sync.RWMutex
        altProto   map[string]RoundTripper // nil or map of URI scheme =&gt; RoundTripper

        connMu sync.Mutex // mutex for conn count
        // Conn count which record current connection of each backend
        // when create a persistConn we count plus one of the cm key,
        // and minus one when the persistConn is close.
        connCnt map[string]int

        // Proxy specifies a function to return a proxy for a given
        // Request. If the function returns a non-nil error, the
        // request is aborted with the provided error.
        // If Proxy is nil or returns a nil *URL, no proxy is used.
        Proxy func(*Request) (*url.URL, error)

        // Dial specifies the dial function for creating TCP
        // connections.
        // If Dial is nil, net.Dial is used.
        Dial func(network, addr string) (net.Conn, error)

        // TLSClientConfig specifies the TLS configuration to use with
        // tls.Client. If nil, the default configuration is used.
        TLSClientConfig *bfe_tls.Config

        // DisableKeepAlives, if true, prevents re-use of TCP connections
        // between different HTTP requests.
        DisableKeepAlives bool

        // DisableCompression, if true, prevents the Transport from
        // requesting compression with an "Accept-Encoding: gzip"
        // request header when the Request contains no existing
        // Accept-Encoding value. If the Transport requests gzip on
        // its own and gets a gzipped response, it's transparently
        // decoded in the Response.Body. However, if the user
        // explicitly requested gzip it is not automatically
        // uncompressed.
        DisableCompression bool

        // MaxIdleConnsPerHost, if non-zero, controls the maximum idle
        // (keep-alive) to keep per-host.  If zero,
        // DefaultMaxIdleConnsPerHost is used.
        MaxIdleConnsPerHost int

        // MaxConnsPerHost, if non-zero, controls the maximum currency conns
        //  to per-host.  If less than or equal zero, transport will ignore this value.
        MaxConnsPerHost int

        // ResponseHeaderTimeout, if non-zero, specifies the amount of
        // time to wait for a server's response headers after fully
        // writing the request (including its body, if any). This
        // time does not include the time to read the response body.
        ResponseHeaderTimeout time.Duration

        // ReqWriteBufferSize specifies writer buffer size for request.
        // If zero, default buffer size is used.
        ReqWriteBufferSize int

        // FlushInterval specifies the flush interval to flush to
        // the backend while copying the request body.
        // If zero, no periodic flushing is done.
        ReqFlushInterval time.Duration

        // TODO: tunable on global max cached connections
        // TODO: tunable on timeout on cached connections
}

// ProxyFromEnvironment returns the URL of the proxy to use for a
// given request, as indicated by the environment variables
// $HTTP_PROXY and $NO_PROXY (or $http_proxy and $no_proxy).
// An error is returned if the proxy environment is invalid.
// A nil URL and nil error are returned if no proxy is defined in the
// environment, or a proxy should not be used for the given request.
func ProxyFromEnvironment(req *Request) (*url.URL, error) <span class="cov0" title="0">{
        proxy := getenvEitherCase("HTTP_PROXY")
        if proxy == "" </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">if !useProxy(canonicalAddr(req.URL)) </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">proxyURL, err := url.Parse(proxy)
        if err != nil || !strings.HasPrefix(proxyURL.Scheme, "http") </span><span class="cov0" title="0">{
                // proxy was bogus. Try prepending "http://" to it and
                // see if that parses correctly. If not, we fall
                // through and complain about the original one.
                if proxyURL, err := url.Parse("http://" + proxy); err == nil </span><span class="cov0" title="0">{
                        return proxyURL, nil
                }</span>
        }
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid proxy address %q: %v", proxy, err)
        }</span>
        <span class="cov0" title="0">return proxyURL, nil</span>
}

// ProxyURL returns a proxy function (for use in a Transport)
// that always returns the same URL.
func ProxyURL(fixedURL *url.URL) func(*Request) (*url.URL, error) <span class="cov0" title="0">{
        return func(*Request) (*url.URL, error) </span><span class="cov0" title="0">{
                return fixedURL, nil
        }</span>
}

// transportRequest is a wrapper around a *Request that adds
// optional extra headers to write.
type transportRequest struct {
        *Request        // original request, not to be mutated
        extra    Header // extra headers to write, or nil
}

func (tr *transportRequest) extraHeaders() Header <span class="cov0" title="0">{
        if tr.extra == nil </span><span class="cov0" title="0">{
                tr.extra = make(Header)
        }</span>
        <span class="cov0" title="0">return tr.extra</span>
}

// RoundTrip implements the RoundTripper interface.
//
// For higher-level HTTP client support (such as handling of cookies
// and redirects), see Get, Post, and the Client type.
func (t *Transport) RoundTrip(req *Request) (resp *Response, err error) <span class="cov0" title="0">{
        state.HttpBackendReqAll.Inc(1)
        if req.URL == nil </span><span class="cov0" title="0">{
                return nil, errors.New("http: nil Request.URL")
        }</span>
        <span class="cov0" title="0">if req.Header == nil </span><span class="cov0" title="0">{
                return nil, errors.New("http: nil Request.Header")
        }</span>
        <span class="cov0" title="0">if req.URL.Scheme != "http" &amp;&amp; req.URL.Scheme != "https" </span><span class="cov0" title="0">{
                t.altMu.RLock()
                var rt RoundTripper
                if t.altProto != nil </span><span class="cov0" title="0">{
                        rt = t.altProto[req.URL.Scheme]
                }</span>
                <span class="cov0" title="0">t.altMu.RUnlock()
                if rt == nil </span><span class="cov0" title="0">{
                        return nil, &amp;badStringError{"unsupported protocol scheme", req.URL.Scheme}
                }</span>
                <span class="cov0" title="0">return rt.RoundTrip(req)</span>
        }
        <span class="cov0" title="0">if req.URL.Host == "" </span><span class="cov0" title="0">{
                return nil, errors.New("http: no Host in request URL")
        }</span>
        <span class="cov0" title="0">treq := &amp;transportRequest{Request: req}
        cm, err := t.connectMethodForRequest(treq)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // record start connect backend time
        <span class="cov0" title="0">connectStartTime := time.Now()

        // Get the cached or newly-created connection to either the
        // host (for http or https), the http proxy, or the http proxy
        // pre-CONNECTed to https server.  In any case, we'll be ready
        // to send it requests.
        pconn, err := t.getConn(cm)
        if err != nil </span><span class="cov0" title="0">{
                return nil, ConnectError{Err: err, Addr: cm.addr()}
        }</span>

        // set connect backend time stat
        <span class="cov0" title="0">req.State.ConnectBackendStart = connectStartTime
        req.State.ConnectBackendEnd = time.Now()

        resp, err = pconn.roundTrip(treq)
        if err == nil </span><span class="cov0" title="0">{
                state.HttpBackendReqSucc.Inc(1)
        }</span>
        <span class="cov0" title="0">return</span>
}

// RegisterProtocol registers a new protocol with scheme.
// The Transport will pass requests using the given scheme to rt.
// It is rt's responsibility to simulate HTTP request semantics.
//
// RegisterProtocol can be used by other packages to provide
// implementations of protocol schemes like "ftp" or "file".
func (t *Transport) RegisterProtocol(scheme string, rt RoundTripper) <span class="cov0" title="0">{
        if scheme == "http" || scheme == "https" </span><span class="cov0" title="0">{
                panic("protocol " + scheme + " already registered")</span>
        }
        <span class="cov0" title="0">t.altMu.Lock()
        defer t.altMu.Unlock()
        if t.altProto == nil </span><span class="cov0" title="0">{
                t.altProto = make(map[string]RoundTripper)
        }</span>
        <span class="cov0" title="0">if _, exists := t.altProto[scheme]; exists </span><span class="cov0" title="0">{
                panic("protocol " + scheme + " already registered")</span>
        }
        <span class="cov0" title="0">t.altProto[scheme] = rt</span>
}

// CloseIdleConnections closes any connections which were previously
// connected from previous requests but are now sitting idle in
// a "keep-alive" state. It does not interrupt any connections currently
// in use.
func (t *Transport) CloseIdleConnections() <span class="cov0" title="0">{
        t.idleMu.Lock()
        m := t.idleConn
        t.idleConn = nil
        t.idleConnCh = nil
        t.idleMu.Unlock()
        if m == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">for _, conns := range m </span><span class="cov0" title="0">{
                for _, pconn := range conns </span><span class="cov0" title="0">{
                        pconn.close()
                }</span>
        }
}

// CancelRequest cancels an in-flight request by closing its
// connection.
func (t *Transport) CancelRequest(req *Request) <span class="cov0" title="0">{
        t.reqMu.Lock()
        pc := t.reqConn[req]
        t.reqMu.Unlock()
        if pc != nil </span><span class="cov0" title="0">{
                pc.conn.Close()
        }</span>
}

//
// Private implementation past this point.
//

func getenvEitherCase(k string) string <span class="cov0" title="0">{
        if v := os.Getenv(strings.ToUpper(k)); v != "" </span><span class="cov0" title="0">{
                return v
        }</span>
        <span class="cov0" title="0">return os.Getenv(strings.ToLower(k))</span>
}

func (t *Transport) connectMethodForRequest(treq *transportRequest) (*connectMethod, error) <span class="cov0" title="0">{
        cm := &amp;connectMethod{
                targetScheme: treq.URL.Scheme,
                targetAddr:   canonicalAddr(treq.URL),
        }
        if t.Proxy != nil </span><span class="cov0" title="0">{
                var err error
                cm.proxyURL, err = t.Proxy(treq.Request)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">return cm, nil</span>
}

// proxyAuth returns the Proxy-Authorization header to set
// on requests, if applicable.
func (cm *connectMethod) proxyAuth() string <span class="cov0" title="0">{
        if cm.proxyURL == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">if u := cm.proxyURL.User; u != nil </span><span class="cov0" title="0">{
                username := u.Username()
                password, _ := u.Password()
                return "Basic " + basicAuth(username, password)
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (t *Transport) releaseConnCnt(cacheKey string) <span class="cov0" title="0">{
        t.connMu.Lock()
        if t.connCnt == nil </span><span class="cov0" title="0">{
                t.connMu.Unlock()
                return
        }</span>
        <span class="cov0" title="0">t.connCnt[cacheKey]--
        t.connMu.Unlock()</span>
}

// putIdleConn adds pconn to the list of idle persistent connections awaiting
// a new request.
// If pconn is no longer needed or not in a good state, putIdleConn
// returns false.
func (t *Transport) putIdleConn(pconn *persistConn) bool <span class="cov0" title="0">{
        if t.DisableKeepAlives || t.MaxIdleConnsPerHost &lt; 0 </span><span class="cov0" title="0">{
                pconn.close()
                return false
        }</span>
        <span class="cov0" title="0">if pconn.isBroken() </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">key := pconn.cacheKey
        max := t.MaxIdleConnsPerHost
        if max == 0 </span><span class="cov0" title="0">{
                max = DefaultMaxIdleConnsPerHost
        }</span>
        <span class="cov0" title="0">t.idleMu.Lock()

        waitingDialer := t.idleConnCh[key]
        select </span>{
        case waitingDialer &lt;- pconn:<span class="cov0" title="0">
                // We're done with this pconn and somebody else is
                // currently waiting for a conn of this type (they're
                // actively dialing, but this conn is ready
                // first). Chrome calls this socket late binding.  See
                // https://insouciant.org/tech/connection-management-in-chromium/
                t.idleMu.Unlock()
                return true</span>
        default:<span class="cov0" title="0">
                if waitingDialer != nil </span><span class="cov0" title="0">{
                        // They had populated this, but their dial won
                        // first, so we can clean up this map entry.
                        delete(t.idleConnCh, key)
                }</span>
        }
        <span class="cov0" title="0">if t.idleConn == nil </span><span class="cov0" title="0">{
                t.idleConn = make(map[string][]*persistConn)
        }</span>
        // evict the oldest connection when idleConn exceed its limits.
        <span class="cov0" title="0">if len(t.idleConn[key]) &gt;= max </span><span class="cov0" title="0">{
                oldest := t.idleConn[key][0]
                t.idleConn[key] = append(t.idleConn[key][1:], pconn)
                t.idleMu.Unlock()
                oldest.close()
                return true
        }</span>
        <span class="cov0" title="0">for _, exist := range t.idleConn[key] </span><span class="cov0" title="0">{
                if exist == pconn </span><span class="cov0" title="0">{
                        log.Logger.Error("dup idle pconn %p in freelist", pconn)
                }</span>
        }
        <span class="cov0" title="0">t.idleConn[key] = append(t.idleConn[key], pconn)
        t.idleMu.Unlock()
        return true</span>
}

// getIdleConnCh returns a channel to receive and return idle
// persistent connection for the given connectMethod.
// It may return nil, if persistent connections are not being used.
func (t *Transport) getIdleConnCh(cm *connectMethod) chan *persistConn <span class="cov0" title="0">{
        if t.DisableKeepAlives </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">key := cm.key()
        t.idleMu.Lock()
        defer t.idleMu.Unlock()
        if t.idleConnCh == nil </span><span class="cov0" title="0">{
                t.idleConnCh = make(map[string]chan *persistConn)
        }</span>
        <span class="cov0" title="0">ch, ok := t.idleConnCh[key]
        if !ok </span><span class="cov0" title="0">{
                ch = make(chan *persistConn)
                t.idleConnCh[key] = ch
        }</span>
        <span class="cov0" title="0">return ch</span>
}

func (t *Transport) getIdleConn(cm *connectMethod) (pconn *persistConn) <span class="cov0" title="0">{
        key := cm.key()
        t.idleMu.Lock()
        defer t.idleMu.Unlock()
        if t.idleConn == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                pconns, ok := t.idleConn[key]
                if !ok </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">if len(pconns) == 1 </span><span class="cov0" title="0">{
                        pconn = pconns[0]
                        delete(t.idleConn, key)
                }</span> else<span class="cov0" title="0"> {
                        // 2 or more cached connections; pop last
                        // TODO: queue?
                        pconn = pconns[len(pconns)-1]
                        t.idleConn[key] = pconns[0 : len(pconns)-1]
                }</span>
                <span class="cov0" title="0">if !pconn.isBroken() </span><span class="cov0" title="0">{
                        return
                }</span>
        }
}

func (t *Transport) setReqConn(r *Request, pc *persistConn) <span class="cov0" title="0">{
        t.reqMu.Lock()
        defer t.reqMu.Unlock()
        if t.reqConn == nil </span><span class="cov0" title="0">{
                t.reqConn = make(map[*Request]*persistConn)
        }</span>
        <span class="cov0" title="0">if pc != nil </span><span class="cov0" title="0">{
                t.reqConn[r] = pc
        }</span> else<span class="cov0" title="0"> {
                delete(t.reqConn, r)
        }</span>
}

func (t *Transport) dial(network, addr string) (c net.Conn, err error) <span class="cov0" title="0">{
        if t.Dial != nil </span><span class="cov0" title="0">{
                return t.Dial(network, addr)
        }</span>
        <span class="cov0" title="0">return net.Dial(network, addr)</span>
}

// check whether we can create new conn to backend with given cachekey
func (t *Transport) checkAndIncConnCnt(cacheKey string, maxValue int) bool <span class="cov0" title="0">{
        t.connMu.Lock()
        if t.connCnt == nil </span><span class="cov0" title="0">{
                t.connCnt = make(map[string]int)
        }</span>
        <span class="cov0" title="0">if val, ok := t.connCnt[cacheKey]; ok &amp;&amp; val &gt;= maxValue </span><span class="cov0" title="0">{
                t.connMu.Unlock()
                return false
        }</span>
        <span class="cov0" title="0">t.connCnt[cacheKey]++
        t.connMu.Unlock()
        return true</span>
}

// getConn dials and creates a new persistConn to the target as
// specified in the connectMethod.  This includes doing a proxy CONNECT
// and/or setting up TLS.  If this doesn't return an error, the persistConn
// is ready to write requests to.
func (t *Transport) getConn(cm *connectMethod) (*persistConn, error) <span class="cov0" title="0">{
        if pc := t.getIdleConn(cm); pc != nil </span><span class="cov0" title="0">{
                return pc, nil
        }</span>

        <span class="cov0" title="0">type dialRes struct {
                pc  *persistConn
                err error
        }
        dialc := make(chan dialRes)
        go func() </span><span class="cov0" title="0">{
                cacheKey := cm.key()
                if t.MaxConnsPerHost &gt; 0 &amp;&amp; !t.checkAndIncConnCnt(cacheKey, t.MaxConnsPerHost) </span><span class="cov0" title="0">{
                        dialc &lt;- dialRes{nil, fmt.Errorf("cm key[%v] greater than max conns[%d]", cacheKey, t.MaxConnsPerHost)}
                        return
                }</span>
                <span class="cov0" title="0">pc, err := t.dialConn(cm)
                state.HttpBackendConnAll.Inc(1)
                if err == nil </span><span class="cov0" title="0">{
                        state.HttpBackendConnSucc.Inc(1)
                }</span> else<span class="cov0" title="0"> {
                        t.releaseConnCnt(cacheKey)
                }</span>

                <span class="cov0" title="0">dialc &lt;- dialRes{pc, err}</span>
        }()

        <span class="cov0" title="0">idleConnCh := t.getIdleConnCh(cm)
        select </span>{
        case v := &lt;-dialc:<span class="cov0" title="0">
                // Our dial finished.
                return v.pc, v.err</span>
        case pc := &lt;-idleConnCh:<span class="cov0" title="0">
                // Another request finished first and its net.Conn
                // became available before our dial. Or somebody
                // else's dial that they didn't use.
                // But our dial is still going, so give it away
                // when it finishes:
                go func() </span><span class="cov0" title="0">{
                        if v := &lt;-dialc; v.err == nil </span><span class="cov0" title="0">{
                                t.putIdleConn(v.pc)
                        }</span>
                }()
                <span class="cov0" title="0">return pc, nil</span>
        }
}

func (t *Transport) dialConn(cm *connectMethod) (*persistConn, error) <span class="cov0" title="0">{
        conn, err := t.dial("tcp", cm.addr())
        if err != nil </span><span class="cov0" title="0">{
                if cm.proxyURL != nil </span><span class="cov0" title="0">{
                        err = fmt.Errorf("http: error connecting to proxy %s: %v", cm.proxyURL, err)
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov0" title="0">pa := cm.proxyAuth()

        pconn := &amp;persistConn{
                t:        t,
                cacheKey: cm.key(),
                conn:     conn,
                reqch:    make(chan requestAndChan, 1),
                writech:  make(chan writeRequest, 1),
                closech:  make(chan struct{}),
        }

        switch </span>{
        case cm.proxyURL == nil:<span class="cov0" title="0"></span>
                // Do nothing.
        case cm.targetScheme == "http":<span class="cov0" title="0">
                pconn.isProxy = true
                if pa != "" </span><span class="cov0" title="0">{
                        pconn.mutateHeaderFunc = func(h Header) </span><span class="cov0" title="0">{
                                h.Set("Proxy-Authorization", pa)
                        }</span>
                }
        case cm.targetScheme == "https":<span class="cov0" title="0">
                connectReq := &amp;Request{
                        Method: MethodConnect,
                        URL:    &amp;url.URL{Opaque: cm.targetAddr},
                        Host:   cm.targetAddr,
                        Header: make(Header),
                }
                if pa != "" </span><span class="cov0" title="0">{
                        connectReq.Header.Set("Proxy-Authorization", pa)
                }</span>
                <span class="cov0" title="0">connectReq.Write(conn)

                // Read response.
                // Okay to use and discard buffered reader here, because
                // TLS server will not speak until spoken to.
                br := bfe_bufio.NewReader(conn)
                resp, err := ReadResponse(br, connectReq)
                if err != nil </span><span class="cov0" title="0">{
                        conn.Close()
                        return nil, err
                }</span>
                <span class="cov0" title="0">if resp.StatusCode != 200 </span><span class="cov0" title="0">{
                        f := strings.SplitN(resp.Status, " ", 2)
                        conn.Close()
                        return nil, errors.New(f[1])
                }</span>
        }

        <span class="cov0" title="0">if cm.targetScheme == "https" </span><span class="cov0" title="0">{
                // Initiate TLS and check remote host name against certificate.
                cfg := t.TLSClientConfig
                if cfg == nil || cfg.ServerName == "" </span><span class="cov0" title="0">{
                        host := cm.tlsHost()
                        if cfg == nil </span><span class="cov0" title="0">{
                                cfg = &amp;bfe_tls.Config{ServerName: host}
                        }</span> else<span class="cov0" title="0"> {
                                clone := cfg.Clone() // shallow clone
                                clone.ServerName = host
                                cfg = clone
                        }</span>
                }
                <span class="cov0" title="0">conn = bfe_tls.Client(conn, cfg)
                if err = conn.(*bfe_tls.Conn).Handshake(); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">if !cfg.InsecureSkipVerify </span><span class="cov0" title="0">{
                        if err = conn.(*bfe_tls.Conn).VerifyHostname(cfg.ServerName); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                }
                <span class="cov0" title="0">pconn.conn = conn</span>
        }

        <span class="cov0" title="0">pconn.br = bfe_bufio.NewReader(pconn.conn)

        if t.ReqWriteBufferSize &gt; 0 </span><span class="cov0" title="0">{
                pconn.bw = bfe_bufio.NewWriterSize(pconn.conn, t.ReqWriteBufferSize)
        }</span> else<span class="cov0" title="0"> {
                pconn.bw = bfe_bufio.NewWriter(pconn.conn)
        }</span>

        <span class="cov0" title="0">if t.ReqFlushInterval &gt; 0 </span><span class="cov0" title="0">{
                pconn.bw = NewMaxLatencyWriter(pconn.bw, t.ReqFlushInterval, nil)
        }</span>

        <span class="cov0" title="0">go pconn.readLoop()
        go pconn.writeLoop()
        return pconn, nil</span>
}

// useProxy returns true if requests to addr should use a proxy,
// according to the NO_PROXY or no_proxy environment variable.
// addr is always a canonicalAddr with a host and port.
func useProxy(addr string) bool <span class="cov0" title="0">{
        if len(addr) == 0 </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">host, _, err := net.SplitHostPort(addr)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">if host == "localhost" </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">if ip := net.ParseIP(host); ip != nil </span><span class="cov0" title="0">{
                if ip.IsLoopback() </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">noProxy := getenvEitherCase("NO_PROXY")
        if noProxy == "*" </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">addr = strings.ToLower(strings.TrimSpace(addr))
        if hasPort(addr) </span><span class="cov0" title="0">{
                addr = addr[:strings.LastIndex(addr, ":")]
        }</span>

        <span class="cov0" title="0">for _, p := range strings.Split(noProxy, ",") </span><span class="cov0" title="0">{
                p = strings.ToLower(strings.TrimSpace(p))
                if len(p) == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if hasPort(p) </span><span class="cov0" title="0">{
                        p = p[:strings.LastIndex(p, ":")]
                }</span>
                <span class="cov0" title="0">if addr == p </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov0" title="0">if p[0] == '.' &amp;&amp; (strings.HasSuffix(addr, p) || addr == p[1:]) </span><span class="cov0" title="0">{
                        // no_proxy ".foo.com" matches "bar.foo.com" or "foo.com"
                        return false
                }</span>
                <span class="cov0" title="0">if p[0] != '.' &amp;&amp; strings.HasSuffix(addr, p) &amp;&amp; addr[len(addr)-len(p)-1] == '.' </span><span class="cov0" title="0">{
                        // no_proxy "foo.com" matches "bar.foo.com"
                        return false
                }</span>
        }
        <span class="cov0" title="0">return true</span>
}

// connectMethod is the map key (in its String form) for keeping persistent
// TCP connections alive for subsequent HTTP requests.
//
// A connect method may be of the following types:
//
// Cache key form                Description
// -----------------             -------------------------
// ||http|foo.com                http directly to server, no proxy
// ||https|foo.com               https directly to server, no proxy
// http://proxy.com|https|foo.com  http to proxy, then CONNECT to foo.com
// http://proxy.com|http           http to proxy, http to anywhere after that
//
// Note: no support to https to the proxy yet.
//
type connectMethod struct {
        proxyURL     *url.URL // nil for no proxy, else full proxy URL
        targetScheme string   // "http" or "https"
        targetAddr   string   // Not used if proxy + http targetScheme (4th example in table)
}

func (ck *connectMethod) key() string <span class="cov0" title="0">{
        return ck.String() // TODO: use a struct type instead
}</span>

func (ck *connectMethod) String() string <span class="cov0" title="0">{
        proxyStr := ""
        targetAddr := ck.targetAddr
        if ck.proxyURL != nil </span><span class="cov0" title="0">{
                proxyStr = ck.proxyURL.String()
                if ck.targetScheme == "http" </span><span class="cov0" title="0">{
                        targetAddr = ""
                }</span>
        }
        <span class="cov0" title="0">return strings.Join([]string{proxyStr, ck.targetScheme, targetAddr}, "|")</span>
}

// addr returns the first hop "host:port" to which we need to TCP connect.
func (cm *connectMethod) addr() string <span class="cov0" title="0">{
        if cm.proxyURL != nil </span><span class="cov0" title="0">{
                return canonicalAddr(cm.proxyURL)
        }</span>
        <span class="cov0" title="0">return cm.targetAddr</span>
}

// tlsHost returns the host name to match against the peer's
// TLS certificate.
func (cm *connectMethod) tlsHost() string <span class="cov0" title="0">{
        h := cm.targetAddr
        if hasPort(h) </span><span class="cov0" title="0">{
                h = h[:strings.LastIndex(h, ":")]
        }</span>
        <span class="cov0" title="0">return h</span>
}

// persistConn wraps a connection, usually a persistent one
// (but may be used for non-keep-alive requests as well)
type persistConn struct {
        t        *Transport
        cacheKey string // its connectMethod.String()
        conn     net.Conn
        closed   bool                // whether conn has been closed
        br       *bfe_bufio.Reader   // from conn
        bw       WriteFlusher        // to conn
        reqch    chan requestAndChan // written by roundTrip; read by readLoop
        writech  chan writeRequest   // written by roundTrip; read by writeLoop
        closech  chan struct{}       // broadcast close when readLoop (TCP connection) closes
        isProxy  bool

        lk                   sync.Mutex // guards following 3 fields
        numExpectedResponses int
        broken               bool // an error has happened on this connection; marked broken so it's not reused.
        // mutateHeaderFunc is an optional func to modify extra
        // headers on each outbound request before it's written. (the
        // original Request given to RoundTrip is not modified)
        mutateHeaderFunc func(Header)
}

func (pc *persistConn) isBroken() bool <span class="cov0" title="0">{
        pc.lk.Lock()
        b := pc.broken
        pc.lk.Unlock()
        return b
}</span>

var remoteSideClosedFunc func(error) bool // or nil to use default

func remoteSideClosed(err error) bool <span class="cov0" title="0">{
        if err == io.EOF </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">if remoteSideClosedFunc != nil </span><span class="cov0" title="0">{
                return remoteSideClosedFunc(err)
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (pc *persistConn) readLoop() <span class="cov0" title="0">{
        defer close(pc.closech)
        defer func() </span><span class="cov0" title="0">{
                if err := recover(); err != nil </span><span class="cov0" title="0">{
                        log.Logger.Warn("panic:persistConn.readLoop():%v\n%s", err, gotrack.CurrentStackTrace(0))

                        pc.close()
                        state.HttpPanicBackendRead.Inc(1)
                }</span>
        }()

        <span class="cov0" title="0">alive := true

        for alive </span><span class="cov0" title="0">{
                pb, err := pc.br.Peek(1)

                pc.lk.Lock()
                if pc.numExpectedResponses == 0 </span><span class="cov0" title="0">{
                        pc.closeLocked()
                        pc.lk.Unlock()
                        if len(pb) &gt; 0 </span><span class="cov0" title="0">{
                                log.Logger.Info("Unsolicited response received on idle HTTP channel starting with %q; err=%v",
                                        string(pb), err)
                        }</span>
                        <span class="cov0" title="0">return</span>
                }
                <span class="cov0" title="0">pc.lk.Unlock()

                rc := &lt;-pc.reqch

                var resp *Response
                if err == nil </span><span class="cov0" title="0">{
                        resp, err = ReadResponse(pc.br, rc.req)
                        if err == nil &amp;&amp; resp.StatusCode == 100 </span><span class="cov0" title="0">{
                                // Skip any 100-continue for now.
                                // TODO(bradfitz): if rc.req had "Expect: 100-continue",
                                // actually block the request body write and signal the
                                // writeLoop now to begin sending it. (Issue 2184) For now we
                                // eat it, since we're never expecting one.
                                resp, err = ReadResponse(pc.br, rc.req)
                        }</span>
                }
                <span class="cov0" title="0">hasBody := resp != nil &amp;&amp; rc.req.Method != MethodHead &amp;&amp; resp.ContentLength != 0

                if err != nil </span><span class="cov0" title="0">{
                        pc.close()
                }</span> else<span class="cov0" title="0"> {
                        if rc.addedGzip &amp;&amp; hasBody &amp;&amp; resp.Header.Get("Content-Encoding") == "gzip" </span><span class="cov0" title="0">{
                                resp.Header.Del("Content-Encoding")
                                resp.Header.Del("Content-Length")
                                resp.ContentLength = -1
                                gzReader, zerr := gzip.NewReader(resp.Body)
                                if zerr != nil </span><span class="cov0" title="0">{
                                        pc.close()
                                        err = zerr
                                }</span> else<span class="cov0" title="0"> {
                                        resp.Body = &amp;readerAndCloser{gzReader, resp.Body}
                                }</span>
                        }
                        <span class="cov0" title="0">resp.Body = &amp;bodyEOFSignal{body: resp.Body}</span>
                }

                <span class="cov0" title="0">if err != nil || resp.Close || rc.req.Close || resp.StatusCode &lt;= 199 </span><span class="cov0" title="0">{
                        // Don't do keep-alive on error if either party requested a close
                        // or we get an unexpected informational (1xx) response.
                        // StatusCode 100 is already handled above.
                        alive = false
                }</span>

                <span class="cov0" title="0">var waitForBodyRead chan bool
                if hasBody </span><span class="cov0" title="0">{
                        waitForBodyRead = make(chan bool, 2)
                        resp.Body.(*bodyEOFSignal).earlyCloseFn = func() error </span><span class="cov0" title="0">{
                                // Sending false here sets alive to
                                // false and closes the connection
                                // below.
                                waitForBodyRead &lt;- false
                                return nil
                        }</span>
                        <span class="cov0" title="0">resp.Body.(*bodyEOFSignal).fn = func(err error) </span><span class="cov0" title="0">{
                                alive1 := alive
                                if err != nil </span><span class="cov0" title="0">{
                                        alive1 = false
                                }</span>
                                <span class="cov0" title="0">if alive1 &amp;&amp; !pc.t.putIdleConn(pc) </span><span class="cov0" title="0">{
                                        alive1 = false
                                }</span>
                                <span class="cov0" title="0">if !alive1 || pc.isBroken() </span><span class="cov0" title="0">{
                                        pc.close()
                                }</span>
                                <span class="cov0" title="0">waitForBodyRead &lt;- alive1</span>
                        }
                }

                <span class="cov0" title="0">if alive &amp;&amp; !hasBody </span><span class="cov0" title="0">{
                        if !pc.t.putIdleConn(pc) </span><span class="cov0" title="0">{
                                alive = false
                        }</span>
                }

                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        err = ReadRespHeaderError{Err: err}
                }</span>

                <span class="cov0" title="0">rc.ch &lt;- responseAndError{resp, err}

                // Wait for the just-returned response body to be fully consumed
                // before we race and peek on the underlying bufio reader.
                if waitForBodyRead != nil </span><span class="cov0" title="0">{
                        alive = &lt;-waitForBodyRead
                }</span>

                <span class="cov0" title="0">pc.t.setReqConn(rc.req, nil)

                if !alive </span><span class="cov0" title="0">{
                        pc.close()
                }</span>
        }
}

func (pc *persistConn) writeLoop() <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                if err := recover(); err != nil </span><span class="cov0" title="0">{
                        log.Logger.Warn("panic:persistConn.writeLoop():%v\n%s", err, gotrack.CurrentStackTrace(0))

                        // close connection
                        pc.close()
                        state.HttpPanicBackendWrite.Inc(1)
                }</span>
        }()

        // Start flush loop for request
        <span class="cov0" title="0">if mlw, ok := pc.bw.(*MaxLatencyWriter); ok </span><span class="cov0" title="0">{
                go mlw.FlushLoop()
                defer mlw.Stop()
        }</span>

        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                select </span>{
                case wr := &lt;-pc.writech:<span class="cov0" title="0">
                        if pc.isBroken() </span><span class="cov0" title="0">{
                                wr.ch &lt;- WriteRequestError{Err: errors.New("http: can't write HTTP request on broken connection")}
                                continue</span>
                        }
                        <span class="cov0" title="0">err := wr.req.Request.write(pc.bw, pc.isProxy, wr.req.extra)
                        if err == nil </span><span class="cov0" title="0">{
                                err = pc.bw.Flush()
                        }</span>
                        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                err = WriteRequestError{Err: err}
                                pc.markBroken()
                        }</span>
                        <span class="cov0" title="0">wr.ch &lt;- err</span>
                case &lt;-pc.closech:<span class="cov0" title="0">
                        return</span>
                }
        }
}

type responseAndError struct {
        res *Response
        err error
}

type requestAndChan struct {
        req *Request
        ch  chan responseAndError

        // did the Transport (as opposed to the client code) add an
        // Accept-Encoding gzip header? only if it we set it do
        // we transparently decode the gzip.
        addedGzip bool
}

// A writeRequest is sent by the readLoop's goroutine to the
// writeLoop's goroutine to write a request while the read loop
// concurrently waits on both the write response and the server's
// reply.
type writeRequest struct {
        req *transportRequest
        ch  chan&lt;- error
}

func (pc *persistConn) roundTrip(req *transportRequest) (resp *Response, err error) <span class="cov0" title="0">{
        pc.t.setReqConn(req.Request, pc)
        pc.lk.Lock()
        pc.numExpectedResponses++
        headerFn := pc.mutateHeaderFunc
        pc.lk.Unlock()

        if headerFn != nil </span><span class="cov0" title="0">{
                headerFn(req.extraHeaders())
        }</span>

        // Ask for a compressed version if the caller didn't set their
        // own value for Accept-Encoding. We only attempted to
        // uncompress the gzip stream if we were the layer that
        // requested it.
        <span class="cov0" title="0">requestedGzip := false
        if !pc.t.DisableCompression &amp;&amp; req.Header.Get("Accept-Encoding") == "" &amp;&amp; req.Method != MethodHead </span><span class="cov0" title="0">{
                // Request gzip only, not deflate. Deflate is ambiguous and
                // not as universally supported anyway.
                // See: http://www.gzip.org/zlib/zlib_faq.html#faq38
                //
                // Note that we don't request this for HEAD requests,
                // due to a bug in nginx:
                //   http://trac.nginx.org/nginx/ticket/358
                //   http://golang.org/issue/5522
                requestedGzip = true
                req.extraHeaders().Set("Accept-Encoding", "gzip")
        }</span>

        // Write the request concurrently with waiting for a response,
        // in case the server decides to reply before reading our full
        // request body.
        <span class="cov0" title="0">writeErrCh := make(chan error, 1)
        pc.writech &lt;- writeRequest{req, writeErrCh}

        resc := make(chan responseAndError, 1)
        pc.reqch &lt;- requestAndChan{req.Request, resc, requestedGzip}

        var re responseAndError
        var pconnDeadCh = pc.closech
        var failTicker &lt;-chan time.Time
        var respHeaderTicker &lt;-chan time.Time
WaitResponse:
        for </span><span class="cov0" title="0">{
                select </span>{
                case err := &lt;-writeErrCh:<span class="cov0" title="0">
                        if err != nil </span><span class="cov0" title="0">{
                                re = responseAndError{nil, err}
                                pc.close()
                                break WaitResponse</span>
                        }
                        <span class="cov0" title="0">if d := pc.t.ResponseHeaderTimeout; d &gt; 0 </span><span class="cov0" title="0">{
                                // Note: The underlying timer created by time.After() is not
                                // recovered by the garbage collector until the timer fires.
                                // For efficiency, we use time.NewTimer() instead of time.After()
                                // and stop the timer if no longer needed.
                                t := time.NewTimer(d)
                                defer t.Stop()
                                respHeaderTicker = t.C
                        }</span>
                case &lt;-pconnDeadCh:<span class="cov0" title="0">
                        // The persist connection is dead. This shouldn't
                        // usually happen (only with Connection: close responses
                        // with no response bodies), but if it does happen it
                        // means either a) the remote server hung up on us
                        // prematurely, or b) the readLoop sent us a response &amp;
                        // closed its closech at roughly the same time, and we
                        // selected this case first, in which case a response
                        // might still be coming soon.
                        //
                        // We can't avoid the select race in b) by using a unbuffered
                        // resc channel instead, because then goroutines can
                        // leak if we exit due to other errors.
                        pconnDeadCh = nil                               // avoid spinning
                        failTicker = time.After(100 * time.Millisecond)</span> // arbitrary time to wait for resc
                case &lt;-failTicker:<span class="cov0" title="0">
                        re = responseAndError{err: TransportBrokenError{}}
                        break WaitResponse</span>
                case &lt;-respHeaderTicker:<span class="cov0" title="0">
                        pc.close()
                        re = responseAndError{err: RespHeaderTimeoutError{}}
                        break WaitResponse</span>
                case re = &lt;-resc:<span class="cov0" title="0">
                        break WaitResponse</span>
                }
        }

        <span class="cov0" title="0">pc.lk.Lock()
        pc.numExpectedResponses--
        pc.lk.Unlock()

        if re.err != nil </span><span class="cov0" title="0">{
                pc.t.setReqConn(req.Request, nil)
        }</span>
        <span class="cov0" title="0">return re.res, re.err</span>
}

// markBroken marks a connection as broken (so it's not reused).
// It differs from close in that it doesn't close the underlying
// connection for use when it's still being read.
func (pc *persistConn) markBroken() <span class="cov0" title="0">{
        pc.lk.Lock()
        defer pc.lk.Unlock()
        pc.broken = true
}</span>

func (pc *persistConn) close() <span class="cov0" title="0">{
        pc.lk.Lock()
        defer pc.lk.Unlock()
        pc.closeLocked()
}</span>

func (pc *persistConn) closeLocked() <span class="cov0" title="0">{
        pc.broken = true
        if !pc.closed </span><span class="cov0" title="0">{
                pc.conn.Close()
                pc.closed = true
                // there are some many reason to close a conn, in order to avoid missing release in some place,
                // it is a safely way to release conn cnt in pc.close()
                pc.t.releaseConnCnt(pc.cacheKey)
        }</span>
        <span class="cov0" title="0">pc.mutateHeaderFunc = nil</span>
}

var portMap = map[string]string{
        "http":  "80",
        "https": "443",
}

// canonicalAddr returns url.Host but always with a ":port" suffix
func canonicalAddr(url *url.URL) string <span class="cov0" title="0">{
        addr := url.Host
        if !hasPort(addr) </span><span class="cov0" title="0">{
                return addr + ":" + portMap[url.Scheme]
        }</span>
        <span class="cov0" title="0">return addr</span>
}

// bodyEOFSignal wraps a ReadCloser but runs fn (if non-nil) at most
// once, right before its final (error-producing) Read or Close call
// returns. If earlyCloseFn is non-nil and Close is called before
// io.EOF is seen, earlyCloseFn is called instead of fn, and its
// return value is the return value from Close.
type bodyEOFSignal struct {
        body         io.ReadCloser
        mu           sync.Mutex   // guards following 4 fields
        closed       bool         // whether Close has been called
        rerr         error        // sticky Read error
        fn           func(error)  // error will be nil on Read io.EOF
        earlyCloseFn func() error // optional alt Close func used if io.EOF not seen
}

func (es *bodyEOFSignal) Read(p []byte) (n int, err error) <span class="cov0" title="0">{
        es.mu.Lock()
        closed, rerr := es.closed, es.rerr
        es.mu.Unlock()
        if closed </span><span class="cov0" title="0">{
                return 0, errors.New("http: read on closed response body")
        }</span>
        <span class="cov0" title="0">if rerr != nil </span><span class="cov0" title="0">{
                return 0, rerr
        }</span>

        <span class="cov0" title="0">n, err = es.body.Read(p)
        if err != nil </span><span class="cov0" title="0">{
                es.mu.Lock()
                defer es.mu.Unlock()
                if es.rerr == nil </span><span class="cov0" title="0">{
                        es.rerr = err
                }</span>
                <span class="cov0" title="0">es.condfn(err)</span>
        }
        <span class="cov0" title="0">return</span>
}

func (es *bodyEOFSignal) Close() error <span class="cov0" title="0">{
        es.mu.Lock()
        defer es.mu.Unlock()
        if es.closed </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">es.closed = true
        if es.earlyCloseFn != nil &amp;&amp; es.rerr != io.EOF </span><span class="cov0" title="0">{
                return es.earlyCloseFn()
        }</span>
        <span class="cov0" title="0">err := es.body.Close()
        es.condfn(err)
        return err</span>
}

// caller must hold es.mu.
func (es *bodyEOFSignal) condfn(err error) <span class="cov0" title="0">{
        if es.fn == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if err == io.EOF </span><span class="cov0" title="0">{
                err = nil
        }</span>
        <span class="cov0" title="0">es.fn(err)
        es.fn = nil</span>
}

type readerAndCloser struct {
        io.Reader
        io.Closer
}
</pre>
		
		<pre class="file" id="file53" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Copyright 2014 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package bfe_http2

import (
        "errors"
        "fmt"
)

// An ErrCode is an unsigned 32-bit error code as defined in the HTTP/2 spec.
type ErrCode uint32

const (
        ErrCodeNo                 ErrCode = 0x0
        ErrCodeProtocol           ErrCode = 0x1
        ErrCodeInternal           ErrCode = 0x2
        ErrCodeFlowControl        ErrCode = 0x3
        ErrCodeSettingsTimeout    ErrCode = 0x4
        ErrCodeStreamClosed       ErrCode = 0x5
        ErrCodeFrameSize          ErrCode = 0x6
        ErrCodeRefusedStream      ErrCode = 0x7
        ErrCodeCancel             ErrCode = 0x8
        ErrCodeCompression        ErrCode = 0x9
        ErrCodeConnect            ErrCode = 0xa
        ErrCodeEnhanceYourCalm    ErrCode = 0xb
        ErrCodeInadequateSecurity ErrCode = 0xc
        ErrCodeHTTP11Required     ErrCode = 0xd
)

var errCodeName = map[ErrCode]string{
        ErrCodeNo:                 "NO_ERROR",
        ErrCodeProtocol:           "PROTOCOL_ERROR",
        ErrCodeInternal:           "INTERNAL_ERROR",
        ErrCodeFlowControl:        "FLOW_CONTROL_ERROR",
        ErrCodeSettingsTimeout:    "SETTINGS_TIMEOUT",
        ErrCodeStreamClosed:       "STREAM_CLOSED",
        ErrCodeFrameSize:          "FRAME_SIZE_ERROR",
        ErrCodeRefusedStream:      "REFUSED_STREAM",
        ErrCodeCancel:             "CANCEL",
        ErrCodeCompression:        "COMPRESSION_ERROR",
        ErrCodeConnect:            "CONNECT_ERROR",
        ErrCodeEnhanceYourCalm:    "ENHANCE_YOUR_CALM",
        ErrCodeInadequateSecurity: "INADEQUATE_SECURITY",
        ErrCodeHTTP11Required:     "HTTP_1_1_REQUIRED",
}

func (e ErrCode) String() string <span class="cov8" title="1">{
        if s, ok := errCodeName[e]; ok </span><span class="cov8" title="1">{
                return s
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("unknown error code 0x%x", uint32(e))</span>
}

// ConnectionError is an error that results in the termination of the
// entire connection.
type ConnectionError struct {
        Code   ErrCode
        Reason string
}

func (e ConnectionError) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("connection error: %s ; %s", ErrCode(e.Code), e.Reason)
}</span>

// StreamError is an error that only affects one stream within an
// HTTP/2 connection.
type StreamError struct {
        StreamID uint32
        Code     ErrCode
        Reason   string
}

func (e StreamError) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("stream error: stream ID %d; %v; %s", e.StreamID, e.Code, e.Reason)
}</span>

// 6.9.1 The Flow Control Window
// "If a sender receives a WINDOW_UPDATE that causes a flow control
// window to exceed this maximum it MUST terminate either the stream
// or the connection, as appropriate. For streams, [...]; for the
// connection, a GOAWAY frame with a FLOW_CONTROL_ERROR code."
type goAwayFlowError struct{}

func (goAwayFlowError) Error() string <span class="cov0" title="0">{ return "connection exceeded flow control window size" }</span>

// connErrorReason wraps a ConnectionError with an informative error about why it occurs.

// Errors of this type are only returned by the frame parser functions
// and converted into ConnectionError(ErrCodeProtocol).
type connError struct {
        Code   ErrCode
        Reason string
}

func (e connError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("http2: connection error: %v: %v", e.Code, e.Reason)
}</span>

type pseudoHeaderError string

func (e pseudoHeaderError) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("invalid pseudo-header %q", string(e))
}</span>

type duplicatePseudoHeaderError string

func (e duplicatePseudoHeaderError) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("duplicate pseudo-header %q", string(e))
}</span>

type headerFieldNameError string

func (e headerFieldNameError) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("invalid header field name %q", string(e))
}</span>

type headerFieldValueError string

func (e headerFieldValueError) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("invalid header field value %q", string(e))
}</span>

type maxStreamsError struct {
        userAgent  string
        streamID   uint32
        maxStreams uint32
}

func (e maxStreamsError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("curOpenStreams(streamID[%d], userAgent[%s] &gt; maxStreams[%d]",
                e.streamID, e.userAgent, e.maxStreams)
}</span>

type maxHeaderUriSizeError struct {
        streamID         uint32
        uri              string
        maxHeaderUriSize uint32
}

func (e maxHeaderUriSizeError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("streamID[%d] uri[%s], len[%d] &gt; maxHeaderUriSize[%d]",
                e.streamID, e.uri, len(e.uri), e.maxHeaderUriSize)
}</span>

type maxHeaderListSizeError struct {
        streamID          uint32
        curHeaderListSize uint32
        maxHeaderListSize uint32
}

func (e maxHeaderListSizeError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("streamID[%d] current headerListSize[%d] &gt; maxHeaderListSize[%d]",
                e.streamID, e.curHeaderListSize, e.maxHeaderListSize)
}</span>

var (
        errMixPseudoHeaderTypes = errors.New("mix of request and response pseudo headers")
        errPseudoAfterRegular   = errors.New("pseudo header field after regular")
)
</pre>
		
		<pre class="file" id="file54" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Copyright 2014 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Flow control

package bfe_http2

// flow is the flow control window's size.
type flow struct {
        // n is the number of DATA bytes we're allowed to send.
        // A flow is kept both on a conn and a per-stream.
        n int32

        // conn points to the shared connection-level flow that is
        // shared by all streams on that conn. It is nil for the flow
        // that's on the conn directly.
        conn *flow
}

func (f *flow) setConnFlow(cf *flow) <span class="cov8" title="1">{ f.conn = cf }</span>

func (f *flow) available() int32 <span class="cov8" title="1">{
        n := f.n
        if f.conn != nil &amp;&amp; f.conn.n &lt; n </span><span class="cov8" title="1">{
                n = f.conn.n
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (f *flow) take(n int32) <span class="cov8" title="1">{
        if n &gt; f.available() </span><span class="cov0" title="0">{
                panic("internal error: took too much")</span>
        }
        <span class="cov8" title="1">f.n -= n
        if f.conn != nil </span><span class="cov8" title="1">{
                f.conn.n -= n
        }</span>
}

// add adds n bytes (positive or negative) to the flow control window.
// It returns false if the sum would exceed 2^31-1.
func (f *flow) add(n int32) bool <span class="cov8" title="1">{
        remain := (1&lt;&lt;31 - 1) - f.n
        if n &gt; remain </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">f.n += n
        return true</span>
}
</pre>
		
		<pre class="file" id="file55" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Copyright 2014 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package bfe_http2

import (
        "bytes"
        "encoding/binary"
        "errors"
        "fmt"
        "io"
        "log"
        "strings"
        "sync"
)

import (
        http "github.com/bfenetworks/bfe/bfe_http"
        "github.com/bfenetworks/bfe/bfe_http2/hpack"
)

const frameHeaderLen = 9

var padZeros = make([]byte, 255) // zeros for padding

// A FrameType is a registered frame type as defined in
// http://http2.github.io/http2-spec/#rfc.section.11.2
type FrameType uint8

const (
        FrameData         FrameType = 0x0
        FrameHeaders      FrameType = 0x1
        FramePriority     FrameType = 0x2
        FrameRSTStream    FrameType = 0x3
        FrameSettings     FrameType = 0x4
        FramePushPromise  FrameType = 0x5
        FramePing         FrameType = 0x6
        FrameGoAway       FrameType = 0x7
        FrameWindowUpdate FrameType = 0x8
        FrameContinuation FrameType = 0x9
)

var frameName = map[FrameType]string{
        FrameData:         "DATA",
        FrameHeaders:      "HEADERS",
        FramePriority:     "PRIORITY",
        FrameRSTStream:    "RST_STREAM",
        FrameSettings:     "SETTINGS",
        FramePushPromise:  "PUSH_PROMISE",
        FramePing:         "PING",
        FrameGoAway:       "GOAWAY",
        FrameWindowUpdate: "WINDOW_UPDATE",
        FrameContinuation: "CONTINUATION",
}

func (t FrameType) String() string <span class="cov8" title="1">{
        if s, ok := frameName[t]; ok </span><span class="cov8" title="1">{
                return s
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("UNKNOWN_FRAME_TYPE_%d", uint8(t))</span>
}

// Flags is a bitmask of HTTP/2 flags.
// The meaning of flags varies depending on the frame type.
type Flags uint8

// Has reports whether f contains all (0 or more) flags in v.
func (f Flags) Has(v Flags) bool <span class="cov8" title="1">{
        return (f &amp; v) == v
}</span>

// Frame-specific FrameHeader flag bits.
const (
        // Data Frame
        FlagDataEndStream Flags = 0x1
        FlagDataPadded    Flags = 0x8

        // Headers Frame
        FlagHeadersEndStream  Flags = 0x1
        FlagHeadersEndHeaders Flags = 0x4
        FlagHeadersPadded     Flags = 0x8
        FlagHeadersPriority   Flags = 0x20

        // Settings Frame
        FlagSettingsAck Flags = 0x1

        // Ping Frame
        FlagPingAck Flags = 0x1

        // Continuation Frame
        FlagContinuationEndHeaders Flags = 0x4

        FlagPushPromiseEndHeaders Flags = 0x4
        FlagPushPromisePadded     Flags = 0x8
)

var flagName = map[FrameType]map[Flags]string{
        FrameData: {
                FlagDataEndStream: "END_STREAM",
                FlagDataPadded:    "PADDED",
        },
        FrameHeaders: {
                FlagHeadersEndStream:  "END_STREAM",
                FlagHeadersEndHeaders: "END_HEADERS",
                FlagHeadersPadded:     "PADDED",
                FlagHeadersPriority:   "PRIORITY",
        },
        FrameSettings: {
                FlagSettingsAck: "ACK",
        },
        FramePing: {
                FlagPingAck: "ACK",
        },
        FrameContinuation: {
                FlagContinuationEndHeaders: "END_HEADERS",
        },
        FramePushPromise: {
                FlagPushPromiseEndHeaders: "END_HEADERS",
                FlagPushPromisePadded:     "PADDED",
        },
}

// a frameParser parses a frame given its FrameHeader and payload
// bytes. The length of payload will always equal fh.Length (which
// might be 0).
type frameParser func(fh FrameHeader, payload []byte) (Frame, error)

var frameParsers = map[FrameType]frameParser{
        FrameData:         parseDataFrame,
        FrameHeaders:      parseHeadersFrame,
        FramePriority:     parsePriorityFrame,
        FrameRSTStream:    parseRSTStreamFrame,
        FrameSettings:     parseSettingsFrame,
        FramePushPromise:  parsePushPromise,
        FramePing:         parsePingFrame,
        FrameGoAway:       parseGoAwayFrame,
        FrameWindowUpdate: parseWindowUpdateFrame,
        FrameContinuation: parseContinuationFrame,
}

func typeFrameParser(t FrameType) frameParser <span class="cov8" title="1">{
        if f := frameParsers[t]; f != nil </span><span class="cov8" title="1">{
                return f
        }</span>
        <span class="cov0" title="0">return parseUnknownFrame</span>
}

// A FrameHeader is the 9 byte header of all HTTP/2 frames.
//
// See http://http2.github.io/http2-spec/#FrameHeader
type FrameHeader struct {
        valid bool // caller can access []byte fields in the Frame

        // Type is the 1 byte frame type. There are ten standard frame
        // types, but extension frame types may be written by WriteRawFrame
        // and will be returned by ReadFrame (as UnknownFrame).
        Type FrameType

        // Flags are the 1 byte of 8 potential bit flags per frame.
        // They are specific to the frame type.
        Flags Flags

        // Length is the length of the frame, not including the 9 byte header.
        // The maximum size is one byte less than 16MB (uint24), but only
        // frames up to 16KB are allowed without peer agreement.
        Length uint32

        // StreamID is which stream this frame is for. Certain frames
        // are not stream-specific, in which case this field is 0.
        StreamID uint32
}

// Header returns h. It exists so FrameHeaders can be embedded in other
// specific frame types and implement the Frame interface.
func (h FrameHeader) Header() FrameHeader <span class="cov8" title="1">{ return h }</span>

func (h FrameHeader) String() string <span class="cov8" title="1">{
        var buf bytes.Buffer
        buf.WriteString("[FrameHeader ")
        h.writeDebug(&amp;buf)
        buf.WriteByte(']')
        return buf.String()
}</span>

func (h FrameHeader) writeDebug(buf *bytes.Buffer) <span class="cov8" title="1">{
        buf.WriteString(h.Type.String())
        if h.Flags != 0 </span><span class="cov8" title="1">{
                buf.WriteString(" flags=")
                set := 0
                for i := uint8(0); i &lt; 8; i++ </span><span class="cov8" title="1">{
                        if h.Flags&amp;(1&lt;&lt;i) == 0 </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">set++
                        if set &gt; 1 </span><span class="cov8" title="1">{
                                buf.WriteByte('|')
                        }</span>
                        <span class="cov8" title="1">name := flagName[h.Type][Flags(1&lt;&lt;i)]
                        if name != "" </span><span class="cov8" title="1">{
                                buf.WriteString(name)
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Fprintf(buf, "0x%x", 1&lt;&lt;i)
                        }</span>
                }
        }
        <span class="cov8" title="1">if h.StreamID != 0 </span><span class="cov8" title="1">{
                fmt.Fprintf(buf, " stream=%d", h.StreamID)
        }</span>
        <span class="cov8" title="1">fmt.Fprintf(buf, " len=%d", h.Length)</span>
}

func (h *FrameHeader) checkValid() <span class="cov8" title="1">{
        if !h.valid </span><span class="cov0" title="0">{
                panic("Frame accessor called on non-owned Frame")</span>
        }
}

func (h *FrameHeader) invalidate() <span class="cov8" title="1">{ h.valid = false }</span>

// frame header bytes.
// Used only by ReadFrameHeader.
var fhBytes = sync.Pool{
        New: func() interface{} <span class="cov8" title="1">{
                buf := make([]byte, frameHeaderLen)
                return &amp;buf
        }</span>,
}

// ReadFrameHeader reads 9 bytes from r and returns a FrameHeader.
// Most users should use Framer.ReadFrame instead.
func ReadFrameHeader(r io.Reader) (FrameHeader, error) <span class="cov8" title="1">{
        bufp := fhBytes.Get().(*[]byte)
        defer fhBytes.Put(bufp)
        return readFrameHeader(*bufp, r)
}</span>

func readFrameHeader(buf []byte, r io.Reader) (FrameHeader, error) <span class="cov8" title="1">{
        _, err := io.ReadFull(r, buf[:frameHeaderLen])
        if err != nil </span><span class="cov8" title="1">{
                return FrameHeader{}, err
        }</span>
        <span class="cov8" title="1">return FrameHeader{
                Length:   (uint32(buf[0])&lt;&lt;16 | uint32(buf[1])&lt;&lt;8 | uint32(buf[2])),
                Type:     FrameType(buf[3]),
                Flags:    Flags(buf[4]),
                StreamID: binary.BigEndian.Uint32(buf[5:]) &amp; (1&lt;&lt;31 - 1),
                valid:    true,
        }, nil</span>
}

// A Frame is the base interface implemented by all frame types.
// Callers will generally type-assert the specific frame type:
// *HeadersFrame, *SettingsFrame, *WindowUpdateFrame, etc.
//
// Frames are only valid until the next call to Framer.ReadFrame.
type Frame interface {
        Header() FrameHeader

        // invalidate is called by Framer.ReadFrame to make this
        // frame's buffers as being invalid, since the subsequent
        // frame will reuse them.
        invalidate()
}

// A Framer reads and writes Frames.
type Framer struct {
        r         io.Reader
        lastFrame Frame
        errDetail error

        // lastHeaderStream is non-zero if the last frame was an
        // unfinished HEADERS/CONTINUATION.
        lastHeaderStream uint32

        maxReadSize uint32
        headerBuf   [frameHeaderLen]byte

        // TODO: let getReadBuf be configurable, and use a less memory-pinning
        // allocator in server.go to minimize memory pinned for many idle conns.
        // Will probably also need to make frame invalidation have a hook too.
        getReadBuf func(size uint32) []byte
        readBuf    []byte // cache for default getReadBuf

        maxWriteSize uint32 // zero means unlimited; TODO: implement

        w    io.Writer
        wbuf []byte

        // AllowIllegalWrites permits the Framer's Write methods to
        // write frames that do not conform to the HTTP/2 spec. This
        // permits using the Framer to test other HTTP/2
        // implementations' conformance to the spec.
        // If false, the Write methods will prefer to return an error
        // rather than comply.
        AllowIllegalWrites bool

        // AllowIllegalReads permits the Framer's ReadFrame method
        // to return non-compliant frames or frame orders.
        // This is for testing and permits using the Framer to test
        // other HTTP/2 implementations' conformance to the spec.
        // It is not compatible with ReadMetaHeaders.
        AllowIllegalReads bool

        // ReadMetaHeaders if non-nil causes ReadFrame to merge
        // HEADERS and CONTINUATION frames together and return
        // MetaHeadersFrame instead.
        ReadMetaHeaders *hpack.Decoder

        // MaxHeaderListSize is the http2 MAX_HEADER_LIST_SIZE.
        // It's used only if ReadMetaHeaders is set; 0 means a sane default
        // (currently 16MB)
        // If the limit is hit, MetaHeadersFrame.Truncated is set true.
        MaxHeaderListSize uint32

        // max uri size
        MaxHeaderUriSize uint32

        // TODO: track which type of frame &amp; with which flags was sent
        // last.  Then return an error (unless AllowIllegalWrites) if
        // we're in the middle of a header block and a
        // non-Continuation or Continuation on a different stream is
        // attempted to be written.

        logReads bool

        debugFramer    *Framer // only use for logging written writes
        debugFramerBuf *bytes.Buffer
}

func (fr *Framer) maxHeaderListSize() uint32 <span class="cov8" title="1">{
        if fr.MaxHeaderListSize == 0 </span><span class="cov8" title="1">{
                return http.DefaultMaxHeaderBytes
        }</span>
        <span class="cov8" title="1">return fr.MaxHeaderListSize</span>
}

func (fr *Framer) maxHeaderUriSize() uint32 <span class="cov8" title="1">{
        if fr.MaxHeaderUriSize == 0 </span><span class="cov8" title="1">{
                return http.DefaultMaxHeaderUriBytes
        }</span>
        <span class="cov8" title="1">return fr.MaxHeaderUriSize</span>
}

func (f *Framer) startWrite(ftype FrameType, flags Flags, streamID uint32) <span class="cov8" title="1">{
        // Write the FrameHeader.
        f.wbuf = append(f.wbuf[:0],
                0, // 3 bytes of length, filled in in endWrite
                0,
                0,
                byte(ftype),
                byte(flags),
                byte(streamID&gt;&gt;24),
                byte(streamID&gt;&gt;16),
                byte(streamID&gt;&gt;8),
                byte(streamID))
}</span>

func (f *Framer) endWrite() error <span class="cov8" title="1">{
        // Now that we know the final size, fill in the FrameHeader in
        // the space previously reserved for it. Abuse append.
        length := len(f.wbuf) - frameHeaderLen
        if length &gt;= (1 &lt;&lt; 24) </span><span class="cov8" title="1">{
                return ErrFrameTooLarge
        }</span>
        <span class="cov8" title="1">_ = append(f.wbuf[:0],
                byte(length&gt;&gt;16),
                byte(length&gt;&gt;8),
                byte(length))
        if logFrameWrites </span><span class="cov0" title="0">{
                f.logWrite()
        }</span>

        <span class="cov8" title="1">n, err := f.w.Write(f.wbuf)
        if err == nil &amp;&amp; n != len(f.wbuf) </span><span class="cov0" title="0">{
                err = io.ErrShortWrite
        }</span>
        <span class="cov8" title="1">return err</span>
}

func (f *Framer) logWrite() <span class="cov0" title="0">{
        if f.debugFramer == nil </span><span class="cov0" title="0">{
                f.debugFramerBuf = new(bytes.Buffer)
                f.debugFramer = NewFramer(nil, f.debugFramerBuf)
                f.debugFramer.logReads = false // we log it ourselves, saying "wrote" below
                // Let us read anything, even if we accidentally wrote it
                // in the wrong order:
                f.debugFramer.AllowIllegalReads = true
        }</span>
        <span class="cov0" title="0">f.debugFramerBuf.Write(f.wbuf)
        fr, err := f.debugFramer.ReadFrame()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("http2: Framer %p: failed to decode just-written frame", f)
                return
        }</span>
        <span class="cov0" title="0">log.Printf("http2: Framer %p: wrote %v", f, summarizeFrame(fr))</span>
}

func (f *Framer) writeByte(v byte)     <span class="cov8" title="1">{ f.wbuf = append(f.wbuf, v) }</span>
func (f *Framer) writeBytes(v []byte)  <span class="cov8" title="1">{ f.wbuf = append(f.wbuf, v...) }</span>
func (f *Framer) writeUint16(v uint16) <span class="cov8" title="1">{ f.wbuf = append(f.wbuf, byte(v&gt;&gt;8), byte(v)) }</span>
func (f *Framer) writeUint32(v uint32) <span class="cov8" title="1">{
        f.wbuf = append(f.wbuf, byte(v&gt;&gt;24), byte(v&gt;&gt;16), byte(v&gt;&gt;8), byte(v))
}</span>

const (
        minMaxFrameSize = 1 &lt;&lt; 14
        maxFrameSize    = 1&lt;&lt;24 - 1
)

// NewFramer returns a Framer that writes frames to w and reads them from r.
func NewFramer(w io.Writer, r io.Reader) *Framer <span class="cov8" title="1">{
        fr := &amp;Framer{
                w:        w,
                r:        r,
                logReads: logFrameReads,
        }
        fr.getReadBuf = func(size uint32) []byte </span><span class="cov8" title="1">{
                if cap(fr.readBuf) &gt;= int(size) </span><span class="cov8" title="1">{
                        return fr.readBuf[:size]
                }</span>
                <span class="cov8" title="1">fr.readBuf = make([]byte, size)
                return fr.readBuf</span>
        }
        <span class="cov8" title="1">fr.SetMaxReadFrameSize(maxFrameSize)
        return fr</span>
}

// SetMaxReadFrameSize sets the maximum size of a frame
// that will be read by a subsequent call to ReadFrame.
// It is the caller's responsibility to advertise this
// limit with a SETTINGS frame.
func (fr *Framer) SetMaxReadFrameSize(v uint32) <span class="cov8" title="1">{
        if v &gt; maxFrameSize </span><span class="cov0" title="0">{
                v = maxFrameSize
        }</span>
        <span class="cov8" title="1">fr.maxReadSize = v</span>
}

// ErrorDetail returns a more detailed error of the last error
// returned by Framer.ReadFrame. For instance, if ReadFrame
// returns a StreamError with code PROTOCOL_ERROR, ErrorDetail
// will say exactly what was invalid. ErrorDetail is not guaranteed
// to return a non-nil value and like the rest of the http2 package,
// its return value is not protected by an API compatibility promise.
// ErrorDetail is reset after the next call to ReadFrame.
func (fr *Framer) ErrorDetail() error <span class="cov0" title="0">{
        return fr.errDetail
}</span>

// ErrFrameTooLarge is returned from Framer.ReadFrame when the peer
// sends a frame that is larger than declared with SetMaxReadFrameSize.
var ErrFrameTooLarge = errors.New("http2: frame too large")

// terminalReadFrameError reports whether err is an unrecoverable
// error from ReadFrame and no other frames should be read.
func terminalReadFrameError(err error) bool <span class="cov8" title="1">{
        if _, ok := err.(StreamError); ok </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return err != nil</span>
}

// ReadFrame reads a single frame. The returned Frame is only valid
// until the next call to ReadFrame.
//
// If the frame is larger than previously set with SetMaxReadFrameSize, the
// returned error is ErrFrameTooLarge. Other errors may be of type
// ConnectionError, StreamError, or anything else from from the underlying
// reader.
func (fr *Framer) ReadFrame() (Frame, error) <span class="cov8" title="1">{
        fr.errDetail = nil
        if fr.lastFrame != nil </span><span class="cov8" title="1">{
                fr.lastFrame.invalidate()
        }</span>
        <span class="cov8" title="1">fh, err := readFrameHeader(fr.headerBuf[:], fr.r)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if fh.Length &gt; fr.maxReadSize </span><span class="cov8" title="1">{
                return nil, ErrFrameTooLarge
        }</span>
        <span class="cov8" title="1">payload := fr.getReadBuf(fh.Length)
        if _, err := io.ReadFull(fr.r, payload); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">f, err := typeFrameParser(fh.Type)(fh, payload)
        if err != nil </span><span class="cov8" title="1">{
                if ce, ok := err.(connError); ok </span><span class="cov8" title="1">{
                        return nil, fr.connError(ce.Code, ce.Reason)
                }</span>
                <span class="cov8" title="1">return nil, err</span>
        }
        <span class="cov8" title="1">if err := fr.checkFrameOrder(f); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if fr.logReads </span><span class="cov0" title="0">{
                log.Printf("http2: Framer %p: read %v", fr, summarizeFrame(f))
        }</span>
        <span class="cov8" title="1">if fh.Type == FrameHeaders &amp;&amp; fr.ReadMetaHeaders != nil </span><span class="cov8" title="1">{
                return fr.readMetaFrame(f.(*HeadersFrame))
        }</span>
        <span class="cov8" title="1">return f, nil</span>
}

// connError returns ConnectionError(code) but first
// stashes away a public reason to the caller can optionally relay it
// to the peer before hanging up on them. This might help others debug
// their implementations.
func (fr *Framer) connError(code ErrCode, reason string) error <span class="cov8" title="1">{
        fr.errDetail = errors.New(reason)
        return ConnectionError{code, reason}
}</span>

// checkFrameOrder reports an error if f is an invalid frame to return
// next from ReadFrame. Mostly it checks whether HEADERS and
// CONTINUATION frames are contiguous.
func (fr *Framer) checkFrameOrder(f Frame) error <span class="cov8" title="1">{
        last := fr.lastFrame
        fr.lastFrame = f
        if fr.AllowIllegalReads </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">fh := f.Header()
        if fr.lastHeaderStream != 0 </span><span class="cov8" title="1">{
                if fh.Type != FrameContinuation </span><span class="cov8" title="1">{
                        return fr.connError(ErrCodeProtocol,
                                fmt.Sprintf("got %s for stream %d; expected CONTINUATION following %s for stream %d",
                                        fh.Type, fh.StreamID,
                                        last.Header().Type, fr.lastHeaderStream))
                }</span>
                <span class="cov8" title="1">if fh.StreamID != fr.lastHeaderStream </span><span class="cov8" title="1">{
                        return fr.connError(ErrCodeProtocol,
                                fmt.Sprintf("got CONTINUATION for stream %d; expected stream %d",
                                        fh.StreamID, fr.lastHeaderStream))
                }</span>
        } else<span class="cov8" title="1"> if fh.Type == FrameContinuation </span><span class="cov8" title="1">{
                return fr.connError(ErrCodeProtocol, fmt.Sprintf("unexpected CONTINUATION for stream %d", fh.StreamID))
        }</span>

        <span class="cov8" title="1">switch fh.Type </span>{
        case FrameHeaders, FrameContinuation:<span class="cov8" title="1">
                if fh.Flags.Has(FlagHeadersEndHeaders) </span><span class="cov8" title="1">{
                        fr.lastHeaderStream = 0
                }</span> else<span class="cov8" title="1"> {
                        fr.lastHeaderStream = fh.StreamID
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// A DataFrame conveys arbitrary, variable-length sequences of octets
// associated with a stream.
// See http://http2.github.io/http2-spec/#rfc.section.6.1
type DataFrame struct {
        FrameHeader
        data []byte
}

func (f *DataFrame) StreamEnded() bool <span class="cov8" title="1">{
        return f.FrameHeader.Flags.Has(FlagDataEndStream)
}</span>

// Data returns the frame's data octets, not including any padding
// size byte or padding suffix bytes.
// The caller must not retain the returned memory past the next
// call to ReadFrame.
func (f *DataFrame) Data() []byte <span class="cov8" title="1">{
        f.checkValid()
        return f.data
}</span>

func parseDataFrame(fh FrameHeader, payload []byte) (Frame, error) <span class="cov8" title="1">{
        if fh.StreamID == 0 </span><span class="cov0" title="0">{
                // DATA frames MUST be associated with a stream. If a
                // DATA frame is received whose stream identifier
                // field is 0x0, the recipient MUST respond with a
                // connection error (Section 5.4.1) of type
                // PROTOCOL_ERROR.
                return nil, connError{ErrCodeProtocol, "DATA frame with stream ID 0"}
        }</span>
        <span class="cov8" title="1">f := &amp;DataFrame{
                FrameHeader: fh,
        }
        var padSize byte
        if fh.Flags.Has(FlagDataPadded) </span><span class="cov8" title="1">{
                var err error
                payload, padSize, err = readByte(payload)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov8" title="1">if int(padSize) &gt; len(payload) </span><span class="cov0" title="0">{
                // If the length of the padding is greater than the
                // length of the frame payload, the recipient MUST
                // treat this as a connection error.
                // Filed: https://github.com/http2/http2-spec/issues/610
                return nil, connError{ErrCodeProtocol, "pad size larger than data payload"}
        }</span>
        <span class="cov8" title="1">f.data = payload[:len(payload)-int(padSize)]
        return f, nil</span>
}

var (
        errStreamID  = errors.New("invalid streamid")
        errPadLength = errors.New("pad length too large")
)

func validStreamID(streamID uint32) bool <span class="cov8" title="1">{
        return streamID != 0 &amp;&amp; streamID&amp;(1&lt;&lt;31) == 0
}</span>

// WriteData writes a DATA frame.
//
// It will perform exactly one Write to the underlying Writer.
// It is the caller's responsibility to not call other Write methods concurrently.
func (f *Framer) WriteData(streamID uint32, endStream bool, data []byte) error <span class="cov8" title="1">{
        return f.WriteDataPadded(streamID, endStream, data, nil)
}</span>

// WriteData writes a DATA frame with optional padding.
//
// If pad is nil, the padding bit is not sent.
// The length of pad must not exceed 255 bytes.
//
// It will perform exactly one Write to the underlying Writer.
// It is the caller's responsibility not to violate the maximum frame size
// and to not call other Write methods concurrently.
func (f *Framer) WriteDataPadded(streamID uint32, endStream bool, data, pad []byte) error <span class="cov8" title="1">{
        if !validStreamID(streamID) &amp;&amp; !f.AllowIllegalWrites </span><span class="cov0" title="0">{
                return errStreamID
        }</span>
        <span class="cov8" title="1">if len(pad) &gt; 255 </span><span class="cov0" title="0">{
                return errPadLength
        }</span>

        <span class="cov8" title="1">var flags Flags
        if endStream </span><span class="cov8" title="1">{
                flags |= FlagDataEndStream
        }</span>
        <span class="cov8" title="1">if pad != nil </span><span class="cov8" title="1">{
                flags |= FlagDataPadded
        }</span>
        <span class="cov8" title="1">f.startWrite(FrameData, flags, streamID)
        if pad != nil </span><span class="cov8" title="1">{
                f.wbuf = append(f.wbuf, byte(len(pad)))
        }</span>
        <span class="cov8" title="1">f.wbuf = append(f.wbuf, data...)
        f.wbuf = append(f.wbuf, pad...)
        return f.endWrite()</span>
}

// A SettingsFrame conveys configuration parameters that affect how
// endpoints communicate, such as preferences and constraints on peer
// behavior.
//
// See http://http2.github.io/http2-spec/#SETTINGS
type SettingsFrame struct {
        FrameHeader
        p []byte
}

func parseSettingsFrame(fh FrameHeader, p []byte) (Frame, error) <span class="cov8" title="1">{
        if fh.Flags.Has(FlagSettingsAck) &amp;&amp; fh.Length &gt; 0 </span><span class="cov0" title="0">{
                // When this (ACK 0x1) bit is set, the payload of the
                // SETTINGS frame MUST be empty.  Receipt of a
                // SETTINGS frame with the ACK flag set and a length
                // field value other than 0 MUST be treated as a
                // connection error (Section 5.4.1) of type
                // FRAME_SIZE_ERROR.
                return nil, ConnectionError{ErrCodeFrameSize, "SETTINGS with ACK flag but nonempty payload"}
        }</span>
        <span class="cov8" title="1">if fh.StreamID != 0 </span><span class="cov0" title="0">{
                // SETTINGS frames always apply to a connection,
                // never a single stream.  The stream identifier for a
                // SETTINGS frame MUST be zero (0x0).  If an endpoint
                // receives a SETTINGS frame whose stream identifier
                // field is anything other than 0x0, the endpoint MUST
                // respond with a connection error (Section 5.4.1) of
                // type PROTOCOL_ERROR.
                return nil, ConnectionError{ErrCodeProtocol, "SETTINGS with non-zero stream Id"}
        }</span>
        <span class="cov8" title="1">if len(p)%6 != 0 </span><span class="cov0" title="0">{
                // Expecting even number of 6 byte settings.
                return nil, ConnectionError{ErrCodeFrameSize, "SETTINGS with wrong payload size"}
        }</span>
        <span class="cov8" title="1">f := &amp;SettingsFrame{FrameHeader: fh, p: p}
        if v, ok := f.Value(SettingInitialWindowSize); ok &amp;&amp; v &gt; (1&lt;&lt;31)-1 </span><span class="cov0" title="0">{
                // Values above the maximum flow control window size of 2^31 - 1 MUST
                // be treated as a connection error (Section 5.4.1) of type
                // FLOW_CONTROL_ERROR.
                return nil, ConnectionError{ErrCodeFlowControl, "SETTINGS with illegal InitialWindowSize"}
        }</span>
        <span class="cov8" title="1">return f, nil</span>
}

func (f *SettingsFrame) IsAck() bool <span class="cov8" title="1">{
        return f.FrameHeader.Flags.Has(FlagSettingsAck)
}</span>

func (f *SettingsFrame) Value(s SettingID) (v uint32, ok bool) <span class="cov8" title="1">{
        f.checkValid()
        buf := f.p
        for len(buf) &gt; 0 </span><span class="cov8" title="1">{
                settingID := SettingID(binary.BigEndian.Uint16(buf[:2]))
                if settingID == s </span><span class="cov8" title="1">{
                        return binary.BigEndian.Uint32(buf[2:6]), true
                }</span>
                <span class="cov8" title="1">buf = buf[6:]</span>
        }
        <span class="cov8" title="1">return 0, false</span>
}

// ForeachSetting runs fn for each setting.
// It stops and returns the first error.
func (f *SettingsFrame) ForeachSetting(fn func(Setting) error) error <span class="cov8" title="1">{
        f.checkValid()
        buf := f.p
        for len(buf) &gt; 0 </span><span class="cov8" title="1">{
                if err := fn(Setting{
                        SettingID(binary.BigEndian.Uint16(buf[:2])),
                        binary.BigEndian.Uint32(buf[2:6]),
                }); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">buf = buf[6:]</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// WriteSettings writes a SETTINGS frame with zero or more settings
// specified and the ACK bit not set.
//
// It will perform exactly one Write to the underlying Writer.
// It is the caller's responsibility to not call other Write methods concurrently.
func (f *Framer) WriteSettings(settings ...Setting) error <span class="cov8" title="1">{
        f.startWrite(FrameSettings, 0, 0)
        for _, s := range settings </span><span class="cov8" title="1">{
                f.writeUint16(uint16(s.ID))
                f.writeUint32(s.Val)
        }</span>
        <span class="cov8" title="1">return f.endWrite()</span>
}

// WriteSettings writes an empty SETTINGS frame with the ACK bit set.
//
// It will perform exactly one Write to the underlying Writer.
// It is the caller's responsibility to not call other Write methods concurrently.
func (f *Framer) WriteSettingsAck() error <span class="cov8" title="1">{
        f.startWrite(FrameSettings, FlagSettingsAck, 0)
        return f.endWrite()
}</span>

// A PingFrame is a mechanism for measuring a minimal round trip time
// from the sender, as well as determining whether an idle connection
// is still functional.
// See http://http2.github.io/http2-spec/#rfc.section.6.7
type PingFrame struct {
        FrameHeader
        Data [8]byte
}

func (f *PingFrame) IsAck() bool <span class="cov8" title="1">{ return f.Flags.Has(FlagPingAck) }</span>

func parsePingFrame(fh FrameHeader, payload []byte) (Frame, error) <span class="cov8" title="1">{
        if len(payload) != 8 </span><span class="cov0" title="0">{
                return nil, ConnectionError{ErrCodeFrameSize, "PING with wrong payload size"}
        }</span>
        <span class="cov8" title="1">if fh.StreamID != 0 </span><span class="cov0" title="0">{
                return nil, ConnectionError{ErrCodeProtocol, "PING with non-zero stream ID"}
        }</span>
        <span class="cov8" title="1">f := &amp;PingFrame{FrameHeader: fh}
        copy(f.Data[:], payload)
        return f, nil</span>
}

func (f *Framer) WritePing(ack bool, data [8]byte) error <span class="cov8" title="1">{
        var flags Flags
        if ack </span><span class="cov8" title="1">{
                flags = FlagPingAck
        }</span>
        <span class="cov8" title="1">f.startWrite(FramePing, flags, 0)
        f.writeBytes(data[:])
        return f.endWrite()</span>
}

// A GoAwayFrame informs the remote peer to stop creating streams on this connection.
// See http://http2.github.io/http2-spec/#rfc.section.6.8
type GoAwayFrame struct {
        FrameHeader
        LastStreamID uint32
        ErrCode      ErrCode
        debugData    []byte
}

// DebugData returns any debug data in the GOAWAY frame. Its contents
// are not defined.
// The caller must not retain the returned memory past the next
// call to ReadFrame.
func (f *GoAwayFrame) DebugData() []byte <span class="cov8" title="1">{
        f.checkValid()
        return f.debugData
}</span>

func parseGoAwayFrame(fh FrameHeader, p []byte) (Frame, error) <span class="cov8" title="1">{
        if fh.StreamID != 0 </span><span class="cov0" title="0">{
                return nil, ConnectionError{ErrCodeProtocol, "GOAWAY with non-zero stream ID"}
        }</span>
        <span class="cov8" title="1">if len(p) &lt; 8 </span><span class="cov0" title="0">{
                return nil, ConnectionError{ErrCodeFrameSize, "GOAWAY with wrong payload size"}
        }</span>
        <span class="cov8" title="1">return &amp;GoAwayFrame{
                FrameHeader:  fh,
                LastStreamID: binary.BigEndian.Uint32(p[:4]) &amp; (1&lt;&lt;31 - 1),
                ErrCode:      ErrCode(binary.BigEndian.Uint32(p[4:8])),
                debugData:    p[8:],
        }, nil</span>
}

func (f *Framer) WriteGoAway(maxStreamID uint32, code ErrCode, debugData []byte) error <span class="cov8" title="1">{
        f.startWrite(FrameGoAway, 0, 0)
        f.writeUint32(maxStreamID &amp; (1&lt;&lt;31 - 1))
        f.writeUint32(uint32(code))
        f.writeBytes(debugData)
        return f.endWrite()
}</span>

// An UnknownFrame is the frame type returned when the frame type is unknown
// or no specific frame type parser exists.
type UnknownFrame struct {
        FrameHeader
        p []byte
}

// Payload returns the frame's payload (after the header).  It is not
// valid to call this method after a subsequent call to
// Framer.ReadFrame, nor is it valid to retain the returned slice.
// The memory is owned by the Framer and is invalidated when the next
// frame is read.
func (f *UnknownFrame) Payload() []byte <span class="cov0" title="0">{
        f.checkValid()
        return f.p
}</span>

func parseUnknownFrame(fh FrameHeader, p []byte) (Frame, error) <span class="cov0" title="0">{
        return &amp;UnknownFrame{fh, p}, nil
}</span>

// A WindowUpdateFrame is used to implement flow control.
// See http://http2.github.io/http2-spec/#rfc.section.6.9
type WindowUpdateFrame struct {
        FrameHeader
        Increment uint32 // never read with high bit set
}

func parseWindowUpdateFrame(fh FrameHeader, p []byte) (Frame, error) <span class="cov8" title="1">{
        if len(p) != 4 </span><span class="cov0" title="0">{
                return nil, ConnectionError{ErrCodeFrameSize, "WINDOW_UPDATE with wrong payload size"}
        }</span>
        <span class="cov8" title="1">inc := binary.BigEndian.Uint32(p[:4]) &amp; 0x7fffffff // mask off high reserved bit
        if inc == 0 </span><span class="cov0" title="0">{
                errMsg := "WINDOW_UPDATE with zero increment"
                // A receiver MUST treat the receipt of a
                // WINDOW_UPDATE frame with an flow control window
                // increment of 0 as a stream error (Section 5.4.2) of
                // type PROTOCOL_ERROR; errors on the connection flow
                // control window MUST be treated as a connection
                // error (Section 5.4.1).
                if fh.StreamID == 0 </span><span class="cov0" title="0">{
                        return nil, ConnectionError{ErrCodeProtocol, errMsg}
                }</span>
                <span class="cov0" title="0">return nil, StreamError{fh.StreamID, ErrCodeProtocol, errMsg}</span>
        }
        <span class="cov8" title="1">return &amp;WindowUpdateFrame{
                FrameHeader: fh,
                Increment:   inc,
        }, nil</span>
}

// WriteWindowUpdate writes a WINDOW_UPDATE frame.
// The increment value must be between 1 and 2,147,483,647, inclusive.
// If the Stream ID is zero, the window update applies to the
// connection as a whole.
func (f *Framer) WriteWindowUpdate(streamID, incr uint32) error <span class="cov8" title="1">{
        // "The legal range for the increment to the flow control window is 1 to 2^31-1 (2,147,483,647) octets."
        if (incr &lt; 1 || incr &gt; 2147483647) &amp;&amp; !f.AllowIllegalWrites </span><span class="cov0" title="0">{
                return errors.New("illegal window increment value")
        }</span>
        <span class="cov8" title="1">f.startWrite(FrameWindowUpdate, 0, streamID)
        f.writeUint32(incr)
        return f.endWrite()</span>
}

// A HeadersFrame is used to open a stream and additionally carries a
// header block fragment.
type HeadersFrame struct {
        FrameHeader

        // Priority is set if FlagHeadersPriority is set in the FrameHeader.
        Priority PriorityParam

        headerFragBuf []byte // not owned
}

func (f *HeadersFrame) HeaderBlockFragment() []byte <span class="cov8" title="1">{
        f.checkValid()
        return f.headerFragBuf
}</span>

func (f *HeadersFrame) HeadersEnded() bool <span class="cov8" title="1">{
        return f.FrameHeader.Flags.Has(FlagHeadersEndHeaders)
}</span>

func (f *HeadersFrame) StreamEnded() bool <span class="cov8" title="1">{
        return f.FrameHeader.Flags.Has(FlagHeadersEndStream)
}</span>

func (f *HeadersFrame) HasPriority() bool <span class="cov8" title="1">{
        return f.FrameHeader.Flags.Has(FlagHeadersPriority)
}</span>

func parseHeadersFrame(fh FrameHeader, p []byte) (_ Frame, err error) <span class="cov8" title="1">{
        hf := &amp;HeadersFrame{
                FrameHeader: fh,
        }
        if fh.StreamID == 0 </span><span class="cov8" title="1">{
                // HEADERS frames MUST be associated with a stream.  If a HEADERS frame
                // is received whose stream identifier field is 0x0, the recipient MUST
                // respond with a connection error (Section 5.4.1) of type
                // PROTOCOL_ERROR.
                return nil, connError{ErrCodeProtocol, "HEADERS frame with stream ID 0"}
        }</span>
        <span class="cov8" title="1">var padLength uint8
        if fh.Flags.Has(FlagHeadersPadded) </span><span class="cov8" title="1">{
                if p, padLength, err = readByte(p); err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
        }
        <span class="cov8" title="1">if fh.Flags.Has(FlagHeadersPriority) </span><span class="cov8" title="1">{
                var v uint32
                p, v, err = readUint32(p)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">hf.Priority.StreamDep = v &amp; 0x7fffffff
                hf.Priority.Exclusive = (v != hf.Priority.StreamDep) // high bit was set
                p, hf.Priority.Weight, err = readByte(p)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov8" title="1">if len(p)-int(padLength) &lt;= 0 </span><span class="cov8" title="1">{
                return nil, StreamError{fh.StreamID, ErrCodeProtocol, "HEADERS without fragment"}
        }</span>
        <span class="cov8" title="1">hf.headerFragBuf = p[:len(p)-int(padLength)]
        return hf, nil</span>
}

// HeadersFrameParam are the parameters for writing a HEADERS frame.
type HeadersFrameParam struct {
        // StreamID is the required Stream ID to initiate.
        StreamID uint32
        // BlockFragment is part (or all) of a Header Block.
        BlockFragment []byte

        // EndStream indicates that the header block is the last that
        // the endpoint will send for the identified stream. Setting
        // this flag causes the stream to enter one of "half closed"
        // states.
        EndStream bool

        // EndHeaders indicates that this frame contains an entire
        // header block and is not followed by any
        // CONTINUATION frames.
        EndHeaders bool

        // PadLength is the optional number of bytes of zeros to add
        // to this frame.
        PadLength uint8

        // Priority, if non-zero, includes stream priority information
        // in the HEADER frame.
        Priority PriorityParam
}

// WriteHeaders writes a single HEADERS frame.
//
// This is a low-level header writing method. Encoding headers and
// splitting them into any necessary CONTINUATION frames is handled
// elsewhere.
//
// It will perform exactly one Write to the underlying Writer.
// It is the caller's responsibility to not call other Write methods concurrently.
func (f *Framer) WriteHeaders(p HeadersFrameParam) error <span class="cov8" title="1">{
        if !validStreamID(p.StreamID) &amp;&amp; !f.AllowIllegalWrites </span><span class="cov0" title="0">{
                return errStreamID
        }</span>
        <span class="cov8" title="1">var flags Flags
        if p.PadLength != 0 </span><span class="cov8" title="1">{
                flags |= FlagHeadersPadded
        }</span>
        <span class="cov8" title="1">if p.EndStream </span><span class="cov8" title="1">{
                flags |= FlagHeadersEndStream
        }</span>
        <span class="cov8" title="1">if p.EndHeaders </span><span class="cov8" title="1">{
                flags |= FlagHeadersEndHeaders
        }</span>
        <span class="cov8" title="1">if !p.Priority.IsZero() </span><span class="cov8" title="1">{
                flags |= FlagHeadersPriority
        }</span>
        <span class="cov8" title="1">f.startWrite(FrameHeaders, flags, p.StreamID)
        if p.PadLength != 0 </span><span class="cov8" title="1">{
                f.writeByte(p.PadLength)
        }</span>
        <span class="cov8" title="1">if !p.Priority.IsZero() </span><span class="cov8" title="1">{
                v := p.Priority.StreamDep
                if !validStreamID(v) &amp;&amp; !f.AllowIllegalWrites </span><span class="cov0" title="0">{
                        return errors.New("invalid dependent stream id")
                }</span>
                <span class="cov8" title="1">if p.Priority.Exclusive </span><span class="cov8" title="1">{
                        v |= 1 &lt;&lt; 31
                }</span>
                <span class="cov8" title="1">f.writeUint32(v)
                f.writeByte(p.Priority.Weight)</span>
        }
        <span class="cov8" title="1">f.wbuf = append(f.wbuf, p.BlockFragment...)
        f.wbuf = append(f.wbuf, padZeros[:p.PadLength]...)
        return f.endWrite()</span>
}

// A PriorityFrame specifies the sender-advised priority of a stream.
// See http://http2.github.io/http2-spec/#rfc.section.6.3
type PriorityFrame struct {
        FrameHeader
        PriorityParam
}

// PriorityParam are the stream prioritzation parameters.
type PriorityParam struct {
        // StreamDep is a 31-bit stream identifier for the
        // stream that this stream depends on. Zero means no
        // dependency.
        StreamDep uint32

        // Exclusive is whether the dependency is exclusive.
        Exclusive bool

        // Weight is the stream's zero-indexed weight. It should be
        // set together with StreamDep, or neither should be set.  Per
        // the spec, "Add one to the value to obtain a weight between
        // 1 and 256."
        Weight uint8
}

func (p PriorityParam) IsZero() bool <span class="cov8" title="1">{
        return p == PriorityParam{}
}</span>

func parsePriorityFrame(fh FrameHeader, payload []byte) (Frame, error) <span class="cov8" title="1">{
        if fh.StreamID == 0 </span><span class="cov0" title="0">{
                return nil, connError{ErrCodeProtocol, "PRIORITY frame with stream ID 0"}
        }</span>
        <span class="cov8" title="1">if len(payload) != 5 </span><span class="cov0" title="0">{
                return nil, connError{ErrCodeFrameSize, fmt.Sprintf("PRIORITY frame payload size was %d; want 5", len(payload))}
        }</span>
        <span class="cov8" title="1">v := binary.BigEndian.Uint32(payload[:4])
        streamID := v &amp; 0x7fffffff // mask off high bit
        return &amp;PriorityFrame{
                FrameHeader: fh,
                PriorityParam: PriorityParam{
                        Weight:    payload[4],
                        StreamDep: streamID,
                        Exclusive: streamID != v, // was high bit set?
                },
        }, nil</span>
}

// WritePriority writes a PRIORITY frame.
//
// It will perform exactly one Write to the underlying Writer.
// It is the caller's responsibility to not call other Write methods concurrently.
func (f *Framer) WritePriority(streamID uint32, p PriorityParam) error <span class="cov8" title="1">{
        if !validStreamID(streamID) &amp;&amp; !f.AllowIllegalWrites </span><span class="cov0" title="0">{
                return errStreamID
        }</span>
        <span class="cov8" title="1">f.startWrite(FramePriority, 0, streamID)
        v := p.StreamDep
        if p.Exclusive </span><span class="cov8" title="1">{
                v |= 1 &lt;&lt; 31
        }</span>
        <span class="cov8" title="1">f.writeUint32(v)
        f.writeByte(p.Weight)
        return f.endWrite()</span>
}

// A RSTStreamFrame allows for abnormal termination of a stream.
// See http://http2.github.io/http2-spec/#rfc.section.6.4
type RSTStreamFrame struct {
        FrameHeader
        ErrCode ErrCode
}

func parseRSTStreamFrame(fh FrameHeader, p []byte) (Frame, error) <span class="cov8" title="1">{
        if len(p) != 4 </span><span class="cov0" title="0">{
                return nil, ConnectionError{ErrCodeFrameSize, "RESET with wrong payload size"}
        }</span>
        <span class="cov8" title="1">if fh.StreamID == 0 </span><span class="cov0" title="0">{
                return nil, ConnectionError{ErrCodeProtocol, "RESET with non-zero stream ID"}
        }</span>
        <span class="cov8" title="1">return &amp;RSTStreamFrame{fh, ErrCode(binary.BigEndian.Uint32(p[:4]))}, nil</span>
}

// WriteRSTStream writes a RST_STREAM frame.
//
// It will perform exactly one Write to the underlying Writer.
// It is the caller's responsibility to not call other Write methods concurrently.
func (f *Framer) WriteRSTStream(streamID uint32, code ErrCode) error <span class="cov8" title="1">{
        if !validStreamID(streamID) &amp;&amp; !f.AllowIllegalWrites </span><span class="cov0" title="0">{
                return errStreamID
        }</span>
        <span class="cov8" title="1">f.startWrite(FrameRSTStream, 0, streamID)
        f.writeUint32(uint32(code))
        return f.endWrite()</span>
}

// A ContinuationFrame is used to continue a sequence of header block fragments.
// See http://http2.github.io/http2-spec/#rfc.section.6.10
type ContinuationFrame struct {
        FrameHeader
        headerFragBuf []byte
}

func parseContinuationFrame(fh FrameHeader, p []byte) (Frame, error) <span class="cov8" title="1">{
        if fh.StreamID == 0 </span><span class="cov8" title="1">{
                return nil, connError{ErrCodeProtocol, "CONTINUATION frame with stream ID 0"}
        }</span>
        <span class="cov8" title="1">return &amp;ContinuationFrame{fh, p}, nil</span>
}

func (f *ContinuationFrame) HeaderBlockFragment() []byte <span class="cov8" title="1">{
        f.checkValid()
        return f.headerFragBuf
}</span>

func (f *ContinuationFrame) HeadersEnded() bool <span class="cov8" title="1">{
        return f.FrameHeader.Flags.Has(FlagContinuationEndHeaders)
}</span>

// WriteContinuation writes a CONTINUATION frame.
//
// It will perform exactly one Write to the underlying Writer.
// It is the caller's responsibility to not call other Write methods concurrently.
func (f *Framer) WriteContinuation(streamID uint32, endHeaders bool, headerBlockFragment []byte) error <span class="cov8" title="1">{
        if !validStreamID(streamID) &amp;&amp; !f.AllowIllegalWrites </span><span class="cov0" title="0">{
                return errStreamID
        }</span>
        <span class="cov8" title="1">var flags Flags
        if endHeaders </span><span class="cov8" title="1">{
                flags |= FlagContinuationEndHeaders
        }</span>
        <span class="cov8" title="1">f.startWrite(FrameContinuation, flags, streamID)
        f.wbuf = append(f.wbuf, headerBlockFragment...)
        return f.endWrite()</span>
}

// A PushPromiseFrame is used to initiate a server stream.
// See http://http2.github.io/http2-spec/#rfc.section.6.6
type PushPromiseFrame struct {
        FrameHeader
        PromiseID     uint32
        headerFragBuf []byte // not owned
}

func (f *PushPromiseFrame) HeaderBlockFragment() []byte <span class="cov0" title="0">{
        f.checkValid()
        return f.headerFragBuf
}</span>

func (f *PushPromiseFrame) HeadersEnded() bool <span class="cov0" title="0">{
        return f.FrameHeader.Flags.Has(FlagPushPromiseEndHeaders)
}</span>

func parsePushPromise(fh FrameHeader, p []byte) (_ Frame, err error) <span class="cov8" title="1">{
        pp := &amp;PushPromiseFrame{
                FrameHeader: fh,
        }
        if pp.StreamID == 0 </span><span class="cov0" title="0">{
                // PUSH_PROMISE frames MUST be associated with an existing,
                // peer-initiated stream. The stream identifier of a
                // PUSH_PROMISE frame indicates the stream it is associated
                // with. If the stream identifier field specifies the value
                // 0x0, a recipient MUST respond with a connection error
                // (Section 5.4.1) of type PROTOCOL_ERROR.
                return nil, ConnectionError{ErrCodeProtocol, "PushPromise with zero stream ID"}
        }</span>
        // The PUSH_PROMISE frame includes optional padding.
        // Padding fields and flags are identical to those defined for DATA frames
        <span class="cov8" title="1">var padLength uint8
        if fh.Flags.Has(FlagPushPromisePadded) </span><span class="cov0" title="0">{
                if p, padLength, err = readByte(p); err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        <span class="cov8" title="1">p, pp.PromiseID, err = readUint32(p)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        // pp.PromiseID = pp.PromiseID &amp; (1&lt;&lt;31 - 1)
        <span class="cov8" title="1">pp.PromiseID &amp;= (1&lt;&lt;31 - 1)

        if int(padLength) &gt; len(p) </span><span class="cov0" title="0">{
                // like the DATA frame, error out if padding is longer than the body.
                return nil, ConnectionError{ErrCodeProtocol, "PushPromise with invalid padding"}
        }</span>
        <span class="cov8" title="1">pp.headerFragBuf = p[:len(p)-int(padLength)]
        return pp, nil</span>
}

// PushPromiseParam are the parameters for writing a PUSH_PROMISE frame.
type PushPromiseParam struct {
        // StreamID is the required Stream ID to initiate.
        StreamID uint32

        // PromiseID is the required Stream ID which this
        // Push Promises
        PromiseID uint32

        // BlockFragment is part (or all) of a Header Block.
        BlockFragment []byte

        // EndHeaders indicates that this frame contains an entire
        // header block and is not followed by any
        // CONTINUATION frames.
        EndHeaders bool

        // PadLength is the optional number of bytes of zeros to add
        // to this frame.
        PadLength uint8
}

// WritePushPromise writes a single PushPromise Frame.
//
// As with Header Frames, This is the low level call for writing
// individual frames. Continuation frames are handled elsewhere.
//
// It will perform exactly one Write to the underlying Writer.
// It is the caller's responsibility to not call other Write methods concurrently.
func (f *Framer) WritePushPromise(p PushPromiseParam) error <span class="cov8" title="1">{
        if !validStreamID(p.StreamID) &amp;&amp; !f.AllowIllegalWrites </span><span class="cov0" title="0">{
                return errStreamID
        }</span>
        <span class="cov8" title="1">var flags Flags
        if p.PadLength != 0 </span><span class="cov0" title="0">{
                flags |= FlagPushPromisePadded
        }</span>
        <span class="cov8" title="1">if p.EndHeaders </span><span class="cov0" title="0">{
                flags |= FlagPushPromiseEndHeaders
        }</span>
        <span class="cov8" title="1">f.startWrite(FramePushPromise, flags, p.StreamID)
        if p.PadLength != 0 </span><span class="cov0" title="0">{
                f.writeByte(p.PadLength)
        }</span>
        <span class="cov8" title="1">if !validStreamID(p.PromiseID) &amp;&amp; !f.AllowIllegalWrites </span><span class="cov0" title="0">{
                return errStreamID
        }</span>
        <span class="cov8" title="1">f.writeUint32(p.PromiseID)
        f.wbuf = append(f.wbuf, p.BlockFragment...)
        f.wbuf = append(f.wbuf, padZeros[:p.PadLength]...)
        return f.endWrite()</span>
}

// WriteRawFrame writes a raw frame. This can be used to write
// extension frames unknown to this package.
func (f *Framer) WriteRawFrame(t FrameType, flags Flags, streamID uint32, payload []byte) error <span class="cov8" title="1">{
        f.startWrite(t, flags, streamID)
        f.writeBytes(payload)
        return f.endWrite()
}</span>

func readByte(p []byte) (remain []byte, b byte, err error) <span class="cov8" title="1">{
        if len(p) == 0 </span><span class="cov0" title="0">{
                return nil, 0, io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return p[1:], p[0], nil</span>
}

func readUint32(p []byte) (remain []byte, v uint32, err error) <span class="cov8" title="1">{
        if len(p) &lt; 4 </span><span class="cov0" title="0">{
                return nil, 0, io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return p[4:], binary.BigEndian.Uint32(p[:4]), nil</span>
}

type streamEnder interface {
        StreamEnded() bool
}

type headersEnder interface {
        HeadersEnded() bool
}

type headersOrContinuation interface {
        headersEnder
        HeaderBlockFragment() []byte
}

// A MetaHeadersFrame is the representation of one HEADERS frame and
// zero or more contiguous CONTINUATION frames and the decoding of
// their HPACK-encoded contents.
//
// This type of frame does not appear on the wire and is only returned
// by the Framer when Framer.ReadMetaHeaders is set.
type MetaHeadersFrame struct {
        *HeadersFrame

        // Fields are the fields contained in the HEADERS and
        // CONTINUATION frames. The underlying slice is owned by the
        // Framer and must not be retained after the next call to
        // ReadFrame.
        //
        // Fields are guaranteed to be in the correct http2 order and
        // not have unknown pseudo header fields or invalid header
        // field names or values. Required pseudo header fields may be
        // missing, however. Use the MetaHeadersFrame.Pseudo accessor
        // method access pseudo headers.
        Fields []hpack.HeaderField

        // Truncated is whether the max header list size limit was hit
        // and Fields is incomplete. The hpack decoder state is still
        // valid, however.
        Truncated bool
}

// PseudoValue returns the given pseudo header field's value.
// The provided pseudo field should not contain the leading colon.
func (mh *MetaHeadersFrame) PseudoValue(pseudo string) string <span class="cov8" title="1">{
        for _, hf := range mh.Fields </span><span class="cov8" title="1">{
                if !hf.IsPseudo() </span><span class="cov8" title="1">{
                        return ""
                }</span>
                <span class="cov8" title="1">if hf.Name[1:] == pseudo </span><span class="cov8" title="1">{
                        return hf.Value
                }</span>
        }
        <span class="cov8" title="1">return ""</span>
}

// RegularValue returns the given regular header field's value.
func (mh *MetaHeadersFrame) RegularValue(regular string) string <span class="cov0" title="0">{
        for _, hf := range mh.RegularFields() </span><span class="cov0" title="0">{
                if hf.Name == regular </span><span class="cov0" title="0">{
                        return hf.Value
                }</span>
        }
        <span class="cov0" title="0">return ""</span>
}

// RegularFields returns the regular (non-pseudo) header fields of mh.
// The caller does not own the returned slice.
func (mh *MetaHeadersFrame) RegularFields() []hpack.HeaderField <span class="cov8" title="1">{
        for i, hf := range mh.Fields </span><span class="cov8" title="1">{
                if !hf.IsPseudo() </span><span class="cov8" title="1">{
                        return mh.Fields[i:]
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// PseudoFields returns the pseudo header fields of mh.
// The caller does not own the returned slice.
func (mh *MetaHeadersFrame) PseudoFields() []hpack.HeaderField <span class="cov8" title="1">{
        for i, hf := range mh.Fields </span><span class="cov8" title="1">{
                if !hf.IsPseudo() </span><span class="cov8" title="1">{
                        return mh.Fields[:i]
                }</span>
        }
        <span class="cov8" title="1">return mh.Fields</span>
}

func (mh *MetaHeadersFrame) checkPseudos() error <span class="cov8" title="1">{
        var isRequest, isResponse bool
        pf := mh.PseudoFields()
        for i, hf := range pf </span><span class="cov8" title="1">{
                switch hf.Name </span>{
                case ":method", ":path", ":scheme", ":authority":<span class="cov8" title="1">
                        isRequest = true</span>
                case ":status":<span class="cov8" title="1">
                        isResponse = true</span>
                default:<span class="cov8" title="1">
                        return pseudoHeaderError(hf.Name)</span>
                }
                // Check for duplicates.
                // This would be a bad algorithm, but N is 4.
                // And this doesn't allocate.
                <span class="cov8" title="1">for _, hf2 := range pf[:i] </span><span class="cov8" title="1">{
                        if hf.Name == hf2.Name </span><span class="cov8" title="1">{
                                return duplicatePseudoHeaderError(hf.Name)
                        }</span>
                }
        }
        <span class="cov8" title="1">if isRequest &amp;&amp; isResponse </span><span class="cov8" title="1">{
                return errMixPseudoHeaderTypes
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (fr *Framer) maxHeaderStringLen() int <span class="cov8" title="1">{
        v := fr.maxHeaderListSize()
        if uint32(int(v)) == v </span><span class="cov8" title="1">{
                return int(v)
        }</span>
        // They had a crazy big number for MaxHeaderBytes anyway,
        // so give them unlimited header lengths:
        <span class="cov0" title="0">return 0</span>
}

// now we only check uri size
func (fr *Framer) checkHeaderFieldLimit(f *HeadersFrame, hf *hpack.HeaderField) error <span class="cov8" title="1">{
        if hf.Name == ":path" </span><span class="cov8" title="1">{
                if len(hf.Value) &gt; int(fr.maxHeaderUriSize()) </span><span class="cov0" title="0">{
                        state.H2ErrMaxHeaderUriSize.Inc(1)
                        return maxHeaderUriSizeError{
                                streamID:         f.FrameHeader.StreamID,
                                uri:              hf.Value,
                                maxHeaderUriSize: fr.maxHeaderUriSize(),
                        }
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// readMetaFrame returns 0 or more CONTINUATION frames from fr and
// merge them into into the provided f and returns a MetaHeadersFrame
// with the decoded hpack values.
func (fr *Framer) readMetaFrame(f *HeadersFrame) (*MetaHeadersFrame, error) <span class="cov8" title="1">{
        if fr.AllowIllegalReads </span><span class="cov0" title="0">{
                return nil, errors.New("illegal use of AllowIllegalReads with ReadMetaHeaders")
        }</span>
        <span class="cov8" title="1">mh := &amp;MetaHeadersFrame{
                HeadersFrame: f,
        }
        var remainSize = fr.maxHeaderListSize()

        var sawRegular bool
        // origin header size of current stream.
        // it includes both pseudo and regular headers
        // but it does not includes:
        //        - the truncated parts
        //        - the parts following the invalid fields
        //        - the parts following the exceeds the uri/header limit size
        var headerSize uint32
        var invalid error // pseudo header field errors

        hdec := fr.ReadMetaHeaders
        hdec.SetEmitEnabled(true)
        hdec.SetMaxStringLength(fr.maxHeaderStringLen())
        hdec.SetEmitFunc(func(hf hpack.HeaderField) error </span><span class="cov8" title="1">{
                headerSize += hf.FieldSize()
                if err := fr.checkHeaderFieldLimit(f, &amp;hf); err != nil </span><span class="cov0" title="0">{
                        invalid = err
                        return err
                }</span>

                <span class="cov8" title="1">if !validHeaderFieldValue(hf.Value) </span><span class="cov8" title="1">{
                        invalid = headerFieldValueError(hf.Value)
                }</span>
                <span class="cov8" title="1">isPseudo := strings.HasPrefix(hf.Name, ":")
                if isPseudo </span><span class="cov8" title="1">{
                        if sawRegular </span><span class="cov8" title="1">{
                                invalid = errPseudoAfterRegular
                        }</span>
                } else<span class="cov8" title="1"> {
                        sawRegular = true
                        if !validHeaderFieldName(hf.Name) </span><span class="cov8" title="1">{
                                invalid = headerFieldNameError(hf.Name)
                        }</span>
                }

                <span class="cov8" title="1">if invalid != nil </span><span class="cov8" title="1">{
                        hdec.SetEmitEnabled(false)
                        return nil
                }</span>

                <span class="cov8" title="1">size := hf.Size()
                if size &gt; remainSize </span><span class="cov8" title="1">{
                        hdec.SetEmitEnabled(false)
                        mh.Truncated = true
                        state.H2ErrMaxHeaderListSize.Inc(1)
                        return maxHeaderListSizeError{
                                streamID:          f.FrameHeader.StreamID,
                                curHeaderListSize: fr.maxHeaderListSize() - remainSize + size,
                                maxHeaderListSize: fr.maxHeaderListSize(),
                        }
                }</span>
                <span class="cov8" title="1">remainSize -= size

                mh.Fields = append(mh.Fields, hf)
                return nil</span>
        })
        // Lose reference to MetaHeadersFrame:
        <span class="cov8" title="1">defer hdec.SetEmitFunc(func(hf hpack.HeaderField) error </span><span class="cov0" title="0">{ return nil }</span>)

        // compressed header size of current stream.
        // no matter invalid is nil or not.
        <span class="cov8" title="1">blockSize := 0
        var hc headersOrContinuation = f
        var err error
        for </span><span class="cov8" title="1">{
                frag := hc.HeaderBlockFragment()
                blockSize += len(frag)
                if _, err = hdec.Write(frag); err != nil </span><span class="cov8" title="1">{
                        // do not return ConnectionError err type,
                        // because the conn shoule be closed immediately
                        switch err := err.(type) </span>{
                        case maxHeaderUriSizeError:<span class="cov0" title="0">
                                return nil, err</span>
                        case maxHeaderListSizeError:<span class="cov8" title="1">
                                return nil, err</span>
                        }
                        <span class="cov8" title="1">errMsg := fmt.Sprintf("ReadMetaFrame err: %s", err)
                        return nil, ConnectionError{ErrCodeCompression, errMsg}</span>
                }

                <span class="cov8" title="1">if hc.HeadersEnded() </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">if f, err := fr.ReadFrame(); err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span> else<span class="cov8" title="1"> {
                        hc = f.(*ContinuationFrame) // guaranteed by checkFrameOrder
                }</span>
        }

        <span class="cov8" title="1">mh.HeadersFrame.headerFragBuf = nil
        mh.HeadersFrame.invalidate()

        if err := hdec.Close(); err != nil </span><span class="cov8" title="1">{
                errMsg := fmt.Sprintf("ReadMetaFrame err: %s", err)
                return nil, ConnectionError{ErrCodeCompression, errMsg}
        }</span>
        <span class="cov8" title="1">if invalid != nil </span><span class="cov8" title="1">{
                fr.errDetail = invalid
                errMsg := fmt.Sprintf("readMetaFrame err: %s", invalid)
                return nil, StreamError{mh.StreamID, ErrCodeProtocol, errMsg}
        }</span>
        <span class="cov8" title="1">if err := mh.checkPseudos(); err != nil </span><span class="cov8" title="1">{
                fr.errDetail = err
                errMsg := fmt.Sprintf("readMetaFrame err: %s", err)
                return nil, StreamError{mh.StreamID, ErrCodeProtocol, errMsg}
        }</span>

        // only count size when invalid == nil
        // so the state of headerSize and blockSize keep consistency
        <span class="cov8" title="1">state.H2ReqHeaderOriginalSize.Inc(uint(headerSize))
        state.H2ReqHeaderCompressSize.Inc(uint(blockSize))

        return mh, nil</span>
}

func summarizeFrame(f Frame) string <span class="cov8" title="1">{
        var buf bytes.Buffer
        f.Header().writeDebug(&amp;buf)
        switch f := f.(type) </span>{
        case *SettingsFrame:<span class="cov8" title="1">
                n := 0
                f.ForeachSetting(func(s Setting) error </span><span class="cov8" title="1">{
                        n++
                        if n == 1 </span><span class="cov8" title="1">{
                                buf.WriteString(", settings:")
                        }</span>
                        <span class="cov8" title="1">fmt.Fprintf(&amp;buf, " %v=%v,", s.ID, s.Val)
                        return nil</span>
                })
                <span class="cov8" title="1">if n &gt; 0 </span><span class="cov8" title="1">{
                        buf.Truncate(buf.Len() - 1) // remove trailing comma
                }</span>
        case *DataFrame:<span class="cov8" title="1">
                data := f.Data()
                const max = 256
                if len(data) &gt; max </span><span class="cov0" title="0">{
                        data = data[:max]
                }</span>
                <span class="cov8" title="1">fmt.Fprintf(&amp;buf, " data=%q", data)
                if len(f.Data()) &gt; max </span><span class="cov0" title="0">{
                        fmt.Fprintf(&amp;buf, " (%d bytes omitted)", len(f.Data())-max)
                }</span>
        case *WindowUpdateFrame:<span class="cov8" title="1">
                if f.StreamID == 0 </span><span class="cov8" title="1">{
                        buf.WriteString(" (conn)")
                }</span>
                <span class="cov8" title="1">fmt.Fprintf(&amp;buf, " incr=%v", f.Increment)</span>
        case *PingFrame:<span class="cov8" title="1">
                fmt.Fprintf(&amp;buf, " ping=%q", f.Data[:])</span>
        case *GoAwayFrame:<span class="cov0" title="0">
                fmt.Fprintf(&amp;buf, " LastStreamID=%v ErrCode=%v Debug=%q",
                        f.LastStreamID, f.ErrCode, f.debugData)</span>
        case *RSTStreamFrame:<span class="cov8" title="1">
                fmt.Fprintf(&amp;buf, " ErrCode=%v", f.ErrCode)</span>
        }
        <span class="cov8" title="1">return buf.String()</span>
}
</pre>
		
		<pre class="file" id="file56" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Copyright 2014 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package bfe_http2

import (
        "strings"
)

import (
        http "github.com/bfenetworks/bfe/bfe_http"
)

var (
        commonLowerHeader = map[string]string{} // Go-Canonical-Case -&gt; lower-case
        commonCanonHeader = map[string]string{} // lower-case -&gt; Go-Canonical-Case
)

func init() <span class="cov8" title="1">{
        for _, v := range []string{
                "accept",
                "accept-charset",
                "accept-encoding",
                "accept-language",
                "accept-ranges",
                "age",
                "access-control-allow-origin",
                "allow",
                "authorization",
                "cache-control",
                "content-disposition",
                "content-encoding",
                "content-language",
                "content-length",
                "content-location",
                "content-range",
                "content-type",
                "cookie",
                "date",
                "etag",
                "expect",
                "expires",
                "from",
                "host",
                "if-match",
                "if-modified-since",
                "if-none-match",
                "if-unmodified-since",
                "last-modified",
                "link",
                "location",
                "max-forwards",
                "proxy-authenticate",
                "proxy-authorization",
                "range",
                "referer",
                "refresh",
                "retry-after",
                "server",
                "set-cookie",
                "strict-transport-security",
                "trailer",
                "transfer-encoding",
                "user-agent",
                "vary",
                "via",
                "www-authenticate",
        } </span><span class="cov8" title="1">{
                chk := http.CanonicalHeaderKey(v)
                commonLowerHeader[chk] = v
                commonCanonHeader[v] = chk
        }</span>
}

func lowerHeader(v string) string <span class="cov8" title="1">{
        if s, ok := commonLowerHeader[v]; ok </span><span class="cov8" title="1">{
                return s
        }</span>
        <span class="cov8" title="1">return strings.ToLower(v)</span>
}
</pre>
		
		<pre class="file" id="file57" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Copyright 2014 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package hpack

import (
        "io"
)

const (
        uint32Max              = ^uint32(0)
        initialHeaderTableSize = 4096
)

type Encoder struct {
        dynTab dynamicTable
        // minSize is the minimum table size set by
        // SetMaxDynamicTableSize after the previous Header Table Size
        // Update.
        minSize uint32
        // maxSizeLimit is the maximum table size this encoder
        // supports. This will protect the encoder from too large
        // size.
        maxSizeLimit uint32
        // tableSizeUpdate indicates whether "Header Table Size
        // Update" is required.
        tableSizeUpdate bool
        w               io.Writer
        buf             []byte
}

// NewEncoder returns a new Encoder which performs HPACK encoding. An
// encoded data is written to w.
func NewEncoder(w io.Writer) *Encoder <span class="cov8" title="1">{
        e := &amp;Encoder{
                minSize:         uint32Max,
                maxSizeLimit:    initialHeaderTableSize,
                tableSizeUpdate: false,
                w:               w,
        }
        e.dynTab.setMaxSize(initialHeaderTableSize)
        return e
}</span>

// WriteField encodes f into a single Write to e's underlying Writer.
// This function may also produce bytes for "Header Table Size Update"
// if necessary.  If produced, it is done before encoding f.
func (e *Encoder) WriteField(f HeaderField) error <span class="cov8" title="1">{
        e.buf = e.buf[:0]

        if e.tableSizeUpdate </span><span class="cov8" title="1">{
                e.tableSizeUpdate = false
                if e.minSize &lt; e.dynTab.maxSize </span><span class="cov8" title="1">{
                        e.buf = appendTableSize(e.buf, e.minSize)
                }</span>
                <span class="cov8" title="1">e.minSize = uint32Max
                e.buf = appendTableSize(e.buf, e.dynTab.maxSize)</span>
        }

        <span class="cov8" title="1">idx, nameValueMatch := e.searchTable(f)
        if nameValueMatch </span><span class="cov8" title="1">{
                e.buf = appendIndexed(e.buf, idx)
        }</span> else<span class="cov8" title="1"> {
                indexing := e.shouldIndex(f)
                if indexing </span><span class="cov8" title="1">{
                        e.dynTab.add(f)
                }</span>

                <span class="cov8" title="1">if idx == 0 </span><span class="cov8" title="1">{
                        e.buf = appendNewName(e.buf, f, indexing)
                }</span> else<span class="cov8" title="1"> {
                        e.buf = appendIndexedName(e.buf, f, idx, indexing)
                }</span>
        }
        <span class="cov8" title="1">n, err := e.w.Write(e.buf)
        if err == nil &amp;&amp; n != len(e.buf) </span><span class="cov0" title="0">{
                err = io.ErrShortWrite
        }</span>
        <span class="cov8" title="1">return err</span>
}

// searchTable searches f in both stable and dynamic header tables.
// The static header table is searched first. Only when there is no
// exact match for both name and value, the dynamic header table is
// then searched. If there is no match, i is 0. If both name and value
// match, i is the matched index and nameValueMatch becomes true. If
// only name matches, i points to that index and nameValueMatch
// becomes false.
func (e *Encoder) searchTable(f HeaderField) (i uint64, nameValueMatch bool) <span class="cov8" title="1">{
        for idx, hf := range staticTable </span><span class="cov8" title="1">{
                if !constantTimeStringCompare(hf.Name, f.Name) </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if i == 0 </span><span class="cov8" title="1">{
                        i = uint64(idx + 1)
                }</span>
                <span class="cov8" title="1">if f.Sensitive </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if !constantTimeStringCompare(hf.Value, f.Value) </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">i = uint64(idx + 1)
                nameValueMatch = true
                return</span>
        }

        <span class="cov8" title="1">j, nameValueMatch := e.dynTab.search(f)
        if nameValueMatch || (i == 0 &amp;&amp; j != 0) </span><span class="cov8" title="1">{
                i = j + uint64(len(staticTable))
        }</span>
        <span class="cov8" title="1">return</span>
}

// SetMaxDynamicTableSize changes the dynamic header table size to v.
// The actual size is bounded by the value passed to
// SetMaxDynamicTableSizeLimit.
func (e *Encoder) SetMaxDynamicTableSize(v uint32) <span class="cov8" title="1">{
        if v &gt; e.maxSizeLimit </span><span class="cov8" title="1">{
                v = e.maxSizeLimit
        }</span>
        <span class="cov8" title="1">if v &lt; e.minSize </span><span class="cov8" title="1">{
                e.minSize = v
        }</span>
        <span class="cov8" title="1">e.tableSizeUpdate = true
        e.dynTab.setMaxSize(v)</span>
}

// SetMaxDynamicTableSizeLimit changes the maximum value that can be
// specified in SetMaxDynamicTableSize to v. By default, it is set to
// 4096, which is the same size of the default dynamic header table
// size described in HPACK specification. If the current maximum
// dynamic header table size is strictly greater than v, "Header Table
// Size Update" will be done in the next WriteField call and the
// maximum dynamic header table size is truncated to v.
func (e *Encoder) SetMaxDynamicTableSizeLimit(v uint32) <span class="cov8" title="1">{
        e.maxSizeLimit = v
        if e.dynTab.maxSize &gt; v </span><span class="cov8" title="1">{
                e.tableSizeUpdate = true
                e.dynTab.setMaxSize(v)
        }</span>
}

// shouldIndex reports whether f should be indexed.
func (e *Encoder) shouldIndex(f HeaderField) bool <span class="cov8" title="1">{
        return !f.Sensitive &amp;&amp; f.Size() &lt;= e.dynTab.maxSize
}</span>

// appendIndexed appends index i, as encoded in "Indexed Header Field"
// representation, to dst and returns the extended buffer.
func appendIndexed(dst []byte, i uint64) []byte <span class="cov8" title="1">{
        first := len(dst)
        dst = appendVarInt(dst, 7, i)
        dst[first] |= 0x80
        return dst
}</span>

// appendNewName appends f, as encoded in one of "Literal Header field
// - New Name" representation variants, to dst and returns the
// extended buffer.
//
// If f.Sensitive is true, "Never Indexed" representation is used. If
// f.Sensitive is false and indexing is true, "Inremental Indexing"
// representation is used.
func appendNewName(dst []byte, f HeaderField, indexing bool) []byte <span class="cov8" title="1">{
        dst = append(dst, encodeTypeByte(indexing, f.Sensitive))
        dst = appendHpackString(dst, f.Name)
        return appendHpackString(dst, f.Value)
}</span>

// appendIndexedName appends f and index i referring indexed name
// entry, as encoded in one of "Literal Header field - Indexed Name"
// representation variants, to dst and returns the extended buffer.
//
// If f.Sensitive is true, "Never Indexed" representation is used. If
// f.Sensitive is false and indexing is true, "Incremental Indexing"
// representation is used.
func appendIndexedName(dst []byte, f HeaderField, i uint64, indexing bool) []byte <span class="cov8" title="1">{
        first := len(dst)
        var n byte
        if indexing </span><span class="cov8" title="1">{
                n = 6
        }</span> else<span class="cov8" title="1"> {
                n = 4
        }</span>
        <span class="cov8" title="1">dst = appendVarInt(dst, n, i)
        dst[first] |= encodeTypeByte(indexing, f.Sensitive)
        return appendHpackString(dst, f.Value)</span>
}

// appendTableSize appends v, as encoded in "Header Table Size Update"
// representation, to dst and returns the extended buffer.
func appendTableSize(dst []byte, v uint32) []byte <span class="cov8" title="1">{
        first := len(dst)
        dst = appendVarInt(dst, 5, uint64(v))
        dst[first] |= 0x20
        return dst
}</span>

// appendVarInt appends i, as encoded in variable integer form using n
// bit prefix, to dst and returns the extended buffer.
//
// See
// http://http2.github.io/http2-spec/compression.html#integer.representation
func appendVarInt(dst []byte, n byte, i uint64) []byte <span class="cov8" title="1">{
        k := uint64((1 &lt;&lt; n) - 1)
        if i &lt; k </span><span class="cov8" title="1">{
                return append(dst, byte(i))
        }</span>
        <span class="cov8" title="1">dst = append(dst, byte(k))
        i -= k
        for ; i &gt;= 128; i &gt;&gt;= 7 </span><span class="cov8" title="1">{
                dst = append(dst, byte(0x80|(i&amp;0x7f)))
        }</span>
        <span class="cov8" title="1">return append(dst, byte(i))</span>
}

// appendHpackString appends s, as encoded in "String Literal"
// representation, to dst and returns the the extended buffer.
//
// s will be encoded in Huffman codes only when it produces strictly
// shorter byte string.
func appendHpackString(dst []byte, s string) []byte <span class="cov8" title="1">{
        huffmanLength := HuffmanEncodeLength(s)
        if huffmanLength &lt; uint64(len(s)) </span><span class="cov8" title="1">{
                first := len(dst)
                dst = appendVarInt(dst, 7, huffmanLength)
                dst = AppendHuffmanString(dst, s)
                dst[first] |= 0x80
        }</span> else<span class="cov8" title="1"> {
                dst = appendVarInt(dst, 7, uint64(len(s)))
                dst = append(dst, s...)
        }</span>
        <span class="cov8" title="1">return dst</span>
}

// encodeTypeByte returns type byte. If sensitive is true, type byte
// for "Never Indexed" representation is returned. If sensitive is
// false and indexing is true, type byte for "Incremental Indexing"
// representation is returned. Otherwise, type byte for "Without
// Indexing" is returned.
func encodeTypeByte(indexing, sensitive bool) byte <span class="cov8" title="1">{
        if sensitive </span><span class="cov8" title="1">{
                return 0x10
        }</span>
        <span class="cov8" title="1">if indexing </span><span class="cov8" title="1">{
                return 0x40
        }</span>
        <span class="cov8" title="1">return 0</span>
}
</pre>
		
		<pre class="file" id="file58" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Copyright 2014 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Package hpack implements HPACK, a compression format for
// efficiently representing HTTP header fields in the context of HTTP/2.
//
// See http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-09
package hpack

import (
        "bytes"
        "errors"
        "fmt"
)

// A DecodingError is something the spec defines as a decoding error.
type DecodingError struct {
        Err error
}

func (de DecodingError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("decoding error: %v", de.Err)
}</span>

// An InvalidIndexError is returned when an encoder references a table
// entry before the static table or after the end of the dynamic table.
type InvalidIndexError int

func (e InvalidIndexError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("invalid indexed representation index %d", int(e))
}</span>

// A HeaderField is a name-value pair. Both the name and value are
// treated as opaque sequences of octets.
type HeaderField struct {
        Name, Value string

        // Sensitive means that this header field should never be
        // indexed.
        Sensitive bool
}

// IsPseudo reports whether the header field is an http2 pseudo header.
// That is, it reports whether it starts with a colon.
// It is not otherwise guaranteed to be a valid pseudo header field,
// though.
func (hf HeaderField) IsPseudo() bool <span class="cov0" title="0">{
        return len(hf.Name) != 0 &amp;&amp; hf.Name[0] == ':'
}</span>

func (hf HeaderField) String() string <span class="cov0" title="0">{
        var suffix string
        if hf.Sensitive </span><span class="cov0" title="0">{
                suffix = " (sensitive)"
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("header field %q = %q%s", hf.Name, hf.Value, suffix)</span>
}

// Size returns the size of an entry per RFC 7540 section 5.2.
func (hf HeaderField) Size() uint32 <span class="cov8" title="1">{
        // http://http2.github.io/http2-spec/compression.html#rfc.section.4.1
        // "The size of the dynamic table is the sum of the size of
        // its entries.  The size of an entry is the sum of its name's
        // length in octets (as defined in Section 5.2), its value's
        // length in octets (see Section 5.2), plus 32.  The size of
        // an entry is calculated using the length of the name and
        // value without any Huffman encoding applied."

        // This can overflow if somebody makes a large HeaderField
        // Name and/or Value by hand, but we don't care, because that
        // won't happen on the wire because the encoding doesn't allow
        // it.
        return uint32(len(hf.Name) + len(hf.Value) + 32)
}</span>

// FieldSize return the sum of name/value length in octects
func (hf HeaderField) FieldSize() uint32 <span class="cov0" title="0">{
        return uint32(len(hf.Name) + len(hf.Value))
}</span>

// A Decoder is the decoding context for incremental processing of
// header blocks.
type Decoder struct {
        dynTab dynamicTable
        emit   func(f HeaderField) error

        emitEnabled bool // whether calls to emit are enabled
        maxStrLen   int  // 0 means unlimited

        // buf is the unparsed buffer. It's only written to
        // saveBuf if it was truncated in the middle of a header
        // block. Because it's usually not owned, we can only
        // process it under Write.
        buf []byte // not owned; only valid during Write

        // saveBuf is previous data passed to Write which we weren't able
        // to fully parse before. Unlike buf, we own this data.
        saveBuf bytes.Buffer
}

// NewDecoder returns a new decoder with the provided maximum dynamic
// table size. The emitFunc will be called for each valid field
// parsed, in the same goroutine as calls to Write, before Write returns.
func NewDecoder(maxDynamicTableSize uint32, emitFunc func(f HeaderField) error) *Decoder <span class="cov8" title="1">{
        d := &amp;Decoder{
                emit:        emitFunc,
                emitEnabled: true,
        }
        d.dynTab.allowedMaxSize = maxDynamicTableSize
        d.dynTab.setMaxSize(maxDynamicTableSize)
        return d
}</span>

// ErrStringLength is returned by Decoder.Write when the max string length
// (as configured by Decoder.SetMaxStringLength) would be violated.
var ErrStringLength = errors.New("hpack: string too long")

// SetMaxStringLength sets the maximum size of a HeaderField name or
// value string. If a string exceeds this length (even after any
// decompression), Write will return ErrStringLength.
// A value of 0 means unlimited and is the default from NewDecoder.
func (d *Decoder) SetMaxStringLength(n int) <span class="cov8" title="1">{
        d.maxStrLen = n
}</span>

// SetEmitFunc changes the callback used when new header fields
// are decoded.
// It must be non-nil. It does not affect EmitEnabled.
func (d *Decoder) SetEmitFunc(emitFunc func(f HeaderField) error) <span class="cov0" title="0">{
        d.emit = emitFunc
}</span>

// SetEmitEnabled controls whether the emitFunc provided to NewDecoder
// should be called. The default is true.
//
// This facility exists to let servers enforce MAX_HEADER_LIST_SIZE
// while still decoding and keeping in-sync with decoder state, but
// without doing unnecessary decompression or generating unnecessary
// garbage for header fields past the limit.
func (d *Decoder) SetEmitEnabled(v bool) <span class="cov8" title="1">{ d.emitEnabled = v }</span>

// EmitEnabled reports whether calls to the emitFunc provided to NewDecoder
// are currently enabled. The default is true.
func (d *Decoder) EmitEnabled() bool <span class="cov8" title="1">{ return d.emitEnabled }</span>

// TODO: add method *Decoder.Reset(maxSize, emitFunc) to let callers re-use Decoders and their
// underlying buffers for garbage reasons.

func (d *Decoder) SetMaxDynamicTableSize(v uint32) <span class="cov0" title="0">{
        d.dynTab.setMaxSize(v)
}</span>

// SetAllowedMaxDynamicTableSize sets the upper bound that the encoded
// stream (via dynamic table size updates) may set the maximum size
// to.
func (d *Decoder) SetAllowedMaxDynamicTableSize(v uint32) <span class="cov0" title="0">{
        d.dynTab.allowedMaxSize = v
}</span>

type dynamicTable struct {
        // ents is the FIFO described at
        // http://http2.github.io/http2-spec/compression.html#rfc.section.2.3.2
        // The newest (low index) is append at the end, and items are
        // evicted from the front.
        ents           []HeaderField
        size           uint32
        maxSize        uint32 // current maxSize
        allowedMaxSize uint32 // maxSize may go up to this, inclusive
}

func (dt *dynamicTable) setMaxSize(v uint32) <span class="cov8" title="1">{
        dt.maxSize = v
        dt.evict()
}</span>

// TODO: change dynamicTable to be a struct with a slice and a size int field,
// per http://http2.github.io/http2-spec/compression.html#rfc.section.4.1:
//
//
// Then make add increment the size. maybe the max size should move from Decoder to
// dynamicTable and add should return an ok bool if there was enough space.
//
// Later we'll need a remove operation on dynamicTable.

func (dt *dynamicTable) add(f HeaderField) <span class="cov8" title="1">{
        dt.ents = append(dt.ents, f)
        dt.size += f.Size()
        dt.evict()
}</span>

// If we're too big, evict old stuff (front of the slice)
func (dt *dynamicTable) evict() <span class="cov8" title="1">{
        base := dt.ents // keep base pointer of slice
        for dt.size &gt; dt.maxSize </span><span class="cov8" title="1">{
                dt.size -= dt.ents[0].Size()
                dt.ents = dt.ents[1:]
        }</span>

        // Shift slice contents down if we evicted things.
        <span class="cov8" title="1">if len(dt.ents) != len(base) </span><span class="cov8" title="1">{
                copy(base, dt.ents)
                dt.ents = base[:len(dt.ents)]
        }</span>
}

// constantTimeStringCompare compares string a and b in a constant
// time manner.
func constantTimeStringCompare(a, b string) bool <span class="cov8" title="1">{
        if len(a) != len(b) </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">c := byte(0)

        for i := 0; i &lt; len(a); i++ </span><span class="cov8" title="1">{
                c |= a[i] ^ b[i]
        }</span>

        <span class="cov8" title="1">return c == 0</span>
}

// Search searches f in the table. The return value i is 0 if there is
// no name match. If there is name match or name/value match, i is the
// index of that entry (1-based). If both name and value match,
// nameValueMatch becomes true.
func (dt *dynamicTable) search(f HeaderField) (i uint64, nameValueMatch bool) <span class="cov8" title="1">{
        l := len(dt.ents)
        for j := l - 1; j &gt;= 0; j-- </span><span class="cov8" title="1">{
                ent := dt.ents[j]
                if !constantTimeStringCompare(ent.Name, f.Name) </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if i == 0 </span><span class="cov8" title="1">{
                        i = uint64(l - j)
                }</span>
                <span class="cov8" title="1">if f.Sensitive </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if !constantTimeStringCompare(ent.Value, f.Value) </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">i = uint64(l - j)
                nameValueMatch = true
                return</span>
        }
        <span class="cov8" title="1">return</span>
}

func (d *Decoder) maxTableIndex() int <span class="cov8" title="1">{
        return len(d.dynTab.ents) + len(staticTable)
}</span>

func (d *Decoder) at(i uint64) (hf HeaderField, ok bool) <span class="cov8" title="1">{
        if i &lt; 1 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if i &gt; uint64(d.maxTableIndex()) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if i &lt;= uint64(len(staticTable)) </span><span class="cov8" title="1">{
                return staticTable[i-1], true
        }</span>
        <span class="cov8" title="1">dents := d.dynTab.ents
        return dents[len(dents)-(int(i)-len(staticTable))], true</span>
}

// DecodeFull decodes an entire block.
//
// TODO: remove this method and make it incremental later? This is
// easier for debugging now.
func (d *Decoder) DecodeFull(p []byte) ([]HeaderField, error) <span class="cov8" title="1">{
        var hf []HeaderField
        saveFunc := d.emit
        defer func() </span><span class="cov8" title="1">{ d.emit = saveFunc }</span>()
        <span class="cov8" title="1">d.emit = func(f HeaderField) error </span><span class="cov8" title="1">{
                hf = append(hf, f)
                return nil
        }</span>
        <span class="cov8" title="1">if _, err := d.Write(p); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := d.Close(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return hf, nil</span>
}

func (d *Decoder) Close() error <span class="cov8" title="1">{
        if d.saveBuf.Len() &gt; 0 </span><span class="cov0" title="0">{
                d.saveBuf.Reset()
                return DecodingError{errors.New("truncated headers")}
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (d *Decoder) Write(p []byte) (n int, err error) <span class="cov8" title="1">{
        if len(p) == 0 </span><span class="cov0" title="0">{
                // Prevent state machine CPU attacks (making us redo
                // work up to the point of finding out we don't have
                // enough data)
                return
        }</span>
        // Only copy the data if we have to. Optimistically assume
        // that p will contain a complete header block.
        <span class="cov8" title="1">if d.saveBuf.Len() == 0 </span><span class="cov8" title="1">{
                d.buf = p
        }</span> else<span class="cov0" title="0"> {
                d.saveBuf.Write(p)
                d.buf = d.saveBuf.Bytes()
                d.saveBuf.Reset()
        }</span>

        <span class="cov8" title="1">for len(d.buf) &gt; 0 </span><span class="cov8" title="1">{
                err = d.parseHeaderFieldRepr()
                if err == errNeedMore </span><span class="cov0" title="0">{
                        // Extra paranoia, making sure saveBuf won't
                        // get too large.  All the varint and string
                        // reading code earlier should already catch
                        // overlong things and return ErrStringLength,
                        // but keep this as a last resort.
                        const varIntOverhead = 8 // conservative
                        if d.maxStrLen != 0 &amp;&amp; int64(len(d.buf)) &gt; 2*(int64(d.maxStrLen)+varIntOverhead) </span><span class="cov0" title="0">{
                                return 0, ErrStringLength
                        }</span>
                        <span class="cov0" title="0">d.saveBuf.Write(d.buf)
                        return len(p), nil</span>
                }
                <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                        break</span>
                }
        }
        <span class="cov8" title="1">return len(p), err</span>
}

// errNeedMore is an internal sentinel error value that means the
// buffer is truncated and we need to read more data before we can
// continue parsing.
var errNeedMore = errors.New("need more data")

type indexType int

const (
        indexedTrue indexType = iota
        indexedFalse
        indexedNever
)

func (v indexType) indexed() bool   <span class="cov8" title="1">{ return v == indexedTrue }</span>
func (v indexType) sensitive() bool <span class="cov8" title="1">{ return v == indexedNever }</span>

// returns errNeedMore if there isn't enough data available.
// any other error is fatal.
// consumes d.buf iff it returns nil.
// precondition: must be called with len(d.buf) &gt; 0
func (d *Decoder) parseHeaderFieldRepr() error <span class="cov8" title="1">{
        b := d.buf[0]
        switch </span>{
        case b&amp;128 != 0:<span class="cov8" title="1">
                // Indexed representation.
                // High bit set?
                // http://http2.github.io/http2-spec/compression.html#rfc.section.6.1
                return d.parseFieldIndexed()</span>
        case b&amp;192 == 64:<span class="cov8" title="1">
                // 6.2.1 Literal Header Field with Incremental Indexing
                // 0b10xxxxxx: top two bits are 10
                // http://http2.github.io/http2-spec/compression.html#rfc.section.6.2.1
                return d.parseFieldLiteral(6, indexedTrue)</span>
        case b&amp;240 == 0:<span class="cov8" title="1">
                // 6.2.2 Literal Header Field without Indexing
                // 0b0000xxxx: top four bits are 0000
                // http://http2.github.io/http2-spec/compression.html#rfc.section.6.2.2
                return d.parseFieldLiteral(4, indexedFalse)</span>
        case b&amp;240 == 16:<span class="cov8" title="1">
                // 6.2.3 Literal Header Field never Indexed
                // 0b0001xxxx: top four bits are 0001
                // http://http2.github.io/http2-spec/compression.html#rfc.section.6.2.3
                return d.parseFieldLiteral(4, indexedNever)</span>
        case b&amp;224 == 32:<span class="cov0" title="0">
                // 6.3 Dynamic Table Size Update
                // Top three bits are '001'.
                // http://http2.github.io/http2-spec/compression.html#rfc.section.6.3
                return d.parseDynamicTableSizeUpdate()</span>
        }

        <span class="cov0" title="0">return DecodingError{errors.New("invalid encoding")}</span>
}

// (same invariants and behavior as parseHeaderFieldRepr)
func (d *Decoder) parseFieldIndexed() error <span class="cov8" title="1">{
        buf := d.buf
        idx, buf, err := readVarInt(7, buf)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">hf, ok := d.at(idx)
        if !ok </span><span class="cov0" title="0">{
                return DecodingError{InvalidIndexError(idx)}
        }</span>
        <span class="cov8" title="1">d.buf = buf
        return d.callEmit(HeaderField{Name: hf.Name, Value: hf.Value})</span>
}

// (same invariants and behavior as parseHeaderFieldRepr)
func (d *Decoder) parseFieldLiteral(n uint8, it indexType) error <span class="cov8" title="1">{
        buf := d.buf
        nameIdx, buf, err := readVarInt(n, buf)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">var hf HeaderField
        wantStr := d.emitEnabled || it.indexed()
        if nameIdx &gt; 0 </span><span class="cov8" title="1">{
                ihf, ok := d.at(nameIdx)
                if !ok </span><span class="cov0" title="0">{
                        return DecodingError{InvalidIndexError(nameIdx)}
                }</span>
                <span class="cov8" title="1">hf.Name = ihf.Name</span>
        } else<span class="cov8" title="1"> {
                hf.Name, buf, err = d.readString(buf, wantStr)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">hf.Value, buf, err = d.readString(buf, wantStr)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">d.buf = buf
        if it.indexed() </span><span class="cov8" title="1">{
                d.dynTab.add(hf)
        }</span>
        <span class="cov8" title="1">hf.Sensitive = it.sensitive()
        return d.callEmit(hf)</span>
}

func (d *Decoder) callEmit(hf HeaderField) error <span class="cov8" title="1">{
        if d.maxStrLen != 0 </span><span class="cov8" title="1">{
                if len(hf.Name) &gt; d.maxStrLen || len(hf.Value) &gt; d.maxStrLen </span><span class="cov0" title="0">{
                        return ErrStringLength
                }</span>
        }

        <span class="cov8" title="1">if d.emitEnabled </span><span class="cov8" title="1">{
                return d.emit(hf)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// (same invariants and behavior as parseHeaderFieldRepr)
func (d *Decoder) parseDynamicTableSizeUpdate() error <span class="cov0" title="0">{
        buf := d.buf
        size, buf, err := readVarInt(5, buf)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if size &gt; uint64(d.dynTab.allowedMaxSize) </span><span class="cov0" title="0">{
                return DecodingError{errors.New("dynamic table size update too large")}
        }</span>
        <span class="cov0" title="0">d.dynTab.setMaxSize(uint32(size))
        d.buf = buf
        return nil</span>
}

var errVarintOverflow = DecodingError{errors.New("varint integer overflow")}

// readVarInt reads an unsigned variable length integer off the
// beginning of p. n is the parameter as described in
// http://http2.github.io/http2-spec/compression.html#rfc.section.5.1.
//
// n must always be between 1 and 8.
//
// The returned remain buffer is either a smaller suffix of p, or err != nil.
// The error is errNeedMore if p doesn't contain a complete integer.
func readVarInt(n byte, p []byte) (i uint64, remain []byte, err error) <span class="cov8" title="1">{
        if n &lt; 1 || n &gt; 8 </span><span class="cov0" title="0">{
                panic("bad n")</span>
        }
        <span class="cov8" title="1">if len(p) == 0 </span><span class="cov0" title="0">{
                return 0, p, errNeedMore
        }</span>
        <span class="cov8" title="1">i = uint64(p[0])
        if n &lt; 8 </span><span class="cov8" title="1">{
                i &amp;= (1 &lt;&lt; uint64(n)) - 1
        }</span>
        <span class="cov8" title="1">if i &lt; (1&lt;&lt;uint64(n))-1 </span><span class="cov8" title="1">{
                return i, p[1:], nil
        }</span>

        <span class="cov8" title="1">origP := p
        p = p[1:]
        var m uint64
        for len(p) &gt; 0 </span><span class="cov8" title="1">{
                b := p[0]
                p = p[1:]
                i += uint64(b&amp;127) &lt;&lt; m
                if b&amp;128 == 0 </span><span class="cov8" title="1">{
                        return i, p, nil
                }</span>
                <span class="cov8" title="1">m += 7
                if m &gt;= 63 </span><span class="cov8" title="1">{ // TODO: proper overflow check. making this up.
                        return 0, origP, errVarintOverflow
                }</span>
        }
        <span class="cov8" title="1">return 0, origP, errNeedMore</span>
}

// readString decodes an hpack string from p.
//
// wantStr is whether s will be used. If false, decompression and
// []byte-&gt;string garbage are skipped if s will be ignored
// anyway. This does mean that huffman decoding errors for non-indexed
// strings past the MAX_HEADER_LIST_SIZE are ignored, but the server
// is returning an error anyway, and because they're not indexed, the error
// won't affect the decoding state.
func (d *Decoder) readString(p []byte, wantStr bool) (s string, remain []byte, err error) <span class="cov8" title="1">{
        if len(p) == 0 </span><span class="cov0" title="0">{
                return "", p, errNeedMore
        }</span>
        <span class="cov8" title="1">isHuff := p[0]&amp;128 != 0
        strLen, p, err := readVarInt(7, p)
        if err != nil </span><span class="cov0" title="0">{
                return "", p, err
        }</span>
        <span class="cov8" title="1">if d.maxStrLen != 0 &amp;&amp; strLen &gt; uint64(d.maxStrLen) </span><span class="cov8" title="1">{
                return "", nil, ErrStringLength
        }</span>
        <span class="cov8" title="1">if uint64(len(p)) &lt; strLen </span><span class="cov0" title="0">{
                return "", p, errNeedMore
        }</span>
        <span class="cov8" title="1">if !isHuff </span><span class="cov8" title="1">{
                if wantStr </span><span class="cov8" title="1">{
                        s = string(p[:strLen])
                }</span>
                <span class="cov8" title="1">return s, p[strLen:], nil</span>
        }

        <span class="cov8" title="1">if wantStr </span><span class="cov8" title="1">{
                buf := bufPool.Get().(*bytes.Buffer)
                buf.Reset() // don't trust others
                defer bufPool.Put(buf)
                if err := huffmanDecode(buf, d.maxStrLen, p[:strLen]); err != nil </span><span class="cov0" title="0">{
                        buf.Reset()
                        return "", nil, err
                }</span>
                <span class="cov8" title="1">s = buf.String()
                buf.Reset()</span> // be nice to GC
        }
        <span class="cov8" title="1">return s, p[strLen:], nil</span>
}
</pre>
		
		<pre class="file" id="file59" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Copyright 2014 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package hpack

import (
        "bytes"
        "errors"
        "io"
        "sync"
)

var bufPool = sync.Pool{
        New: func() interface{} <span class="cov8" title="1">{ return new(bytes.Buffer) }</span>,
}

// HuffmanDecode decodes the string in v and writes the expanded
// result to w, returning the number of bytes written to w and the
// Write call's return value. At most one Write call is made.
func HuffmanDecode(w io.Writer, v []byte) (int, error) <span class="cov8" title="1">{
        buf := bufPool.Get().(*bytes.Buffer)
        buf.Reset()
        defer bufPool.Put(buf)
        if err := huffmanDecode(buf, 0, v); err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov8" title="1">return w.Write(buf.Bytes())</span>
}

// HuffmanDecodeToString decodes the string in v.
func HuffmanDecodeToString(v []byte) (string, error) <span class="cov8" title="1">{
        buf := bufPool.Get().(*bytes.Buffer)
        buf.Reset()
        defer bufPool.Put(buf)
        if err := huffmanDecode(buf, 0, v); err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>
        <span class="cov0" title="0">return buf.String(), nil</span>
}

// ErrInvalidHuffman is returned for errors found decoding
// Huffman-encoded strings.
var ErrInvalidHuffman = errors.New("hpack: invalid Huffman-encoded data")

// huffmanDecode decodes v to buf.
// If maxLen is greater than 0, attempts to write more to buf than
// maxLen bytes will return ErrStringLength.
func huffmanDecode(buf *bytes.Buffer, maxLen int, v []byte) error <span class="cov8" title="1">{
        n := rootHuffmanNode
        cur, nbits := uint(0), uint8(0)
        for _, b := range v </span><span class="cov8" title="1">{
                cur = cur&lt;&lt;8 | uint(b)
                nbits += 8
                for nbits &gt;= 8 </span><span class="cov8" title="1">{
                        idx := byte(cur &gt;&gt; (nbits - 8))
                        n = n.children[idx]
                        if n == nil </span><span class="cov8" title="1">{
                                return ErrInvalidHuffman
                        }</span>
                        <span class="cov8" title="1">if n.children == nil </span><span class="cov8" title="1">{
                                if maxLen != 0 &amp;&amp; buf.Len() == maxLen </span><span class="cov8" title="1">{
                                        return ErrStringLength
                                }</span>
                                <span class="cov8" title="1">buf.WriteByte(n.sym)
                                nbits -= n.codeLen
                                n = rootHuffmanNode</span>
                        } else<span class="cov8" title="1"> {
                                nbits -= 8
                        }</span>
                }
        }
        <span class="cov8" title="1">for nbits &gt; 0 </span><span class="cov8" title="1">{
                n = n.children[byte(cur&lt;&lt;(8-nbits))]
                if n.children != nil || n.codeLen &gt; nbits </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">buf.WriteByte(n.sym)
                nbits -= n.codeLen
                n = rootHuffmanNode</span>
        }
        <span class="cov8" title="1">return nil</span>
}

type node struct {
        // children is non-nil for internal nodes
        children []*node

        // The following are only valid if children is nil:
        codeLen uint8 // number of bits that led to the output of sym
        sym     byte  // output symbol
}

func newInternalNode() *node <span class="cov8" title="1">{
        return &amp;node{children: make([]*node, 256)}
}</span>

var rootHuffmanNode = newInternalNode()

func init() <span class="cov8" title="1">{
        if len(huffmanCodes) != 256 </span><span class="cov0" title="0">{
                panic("unexpected size")</span>
        }
        <span class="cov8" title="1">for i, code := range huffmanCodes </span><span class="cov8" title="1">{
                addDecoderNode(byte(i), code, huffmanCodeLen[i])
        }</span>
}

func addDecoderNode(sym byte, code uint32, codeLen uint8) <span class="cov8" title="1">{
        cur := rootHuffmanNode
        for codeLen &gt; 8 </span><span class="cov8" title="1">{
                codeLen -= 8
                i := uint8(code &gt;&gt; codeLen)
                if cur.children[i] == nil </span><span class="cov8" title="1">{
                        cur.children[i] = newInternalNode()
                }</span>
                <span class="cov8" title="1">cur = cur.children[i]</span>
        }
        <span class="cov8" title="1">shift := 8 - codeLen
        start, end := int(uint8(code&lt;&lt;shift)), int(1&lt;&lt;shift)
        for i := start; i &lt; start+end; i++ </span><span class="cov8" title="1">{
                cur.children[i] = &amp;node{sym: sym, codeLen: codeLen}
        }</span>
}

// AppendHuffmanString appends s, as encoded in Huffman codes, to dst
// and returns the extended buffer.
func AppendHuffmanString(dst []byte, s string) []byte <span class="cov8" title="1">{
        rembits := uint8(8)

        for i := 0; i &lt; len(s); i++ </span><span class="cov8" title="1">{
                if rembits == 8 </span><span class="cov8" title="1">{
                        dst = append(dst, 0)
                }</span>
                <span class="cov8" title="1">dst, rembits = appendByteToHuffmanCode(dst, rembits, s[i])</span>
        }

        <span class="cov8" title="1">if rembits &lt; 8 </span><span class="cov8" title="1">{
                // special EOS symbol
                code := uint32(0x3fffffff)
                nbits := uint8(30)

                t := uint8(code &gt;&gt; (nbits - rembits))
                dst[len(dst)-1] |= t
        }</span>

        <span class="cov8" title="1">return dst</span>
}

// HuffmanEncodeLength returns the number of bytes required to encode
// s in Huffman codes. The result is round up to byte boundary.
func HuffmanEncodeLength(s string) uint64 <span class="cov8" title="1">{
        n := uint64(0)
        for i := 0; i &lt; len(s); i++ </span><span class="cov8" title="1">{
                n += uint64(huffmanCodeLen[s[i]])
        }</span>
        <span class="cov8" title="1">return (n + 7) / 8</span>
}

// appendByteToHuffmanCode appends Huffman code for c to dst and
// returns the extended buffer and the remaining bits in the last
// element. The appending is not byte aligned and the remaining bits
// in the last element of dst is given in rembits.
func appendByteToHuffmanCode(dst []byte, rembits uint8, c byte) ([]byte, uint8) <span class="cov8" title="1">{
        code := huffmanCodes[c]
        nbits := huffmanCodeLen[c]

        for </span><span class="cov8" title="1">{
                if rembits &gt; nbits </span><span class="cov8" title="1">{
                        t := uint8(code &lt;&lt; (rembits - nbits))
                        dst[len(dst)-1] |= t
                        rembits -= nbits
                        break</span>
                }

                <span class="cov8" title="1">t := uint8(code &gt;&gt; (nbits - rembits))
                dst[len(dst)-1] |= t

                nbits -= rembits
                rembits = 8

                if nbits == 0 </span><span class="cov8" title="1">{
                        break</span>
                }

                <span class="cov8" title="1">dst = append(dst, 0)</span>
        }

        <span class="cov8" title="1">return dst, rembits</span>
}
</pre>
		
		<pre class="file" id="file60" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Copyright 2014 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package hpack

func pair(name, value string) HeaderField <span class="cov8" title="1">{
        return HeaderField{Name: name, Value: value}
}</span>

// http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-07#appendix-B
var staticTable = [...]HeaderField{
        pair(":authority", ""), // index 1 (1-based)
        pair(":method", "GET"),
        pair(":method", "POST"),
        pair(":path", "/"),
        pair(":path", "/index.html"),
        pair(":scheme", "http"),
        pair(":scheme", "https"),
        pair(":status", "200"),
        pair(":status", "204"),
        pair(":status", "206"),
        pair(":status", "304"),
        pair(":status", "400"),
        pair(":status", "404"),
        pair(":status", "500"),
        pair("accept-charset", ""),
        pair("accept-encoding", "gzip, deflate"),
        pair("accept-language", ""),
        pair("accept-ranges", ""),
        pair("accept", ""),
        pair("access-control-allow-origin", ""),
        pair("age", ""),
        pair("allow", ""),
        pair("authorization", ""),
        pair("cache-control", ""),
        pair("content-disposition", ""),
        pair("content-encoding", ""),
        pair("content-language", ""),
        pair("content-length", ""),
        pair("content-location", ""),
        pair("content-range", ""),
        pair("content-type", ""),
        pair("cookie", ""),
        pair("date", ""),
        pair("etag", ""),
        pair("expect", ""),
        pair("expires", ""),
        pair("from", ""),
        pair("host", ""),
        pair("if-match", ""),
        pair("if-modified-since", ""),
        pair("if-none-match", ""),
        pair("if-range", ""),
        pair("if-unmodified-since", ""),
        pair("last-modified", ""),
        pair("link", ""),
        pair("location", ""),
        pair("max-forwards", ""),
        pair("proxy-authenticate", ""),
        pair("proxy-authorization", ""),
        pair("range", ""),
        pair("referer", ""),
        pair("refresh", ""),
        pair("retry-after", ""),
        pair("server", ""),
        pair("set-cookie", ""),
        pair("strict-transport-security", ""),
        pair("transfer-encoding", ""),
        pair("user-agent", ""),
        pair("vary", ""),
        pair("via", ""),
        pair("www-authenticate", ""),
}

var huffmanCodes = [256]uint32{
        0x1ff8,
        0x7fffd8,
        0xfffffe2,
        0xfffffe3,
        0xfffffe4,
        0xfffffe5,
        0xfffffe6,
        0xfffffe7,
        0xfffffe8,
        0xffffea,
        0x3ffffffc,
        0xfffffe9,
        0xfffffea,
        0x3ffffffd,
        0xfffffeb,
        0xfffffec,
        0xfffffed,
        0xfffffee,
        0xfffffef,
        0xffffff0,
        0xffffff1,
        0xffffff2,
        0x3ffffffe,
        0xffffff3,
        0xffffff4,
        0xffffff5,
        0xffffff6,
        0xffffff7,
        0xffffff8,
        0xffffff9,
        0xffffffa,
        0xffffffb,
        0x14,
        0x3f8,
        0x3f9,
        0xffa,
        0x1ff9,
        0x15,
        0xf8,
        0x7fa,
        0x3fa,
        0x3fb,
        0xf9,
        0x7fb,
        0xfa,
        0x16,
        0x17,
        0x18,
        0x0,
        0x1,
        0x2,
        0x19,
        0x1a,
        0x1b,
        0x1c,
        0x1d,
        0x1e,
        0x1f,
        0x5c,
        0xfb,
        0x7ffc,
        0x20,
        0xffb,
        0x3fc,
        0x1ffa,
        0x21,
        0x5d,
        0x5e,
        0x5f,
        0x60,
        0x61,
        0x62,
        0x63,
        0x64,
        0x65,
        0x66,
        0x67,
        0x68,
        0x69,
        0x6a,
        0x6b,
        0x6c,
        0x6d,
        0x6e,
        0x6f,
        0x70,
        0x71,
        0x72,
        0xfc,
        0x73,
        0xfd,
        0x1ffb,
        0x7fff0,
        0x1ffc,
        0x3ffc,
        0x22,
        0x7ffd,
        0x3,
        0x23,
        0x4,
        0x24,
        0x5,
        0x25,
        0x26,
        0x27,
        0x6,
        0x74,
        0x75,
        0x28,
        0x29,
        0x2a,
        0x7,
        0x2b,
        0x76,
        0x2c,
        0x8,
        0x9,
        0x2d,
        0x77,
        0x78,
        0x79,
        0x7a,
        0x7b,
        0x7ffe,
        0x7fc,
        0x3ffd,
        0x1ffd,
        0xffffffc,
        0xfffe6,
        0x3fffd2,
        0xfffe7,
        0xfffe8,
        0x3fffd3,
        0x3fffd4,
        0x3fffd5,
        0x7fffd9,
        0x3fffd6,
        0x7fffda,
        0x7fffdb,
        0x7fffdc,
        0x7fffdd,
        0x7fffde,
        0xffffeb,
        0x7fffdf,
        0xffffec,
        0xffffed,
        0x3fffd7,
        0x7fffe0,
        0xffffee,
        0x7fffe1,
        0x7fffe2,
        0x7fffe3,
        0x7fffe4,
        0x1fffdc,
        0x3fffd8,
        0x7fffe5,
        0x3fffd9,
        0x7fffe6,
        0x7fffe7,
        0xffffef,
        0x3fffda,
        0x1fffdd,
        0xfffe9,
        0x3fffdb,
        0x3fffdc,
        0x7fffe8,
        0x7fffe9,
        0x1fffde,
        0x7fffea,
        0x3fffdd,
        0x3fffde,
        0xfffff0,
        0x1fffdf,
        0x3fffdf,
        0x7fffeb,
        0x7fffec,
        0x1fffe0,
        0x1fffe1,
        0x3fffe0,
        0x1fffe2,
        0x7fffed,
        0x3fffe1,
        0x7fffee,
        0x7fffef,
        0xfffea,
        0x3fffe2,
        0x3fffe3,
        0x3fffe4,
        0x7ffff0,
        0x3fffe5,
        0x3fffe6,
        0x7ffff1,
        0x3ffffe0,
        0x3ffffe1,
        0xfffeb,
        0x7fff1,
        0x3fffe7,
        0x7ffff2,
        0x3fffe8,
        0x1ffffec,
        0x3ffffe2,
        0x3ffffe3,
        0x3ffffe4,
        0x7ffffde,
        0x7ffffdf,
        0x3ffffe5,
        0xfffff1,
        0x1ffffed,
        0x7fff2,
        0x1fffe3,
        0x3ffffe6,
        0x7ffffe0,
        0x7ffffe1,
        0x3ffffe7,
        0x7ffffe2,
        0xfffff2,
        0x1fffe4,
        0x1fffe5,
        0x3ffffe8,
        0x3ffffe9,
        0xffffffd,
        0x7ffffe3,
        0x7ffffe4,
        0x7ffffe5,
        0xfffec,
        0xfffff3,
        0xfffed,
        0x1fffe6,
        0x3fffe9,
        0x1fffe7,
        0x1fffe8,
        0x7ffff3,
        0x3fffea,
        0x3fffeb,
        0x1ffffee,
        0x1ffffef,
        0xfffff4,
        0xfffff5,
        0x3ffffea,
        0x7ffff4,
        0x3ffffeb,
        0x7ffffe6,
        0x3ffffec,
        0x3ffffed,
        0x7ffffe7,
        0x7ffffe8,
        0x7ffffe9,
        0x7ffffea,
        0x7ffffeb,
        0xffffffe,
        0x7ffffec,
        0x7ffffed,
        0x7ffffee,
        0x7ffffef,
        0x7fffff0,
        0x3ffffee,
}

var huffmanCodeLen = [256]uint8{
        13, 23, 28, 28, 28, 28, 28, 28, 28, 24, 30, 28, 28, 30, 28, 28,
        28, 28, 28, 28, 28, 28, 30, 28, 28, 28, 28, 28, 28, 28, 28, 28,
        6, 10, 10, 12, 13, 6, 8, 11, 10, 10, 8, 11, 8, 6, 6, 6,
        5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 7, 8, 15, 6, 12, 10,
        13, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
        7, 7, 7, 7, 7, 7, 7, 7, 8, 7, 8, 13, 19, 13, 14, 6,
        15, 5, 6, 5, 6, 5, 6, 6, 6, 5, 7, 7, 6, 6, 6, 5,
        6, 7, 6, 5, 5, 6, 7, 7, 7, 7, 7, 15, 11, 14, 13, 28,
        20, 22, 20, 20, 22, 22, 22, 23, 22, 23, 23, 23, 23, 23, 24, 23,
        24, 24, 22, 23, 24, 23, 23, 23, 23, 21, 22, 23, 22, 23, 23, 24,
        22, 21, 20, 22, 22, 23, 23, 21, 23, 22, 22, 24, 21, 22, 23, 23,
        21, 21, 22, 21, 23, 22, 23, 23, 20, 22, 22, 22, 23, 22, 22, 23,
        26, 26, 20, 19, 22, 23, 22, 25, 26, 26, 26, 27, 27, 26, 24, 25,
        19, 21, 26, 27, 27, 26, 27, 24, 21, 21, 26, 26, 28, 27, 27, 27,
        20, 24, 20, 21, 22, 21, 21, 23, 22, 22, 25, 25, 24, 24, 26, 23,
        26, 27, 26, 26, 27, 27, 27, 27, 27, 28, 27, 27, 27, 27, 27, 26,
}
</pre>
		
		<pre class="file" id="file61" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Copyright 2014 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Package bfe_http2 implements the HTTP/2 protocol.
//
// This package is low-level and intended to be used directly by very
// few people. Most users will use it indirectly through the automatic
// use by the net/http package (from Go 1.6 and later).
// For use in earlier Go versions see ConfigureServer. (Transport support
// requires Go 1.6 or later)
//
// See https://http2.github.io/ for more information on HTTP/2.
//
// See https://http2.golang.org/ for a test server running this code.
package bfe_http2

import (
        "bufio"
        "errors"
        "fmt"
        "io"
        "os"
        "sort"
        "strconv"
        "strings"
        "sync"
)

import (
        http "github.com/bfenetworks/bfe/bfe_http"
        tls "github.com/bfenetworks/bfe/bfe_tls"
)

var (
        VerboseLogs    bool
        logFrameWrites bool
        logFrameReads  bool
)

func init() <span class="cov8" title="1">{
        e := os.Getenv("GODEBUG")
        if strings.Contains(e, "http2debug=1") </span><span class="cov0" title="0">{
                VerboseLogs = true
        }</span>
        <span class="cov8" title="1">if strings.Contains(e, "http2debug=2") </span><span class="cov0" title="0">{
                VerboseLogs = true
                logFrameWrites = true
                logFrameReads = true
        }</span>
}

const (
        // ClientPreface is the string that must be sent by new
        // connections from clients.
        ClientPreface = "PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n"

        // SETTINGS_MAX_FRAME_SIZE default
        // http://http2.github.io/http2-spec/#rfc.section.6.5.2
        initialMaxFrameSize = 16384

        // NextProtoTLS is the NPN/ALPN protocol negotiated during
        // HTTP/2's TLS setup.
        NextProtoTLS = "h2"

        // http://http2.github.io/http2-spec/#SettingValues
        initialHeaderTableSize = 4096

        initialWindowSize = 65535 // 6.9.2 Initial Flow Control Window Size

        // Note: size of flow control window for connection should not
        // be smaller than 65536 or larger than 2^31 -1
        initialConnRecvWindowSize = 1 &lt;&lt; 30

        defaultMaxReadFrameSize = 1 &lt;&lt; 20
)

var (
        clientPreface = []byte(ClientPreface)
)

type streamState int
type timeoutTag int

const (
        stateIdle streamState = iota
        stateOpen
        stateHalfClosedLocal
        stateHalfClosedRemote
        stateResvLocal
        stateResvRemote
        stateClosed
)

var stateName = [...]string{
        stateIdle:             "Idle",
        stateOpen:             "Open",
        stateHalfClosedLocal:  "HalfClosedLocal",
        stateHalfClosedRemote: "HalfClosedRemote",
        stateResvLocal:        "ResvLocal",
        stateResvRemote:       "ResvRemote",
        stateClosed:           "Closed",
}

const (
        ConnTag timeoutTag = iota
        ReadStreamTag
        WriteStreamTag
)

var tagString = map[timeoutTag]string{
        ConnTag:        "connection",
        ReadStreamTag:  "read stream",
        WriteStreamTag: "write stream",
}

func (t timeoutTag) String() string <span class="cov0" title="0">{
        return tagString[t]
}</span>

func (st streamState) String() string <span class="cov0" title="0">{
        return stateName[st]
}</span>

// Setting is a setting parameter: which setting it is, and its value.
type Setting struct {
        // ID is which setting is being set.
        // See http://http2.github.io/http2-spec/#SettingValues
        ID SettingID

        // Val is the value.
        Val uint32
}

func (s Setting) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("[%v = %d]", s.ID, s.Val)
}</span>

// Valid reports whether the setting is valid.
func (s Setting) Valid() error <span class="cov8" title="1">{
        // Limits and error codes from 6.5.2 Defined SETTINGS Parameters
        switch s.ID </span>{
        case SettingEnablePush:<span class="cov0" title="0">
                if s.Val != 1 &amp;&amp; s.Val != 0 </span><span class="cov0" title="0">{
                        return ConnectionError{ErrCodeProtocol, "SETTINGS with invalid EnablePush"}
                }</span>
        case SettingInitialWindowSize:<span class="cov8" title="1">
                if s.Val &gt; 1&lt;&lt;31-1 </span><span class="cov0" title="0">{
                        return ConnectionError{ErrCodeFlowControl, "SETTINGS with invalid InitialWindowSize"}
                }</span>
        case SettingMaxFrameSize:<span class="cov8" title="1">
                if s.Val &lt; 16384 || s.Val &gt; 1&lt;&lt;24-1 </span><span class="cov0" title="0">{
                        return ConnectionError{ErrCodeProtocol, "SETTINGS with invalid MaxFrameSize"}
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// A SettingID is an HTTP/2 setting as defined in
// http://http2.github.io/http2-spec/#iana-settings
type SettingID uint16

const (
        SettingHeaderTableSize      SettingID = 0x1
        SettingEnablePush           SettingID = 0x2
        SettingMaxConcurrentStreams SettingID = 0x3
        SettingInitialWindowSize    SettingID = 0x4
        SettingMaxFrameSize         SettingID = 0x5
        SettingMaxHeaderListSize    SettingID = 0x6
)

var settingName = map[SettingID]string{
        SettingHeaderTableSize:      "HEADER_TABLE_SIZE",
        SettingEnablePush:           "ENABLE_PUSH",
        SettingMaxConcurrentStreams: "MAX_CONCURRENT_STREAMS",
        SettingInitialWindowSize:    "INITIAL_WINDOW_SIZE",
        SettingMaxFrameSize:         "MAX_FRAME_SIZE",
        SettingMaxHeaderListSize:    "MAX_HEADER_LIST_SIZE",
}

func (s SettingID) String() string <span class="cov8" title="1">{
        if v, ok := settingName[s]; ok </span><span class="cov8" title="1">{
                return v
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("UNKNOWN_SETTING_%d", uint16(s))</span>
}

var (
        errInvalidHeaderFieldName  = errors.New("http2: invalid header field name")
        errInvalidHeaderFieldValue = errors.New("http2: invalid header field value")
)

// validHeaderFieldName reports whether v is a valid header field name (key).
//  RFC 7230 says:
//   header-field   = field-name ":" OWS field-value OWS
//   field-name     = token
//   token          = 1*tchar
//   tchar = "!" / "#" / "$" / "%" / "&amp;" / "'" / "*" / "+" / "-" / "." /
//           "^" / "_" / "`" / "|" / "~" / DIGIT / ALPHA
// Further, http2 says:
//   "Just as in HTTP/1.x, header field names are strings of ASCII
//   characters that are compared in a case-insensitive
//   fashion. However, header field names MUST be converted to
//   lowercase prior to their encoding in HTTP/2. "
func validHeaderFieldName(v string) bool <span class="cov8" title="1">{
        if len(v) == 0 </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">for _, r := range v </span><span class="cov8" title="1">{
                if int(r) &gt;= len(isTokenTable) || ('A' &lt;= r &amp;&amp; r &lt;= 'Z') </span><span class="cov8" title="1">{
                        return false
                }</span>
                <span class="cov8" title="1">if !isTokenTable[byte(r)] </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

// validHeaderFieldValue reports whether v is a valid header field value.
//
// RFC 7230 says:
//  field-value    = *( field-content / obs-fold )
//  obj-fold       =  N/A to http2, and deprecated
//  field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]
//  field-vchar    = VCHAR / obs-text
//  obs-text       = %x80-FF
//  VCHAR          = "any visible [USASCII] character"
//
// http2 further says: "Similarly, HTTP/2 allows header field values
// that are not valid. While most of the values that can be encoded
// will not alter header field parsing, carriage return (CR, ASCII
// 0xd), line feed (LF, ASCII 0xa), and the zero character (NUL, ASCII
// 0x0) might be exploited by an attacker if they are translated
// verbatim. Any request or response that contains a character not
// permitted in a header field value MUST be treated as malformed
// (Section 8.1.2.6). Valid characters are defined by the
// field-content ABNF rule in Section 3.2 of [RFC7230]."
//
// This function does not (yet?) properly handle the rejection of
// strings that begin or end with SP or HTAB.
func validHeaderFieldValue(v string) bool <span class="cov8" title="1">{
        for i := 0; i &lt; len(v); i++ </span><span class="cov8" title="1">{
                if b := v[i]; b &lt; ' ' &amp;&amp; b != '\t' || b == 0x7f </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

var httpCodeStringCommon = map[int]string{} // n -&gt; strconv.Itoa(n)

func init() <span class="cov8" title="1">{
        for i := 100; i &lt;= 999; i++ </span><span class="cov8" title="1">{
                if v := http.StatusTextGet(i); v != "" </span><span class="cov8" title="1">{
                        httpCodeStringCommon[i] = strconv.Itoa(i)
                }</span>
        }
}

func httpCodeString(code int) string <span class="cov8" title="1">{
        if s, ok := httpCodeStringCommon[code]; ok </span><span class="cov8" title="1">{
                return s
        }</span>
        <span class="cov0" title="0">return strconv.Itoa(code)</span>
}

// HopHeaders are connection-specific header fields which should be removed
// when endpoint generates an http/2 message
var HopHeaders = map[string]bool{
        "Connection":          true,
        "Keep-Alive":          true,
        "Proxy-Authenticate":  true,
        "Proxy-Authorization": true,
        "Proxy-Connection":    true,
        "Transfer-Encoding":   true,
        "Upgrade":             true,
}

// from pkg io
type stringWriter interface {
        WriteString(s string) (n int, err error)
}

// A gate lets two goroutines coordinate their activities.
type gate chan struct{}

func (g gate) Done() <span class="cov8" title="1">{ g &lt;- struct{}{} }</span>
func (g gate) Wait() <span class="cov0" title="0">{ &lt;-g }</span>

// A closeWaiter is like a sync.WaitGroup but only goes 1 to 0 (open to closed).
type closeWaiter chan struct{}

// Init makes a closeWaiter usable.
// It exists because so a closeWaiter value can be placed inside a
// larger struct and have the Mutex and Cond's memory in the same
// allocation.
func (cw *closeWaiter) Init() <span class="cov8" title="1">{
        *cw = make(chan struct{})
}</span>

// Close marks the closeWaiter as closed and unblocks any waiters.
func (cw closeWaiter) Close() <span class="cov8" title="1">{
        close(cw)
}</span>

// Wait waits for the closeWaiter to become closed.
func (cw closeWaiter) Wait() <span class="cov8" title="1">{
        &lt;-cw
}</span>

// bufferedWriter is a buffered writer that writes to w.
// Its buffered writer is lazily allocated as needed, to minimize
// idle memory usage with many connections.
type bufferedWriter struct {
        w  io.Writer     // immutable
        bw *bufio.Writer // non-nil when data is buffered
}

func newBufferedWriter(w io.Writer) *bufferedWriter <span class="cov8" title="1">{
        return &amp;bufferedWriter{w: w}
}</span>

var bufWriterPool = sync.Pool{
        New: func() interface{} <span class="cov8" title="1">{
                // TODO: pick something better? this is a bit under
                // (3 x typical 1500 byte MTU) at least.
                return bufio.NewWriterSize(nil, 4&lt;&lt;10)
        }</span>,
}

func (w *bufferedWriter) Write(p []byte) (n int, err error) <span class="cov8" title="1">{
        if w.bw == nil </span><span class="cov8" title="1">{
                bw := bufWriterPool.Get().(*bufio.Writer)
                bw.Reset(w.w)
                w.bw = bw
        }</span>
        <span class="cov8" title="1">return w.bw.Write(p)</span>
}

func (w *bufferedWriter) Flush() error <span class="cov8" title="1">{
        bw := w.bw
        if bw == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">err := bw.Flush()
        bw.Reset(nil)
        bufWriterPool.Put(bw)
        w.bw = nil
        return err</span>
}

func mustUint31(v int32) uint32 <span class="cov0" title="0">{
        if v &lt; 0 || v &gt; 2147483647 </span><span class="cov0" title="0">{
                panic("out of range")</span>
        }
        <span class="cov0" title="0">return uint32(v)</span>
}

// bodyAllowedForStatus reports whether a given response status code
// permits a body. See RFC 2616, section 4.4.
func bodyAllowedForStatus(status int) bool <span class="cov8" title="1">{
        switch </span>{
        case status &gt;= 100 &amp;&amp; status &lt;= 199:<span class="cov0" title="0">
                return false</span>
        case status == 204:<span class="cov0" title="0">
                return false</span>
        case status == 304:<span class="cov0" title="0">
                return false</span>
        }
        <span class="cov8" title="1">return true</span>
}

type httpError struct {
        msg     string
        timeout bool
}

func (e *httpError) Error() string   <span class="cov0" title="0">{ return e.msg }</span>
func (e *httpError) Timeout() bool   <span class="cov0" title="0">{ return e.timeout }</span>
func (e *httpError) Temporary() bool <span class="cov0" title="0">{ return true }</span>

var errTimeout error = &amp;httpError{msg: "http2: timeout awaiting response headers", timeout: true}

var isTokenTable = [127]bool{
        '!':  true,
        '#':  true,
        '$':  true,
        '%':  true,
        '&amp;':  true,
        '\'': true,
        '*':  true,
        '+':  true,
        '-':  true,
        '.':  true,
        '0':  true,
        '1':  true,
        '2':  true,
        '3':  true,
        '4':  true,
        '5':  true,
        '6':  true,
        '7':  true,
        '8':  true,
        '9':  true,
        'A':  true,
        'B':  true,
        'C':  true,
        'D':  true,
        'E':  true,
        'F':  true,
        'G':  true,
        'H':  true,
        'I':  true,
        'J':  true,
        'K':  true,
        'L':  true,
        'M':  true,
        'N':  true,
        'O':  true,
        'P':  true,
        'Q':  true,
        'R':  true,
        'S':  true,
        'T':  true,
        'U':  true,
        'W':  true,
        'V':  true,
        'X':  true,
        'Y':  true,
        'Z':  true,
        '^':  true,
        '_':  true,
        '`':  true,
        'a':  true,
        'b':  true,
        'c':  true,
        'd':  true,
        'e':  true,
        'f':  true,
        'g':  true,
        'h':  true,
        'i':  true,
        'j':  true,
        'k':  true,
        'l':  true,
        'm':  true,
        'n':  true,
        'o':  true,
        'p':  true,
        'q':  true,
        'r':  true,
        's':  true,
        't':  true,
        'u':  true,
        'v':  true,
        'w':  true,
        'x':  true,
        'y':  true,
        'z':  true,
        '|':  true,
        '~':  true,
}

type connectionStater interface {
        ConnectionState() tls.ConnectionState
}

var sorterPool = sync.Pool{New: func() interface{} <span class="cov8" title="1">{ return new(sorter) }</span>}

type sorter struct {
        v []string // owned by sorter
}

func (s *sorter) Len() int           <span class="cov8" title="1">{ return len(s.v) }</span>
func (s *sorter) Swap(i, j int)      <span class="cov8" title="1">{ s.v[i], s.v[j] = s.v[j], s.v[i] }</span>
func (s *sorter) Less(i, j int) bool <span class="cov8" title="1">{ return s.v[i] &lt; s.v[j] }</span>

// Keys returns the sorted keys of h.
//
// The returned slice is only valid until s used again or returned to
// its pool.
func (s *sorter) Keys(h http.Header) []string <span class="cov8" title="1">{
        keys := s.v[:0]
        for k := range h </span><span class="cov8" title="1">{
                keys = append(keys, k)
        }</span>
        <span class="cov8" title="1">s.v = keys
        sort.Sort(s)
        return keys</span>
}

func (s *sorter) SortStrings(ss []string) <span class="cov8" title="1">{
        // Our sorter works on s.v, which sorter owners, so
        // stash it away while we sort the user's buffer.
        save := s.v
        s.v = ss
        sort.Sort(s)
        s.v = save
}</span>

func strSliceContains(ss []string, s string) bool <span class="cov0" title="0">{
        for _, v := range ss </span><span class="cov0" title="0">{
                if v == s </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// CloseConn closes underlying connection for request
func CloseConn(body io.ReadCloser) <span class="cov0" title="0">{
        if b, ok := body.(*RequestBody); ok </span><span class="cov0" title="0">{
                if b.conn != nil </span><span class="cov0" title="0">{
                        b.conn.Close()
                }</span>
        }
}

var http2Limiter http.FlowLimiter

// SetFlowLimiter init flow limiter for http2
func SetFlowLimiter(limiter http.FlowLimiter) <span class="cov0" title="0">{
        http2Limiter = limiter
}</span>

func acceptConn() bool <span class="cov8" title="1">{
        if http2Limiter == nil </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov0" title="0">return http2Limiter.AcceptConn()</span>
}

func acceptRequest() bool <span class="cov8" title="1">{
        if http2Limiter == nil </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov0" title="0">return http2Limiter.AcceptRequest()</span>
}

type ServerRule interface {
        GetHTTP2Rule(conn *tls.Conn) *Rule
}

// Rule is customized http2 config for specific conn in server side
type Rule struct {
        // MaxConcurrentStreams optionally specifies the number of
        // concurrent streams for current conn
        MaxConcurrentStreams uint32

        // MaxUploadBufferPerStream is the size of the initial flow control
        // window for each stream. The HTTP/2 spec does not allow this to
        // be larger than 2^32-1. If the value is zero or larger than the
        // maximum, a default value will be used instead.
        MaxUploadBufferPerStream uint32

        // disable protocol degrade
        DisableDegrade bool
}

var serverRule ServerRule

func SetServerRule(r ServerRule) <span class="cov0" title="0">{
        serverRule = r
}</span>

var enableLargeConnRecvWindow = false

func EnableLargeConnRecvWindow() <span class="cov0" title="0">{
        enableLargeConnRecvWindow = true
}</span>
</pre>
		
		<pre class="file" id="file62" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Copyright 2014 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package bfe_http2

import (
        "bufio"
        "bytes"
        "errors"
        "fmt"
        "io"
        "net"
        "net/textproto"
        "net/url"
        "os"
        "reflect"
        "runtime"
        "strconv"
        "strings"
        "sync"
        "time"
)

import (
        "github.com/baidu/go-lib/gotrack"
        "github.com/baidu/go-lib/log"
)

import (
        http "github.com/bfenetworks/bfe/bfe_http"
        "github.com/bfenetworks/bfe/bfe_http2/hpack"
        tls "github.com/bfenetworks/bfe/bfe_tls"
        "github.com/bfenetworks/bfe/bfe_util/pipe"
)

const (
        prefaceTimeout        = 10 * time.Second
        firstSettingsTimeout  = 2 * time.Second // should be in-flight with preface anyway
        handlerChunkWriteSize = 4 &lt;&lt; 10

        // we refer some implements:
        // client implement, for chrome, it uses 100.
        // see https://code.google.com/p/chromium/codesearch#chromium/src/net/spdy/spdy_session.h&amp;l=63
        // server implement, for nginx it uses 128 as default value.
        // see http://nginx.org/en/docs/http/ngx_http_v2_module.html#http2_max_concurrent_streams
        // we choose 200 here.
        defaultMaxStreams             = 200 // TODO: make this 100 as the GFE seems to?
        defaultReadClientAgainTimeout = 60 * time.Second
        maxQueuedControlFrames        = 10000
)

var (
        errClientDisconnected = errors.New("client disconnected")
        errClosedBody         = errors.New("body closed by handler")
        errHandlerComplete    = errors.New("http2: request body closed due to handler exiting")
        errStreamClosed       = errors.New("http2: stream closed")
)

var responseWriterStatePool = sync.Pool{
        New: func() interface{} <span class="cov8" title="1">{
                rws := &amp;responseWriterState{}
                rws.bw = bufio.NewWriterSize(chunkWriter{rws}, handlerChunkWriteSize)
                return rws
        }</span>,
}

// fix buffer for recv window
var fixBufferPool = sync.Pool{
        New: func() interface{} <span class="cov8" title="1">{
                buffer := make([]byte, initialWindowSize)
                return pipe.NewFixedBuffer(buffer)
        }</span>,
}

// Test hooks.
var (
        testHookOnConn        func()
        testHookGetServerConn func(*serverConn)
        testHookOnPanicMu     *sync.Mutex // nil except in tests
        testHookOnPanic       func(sc *serverConn, panicVal interface{}) (rePanic bool)
)

// Server is an HTTP/2 server.
type Server struct {
        // MaxHandlers limits the number of http.Handler ServeHTTP goroutines
        // which may run at a time over all connections.
        // Negative or zero no limit.
        // TODO: implement
        MaxHandlers int

        // MaxConcurrentStreams optionally specifies the number of
        // concurrent streams that each client may have open at a
        // time. This is unrelated to the number of http.Handler goroutines
        // which may be active globally, which is MaxHandlers.
        // If zero, MaxConcurrentStreams defaults to at least 100, per
        // the HTTP/2 spec's recommendations.
        MaxConcurrentStreams uint32

        // MaxReadFrameSize optionally specifies the largest frame
        // this server is willing to read. A valid value is between
        // 16k and 16M, inclusive. If zero or otherwise invalid, a
        // default value is used.
        MaxReadFrameSize uint32

        // PermitProhibitedCipherSuites, if true, permits the use of
        // cipher suites prohibited by the HTTP/2 spec.
        PermitProhibitedCipherSuites bool

        // MaxUploadBufferPerStream is the size of the initial flow control
        // window for each stream. The HTTP/2 spec does not allow this to
        // be larger than 2^32-1. If the value is zero or larger than the
        // maximum, a default value will be used instead.
        MaxUploadBufferPerStream uint32
}

func (s *Server) initialStreamRecvWindowSize(r *Rule) uint32 <span class="cov8" title="1">{
        if r != nil &amp;&amp; r.MaxUploadBufferPerStream &gt; 0 </span><span class="cov0" title="0">{
                return r.MaxUploadBufferPerStream
        }</span>
        <span class="cov8" title="1">if v := s.MaxUploadBufferPerStream; v &gt; 0 </span><span class="cov0" title="0">{
                return v
        }</span>
        <span class="cov8" title="1">return initialWindowSize</span>
}

func (s *Server) maxReadFrameSize() uint32 <span class="cov8" title="1">{
        if v := s.MaxReadFrameSize; v &gt;= minMaxFrameSize &amp;&amp; v &lt;= maxFrameSize </span><span class="cov8" title="1">{
                return v
        }</span>
        <span class="cov8" title="1">return defaultMaxReadFrameSize</span>
}

func (s *Server) maxConcurrentStreams(r *Rule) uint32 <span class="cov8" title="1">{
        if r != nil &amp;&amp; r.MaxConcurrentStreams &gt; 0 </span><span class="cov0" title="0">{
                return r.MaxConcurrentStreams
        }</span>
        <span class="cov8" title="1">if v := s.MaxConcurrentStreams; v &gt; 0 </span><span class="cov0" title="0">{
                return v
        }</span>
        <span class="cov8" title="1">return defaultMaxStreams</span>
}

// maxQueuedControlFrames is the maximum number of control frames like
// SETTINGS, PING and RST_STREAM that will be queued for writing before
// the connection is closed to prevent memory exhaustion attacks.
func (s *Server) maxQueuedControlFrames() int <span class="cov8" title="1">{
        // TODO: if anybody asks, add a Server field, and remember to define the
        // behavior of negative values.
        return maxQueuedControlFrames
}</span>

// ConfigureServer adds HTTP/2 support to a net/http Server.
//
// The configuration conf may be nil.
//
// ConfigureServer must be called before s begins serving.
func ConfigureServer(s *http.Server, conf *Server) error <span class="cov8" title="1">{
        if conf == nil </span><span class="cov8" title="1">{
                conf = new(Server)
        }</span>

        <span class="cov8" title="1">if s.TLSConfig == nil </span><span class="cov8" title="1">{
                s.TLSConfig = new(tls.Config)
        }</span> else<span class="cov8" title="1"> if s.TLSConfig.CipherSuites != nil </span><span class="cov8" title="1">{
                // If they already provided a CipherSuite list, return
                // an error if it has a bad order or is missing
                // ECDHE_RSA_WITH_AES_128_GCM_SHA256.
                const requiredCipher = tls.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
                haveRequired := false
                sawBad := false
                for i, cs := range s.TLSConfig.CipherSuites </span><span class="cov8" title="1">{
                        if cs == requiredCipher </span><span class="cov8" title="1">{
                                haveRequired = true
                        }</span>
                        <span class="cov8" title="1">if isBadCipher(cs) </span><span class="cov8" title="1">{
                                sawBad = true
                        }</span> else<span class="cov8" title="1"> if sawBad </span><span class="cov8" title="1">{
                                return fmt.Errorf("http2: TLSConfig.CipherSuites index %d contains an HTTP/2-approved cipher suite (%#04x), but it comes after unapproved cipher suites. With this configuration, clients that don't support previous, approved cipher suites may be given an unapproved one and reject the connection.", i, cs)
                        }</span>
                }
                <span class="cov8" title="1">if !haveRequired </span><span class="cov0" title="0">{
                        return fmt.Errorf("http2: TLSConfig.CipherSuites is missing HTTP/2-required TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256")
                }</span>
        }

        // Note: not setting MinVersion to tls.VersionTLS12,
        // as we don't want to interfere with HTTP/1.1 traffic
        // on the user's server. We enforce TLS 1.2 later once
        // we accept a connection. Ideally this should be done
        // during next-proto selection, but using TLS &lt;1.2 with
        // HTTP/2 is still the client's bug.

        <span class="cov8" title="1">s.TLSConfig.PreferServerCipherSuites = true

        haveNPN := false
        for _, p := range s.TLSConfig.NextProtos </span><span class="cov0" title="0">{
                if p == NextProtoTLS </span><span class="cov0" title="0">{
                        haveNPN = true
                        break</span>
                }
        }
        <span class="cov8" title="1">if !haveNPN </span><span class="cov8" title="1">{
                s.TLSConfig.NextProtos = append(s.TLSConfig.NextProtos, NextProtoTLS)
        }</span>
        // h2-14 is temporary (as of 2015-03-05) while we wait for all browsers
        // to switch to "h2".
        <span class="cov8" title="1">s.TLSConfig.NextProtos = append(s.TLSConfig.NextProtos, "h2-14")

        if s.TLSNextProto == nil </span><span class="cov8" title="1">{
                s.TLSNextProto = map[string]func(*http.Server, *tls.Conn, http.Handler){}
        }</span>
        <span class="cov8" title="1">protoHandler := func(hs *http.Server, c *tls.Conn, h http.Handler) </span><span class="cov8" title="1">{
                if testHookOnConn != nil </span><span class="cov0" title="0">{
                        testHookOnConn()
                }</span>
                <span class="cov8" title="1">conf.ServeConn(c, &amp;ServeConnOpts{
                        Handler:    h,
                        BaseConfig: hs,
                })</span>
        }
        <span class="cov8" title="1">s.TLSNextProto[NextProtoTLS] = protoHandler
        s.TLSNextProto["h2-14"] = protoHandler // temporary; see above.
        return nil</span>
}

// NewProtoHandler create tls alpn handler for http2
func NewProtoHandler(conf *Server) func(*http.Server, *tls.Conn, http.Handler) <span class="cov0" title="0">{
        if conf == nil </span><span class="cov0" title="0">{
                conf = new(Server)
        }</span>

        <span class="cov0" title="0">protoHandler := func(hs *http.Server, c *tls.Conn, h http.Handler) </span><span class="cov0" title="0">{
                if testHookOnConn != nil </span><span class="cov0" title="0">{
                        testHookOnConn()
                }</span>
                <span class="cov0" title="0">connOpts := &amp;ServeConnOpts{hs, h}
                conf.ServeConn(c, connOpts)</span>
        }
        <span class="cov0" title="0">return protoHandler</span>
}

func SetConnTimeout(body *RequestBody, d time.Duration) <span class="cov0" title="0">{
        sc := body.conn
        sc.serveG.CheckNotOn() // NOT on serve goroutine
        select </span>{
        // just send timeout value to chan
        case sc.timeoutValueCh &lt;- timeoutValueElem{
                tag:      ConnTag,
                rb:       body,
                duration: d,
        }:<span class="cov0" title="0"></span>
        case &lt;-sc.doneServing:<span class="cov0" title="0">
                return</span>
        }
}

func SetReadStreamTimeout(body *RequestBody, d time.Duration) <span class="cov0" title="0">{
        setStreamTimeout(ReadStreamTag, body, d)
}</span>

func SetWriteStreamTimeout(body *RequestBody, d time.Duration) <span class="cov0" title="0">{
        setStreamTimeout(WriteStreamTag, body, d)
}</span>

func setStreamTimeout(tag timeoutTag, body *RequestBody, d time.Duration) <span class="cov0" title="0">{
        sc := body.conn
        sc.serveG.CheckNotOn() // NOT on serve goroutine
        select </span>{
        // just send timeout value to chan
        case sc.timeoutValueCh &lt;- timeoutValueElem{
                tag:      tag,
                rb:       body,
                duration: d,
        }:<span class="cov0" title="0"></span>
        case &lt;-sc.doneServing:<span class="cov0" title="0">
                return</span>
        }
}

// ServeConnOpts are options for the Server.ServeConn method.
type ServeConnOpts struct {
        // BaseConfig optionally sets the base configuration
        // for values. If nil, defaults are used.
        BaseConfig *http.Server

        // Handler specifies which handler to use for processing
        // requests. If nil, BaseConfig.Handler is used.
        Handler http.Handler
}

func (o *ServeConnOpts) baseConfig() *http.Server <span class="cov8" title="1">{
        if o != nil &amp;&amp; o.BaseConfig != nil </span><span class="cov8" title="1">{
                return o.BaseConfig
        }</span>
        <span class="cov0" title="0">return new(http.Server)</span>
}

func (o *ServeConnOpts) handler() http.Handler <span class="cov8" title="1">{
        if o != nil </span><span class="cov8" title="1">{
                if o.Handler != nil </span><span class="cov8" title="1">{
                        return o.Handler
                }</span>
                <span class="cov8" title="1">if o.BaseConfig != nil &amp;&amp; o.BaseConfig.Handler != nil </span><span class="cov8" title="1">{
                        return o.BaseConfig.Handler
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// ServeConn serves HTTP/2 requests on the provided connection and
// blocks until the connection is no longer readable.
//
// ServeConn starts speaking HTTP/2 assuming that c has not had any
// reads or writes. It writes its initial settings frame and expects
// to be able to read the preface and settings frame from the
// client. If c has a ConnectionState method like a *tls.Conn, the
// ConnectionState is used to verify the TLS ciphersuite and to set
// the Request.TLS field in Handlers.
//
// ServeConn does not support h2c by itself. Any h2c support must be
// implemented in terms of providing a suitably-behaving net.Conn.
//
// The opts parameter is optional. If nil, default values are used.
func (s *Server) ServeConn(c net.Conn, opts *ServeConnOpts) <span class="cov8" title="1">{
        // get rule for current conn
        var r *Rule
        if tlsConn, ok := c.(*tls.Conn); ok &amp;&amp; serverRule != nil </span><span class="cov0" title="0">{
                r = serverRule.GetHTTP2Rule(tlsConn)
        }</span>

        <span class="cov8" title="1">sc := &amp;serverConn{
                srv:              s,
                hs:               opts.baseConfig(),
                conn:             c,
                remoteAddrStr:    c.RemoteAddr().String(),
                bw:               newBufferedWriter(c),
                handler:          opts.handler(),
                streams:          make(map[uint32]*stream),
                readFrameCh:      make(chan readFrameResult),
                wantWriteFrameCh: make(chan frameWriteMsg, 8),
                writeFrameCh:     make(chan frameWriteMsg, 1),    // buffered; one recv in writeFrames goroutine
                wroteFrameCh:     make(chan frameWriteResult, 1), // buffered; one send in writeFrames goroutine
                bodyReadCh:       make(chan bodyReadMsg),         // buffering doesn't matter either way
                doneServing:      make(chan struct{}),
                closeNotifyCh:    opts.BaseConfig.CloseNotifyCh,
                advMaxStreams:    s.maxConcurrentStreams(r),
                rule:             r,
                writeSched: writeScheduler{
                        maxFrameSize: initialMaxFrameSize,
                },
                initialWindowSize: initialWindowSize,
                headerTableSize:   initialHeaderTableSize,
                serveG:            gotrack.NewGoroutineLock(),
                pushEnabled:       true,

                readClientAgainTimeout: defaultReadClientAgainTimeout,
                timeoutEventCh:         make(chan timeoutEventElem, s.maxConcurrentStreams(r)),
                timeoutValueCh:         make(chan timeoutValueElem, s.maxConcurrentStreams(r)),
        }
        sc.flow.add(initialWindowSize)
        sc.inflow.add(initialWindowSize)
        sc.hpackEncoder = hpack.NewEncoder(&amp;sc.headerWriteBuf)

        fr := NewFramer(sc.bw, c)
        fr.ReadMetaHeaders = hpack.NewDecoder(initialHeaderTableSize, nil)
        fr.MaxHeaderListSize = sc.maxHeaderListSize()
        fr.MaxHeaderUriSize = sc.maxHeaderUriSize()
        fr.SetMaxReadFrameSize(s.maxReadFrameSize())
        sc.framer = fr
        if r != nil </span><span class="cov0" title="0">{
                sc.disableDegrade = r.DisableDegrade
        }</span>

        // check conn rate limit
        <span class="cov8" title="1">if !acceptConn() &amp;&amp; !sc.disableDegrade </span><span class="cov0" title="0">{
                state.H2ConnOverload.Inc(1)
                sc.rejectConn(ErrCodeNo, "http2 overload")
                return
        }</span>

        <span class="cov8" title="1">if tc, ok := c.(connectionStater); ok </span><span class="cov8" title="1">{
                sc.tlsState = new(tls.ConnectionState)
                *sc.tlsState = tc.ConnectionState()
                // 9.2 Use of TLS Features
                // An implementation of HTTP/2 over TLS MUST use TLS
                // 1.2 or higher with the restrictions on feature set
                // and cipher suite described in this section. Due to
                // implementation limitations, it might not be
                // possible to fail TLS negotiation. An endpoint MUST
                // immediately terminate an HTTP/2 connection that
                // does not meet the TLS requirements described in
                // this section with a connection error (Section
                // 5.4.1) of type INADEQUATE_SECURITY.
                if sc.tlsState.Version &lt; tls.VersionTLS12 </span><span class="cov8" title="1">{
                        sc.rejectConn(ErrCodeInadequateSecurity, "TLS version too low")
                        return
                }</span>

                //lint:ignore SA9003 empty branch
                <span class="cov8" title="1">if sc.tlsState.ServerName == "" </span>{<span class="cov0" title="0">
                        // Client must use SNI, but we don't enforce that anymore,
                        // since it was causing problems when connecting to bare IP
                        // addresses during development.
                        //
                        // TODO: optionally enforce? Or enforce at the time we receive
                        // a new request, and verify the the ServerName matches the :authority?
                        // But that precludes proxy situations, perhaps.
                        //
                        // So for now, do nothing here again.
                }</span>

                <span class="cov8" title="1">if !s.PermitProhibitedCipherSuites &amp;&amp; isBadCipher(sc.tlsState.CipherSuite) </span><span class="cov8" title="1">{
                        // "Endpoints MAY choose to generate a connection error
                        // (Section 5.4.1) of type INADEQUATE_SECURITY if one of
                        // the prohibited cipher suites are negotiated."
                        //
                        // We choose that. In my opinion, the spec is weak
                        // here. It also says both parties must support at least
                        // TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 so there's no
                        // excuses here. If we really must, we could allow an
                        // "AllowInsecureWeakCiphers" option on the server later.
                        // Let's see how it plays out first.
                        sc.rejectConn(ErrCodeInadequateSecurity, fmt.Sprintf("Prohibited TLS 1.2 Cipher Suite: %x", sc.tlsState.CipherSuite))
                        return
                }</span>
        }

        <span class="cov8" title="1">if hook := testHookGetServerConn; hook != nil </span><span class="cov8" title="1">{
                hook(sc)
        }</span>
        <span class="cov8" title="1">sc.serve()</span>
}

// isBadCipher reports whether the cipher is blocklisted by the HTTP/2 spec.
func isBadCipher(cipher uint16) bool <span class="cov8" title="1">{
        switch cipher </span>{
        case tls.TLS_RSA_WITH_RC4_128_SHA,
                tls.TLS_RSA_WITH_3DES_EDE_CBC_SHA,
                tls.TLS_RSA_WITH_AES_128_CBC_SHA,
                tls.TLS_RSA_WITH_AES_256_CBC_SHA,
                tls.TLS_ECDHE_ECDSA_WITH_RC4_128_SHA,
                tls.TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA,
                tls.TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA,
                tls.TLS_ECDHE_RSA_WITH_RC4_128_SHA,
                tls.TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA,
                tls.TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,
                tls.TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA:<span class="cov8" title="1">
                // Reject cipher suites from Appendix A.
                // "This list includes those cipher suites that do not
                // offer an ephemeral key exchange and those that are
                // based on the TLS null, stream or block cipher type"
                return true</span>
        default:<span class="cov8" title="1">
                return false</span>
        }
}

func (sc *serverConn) rejectConn(err ErrCode, debug string) <span class="cov8" title="1">{
        log.Logger.Info("http2: server rejecting conn: %v, %s", err, debug)
        // ignoring errors. hanging up anyway.
        // The last stream identifier can be set to 0 if no streams were
        // processed. See RFC 7540 Section 6.8
        sc.framer.WriteGoAway(0, err, []byte(debug))
        sc.bw.Flush()
        sc.conn.Close()
}</span>

type serverConn struct {
        // Immutable:
        srv              *Server
        hs               *http.Server
        conn             net.Conn
        bw               *bufferedWriter // writing to conn
        handler          http.Handler
        framer           *Framer
        doneServing      chan struct{}         // closed when serverConn.serve ends
        readFrameCh      chan readFrameResult  // written by serverConn.readFrames
        wantWriteFrameCh chan frameWriteMsg    // from handlers -&gt; serve
        writeFrameCh     chan frameWriteMsg    // from serve -&gt; writeFrames goroutine
        wroteFrameCh     chan frameWriteResult // from writeFrames goroutine -&gt; serve, tickles more frame writes
        bodyReadCh       chan bodyReadMsg      // from handlers -&gt; serve
        closeNotifyCh    chan bool             // from outside -&gt; serve
        testHookCh       chan func(int)        // code to run on the serve loop
        flow             flow                  // conn-wide (not stream-specific) outbound flow control
        inflow           flow                  // conn-wide inbound flow control
        tlsState         *tls.ConnectionState  // shared by all handlers, like net/http
        remoteAddrStr    string
        disableDegrade   bool
        rule             *Rule

        // Everything following is owned by the serve loop; use serveG.Check():
        serveG                gotrack.GoroutineLock // used to verify funcs are on serve()
        pushEnabled           bool
        sawFirstSettings      bool // got the initial SETTINGS frame after the preface
        needToSendSettingsAck bool
        unackedSettings       int    // how many SETTINGS have we sent without ACKs?
        queuedControlFrames   int    // control frames in the writeSched queue
        clientMaxStreams      uint32 // SETTINGS_MAX_CONCURRENT_STREAMS from client (our PUSH_PROMISE limit)
        advMaxStreams         uint32 // our SETTINGS_MAX_CONCURRENT_STREAMS advertised the client
        curOpenStreams        uint32 // client's number of open streams
        maxStreamID           uint32 // max ever seen
        streams               map[uint32]*stream
        initialWindowSize     int32
        headerTableSize       uint32
        peerMaxHeaderListSize uint32            // zero means unknown (default)
        canonHeader           map[string]string // http2-lower-case -&gt; Go-Canonical-Case
        writingFrame          bool              // started write goroutine but haven't heard back on wroteFrameCh
        needsFrameFlush       bool              // last frame write wasn't a flush
        writeSched            writeScheduler
        inGoAway              bool // we've started to or sent GOAWAY
        needToSendGoAway      bool // we need to schedule a GOAWAY frame write
        goAwayCode            ErrCode
        shutdownTimerCh       &lt;-chan time.Time // nil until used
        shutdownTimer         *time.Timer      // nil until used
        freeRequestBodyBuf    []byte           // if non-nil, a free initialWindowSize buffer for getRequestBodyBuf

        // Owned by the writeFrames goroutine:
        headerWriteBuf bytes.Buffer
        hpackEncoder   *hpack.Encoder

        // how long to wait when there is no request processing on the connection
        // it is updated once ServeHTTP() routine found a request is finished
        // but only used when connection become idle(no left request if processing)
        readClientAgainTimeout time.Duration

        // when timeout, timer hook write to chan
        // main routine read from chan
        timeoutEventCh chan timeoutEventElem

        // when save timeout, ServeHTTP() routine write to chan
        // main routine read from chan
        timeoutValueCh chan timeoutValueElem
}

// timeout event
type timeoutEventElem struct {
        tag      timeoutTag
        streamID uint32
}

// timeout value
type timeoutValueElem struct {
        tag      timeoutTag
        rb       *RequestBody
        duration time.Duration
}

func (sc *serverConn) maxHeaderUriSize() uint32 <span class="cov8" title="1">{
        n := sc.hs.MaxHeaderUriBytes
        if n &lt;= 0 </span><span class="cov8" title="1">{
                n = http.DefaultMaxHeaderUriBytes
        }</span>

        <span class="cov8" title="1">return uint32(n)</span>
}

func (sc *serverConn) maxHeaderSize() uint32 <span class="cov8" title="1">{
        n := sc.hs.MaxHeaderBytes
        if n &lt;= 0 </span><span class="cov8" title="1">{
                n = http.DefaultMaxHeaderBytes
        }</span>

        <span class="cov8" title="1">return uint32(n)</span>
}

func (sc *serverConn) maxHeaderListSize() uint32 <span class="cov8" title="1">{
        n := sc.maxHeaderSize()
        // http2's count is in a slightly different unit and includes 32 bytes per pair.
        // So, take the net/http.Server value and pad it up a bit, assuming 10 headers.
        const perFieldOverhead = 32 // per http2 spec
        const typicalHeaders = 10   // conservative
        return uint32(n + typicalHeaders*perFieldOverhead)
}</span>

// stream represents a stream. This is the minimal metadata needed by
// the serve goroutine. Most of the actual stream state is owned by
// the http.Handler's goroutine in the responseWriter. Because the
// responseWriter's responseWriterState is recycled at the end of a
// handler, this struct intentionally has no pointer to the
// *responseWriter{,State} itself, as the Handler ending nils out the
// responseWriter's state field.
type stream struct {
        // immutable:
        sc   *serverConn
        id   uint32
        body *pipe.Pipe  // non-nil if expecting DATA frames
        cw   closeWaiter // closed wait stream transitions to closed state
        isw  uint32      // initial stream window size

        // owned by serverConn's serve loop:
        bodyBytes        int64   // body bytes seen so far
        declBodyBytes    int64   // or -1 if undeclared
        flow             flow    // limits writing from Handler to client
        inflow           flow    // what the client is allowed to POST/etc to us
        parent           *stream // or nil
        numTrailerValues int64
        weight           uint8
        state            streamState
        sentReset        bool // only true once detached from streams map
        gotReset         bool // only true once detacted from streams map
        gotTrailerHeader bool // HEADER frame for trailers was seen
        reqBuf           []byte

        trailer    http.Header // accumulated trailers
        reqTrailer http.Header // handler's Request.Trailer

        // timeout timer, used for TimeoutReadClient and TimeoutWriteClient
        // need to stop if it is not timeout
        readTimeoutTimer  *time.Timer
        writeTimeoutTimer *time.Timer
}

func (sc *serverConn) Framer() *Framer  <span class="cov8" title="1">{ return sc.framer }</span>
func (sc *serverConn) CloseConn() error <span class="cov8" title="1">{ return sc.conn.Close() }</span>
func (sc *serverConn) Flush() error     <span class="cov8" title="1">{ return sc.bw.Flush() }</span>
func (sc *serverConn) HeaderEncoder() (*hpack.Encoder, *bytes.Buffer) <span class="cov8" title="1">{
        return sc.hpackEncoder, &amp;sc.headerWriteBuf
}</span>

func (sc *serverConn) state(streamID uint32) (streamState, *stream) <span class="cov8" title="1">{
        sc.serveG.Check()
        // http://http2.github.io/http2-spec/#rfc.section.5.1
        if st, ok := sc.streams[streamID]; ok </span><span class="cov8" title="1">{
                return st.state, st
        }</span>
        // "The first use of a new stream identifier implicitly closes all
        // streams in the "idle" state that might have been initiated by
        // that peer with a lower-valued stream identifier. For example, if
        // a client sends a HEADERS frame on stream 7 without ever sending a
        // frame on stream 5, then stream 5 transitions to the "closed"
        // state when the first frame for stream 7 is sent or received."
        <span class="cov8" title="1">if streamID &lt;= sc.maxStreamID </span><span class="cov8" title="1">{
                return stateClosed, nil
        }</span>
        <span class="cov8" title="1">return stateIdle, nil</span>
}

// setConnState calls the net/http ConnState hook for this connection, if configured.
// Note that the net/http package does StateNew and StateClosed for us.
// There is currently no plan for StateHijacked or hijacking HTTP/2 connections.
func (sc *serverConn) setConnState(state http.ConnState) <span class="cov8" title="1">{
        if sc.hs.ConnState != nil </span><span class="cov0" title="0">{
                sc.hs.ConnState(sc.conn, state)
        }</span>
}

// errno returns v's underlying uintptr, else 0.
//
// TODO: remove this helper function once http2 can use build
// tags. See comment in isClosedConnError.
func errno(v error) uintptr <span class="cov0" title="0">{
        if rv := reflect.ValueOf(v); rv.Kind() == reflect.Uintptr </span><span class="cov0" title="0">{
                return uintptr(rv.Uint())
        }</span>
        <span class="cov0" title="0">return 0</span>
}

// isClosedConnError reports whether err is an error from use of a closed
// network connection.
func isClosedConnError(err error) bool <span class="cov8" title="1">{
        if err == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // TODO: remove this string search and be more like the Windows
        // case below. That might involve modifying the standard library
        // to return better error types.
        <span class="cov8" title="1">str := err.Error()
        if strings.Contains(str, "use of closed network connection") </span><span class="cov8" title="1">{
                return true
        }</span>

        // TODO(bradfitz): x/tools/cmd/bundle doesn't really support
        // build tags, so I can't make an http2_windows.go file with
        // Windows-specific stuff. Fix that and move this, once we
        // have a way to bundle this into std's net/http somehow.
        <span class="cov8" title="1">if runtime.GOOS == "windows" </span><span class="cov0" title="0">{
                if oe, ok := err.(*net.OpError); ok &amp;&amp; oe.Op == "read" </span><span class="cov0" title="0">{
                        if se, ok := oe.Err.(*os.SyscallError); ok &amp;&amp; se.Syscall == "wsarecv" </span><span class="cov0" title="0">{
                                const WSAECONNABORTED = 10053
                                const WSAECONNRESET = 10054
                                if n := errno(se.Err); n == WSAECONNRESET || n == WSAECONNABORTED </span><span class="cov0" title="0">{
                                        return true
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return false</span>
}

func (sc *serverConn) canonicalHeader(v string) string <span class="cov8" title="1">{
        sc.serveG.Check()
        cv, ok := commonCanonHeader[v]
        if ok </span><span class="cov8" title="1">{
                return cv
        }</span>
        <span class="cov8" title="1">cv, ok = sc.canonHeader[v]
        if ok </span><span class="cov0" title="0">{
                return cv
        }</span>
        <span class="cov8" title="1">if sc.canonHeader == nil </span><span class="cov8" title="1">{
                sc.canonHeader = make(map[string]string)
        }</span>
        <span class="cov8" title="1">cv = http.CanonicalHeaderKey(v)
        sc.canonHeader[v] = cv
        return cv</span>
}

type readFrameResult struct {
        f   Frame // valid until readMore is called
        err error

        // readMore should be called once the consumer no longer needs or
        // retains f. After readMore, f is invalid and more frames can be
        // read.
        readMore func()
}

// readFrames is the loop that reads incoming frames.
// It takes care to only read one frame at a time, blocking until the
// consumer is done with the frame.
// It's run on its own goroutine.
func (sc *serverConn) readFrames() <span class="cov8" title="1">{
        gate := make(gate)
        gateDone := gate.Done
        for </span><span class="cov8" title="1">{
                f, err := sc.framer.ReadFrame()
                if err == nil &amp;&amp; f != nil </span><span class="cov8" title="1">{
                        if _, ok := f.(*MetaHeadersFrame); ok </span><span class="cov8" title="1">{
                                // no timeout till now, cancel read timeout
                                var zero time.Time
                                sc.conn.SetReadDeadline(zero)
                        }</span>
                }

                <span class="cov8" title="1">select </span>{
                case sc.readFrameCh &lt;- readFrameResult{f, err, gateDone}:<span class="cov8" title="1"></span>
                case &lt;-sc.doneServing:<span class="cov0" title="0">
                        return</span>
                }
                <span class="cov8" title="1">select </span>{
                case &lt;-gate:<span class="cov8" title="1"></span>
                case &lt;-sc.doneServing:<span class="cov8" title="1">
                        return</span>
                }
                <span class="cov8" title="1">if terminalReadFrameError(err) </span><span class="cov8" title="1">{
                        return
                }</span>
        }
}

// frameWriteResult is the message passed from writeFrames goroutine to the serve goroutine.
type frameWriteResult struct {
        wm  frameWriteMsg // what was written (or attempted)
        err error         // result of the writeFrame call
}

// writeFrames runs in its own goroutine and writes frame
// and then reports when it's done.
// At most one frame can be added to writeFrameCh per serverConn.
func (sc *serverConn) writeFrames() <span class="cov8" title="1">{
        var wm frameWriteMsg
        var err error

        for </span><span class="cov8" title="1">{
                // get frame from sendChan
                select </span>{
                case wm = &lt;-sc.writeFrameCh:<span class="cov8" title="1"></span>
                case &lt;-sc.doneServing:<span class="cov8" title="1">
                        return</span>
                }

                // write frame
                <span class="cov8" title="1">err = wm.write.writeFrame(sc)
                log.Logger.Debug("http2: write Frame: %v, %v", wm, err)

                // report write result
                select </span>{
                case sc.wroteFrameCh &lt;- frameWriteResult{wm, err}:<span class="cov8" title="1"></span>
                case &lt;-sc.doneServing:<span class="cov8" title="1">
                        return</span>
                }
        }
}

func (sc *serverConn) closeAllStreamsOnConnClose() <span class="cov8" title="1">{
        sc.serveG.Check()
        for _, st := range sc.streams </span><span class="cov8" title="1">{
                sc.closeStream(st, errClientDisconnected)
        }</span>
}

func (sc *serverConn) stopShutdownTimer() <span class="cov8" title="1">{
        sc.serveG.Check()
        if t := sc.shutdownTimer; t != nil </span><span class="cov8" title="1">{
                t.Stop()
        }</span>
}

func (sc *serverConn) notePanic() <span class="cov8" title="1">{
        // Note: this is for serverConn.serve panicking, not http.Handler code.
        if testHookOnPanicMu != nil </span><span class="cov8" title="1">{
                testHookOnPanicMu.Lock()
                defer testHookOnPanicMu.Unlock()
        }</span>
        <span class="cov8" title="1">if e := recover(); e != nil </span><span class="cov0" title="0">{
                log.Logger.Warn("http2: panic serving %v: %v\n%s", sc.conn.RemoteAddr(), e, gotrack.CurrentStackTrace(0))
                state.H2PanicConn.Inc(1)
                if testHookOnPanic != nil </span><span class="cov0" title="0">{
                        if testHookOnPanic(sc, e) </span><span class="cov0" title="0">{
                                panic(e)</span>
                        }
                }
        }
}

func (sc *serverConn) serve() <span class="cov8" title="1">{
        sc.serveG.Check()
        defer sc.notePanic()
        defer sc.conn.Close()
        defer sc.closeAllStreamsOnConnClose()
        defer sc.stopShutdownTimer()
        defer close(sc.doneServing) // unblocks handlers trying to send

        log.Logger.Debug("http2: server connection from %v on %p", sc.conn.RemoteAddr(), sc.hs)

        // set read client timeout for the first request on connection
        sc.conn.SetReadDeadline(time.Now().Add(sc.hs.ReadTimeout))

        sc.writeFrame(frameWriteMsg{
                write: writeSettings{
                        {SettingMaxFrameSize, sc.srv.maxReadFrameSize()},
                        {SettingMaxConcurrentStreams, sc.advMaxStreams},
                        {SettingMaxHeaderListSize, sc.maxHeaderListSize()},
                        {SettingInitialWindowSize, uint32(sc.srv.initialStreamRecvWindowSize(sc.rule))},
                },
        })
        sc.unackedSettings++

        // Note: Flow control window size for each connection starts with initialWindowSize.
        // We use a larger window size for inflow here.
        if enableLargeConnRecvWindow </span><span class="cov0" title="0">{
                sc.sendWindowUpdate(nil, int(initialConnRecvWindowSize-initialWindowSize))
        }</span>

        <span class="cov8" title="1">if err := sc.readPreface(); err != nil </span><span class="cov0" title="0">{
                log.Logger.Debug("http2: server: error reading preface from client %v: %v", sc.conn.RemoteAddr(), err)
                return
        }</span>
        // Now that we've got the preface, get us out of the
        // "StateNew" state.  We can't go directly to idle, though.
        // Active means we read some data and anticipate a request. We'll
        // do another Active when we get a HEADERS frame.
        <span class="cov8" title="1">sc.setConnState(http.StateActive)
        sc.setConnState(http.StateIdle)

        go sc.readFrames()  // closed by defer sc.conn.Close above
        go sc.writeFrames() // closed by defer sc.conn.Close above

        settingsTimer := time.NewTimer(firstSettingsTimeout)
        loopNum := 0
        for </span><span class="cov8" title="1">{
                loopNum++
                select </span>{
                case wm := &lt;-sc.wantWriteFrameCh:<span class="cov8" title="1">
                        sc.writeFrame(wm)</span>
                case res := &lt;-sc.wroteFrameCh:<span class="cov8" title="1">
                        sc.wroteFrame(res)</span>
                case res := &lt;-sc.readFrameCh:<span class="cov8" title="1">
                        if !sc.processFrameFromReader(res) </span><span class="cov8" title="1">{
                                return
                        }</span>
                        <span class="cov8" title="1">res.readMore()
                        if settingsTimer.C != nil </span><span class="cov8" title="1">{
                                settingsTimer.Stop()
                                settingsTimer.C = nil
                        }</span>
                case m := &lt;-sc.bodyReadCh:<span class="cov8" title="1">
                        sc.noteBodyRead(m.st, m.n)</span>
                case &lt;-settingsTimer.C:<span class="cov0" title="0">
                        state.H2TimeoutSetting.Inc(1)
                        log.Logger.Debug("timeout waiting for SETTINGS frames from %v", sc.conn.RemoteAddr())
                        return</span>
                case &lt;-sc.shutdownTimerCh:<span class="cov8" title="1">
                        log.Logger.Debug("GOAWAY close timer fired; closing conn from %v", sc.conn.RemoteAddr())
                        return</span>
                case ch := &lt;-sc.timeoutEventCh:<span class="cov0" title="0"> // timeout event happens
                        sc.handleTimeout(ch)</span>
                case v := &lt;-sc.timeoutValueCh:<span class="cov0" title="0"> // get timeout value update notification
                        // set timeout value
                        sc.setTimeout(v)</span>
                case &lt;-sc.closeNotifyCh:<span class="cov8" title="1"> // graceful shutdown
                        log.Logger.Debug("graceful closing http2 conn from %v", sc.conn.RemoteAddr())
                        sc.goAway(ErrCodeNo)
                        sc.closeNotifyCh = nil</span>
                case fn := &lt;-sc.testHookCh:<span class="cov8" title="1">
                        fn(loopNum)</span>
                }

                // If the peer is causing us to generate a lot of control frames,
                // but not reading them from us, assume they are trying to make us
                // run out of memory.
                <span class="cov8" title="1">if sc.queuedControlFrames &gt; sc.srv.maxQueuedControlFrames() </span><span class="cov0" title="0">{
                        state.H2ConnExceedMaxQueuedControlFrames.Inc(1)
                        log.Logger.Debug("http2: too many control frames in send queue, closing connection")
                        return
                }</span>
        }
}

// hand timeout event for stream timeout, stream timeout, rst stream
func (sc *serverConn) handleTimeout(ch timeoutEventElem) <span class="cov0" title="0">{
        tag := ch.tag
        errMsg := fmt.Sprintf("%s timeout, resetting frame id[%d] from %v",
                tag.String(), ch.streamID, sc.conn.RemoteAddr())
        // stream timeout, rst the stream
        errRst := StreamError{ch.streamID, ErrCodeProtocol, errMsg}
        sc.resetStream(errRst)

        log.Logger.Debug("bfe_http2:%s", errMsg)
}</span>

func (sc *serverConn) setTimeout(elem timeoutValueElem) <span class="cov0" title="0">{
        tag := elem.tag
        rb := elem.rb
        duration := elem.duration
        stream := rb.stream

        if sc != rb.conn </span><span class="cov0" title="0">{
                // there Must be some error, panic
                panic("internal error: bad request body")</span>
        }

        <span class="cov0" title="0">if tag == ConnTag </span><span class="cov0" title="0">{
                // just update timeout value here
                sc.readClientAgainTimeout = duration
        }</span>
        <span class="cov0" title="0">if (tag == ReadStreamTag &amp;&amp; stream.body != nil) || tag == WriteStreamTag </span><span class="cov0" title="0">{
                timerCb := func() </span><span class="cov0" title="0">{
                        select </span>{
                        // timer hook: send timeout event to chan
                        case sc.timeoutEventCh &lt;- timeoutEventElem{
                                streamID: stream.id,
                                tag:      tag,
                        }:<span class="cov0" title="0"></span>
                        case &lt;-sc.doneServing:<span class="cov0" title="0">
                                return</span>
                        }
                        <span class="cov0" title="0">if tag == ReadStreamTag </span><span class="cov0" title="0">{
                                state.H2TimeoutReadStream.Inc(1)
                        }</span>
                        <span class="cov0" title="0">if tag == WriteStreamTag </span><span class="cov0" title="0">{
                                state.H2TimeoutWriteStream.Inc(1)
                        }</span>
                }

                // just launch timeout timer for TimeoutReadClient
                // Note: MUST use the condition: stream.state == stateOpen
                // because the call order of setTimeout() and endStream() which will stop
                // the readTimeoutTimer is uncertain.
                <span class="cov0" title="0">if tag == ReadStreamTag &amp;&amp; stream.state == stateOpen </span><span class="cov0" title="0">{
                        stream.readTimeoutTimer = time.AfterFunc(duration, timerCb)
                }</span>

                // just launch timeout timer for TimeoutWriteClient
                // Note: MUST use the condition: stream.state != stateClosed
                // because the call order of setTimeout() and closeStream() which will stop
                // the writeTimeoutTimer is uncertain.
                <span class="cov0" title="0">if tag == WriteStreamTag &amp;&amp; stream.state != stateClosed </span><span class="cov0" title="0">{
                        stream.writeTimeoutTimer = time.AfterFunc(duration, timerCb)
                }</span>
        }
}

// readPreface reads the ClientPreface greeting from the peer
// or returns an error on timeout or an invalid greeting.
func (sc *serverConn) readPreface() error <span class="cov8" title="1">{
        errc := make(chan error, 1)
        go func() </span><span class="cov8" title="1">{
                // Read the client preface
                buf := make([]byte, len(ClientPreface))
                if _, err := io.ReadFull(sc.conn, buf); err != nil </span><span class="cov0" title="0">{
                        errc &lt;- err
                }</span> else<span class="cov8" title="1"> if !bytes.Equal(buf, clientPreface) </span><span class="cov0" title="0">{
                        errc &lt;- fmt.Errorf("bogus greeting %q", buf)
                }</span> else<span class="cov8" title="1"> {
                        errc &lt;- nil
                }</span>
        }()
        <span class="cov8" title="1">timer := time.NewTimer(prefaceTimeout) // TODO: configurable on *Server?
        defer timer.Stop()
        select </span>{
        case &lt;-timer.C:<span class="cov0" title="0">
                state.H2TimeoutPreface.Inc(1)
                return errors.New("timeout waiting for client preface")</span>
        case err := &lt;-errc:<span class="cov8" title="1">
                if err == nil </span><span class="cov8" title="1">{
                        log.Logger.Debug("http2: server: client %v said hello", sc.conn.RemoteAddr())
                }</span>
                <span class="cov8" title="1">return err</span>
        }
}

var writeDataPool = sync.Pool{
        New: func() interface{} <span class="cov8" title="1">{ return new(writeData) }</span>,
}

// writeDataFromHandler writes DATA response frames from a handler on
// the given stream.
func (sc *serverConn) writeDataFromHandler(stream *stream, data []byte, endStream bool) error <span class="cov8" title="1">{
        ch := make(chan error, 1)
        writeArg := writeDataPool.Get().(*writeData)
        *writeArg = writeData{stream.id, data, endStream}
        err := sc.writeFrameFromHandler(frameWriteMsg{
                write:  writeArg,
                stream: stream,
                done:   ch,
        })
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">var frameWriteDone bool // the frame write is done (successfully or not)
        select </span>{
        case err = &lt;-ch:<span class="cov8" title="1">
                frameWriteDone = true</span>
        case &lt;-sc.doneServing:<span class="cov8" title="1">
                return errClientDisconnected</span>
        case &lt;-stream.cw:<span class="cov8" title="1">
                // If both ch and stream.cw were ready (as might
                // happen on the final Write after an http.Handler
                // ends), prefer the write result. Otherwise this
                // might just be us successfully closing the stream.
                // The writeFrames goroutine and serve goroutines guarantee
                // that the ch send will happen before the stream.cw
                // close.
                select </span>{
                case err = &lt;-ch:<span class="cov0" title="0">
                        frameWriteDone = true</span>
                default:<span class="cov8" title="1">
                        return errStreamClosed</span>
                }
        }
        <span class="cov8" title="1">if frameWriteDone </span><span class="cov8" title="1">{
                *writeArg = writeData{} // reset writeArg
                writeDataPool.Put(writeArg)
        }</span>
        <span class="cov8" title="1">return err</span>
}

// writeFrameFromHandler sends wm to sc.wantWriteFrameCh, but aborts
// if the connection has gone away.
//
// This must not be run from the serve goroutine itself, else it might
// deadlock writing to sc.wantWriteFrameCh (which is only mildly
// buffered and is read by serve itself). If you're on the serve
// goroutine, call writeFrame instead.
func (sc *serverConn) writeFrameFromHandler(wm frameWriteMsg) error <span class="cov8" title="1">{
        sc.serveG.CheckNotOn() // NOT
        select </span>{
        case sc.wantWriteFrameCh &lt;- wm:<span class="cov8" title="1">
                return nil</span>
        case &lt;-sc.doneServing:<span class="cov8" title="1">
                // Serve loop is gone.
                // Client has closed their connection to the server.
                return errClientDisconnected</span>
        }
}

// writeFrame schedules a frame to write and sends it if there's nothing
// already being written.
//
// There is no pushback here (the serve goroutine never blocks). It's
// the http.Handlers that block, waiting for their previous frames to
// make it onto the wire
//
// If you're not on the serve goroutine, use writeFrameFromHandler instead.
func (sc *serverConn) writeFrame(wm frameWriteMsg) <span class="cov8" title="1">{
        sc.serveG.Check()

        if wm.isControl() </span><span class="cov8" title="1">{
                sc.queuedControlFrames++
        }</span>

        <span class="cov8" title="1">sc.writeSched.add(wm)
        sc.scheduleFrameWrite()</span>
}

// startFrameWrite starts write wm (in a separate frame write
// goroutine since that might block on the network), and updates the
// serve goroutine's state about the world, updated from info in wm.
func (sc *serverConn) startFrameWrite(wm frameWriteMsg) <span class="cov8" title="1">{
        sc.serveG.Check()
        if sc.writingFrame </span><span class="cov0" title="0">{
                panic("internal error: can only be writing one frame at a time")</span>
        }

        <span class="cov8" title="1">st := wm.stream
        if st != nil </span><span class="cov8" title="1">{
                switch st.state </span>{
                case stateHalfClosedLocal:<span class="cov0" title="0">
                        panic("internal error: attempt to send frame on half-closed-local stream")</span>
                case stateClosed:<span class="cov8" title="1">
                        if st.sentReset || st.gotReset </span><span class="cov8" title="1">{
                                // Skip this frame.
                                sc.scheduleFrameWrite()
                                return
                        }</span>
                        <span class="cov0" title="0">panic(fmt.Sprintf("internal error: attempt to send a write %v on a closed stream", wm))</span>
                }
        }

        <span class="cov8" title="1">sc.writingFrame = true
        sc.needsFrameFlush = true

        // Note: for avoid blocking serve goroutine, we let write goroutine to write frame
        sc.writeFrameCh &lt;- wm</span>
}

// errHandlerPanicked is the error given to any callers blocked in a read from
// Request.Body when the main goroutine panics. Since most handlers read in the
// the main ServeHTTP goroutine, this will show up rarely.
var errHandlerPanicked = errors.New("http2: handler panicked")

// wroteFrame is called on the serve goroutine with the result of
// whatever happened on writeFrames goroutine.
func (sc *serverConn) wroteFrame(res frameWriteResult) <span class="cov8" title="1">{
        sc.serveG.Check()
        if !sc.writingFrame </span><span class="cov0" title="0">{
                panic("internal error: expected to be already writing a frame")</span>
        }
        <span class="cov8" title="1">sc.writingFrame = false

        wm := res.wm
        st := wm.stream

        closeStream := endsStream(wm.write)

        if _, ok := wm.write.(handlerPanicRST); ok </span><span class="cov0" title="0">{
                sc.closeStream(st, errHandlerPanicked)
        }</span>

        // Reply (if requested) to the blocked ServeHTTP goroutine.
        <span class="cov8" title="1">if ch := wm.done; ch != nil </span><span class="cov8" title="1">{
                select </span>{
                case ch &lt;- res.err:<span class="cov8" title="1"></span>
                default:<span class="cov0" title="0">
                        panic(fmt.Sprintf("unbuffered done channel passed in for type %T", wm.write))</span>
                }
        }
        <span class="cov8" title="1">wm.write = nil // prevent use (assume it's tainted after wm.done send)

        if closeStream </span><span class="cov8" title="1">{
                if st == nil </span><span class="cov0" title="0">{
                        panic("internal error: expecting non-nil stream")</span>
                }
                <span class="cov8" title="1">switch st.state </span>{
                case stateOpen:<span class="cov8" title="1">
                        // Here we would go to stateHalfClosedLocal in
                        // theory, but since our handler is done and
                        // the net/http package provides no mechanism
                        // for finishing writing to a ResponseWriter
                        // while still reading data (see possible TODO
                        // at top of this file), we go into closed
                        // state here anyway, after telling the peer
                        // we're hanging up on them.
                        st.state = stateHalfClosedLocal // won't last long, but necessary for closeStream via resetStream

                        // Section 8.1: a server MAY request that the client abort transmission
                        // of a request without error by sending a RST_STREAM with an error code
                        // of NO_ERROR after sending a complete response
                        errMsg := "finish writing response while still reading request data"
                        errCancel := StreamError{st.id, ErrCodeNo, errMsg}
                        sc.resetStream(errCancel)</span>
                case stateHalfClosedRemote:<span class="cov8" title="1">
                        sc.closeStream(st, errHandlerComplete)</span>
                }
        }

        <span class="cov8" title="1">sc.scheduleFrameWrite()</span>
}

// scheduleFrameWrite tickles the frame writing scheduler.
//
// If a frame is already being written, nothing happens. This will be called again
// when the frame is done being written.
//
// If a frame isn't being written we need to send one, the best frame
// to send is selected, preferring first things that aren't
// stream-specific (e.g. ACKing settings), and then finding the
// highest priority stream.
//
// If a frame isn't being written and there's nothing else to send, we
// flush the write buffer.
func (sc *serverConn) scheduleFrameWrite() <span class="cov8" title="1">{
        sc.serveG.Check()
        if sc.writingFrame </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">if sc.needToSendGoAway </span><span class="cov8" title="1">{
                sc.needToSendGoAway = false
                sc.startFrameWrite(frameWriteMsg{
                        write: &amp;writeGoAway{
                                maxStreamID: sc.maxStreamID,
                                code:        sc.goAwayCode,
                        },
                })
                return
        }</span>
        <span class="cov8" title="1">if sc.needToSendSettingsAck </span><span class="cov8" title="1">{
                sc.needToSendSettingsAck = false
                sc.startFrameWrite(frameWriteMsg{write: writeSettingsAck{}})
                return
        }</span>
        <span class="cov8" title="1">if !sc.inGoAway || sc.goAwayCode == ErrCodeNo </span><span class="cov8" title="1">{
                if wm, ok := sc.writeSched.take(); ok </span><span class="cov8" title="1">{
                        if wm.isControl() </span><span class="cov8" title="1">{
                                sc.queuedControlFrames--
                        }</span>
                        <span class="cov8" title="1">sc.startFrameWrite(wm)
                        return</span>
                }
        }
        <span class="cov8" title="1">if sc.needsFrameFlush </span><span class="cov8" title="1">{
                sc.startFrameWrite(frameWriteMsg{write: flushFrameWriter{}})
                sc.needsFrameFlush = false // after startFrameWrite, since it sets this true
                return
        }</span>
}

func (sc *serverConn) goAway(code ErrCode) <span class="cov8" title="1">{
        sc.serveG.Check()
        if sc.inGoAway </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if code != ErrCodeNo </span><span class="cov8" title="1">{
                sc.shutDownIn(250 * time.Millisecond)
        }</span> else<span class="cov8" title="1"> {
                sc.shutDownIn(sc.hs.GracefulShutdownTimeout)
        }</span>
        <span class="cov8" title="1">sc.inGoAway = true
        sc.needToSendGoAway = true
        sc.goAwayCode = code
        sc.scheduleFrameWrite()</span>
}

func (sc *serverConn) shutDownIn(d time.Duration) <span class="cov8" title="1">{
        sc.serveG.Check()
        sc.shutdownTimer = time.NewTimer(d)
        sc.shutdownTimerCh = sc.shutdownTimer.C
}</span>

func (sc *serverConn) resetStream(se StreamError) <span class="cov8" title="1">{
        sc.serveG.Check()
        sc.writeFrame(frameWriteMsg{write: se})
        if st, ok := sc.streams[se.StreamID]; ok </span><span class="cov8" title="1">{
                st.sentReset = true
                sc.closeStream(st, se)
        }</span>
}

// processFrameFromReader processes the serve loop's read from readFrameCh from the
// frame-reading goroutine.
// processFrameFromReader returns whether the connection should be kept open.
func (sc *serverConn) processFrameFromReader(res readFrameResult) bool <span class="cov8" title="1">{
        sc.serveG.Check()
        err := res.err
        if err != nil </span><span class="cov8" title="1">{
                if err == ErrFrameTooLarge </span><span class="cov8" title="1">{
                        sc.goAway(ErrCodeFrameSize)
                        return true // goAway will close the loop
                }</span>
                <span class="cov8" title="1">clientGone := err == io.EOF || err == io.ErrUnexpectedEOF || isClosedConnError(err)
                if clientGone </span><span class="cov8" title="1">{
                        // TODO: could we also get into this state if
                        // the peer does a half close
                        // (e.g. CloseWrite) because they're done
                        // sending frames but they're still wanting
                        // our open replies?  Investigate.
                        // TODO: add CloseWrite to crypto/tls.Conn first
                        // so we have a way to test this? I suppose
                        // just for testing we could have a non-TLS mode.
                        log.Logger.Debug("http2: server read frame %v", err)
                        return false
                }</span>
        } else<span class="cov8" title="1"> {
                f := res.f
                log.Logger.Debug("http2: server read frame %v", summarizeFrame(f))
                err = sc.processFrame(f)
                if err == nil </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        <span class="cov8" title="1">switch ev := err.(type) </span>{
        case net.Error:<span class="cov0" title="0">
                if ev.Timeout() </span><span class="cov0" title="0">{
                        state.H2TimeoutConn.Inc(1)
                }</span>
                <span class="cov0" title="0">log.Logger.Debug("http2: network error from %v: %v", sc.conn.RemoteAddr(), ev)
                return false</span>
        case StreamError:<span class="cov8" title="1">
                sc.resetStream(ev)
                return true</span>
        case goAwayFlowError:<span class="cov8" title="1">
                sc.goAway(ErrCodeFlowControl)
                return true</span>
        case ConnectionError:<span class="cov8" title="1">
                log.Logger.Debug("http2: server connection error from %v: %v", sc.conn.RemoteAddr(), ev)
                sc.goAway(ErrCode(ev.Code))
                return true</span> // goAway will handle shutdown
        default:<span class="cov0" title="0">
                if res.err != nil </span><span class="cov0" title="0">{
                        log.Logger.Debug("http2: server closing client connection; error reading frame from client %s: %v",
                                sc.conn.RemoteAddr(), err)
                }</span> else<span class="cov0" title="0"> {
                        log.Logger.Debug("http2: server closing client(%s) connection: %v",
                                sc.conn.RemoteAddr(), err)
                }</span>
                <span class="cov0" title="0">return false</span>
        }
}

func (sc *serverConn) processFrame(f Frame) error <span class="cov8" title="1">{
        sc.serveG.Check()

        // First frame received must be SETTINGS.
        if !sc.sawFirstSettings </span><span class="cov8" title="1">{
                if _, ok := f.(*SettingsFrame); !ok </span><span class="cov0" title="0">{
                        return ConnectionError{ErrCodeProtocol, "first frame not SETTINGS"}
                }</span>
                <span class="cov8" title="1">sc.sawFirstSettings = true</span>
        }

        <span class="cov8" title="1">switch f := f.(type) </span>{
        case *SettingsFrame:<span class="cov8" title="1">
                return sc.processSettings(f)</span>
        case *MetaHeadersFrame:<span class="cov8" title="1">
                return sc.processHeaders(f)</span>
        case *WindowUpdateFrame:<span class="cov8" title="1">
                return sc.processWindowUpdate(f)</span>
        case *PingFrame:<span class="cov8" title="1">
                return sc.processPing(f)</span>
        case *DataFrame:<span class="cov8" title="1">
                return sc.processData(f)</span>
        case *RSTStreamFrame:<span class="cov8" title="1">
                return sc.processResetStream(f)</span>
        case *PriorityFrame:<span class="cov0" title="0">
                return sc.processPriority(f)</span>
        case *PushPromiseFrame:<span class="cov8" title="1">
                // A client cannot push. Thus, servers MUST treat the receipt of a PUSH_PROMISE
                // frame as a connection error (Section 5.4.1) of type PROTOCOL_ERROR.
                return ConnectionError{ErrCodeProtocol, "client should not send PushPromise"}</span>
        default:<span class="cov0" title="0">
                log.Logger.Debug("http2: server ignoring frame: %v", f.Header())
                return nil</span>
        }
}

func (sc *serverConn) processPing(f *PingFrame) error <span class="cov8" title="1">{
        sc.serveG.Check()
        if f.IsAck() </span><span class="cov8" title="1">{
                // 6.7 PING: " An endpoint MUST NOT respond to PING frames
                // containing this flag."
                return nil
        }</span>
        <span class="cov8" title="1">if f.StreamID != 0 </span><span class="cov0" title="0">{
                // "PING frames are not associated with any individual
                // stream. If a PING frame is received with a stream
                // identifier field value other than 0x0, the recipient MUST
                // respond with a connection error (Section 5.4.1) of type
                // PROTOCOL_ERROR."
                return ConnectionError{ErrCodeProtocol, "PING with non-zero stream ID"}
        }</span>
        <span class="cov8" title="1">sc.writeFrame(frameWriteMsg{write: writePingAck{f}})

        // no request processing on the conn, update keepalive timeout
        if sc.curOpenStreams == 0 </span><span class="cov8" title="1">{
                sc.setReadClientAgainTimeout()
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (sc *serverConn) processWindowUpdate(f *WindowUpdateFrame) error <span class="cov8" title="1">{
        sc.serveG.Check()
        switch </span>{
        case f.StreamID != 0:<span class="cov8" title="1"> // stream-level flow control
                st := sc.streams[f.StreamID]
                if st == nil </span><span class="cov0" title="0">{
                        // "WINDOW_UPDATE can be sent by a peer that has sent a
                        // frame bearing the END_STREAM flag. This means that a
                        // receiver could receive a WINDOW_UPDATE frame on a "half
                        // closed (remote)" or "closed" stream. A receiver MUST
                        // NOT treat this as an error, see Section 5.1."
                        return nil
                }</span>
                <span class="cov8" title="1">if !st.flow.add(int32(f.Increment)) </span><span class="cov8" title="1">{
                        errMsg := fmt.Sprintf("WINDOW_UPDATE with invalid increment %d, stream window overflow", f.Increment)
                        return StreamError{f.StreamID, ErrCodeFlowControl, errMsg}
                }</span>
        default:<span class="cov8" title="1"> // connection-level flow control
                if !sc.flow.add(int32(f.Increment)) </span><span class="cov8" title="1">{
                        return goAwayFlowError{}
                }</span>
        }
        <span class="cov8" title="1">sc.scheduleFrameWrite()
        return nil</span>
}

func (sc *serverConn) processResetStream(f *RSTStreamFrame) error <span class="cov8" title="1">{
        sc.serveG.Check()
        state.H2ErrGotReset.Inc(1)

        state, st := sc.state(f.StreamID)
        if state == stateIdle </span><span class="cov0" title="0">{
                // 6.4 "RST_STREAM frames MUST NOT be sent for a
                // stream in the "idle" state. If a RST_STREAM frame
                // identifying an idle stream is received, the
                // recipient MUST treat this as a connection error
                // (Section 5.4.1) of type PROTOCOL_ERROR.
                return ConnectionError{ErrCodeProtocol, "recv RESET for stream in Idle state"}
        }</span>
        <span class="cov8" title="1">if st != nil </span><span class="cov8" title="1">{
                st.gotReset = true
                sc.closeStream(st, StreamError{f.StreamID, f.ErrCode, "stream reset by peer"})
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (sc *serverConn) closeStream(st *stream, err error) <span class="cov8" title="1">{
        sc.serveG.Check()
        if st.state == stateIdle || st.state == stateClosed </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("invariant; can't close stream in state %v", st.state))</span>
        }

        // stop all timeout timer if exist
        <span class="cov8" title="1">st.stopTimeoutTimer()

        st.state = stateClosed
        sc.curOpenStreams--
        if sc.curOpenStreams == 0 </span><span class="cov8" title="1">{
                // no request processing on the conn, set read client again timeout
                sc.setReadClientAgainTimeout()
                sc.setConnState(http.StateIdle)
        }</span>
        <span class="cov8" title="1">delete(sc.streams, st.id)
        if p := st.body; p != nil </span><span class="cov8" title="1">{
                p.CloseWithError(err)
                if st.defaultStreamWindow() </span><span class="cov8" title="1">{
                        p.Release(&amp;fixBufferPool)
                }</span>
        }
        <span class="cov8" title="1">st.cw.Close() // signals Handler's CloseNotifier, unblocks writes, etc
        sc.writeSched.forgetStream(st.id)
        if st.reqBuf != nil </span><span class="cov0" title="0">{
                // Stash this request body buffer (64k) away for reuse
                // by a future POST/PUT/etc.
                //
                // TODO(bradfitz): share on the server? sync.Pool?
                // Server requires locks and might hurt contention.
                // sync.Pool might work, or might be worse, depending
                // on goroutine CPU migrations. (get and put on
                // separate CPUs).  Maybe a mix of strategies. But
                // this is an easy win for now.
                sc.freeRequestBodyBuf = st.reqBuf
        }</span>
}

func (sc *serverConn) setReadClientAgainTimeout() <span class="cov8" title="1">{
        t := time.Now().Add(sc.readClientAgainTimeout)
        sc.conn.SetReadDeadline(t)
}</span>

func (sc *serverConn) processSettings(f *SettingsFrame) error <span class="cov8" title="1">{
        sc.serveG.Check()
        if f.IsAck() </span><span class="cov8" title="1">{
                sc.unackedSettings--
                if sc.unackedSettings &lt; 0 </span><span class="cov0" title="0">{
                        // Why is the peer ACKing settings we never sent?
                        // The spec doesn't mention this case, but
                        // hang up on them anyway.
                        return ConnectionError{ErrCodeProtocol, "recv unexpected SETTINGS"}
                }</span>
                <span class="cov8" title="1">return nil</span>
        }
        <span class="cov8" title="1">if err := f.ForeachSetting(sc.processSetting); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">sc.needToSendSettingsAck = true
        sc.scheduleFrameWrite()
        return nil</span>
}

func (sc *serverConn) processSetting(s Setting) error <span class="cov8" title="1">{
        sc.serveG.Check()
        if err := s.Valid(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">log.Logger.Debug("http2: server processing setting %v", s)

        switch s.ID </span>{
        case SettingHeaderTableSize:<span class="cov0" title="0">
                sc.headerTableSize = s.Val
                sc.hpackEncoder.SetMaxDynamicTableSize(s.Val)</span>
        case SettingEnablePush:<span class="cov0" title="0">
                sc.pushEnabled = s.Val != 0</span>
        case SettingMaxConcurrentStreams:<span class="cov0" title="0">
                sc.clientMaxStreams = s.Val</span>
        case SettingInitialWindowSize:<span class="cov8" title="1">
                return sc.processSettingInitialWindowSize(s.Val)</span>
        case SettingMaxFrameSize:<span class="cov8" title="1">
                sc.writeSched.maxFrameSize = s.Val</span>
        case SettingMaxHeaderListSize:<span class="cov0" title="0">
                sc.peerMaxHeaderListSize = s.Val</span>
        default:<span class="cov0" title="0">
                // Unknown setting: "An endpoint that receives a SETTINGS
                // frame with any unknown or unsupported identifier MUST
                // ignore that setting."
                log.Logger.Debug("http2: server ignoring unknown setting %v", s)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (sc *serverConn) processSettingInitialWindowSize(val uint32) error <span class="cov8" title="1">{
        sc.serveG.Check()
        // Note: val already validated to be within range by
        // processSetting's Valid call.

        // "A SETTINGS frame can alter the initial flow control window
        // size for all current streams. When the value of
        // SETTINGS_INITIAL_WINDOW_SIZE changes, a receiver MUST
        // adjust the size of all stream flow control windows that it
        // maintains by the difference between the new value and the
        // old value."
        old := sc.initialWindowSize
        sc.initialWindowSize = int32(val)
        growth := sc.initialWindowSize - old // may be negative
        for _, st := range sc.streams </span><span class="cov0" title="0">{
                if !st.flow.add(growth) </span><span class="cov0" title="0">{
                        // 6.9.2 Initial Flow Control Window Size
                        // "An endpoint MUST treat a change to
                        // SETTINGS_INITIAL_WINDOW_SIZE that causes any flow
                        // control window to exceed the maximum size as a
                        // connection error (Section 5.4.1) of type
                        // FLOW_CONTROL_ERROR."
                        return ConnectionError{ErrCodeFlowControl, "stream window overflow"}
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (sc *serverConn) processData(f *DataFrame) error <span class="cov8" title="1">{
        sc.serveG.Check()
        id := f.Header().StreamID
        if sc.inGoAway &amp;&amp; (sc.goAwayCode != ErrCodeNo || id &gt; sc.maxStreamID) </span><span class="cov8" title="1">{
                // Discard all DATA frames if the GOAWAY is due to an
                // error, or:
                //
                // Section 6.8: After sending a GOAWAY frame, the sender
                // can discard frames for streams initiated by the
                // receiver with identifiers higher than the identified
                // last stream.
                return nil
        }</span>

        <span class="cov8" title="1">data := f.Data()

        // "If a DATA frame is received whose stream is not in "open"
        // or "half closed (local)" state, the recipient MUST respond
        // with a stream error (Section 5.4.2) of type STREAM_CLOSED."
        st, ok := sc.streams[id]
        if !ok || st.state != stateOpen || st.gotTrailerHeader </span><span class="cov8" title="1">{
                // This includes sending a RST_STREAM if the stream is
                // in stateHalfClosedLocal (which currently means that
                // the http.Handler returned, so it's done reading &amp;
                // done writing). Try to stop the client from sending
                // more DATA.

                // But still enforce their connection-level flow control,
                // and return any flow control bytes since we're not going
                // to consume them.
                if sc.inflow.available() &lt; int32(f.Length) </span><span class="cov0" title="0">{
                        errMsg := "connection-level flow control window error"
                        return StreamError{id, ErrCodeFlowControl, errMsg}
                }</span>

                // Deduct the flow control from inflow, since we're
                // going to immediately add it back in
                // sendWindowUpdate, which also schedules sending the
                // frames.
                <span class="cov8" title="1">sc.inflow.take(int32(f.Length))
                sc.sendWindowUpdate(nil, int(f.Length))

                errMsg := "recv DATA frame from stream not in 'open' or 'half closed(local)' state"
                return StreamError{id, ErrCodeStreamClosed, errMsg}</span>
        }
        <span class="cov8" title="1">if st.body == nil </span><span class="cov0" title="0">{
                panic("internal error: should have a body in this state")</span>
        }

        // Sender sending more than they'd declared?
        <span class="cov8" title="1">if st.declBodyBytes != -1 &amp;&amp; st.bodyBytes+int64(len(data)) &gt; st.declBodyBytes </span><span class="cov8" title="1">{
                err := fmt.Errorf("sender tried to send more than declared Content-Length of %d bytes", st.declBodyBytes)
                st.body.CloseWithError(err)
                // RFC 7540, sec 8.1.2.6: A request or response is also malformed if the
                // value of a content-length header field does not equal the sum of the
                // DATA frame payload lengths that form the body.
                return StreamError{id, ErrCodeProtocol, err.Error()}
        }</span>
        <span class="cov8" title="1">if f.Length &gt; 0 </span><span class="cov8" title="1">{
                // Check whether the client has flow control quota.
                if st.inflow.available() &lt; int32(f.Length) </span><span class="cov0" title="0">{
                        errMsg := fmt.Sprintf("sender tried to send more than stream available window size %d", st.inflow.available())
                        return StreamError{id, ErrCodeFlowControl, errMsg}
                }</span>
                <span class="cov8" title="1">st.inflow.take(int32(f.Length))

                if len(data) &gt; 0 </span><span class="cov8" title="1">{
                        wrote, err := st.body.Write(data)
                        if err != nil </span><span class="cov0" title="0">{
                                errMsg := fmt.Sprintf("stream body write error: %s", err)
                                return StreamError{id, ErrCodeStreamClosed, errMsg}
                        }</span>
                        <span class="cov8" title="1">if wrote != len(data) </span><span class="cov0" title="0">{
                                panic("internal error: bad Writer")</span>
                        }
                        <span class="cov8" title="1">st.bodyBytes += int64(len(data))</span>
                }

                // Return any padded flow control now, since we won't
                // refund it later on body reads.
                <span class="cov8" title="1">if pad := int(f.Length) - int(len(data)); pad &gt; 0 </span><span class="cov8" title="1">{
                        sc.sendWindowUpdate(nil, pad) // conn-level
                        sc.sendWindowUpdate(st, pad)  // stream-level
                }</span>
        }
        <span class="cov8" title="1">if f.StreamEnded() </span><span class="cov8" title="1">{
                st.endStream()
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (st *stream) stopTimeoutTimer() <span class="cov8" title="1">{
        // stop readTimeoutTimer in case of some abnormal cases where
        // endStream() can not be called()
        // e.g. 1.POST request &amp;&amp; 2.bfe NOT received all body &amp;&amp; 3.stream rst by BFE
        if t := st.readTimeoutTimer; t != nil </span><span class="cov0" title="0">{
                t.Stop()
        }</span>

        <span class="cov8" title="1">if t := st.writeTimeoutTimer; t != nil </span><span class="cov0" title="0">{
                t.Stop()
        }</span>
}

// endStream closes a Request.Body's pipe. It is called when a DATA
// frame says a request body is over (or after trailers).
func (st *stream) endStream() <span class="cov8" title="1">{
        sc := st.sc
        sc.serveG.Check()

        // although finally we will stop readTimeoutTimer in closeStream()
        // we SHOULD stop readTimeoutTimer immediately here
        if t := st.readTimeoutTimer; t != nil </span><span class="cov0" title="0">{
                t.Stop()
        }</span>

        <span class="cov8" title="1">if st.declBodyBytes != -1 &amp;&amp; st.declBodyBytes != st.bodyBytes </span><span class="cov8" title="1">{
                st.body.CloseWithError(fmt.Errorf("request declared a Content-Length of %d but only wrote %d bytes",
                        st.declBodyBytes, st.bodyBytes))
        }</span> else<span class="cov8" title="1"> {
                st.body.CloseWithErrorAndCode(io.EOF, st.copyTrailersToHandlerRequest)
                st.body.CloseWithError(io.EOF)
        }</span>
        <span class="cov8" title="1">st.state = stateHalfClosedRemote</span>
}

// copyTrailersToHandlerRequest is run in the Handler's goroutine in
// its Request.Body.Read just before it gets io.EOF.
func (st *stream) copyTrailersToHandlerRequest() <span class="cov8" title="1">{
        for k, vv := range st.trailer </span><span class="cov8" title="1">{
                if _, ok := st.reqTrailer[k]; ok </span><span class="cov8" title="1">{
                        // Only copy it over it was pre-declared.
                        st.reqTrailer[k] = vv
                }</span>
        }
}

func (st *stream) defaultStreamWindow() bool <span class="cov8" title="1">{
        if st.isw == 0 || st.isw == initialWindowSize </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (sc *serverConn) processHeaders(f *MetaHeadersFrame) error <span class="cov8" title="1">{
        sc.serveG.Check()
        id := f.Header().StreamID
        if sc.inGoAway </span><span class="cov8" title="1">{
                // Ignore.
                return nil
        }</span>

        // check req rate limit
        <span class="cov8" title="1">if !acceptRequest() &amp;&amp; !sc.disableDegrade </span><span class="cov0" title="0">{
                state.H2ReqOverload.Inc(1)
                sc.goAway(ErrCodeNo)
                return nil
        }</span>

        // http://http2.github.io/http2-spec/#rfc.section.5.1.1
        // Streams initiated by a client MUST use odd-numbered stream
        // identifiers. [...] An endpoint that receives an unexpected
        // stream identifier MUST respond with a connection error
        // (Section 5.4.1) of type PROTOCOL_ERROR.
        <span class="cov8" title="1">if id%2 != 1 </span><span class="cov0" title="0">{
                return ConnectionError{ErrCodeProtocol, "client initiate Stream with even-number StreamId"}
        }</span>
        // A HEADERS frame can be used to create a new stream or
        // send a trailer for an open one. If we already have a stream
        // open, let it process its own HEADERS frame (trailers at this
        // point, if it's valid).
        <span class="cov8" title="1">st := sc.streams[f.Header().StreamID]
        if st != nil </span><span class="cov8" title="1">{
                return st.processTrailerHeaders(f)
        }</span>

        // [...] The identifier of a newly established stream MUST be
        // numerically greater than all streams that the initiating
        // endpoint has opened or reserved. [...]  An endpoint that
        // receives an unexpected stream identifier MUST respond with
        // a connection error (Section 5.4.1) of type PROTOCOL_ERROR.
        <span class="cov8" title="1">if id &lt;= sc.maxStreamID </span><span class="cov0" title="0">{
                return ConnectionError{ErrCodeProtocol, "stream ID not monotonic increment"}
        }</span>
        <span class="cov8" title="1">sc.maxStreamID = id

        st = &amp;stream{
                sc:    sc,
                id:    id,
                state: stateOpen,
                isw:   sc.srv.initialStreamRecvWindowSize(sc.rule),
        }
        if f.StreamEnded() </span><span class="cov8" title="1">{
                st.state = stateHalfClosedRemote
        }</span>
        <span class="cov8" title="1">st.cw.Init()

        st.flow.conn = &amp;sc.flow // link to conn-level counter
        st.flow.add(sc.initialWindowSize)
        st.inflow.conn = &amp;sc.inflow // link to conn-level counter
        st.inflow.add(int32(st.isw))

        sc.streams[id] = st
        if f.HasPriority() </span><span class="cov0" title="0">{
                adjustStreamPriority(sc.streams, st.id, f.Priority)
        }</span>
        <span class="cov8" title="1">sc.curOpenStreams++
        if sc.curOpenStreams == 1 </span><span class="cov8" title="1">{
                sc.setConnState(http.StateActive)
        }</span>
        <span class="cov8" title="1">if sc.curOpenStreams &gt; sc.advMaxStreams </span><span class="cov0" title="0">{
                state.H2ErrMaxStreamPerConn.Inc(1)
                // although the RFC says:
                //
                // "Endpoints MUST NOT exceed the limit set by their
                // peer. An endpoint that receives a HEADERS frame
                // that causes their advertised concurrent stream
                // limit to be exceeded MUST treat this as a stream
                // error (Section 5.4.2) of type PROTOCOL_ERROR or
                // REFUSED_STREAM."

                // we recognize this case as an attack, neither StreamError nor ConnectionError,
                // (we should send goAway first when it's a ConnectionError)
                // so we MUST close the connection immediately
                return maxStreamsError{
                        userAgent:  f.RegularValue("user-agent"),
                        streamID:   st.id,
                        maxStreams: sc.advMaxStreams,
                }
        }</span>

        <span class="cov8" title="1">rw, req, err := sc.newWriterAndRequest(st, f)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">st.reqTrailer = req.Trailer
        if st.reqTrailer != nil </span><span class="cov8" title="1">{
                st.trailer = make(http.Header)
        }</span>
        <span class="cov8" title="1">st.body = req.Body.(*RequestBody).pipe // may be nil
        st.declBodyBytes = req.ContentLength

        handler := sc.handler.ServeHTTP
        if !disableConnHeaderCheck </span><span class="cov8" title="1">{
                if err := checkValidHTTP2Request(req); err != nil </span><span class="cov8" title="1">{
                        handler = new400Handler(err)
                }</span>
        }

        <span class="cov8" title="1">go sc.runHandler(rw, req, handler)
        return nil</span>
}

func (st *stream) processTrailerHeaders(f *MetaHeadersFrame) error <span class="cov8" title="1">{
        sc := st.sc
        sc.serveG.Check()
        if st.gotTrailerHeader </span><span class="cov0" title="0">{
                return ConnectionError{ErrCodeProtocol, "duplicated Trailer"}
        }</span>
        <span class="cov8" title="1">st.gotTrailerHeader = true
        if !f.StreamEnded() </span><span class="cov0" title="0">{
                return StreamError{st.id, ErrCodeProtocol, "MetaHeadersFrame for trailer without END_STREAM flag"}
        }</span>

        <span class="cov8" title="1">if len(f.PseudoFields()) &gt; 0 </span><span class="cov0" title="0">{
                return StreamError{st.id, ErrCodeProtocol, "MetaHeadersFrame for trailer without fields"}
        }</span>
        <span class="cov8" title="1">if st.trailer != nil </span><span class="cov8" title="1">{
                for _, hf := range f.RegularFields() </span><span class="cov8" title="1">{
                        key := sc.canonicalHeader(hf.Name)
                        st.trailer[key] = append(st.trailer[key], hf.Value)
                }</span>
        }
        <span class="cov8" title="1">st.endStream()
        return nil</span>
}

func (sc *serverConn) processPriority(f *PriorityFrame) error <span class="cov0" title="0">{
        adjustStreamPriority(sc.streams, f.StreamID, f.PriorityParam)
        return nil
}</span>

func adjustStreamPriority(streams map[uint32]*stream, streamID uint32, priority PriorityParam) <span class="cov8" title="1">{
        st, ok := streams[streamID]
        if !ok </span><span class="cov0" title="0">{
                // TODO: not quite correct (this streamID might
                // already exist in the dep tree, but be closed), but
                // close enough for now.
                return
        }</span>
        <span class="cov8" title="1">st.weight = priority.Weight
        parent := streams[priority.StreamDep] // might be nil
        if parent == st </span><span class="cov8" title="1">{
                // if client tries to set this stream to be the parent of itself
                // ignore and keep going
                return
        }</span>

        // section 5.3.3: If a stream is made dependent on one of its
        // own dependencies, the formerly dependent stream is first
        // moved to be dependent on the reprioritized stream's previous
        // parent. The moved dependency retains its weight.
        <span class="cov8" title="1">for piter := parent; piter != nil; piter = piter.parent </span><span class="cov8" title="1">{
                if piter == st </span><span class="cov8" title="1">{
                        parent.parent = st.parent
                        break</span>
                }
        }
        <span class="cov8" title="1">st.parent = parent
        if priority.Exclusive &amp;&amp; (st.parent != nil || priority.StreamDep == 0) </span><span class="cov8" title="1">{
                for _, openStream := range streams </span><span class="cov8" title="1">{
                        if openStream != st &amp;&amp; openStream.parent == st.parent </span><span class="cov8" title="1">{
                                openStream.parent = st
                        }</span>
                }
        }
}

func (sc *serverConn) newWriterAndRequest(st *stream, f *MetaHeadersFrame) (*responseWriter, *http.Request, error) <span class="cov8" title="1">{
        sc.serveG.Check()

        method := f.PseudoValue("method")
        path := f.PseudoValue("path")
        scheme := f.PseudoValue("scheme")
        authority := f.PseudoValue("authority")

        isConnect := method == "CONNECT"
        if isConnect </span><span class="cov8" title="1">{
                if path != "" || scheme != "" || authority == "" </span><span class="cov8" title="1">{
                        errMsg := fmt.Sprintf("invalid request(path %s, scheme %s, authority %s)", path, scheme, authority)
                        return nil, nil, StreamError{f.StreamID, ErrCodeProtocol, errMsg}
                }</span>
        } else<span class="cov8" title="1"> if method == "" || path == "" ||
                (scheme != "https" &amp;&amp; scheme != "http") </span><span class="cov8" title="1">{
                // See 8.1.2.6 Malformed Requests and Responses:
                //
                // Malformed requests or responses that are detected
                // MUST be treated as a stream error (Section 5.4.2)
                // of type PROTOCOL_ERROR."
                //
                // 8.1.2.3 Request Pseudo-Header Fields
                // "All HTTP/2 requests MUST include exactly one valid
                // value for the :method, :scheme, and :path
                // pseudo-header fields"
                errMsg := fmt.Sprintf("invalid request(method %s, path %s, scheme %s)", method, path, scheme)
                return nil, nil, StreamError{f.StreamID, ErrCodeProtocol, errMsg}
        }</span>

        <span class="cov8" title="1">bodyOpen := !f.StreamEnded()
        if method == "HEAD" &amp;&amp; bodyOpen </span><span class="cov8" title="1">{
                // HEAD requests can't have bodies
                errMsg := "HEAD request with unexpected body"
                return nil, nil, StreamError{f.StreamID, ErrCodeProtocol, errMsg}
        }</span>
        <span class="cov8" title="1">var tlsState *tls.ConnectionState // nil if not scheme https

        if scheme == "https" </span><span class="cov8" title="1">{
                tlsState = sc.tlsState
        }</span>

        <span class="cov8" title="1">header := make(http.Header)
        for _, hf := range f.RegularFields() </span><span class="cov8" title="1">{
                header.Add(sc.canonicalHeader(hf.Name), hf.Value)
        }</span>

        <span class="cov8" title="1">if authority == "" </span><span class="cov8" title="1">{
                authority = header.Get("Host")
        }</span>
        <span class="cov8" title="1">needsContinue := header.Get("Expect") == "100-continue"
        if needsContinue </span><span class="cov8" title="1">{
                header.Del("Expect")
        }</span>
        // Merge Cookie headers into one "; "-delimited value.
        <span class="cov8" title="1">if cookies := header["Cookie"]; len(cookies) &gt; 1 </span><span class="cov8" title="1">{
                header.Set("Cookie", strings.Join(cookies, "; "))
        }</span>

        // Setup Trailers
        <span class="cov8" title="1">var trailer http.Header
        for _, v := range header["Trailer"] </span><span class="cov8" title="1">{
                for _, key := range strings.Split(v, ",") </span><span class="cov8" title="1">{
                        key = http.CanonicalHeaderKey(strings.TrimSpace(key))
                        switch key </span>{
                        case "Transfer-Encoding", "Trailer", "Content-Length":<span class="cov0" title="0"></span>
                                // Bogus. (copy of http1 rules)
                                // Ignore.
                        default:<span class="cov8" title="1">
                                if trailer == nil </span><span class="cov8" title="1">{
                                        trailer = make(http.Header)
                                }</span>
                                <span class="cov8" title="1">trailer[key] = nil</span>
                        }
                }
        }
        <span class="cov8" title="1">delete(header, "Trailer")

        body := &amp;RequestBody{
                conn:          sc,
                stream:        st,
                needsContinue: needsContinue,
        }
        var url_ *url.URL
        var requestURI string
        if isConnect </span><span class="cov8" title="1">{
                url_ = &amp;url.URL{Host: authority}
                requestURI = authority // mimic HTTP/1 server behavior
        }</span> else<span class="cov8" title="1"> {
                var err error
                url_, err = url.ParseRequestURI(path)
                if err != nil </span><span class="cov0" title="0">{
                        errMsg := fmt.Sprintf("invalid request uri: %s, %s", path, err)
                        return nil, nil, StreamError{f.StreamID, ErrCodeProtocol, errMsg}
                }</span>
                <span class="cov8" title="1">requestURI = path</span>
        }
        <span class="cov8" title="1">req := &amp;http.Request{
                Method:     method,
                URL:        url_,
                RemoteAddr: sc.remoteAddrStr,
                Header:     header,
                RequestURI: requestURI,
                Proto:      "HTTP/2.0",
                ProtoMajor: 2,
                ProtoMinor: 0,
                TLS:        tlsState,
                Host:       authority,
                Body:       body,
                Trailer:    trailer,
                State: &amp;http.RequestState{
                        SerialNumber: st.id/2 + 1,
                        StartTime:    time.Now(),
                },
        }
        if bodyOpen </span><span class="cov8" title="1">{
                if st.defaultStreamWindow() </span><span class="cov8" title="1">{
                        body.pipe = pipe.NewPipeFromBufferPool(&amp;fixBufferPool)
                }</span> else<span class="cov0" title="0"> {
                        body.pipe = pipe.NewPipeWithSize(st.isw)
                }</span>
                <span class="cov8" title="1">if vv, ok := header["Content-Length"]; ok </span><span class="cov8" title="1">{
                        req.ContentLength, _ = strconv.ParseInt(vv[0], 10, 64)
                }</span> else<span class="cov8" title="1"> {
                        req.ContentLength = -1
                }</span>
        }

        <span class="cov8" title="1">rws := responseWriterStatePool.Get().(*responseWriterState)
        bwSave := rws.bw
        *rws = responseWriterState{} // zero all the fields
        rws.conn = sc
        rws.bw = bwSave
        rws.bw.Reset(chunkWriter{rws})
        rws.stream = st
        rws.req = req
        rws.body = body

        rw := &amp;responseWriter{rws: rws}
        return rw, req, nil</span>
}

func (sc *serverConn) getRequestBodyBuf() []byte <span class="cov0" title="0">{
        sc.serveG.Check()
        if buf := sc.freeRequestBodyBuf; buf != nil </span><span class="cov0" title="0">{
                sc.freeRequestBodyBuf = nil
                return buf
        }</span>
        <span class="cov0" title="0">return make([]byte, initialWindowSize)</span>
}

// Run on its own goroutine.
func (sc *serverConn) runHandler(rw *responseWriter, req *http.Request, handler func(http.ResponseWriter, *http.Request)) <span class="cov8" title="1">{
        didPanic := true
        defer func() </span><span class="cov8" title="1">{
                if didPanic </span><span class="cov0" title="0">{
                        e := recover()
                        sc.writeFrameFromHandler(frameWriteMsg{
                                write:  handlerPanicRST{rw.rws.stream.id},
                                stream: rw.rws.stream,
                        })
                        log.Logger.Warn("http2: panic serving %v: %v\n%s", sc.conn.RemoteAddr(), e, gotrack.CurrentStackTrace(0))
                        state.H2PanicStream.Inc(1)
                        return
                }</span>
                <span class="cov8" title="1">rw.handlerDone()</span>
        }()
        <span class="cov8" title="1">handler(rw, req)
        didPanic = false</span>
}

// called from handler goroutines.
// request for closing server connection
func (sc *serverConn) Close() <span class="cov0" title="0">{
        sc.serveG.CheckNotOn() // NOT on
        sc.writeFrameFromHandler(frameWriteMsg{write: closeFrameWriter{}})
}</span>

// called from handler goroutines.
// h may be nil.
func (sc *serverConn) writeHeaders(st *stream, headerData *writeResHeaders) error <span class="cov8" title="1">{
        sc.serveG.CheckNotOn() // NOT on
        var errc chan error
        if headerData.h != nil </span><span class="cov8" title="1">{
                // If there's a header map (which we don't own), so we have to block on
                // waiting for this frame to be written, so an http.Flush mid-handler
                // writes out the correct value of keys, before a handler later potentially
                // mutates it.
                errc = make(chan error, 1)
        }</span>
        <span class="cov8" title="1">if err := sc.writeFrameFromHandler(frameWriteMsg{
                write:  headerData,
                stream: st,
                done:   errc,
        }); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if errc != nil </span><span class="cov8" title="1">{
                select </span>{
                case err := &lt;-errc:<span class="cov8" title="1">
                        return err</span>
                case &lt;-sc.doneServing:<span class="cov0" title="0">
                        return errClientDisconnected</span>
                case &lt;-st.cw:<span class="cov8" title="1">
                        return errStreamClosed</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

// called from handler goroutines.
func (sc *serverConn) write100ContinueHeaders(st *stream) <span class="cov8" title="1">{
        sc.writeFrameFromHandler(frameWriteMsg{
                write:  write100ContinueHeadersFrame{st.id},
                stream: st,
        })
}</span>

// A bodyReadMsg tells the server loop that the http.Handler read n
// bytes of the DATA from the client on the given stream.
type bodyReadMsg struct {
        st *stream
        n  int
}

// called from handler goroutines.
// Notes that the handler for the given stream ID read n bytes of its body
// and schedules flow control tokens to be sent.
func (sc *serverConn) noteBodyReadFromHandler(st *stream, n int) <span class="cov8" title="1">{
        sc.serveG.CheckNotOn() // NOT on
        select </span>{
        case sc.bodyReadCh &lt;- bodyReadMsg{st, n}:<span class="cov8" title="1"></span>
        case &lt;-sc.doneServing:<span class="cov0" title="0"></span>
        }
}

func (sc *serverConn) noteBodyRead(st *stream, n int) <span class="cov8" title="1">{
        sc.serveG.Check()
        sc.sendWindowUpdate(nil, n) // conn-level
        if st.state != stateHalfClosedRemote &amp;&amp; st.state != stateClosed </span><span class="cov8" title="1">{
                // Don't send this WINDOW_UPDATE if the stream is closed
                // remotely.
                sc.sendWindowUpdate(st, n)
        }</span>
}

// st may be nil for conn-level
func (sc *serverConn) sendWindowUpdate(st *stream, n int) <span class="cov8" title="1">{
        sc.serveG.Check()
        // "The legal range for the increment to the flow control
        // window is 1 to 2^31-1 (2,147,483,647) octets."
        // A Go Read call on 64-bit machines could in theory read
        // a larger Read than this. Very unlikely, but we handle it here
        // rather than elsewhere for now.
        const maxUint31 = 1&lt;&lt;31 - 1
        for n &gt;= maxUint31 </span><span class="cov0" title="0">{
                sc.sendWindowUpdate32(st, maxUint31)
                n -= maxUint31
        }</span>
        <span class="cov8" title="1">sc.sendWindowUpdate32(st, int32(n))</span>
}

// st may be nil for conn-level
func (sc *serverConn) sendWindowUpdate32(st *stream, n int32) <span class="cov8" title="1">{
        sc.serveG.Check()
        if n == 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if n &lt; 0 </span><span class="cov0" title="0">{
                panic("negative update")</span>
        }
        <span class="cov8" title="1">var streamID uint32
        if st != nil </span><span class="cov8" title="1">{
                streamID = st.id
        }</span>
        <span class="cov8" title="1">log.Logger.Debug("http2: scheule write window update frame, stream %v, inc %v", streamID, n)
        sc.writeFrame(frameWriteMsg{
                write:  writeWindowUpdate{streamID: streamID, n: uint32(n)},
                stream: st,
        })
        var ok bool
        if st == nil </span><span class="cov8" title="1">{
                ok = sc.inflow.add(n)
        }</span> else<span class="cov8" title="1"> {
                ok = st.inflow.add(n)
        }</span>
        <span class="cov8" title="1">if !ok </span><span class="cov0" title="0">{
                panic("internal error; sent too many window updates without decrements?")</span>
        }
}

type RequestBody struct {
        stream        *stream
        conn          *serverConn
        closed        bool
        pipe          *pipe.Pipe // non-nil if we have a HTTP entity message body
        needsContinue bool       // need to send a 100-continue
}

func (b *RequestBody) Close() error <span class="cov8" title="1">{
        if b.pipe != nil </span><span class="cov8" title="1">{
                b.pipe.CloseWithError(errClosedBody)
        }</span>
        <span class="cov8" title="1">b.closed = true
        return nil</span>
}

func (b *RequestBody) Read(p []byte) (n int, err error) <span class="cov8" title="1">{
        if b.needsContinue </span><span class="cov8" title="1">{
                b.needsContinue = false
                b.conn.write100ContinueHeaders(b.stream)
        }</span>
        <span class="cov8" title="1">if b.pipe == nil </span><span class="cov8" title="1">{
                return 0, io.EOF
        }</span>
        <span class="cov8" title="1">n, err = b.pipe.Read(p)
        if n &gt; 0 </span><span class="cov8" title="1">{
                b.conn.noteBodyReadFromHandler(b.stream, n)
        }</span>
        <span class="cov8" title="1">return</span>
}

// responseWriter is the http.ResponseWriter implementation.  It's
// intentionally small (1 pointer wide) to minimize garbage.  The
// responseWriterState pointer inside is zeroed at the end of a
// request (in handlerDone) and calls on the responseWriter thereafter
// simply crash (caller's mistake), but the much larger responseWriterState
// and buffers are reused between multiple requests.
type responseWriter struct {
        rws *responseWriterState
}

// Optional http.ResponseWriter interfaces implemented.
var (
        _ http.CloseNotifier = (*responseWriter)(nil)
        _ http.Flusher       = (*responseWriter)(nil)
        _ stringWriter       = (*responseWriter)(nil)
)

type responseWriterState struct {
        // immutable within a request:
        stream *stream
        req    *http.Request
        body   *RequestBody // to close at end of request, if DATA frames didn't
        conn   *serverConn

        // TODO: adjust buffer writing sizes based on server config, frame size updates from peer, etc
        bw *bufio.Writer // writing to a chunkWriter{this *responseWriterState}

        // mutated by http.Handler goroutine:
        handlerHeader http.Header // nil until called
        snapHeader    http.Header // snapshot of handlerHeader at WriteHeader time
        trailers      []string    // set in writeChunk
        status        int         // status code passed to WriteHeader
        wroteHeader   bool        // WriteHeader called (explicitly or implicitly). Not necessarily sent to user yet.
        sentHeader    bool        // have we sent the header frame?
        handlerDone   bool        // handler has finished

        sentContentLen int64 // non-zero if handler set a Content-Length header
        wroteBytes     int64

        closeNotifierMu sync.Mutex // guards closeNotifierCh
        closeNotifierCh chan bool  // nil until first used
}

type chunkWriter struct{ rws *responseWriterState }

func (cw chunkWriter) Write(p []byte) (n int, err error) <span class="cov8" title="1">{ return cw.rws.writeChunk(p) }</span>

// reset all fields of responseWriterState
func (rws *responseWriterState) Reset() <span class="cov8" title="1">{
        // reset buffer writer
        bwSave := rws.bw
        bwSave.Reset(nil)

        // zero all the fields except bw
        *rws = responseWriterState{}
        rws.bw = bwSave
}</span>

func (rws *responseWriterState) hasTrailers() bool <span class="cov8" title="1">{ return len(rws.trailers) != 0 }</span>

// declareTrailer is called for each Trailer header when the
// response header is written. It notes that a header will need to be
// written in the trailers at the end of the response.
func (rws *responseWriterState) declareTrailer(k string) <span class="cov0" title="0">{
        k = http.CanonicalHeaderKey(k)
        switch k </span>{
        case "Transfer-Encoding", "Content-Length", "Trailer":<span class="cov0" title="0">
                // Forbidden by RFC 2616 14.40.
                return</span>
        }
        <span class="cov0" title="0">if !strSliceContains(rws.trailers, k) </span><span class="cov0" title="0">{
                rws.trailers = append(rws.trailers, k)
        }</span>
}

// writeChunk writes chunks from the bufio.Writer. But because
// bufio.Writer may bypass its chunking, sometimes p may be
// arbitrarily large.
//
// writeChunk is also responsible (on the first chunk) for sending the
// HEADER response.
func (rws *responseWriterState) writeChunk(p []byte) (n int, err error) <span class="cov8" title="1">{
        if !rws.wroteHeader </span><span class="cov8" title="1">{
                rws.writeHeader(200)
        }</span>

        <span class="cov8" title="1">isHeadResp := rws.req.Method == "HEAD"
        if !rws.sentHeader </span><span class="cov8" title="1">{
                rws.sentHeader = true
                var ctype, clen string
                if clen = rws.snapHeader.Get("Content-Length"); clen != "" </span><span class="cov0" title="0">{
                        rws.snapHeader.Del("Content-Length")
                        clen64, err := strconv.ParseInt(clen, 10, 64)
                        if err == nil &amp;&amp; clen64 &gt;= 0 </span><span class="cov0" title="0">{
                                rws.sentContentLen = clen64
                        }</span> else<span class="cov0" title="0"> {
                                clen = ""
                        }</span>
                }
                <span class="cov8" title="1">if clen == "" &amp;&amp; rws.handlerDone &amp;&amp; bodyAllowedForStatus(rws.status) &amp;&amp; (len(p) &gt; 0 || !isHeadResp) </span><span class="cov8" title="1">{
                        clen = strconv.Itoa(len(p))
                }</span>
                <span class="cov8" title="1">_, hasContentType := rws.snapHeader["Content-Type"]
                if !hasContentType &amp;&amp; bodyAllowedForStatus(rws.status) </span><span class="cov8" title="1">{
                        ctype = http.DetectContentType(p)
                }</span>
                <span class="cov8" title="1">var date string
                if _, ok := rws.snapHeader["Date"]; !ok </span><span class="cov8" title="1">{
                        // TODO(bradfitz): be faster here, like net/http? measure.
                        date = time.Now().UTC().Format(http.TimeFormat)
                }</span>

                <span class="cov8" title="1">for _, v := range rws.snapHeader["Trailer"] </span><span class="cov0" title="0">{
                        foreachHeaderElement(v, rws.declareTrailer)
                }</span>

                <span class="cov8" title="1">endStream := (rws.handlerDone &amp;&amp; !rws.hasTrailers() &amp;&amp; len(p) == 0) || isHeadResp
                err = rws.conn.writeHeaders(rws.stream, &amp;writeResHeaders{
                        streamID:      rws.stream.id,
                        httpResCode:   rws.status,
                        h:             rws.snapHeader,
                        endStream:     endStream,
                        contentType:   ctype,
                        contentLength: clen,
                        date:          date,
                })
                if err != nil </span><span class="cov8" title="1">{
                        return 0, err
                }</span>
                <span class="cov8" title="1">if endStream </span><span class="cov8" title="1">{
                        return 0, nil
                }</span>
        }
        <span class="cov8" title="1">if isHeadResp </span><span class="cov0" title="0">{
                return len(p), nil
        }</span>
        <span class="cov8" title="1">if len(p) == 0 &amp;&amp; !rws.handlerDone </span><span class="cov8" title="1">{
                return 0, nil
        }</span>

        <span class="cov8" title="1">if rws.handlerDone </span><span class="cov8" title="1">{
                rws.promoteUndeclaredTrailers()
        }</span>

        <span class="cov8" title="1">endStream := rws.handlerDone &amp;&amp; !rws.hasTrailers()
        if len(p) &gt; 0 || endStream </span><span class="cov8" title="1">{
                // only send a 0 byte DATA frame if we're ending the stream.
                if err := rws.conn.writeDataFromHandler(rws.stream, p, endStream); err != nil </span><span class="cov8" title="1">{
                        return 0, err
                }</span>
        }

        <span class="cov8" title="1">if rws.handlerDone &amp;&amp; rws.hasTrailers() </span><span class="cov0" title="0">{
                err = rws.conn.writeHeaders(rws.stream, &amp;writeResHeaders{
                        streamID:  rws.stream.id,
                        h:         rws.handlerHeader,
                        trailers:  rws.trailers,
                        endStream: true,
                })
                return len(p), err
        }</span>
        <span class="cov8" title="1">return len(p), nil</span>
}

// TrailerPrefix is a magic prefix for ResponseWriter.Header map keys
// that, if present, signals that the map entry is actually for
// the response trailers, and not the response headers. The prefix
// is stripped after the ServeHTTP call finishes and the values are
// sent in the trailers.
//
// This mechanism is intended only for trailers that are not known
// prior to the headers being written. If the set of trailers is fixed
// or known before the header is written, the normal Go trailers mechanism
// is preferred:
//    https://golang.org/pkg/net/http/#ResponseWriter
//    https://golang.org/pkg/net/http/#example_ResponseWriter_trailers
const TrailerPrefix = "Trailer:"

// promoteUndeclaredTrailers permits http.Handlers to set trailers
// after the header has already been flushed. Because the Go
// ResponseWriter interface has no way to set Trailers (only the
// Header), and because we didn't want to expand the ResponseWriter
// interface, and because nobody used trailers, and because RFC 2616
// says you SHOULD (but not must) predeclare any trailers in the
// header, the official ResponseWriter rules said trailers in Go must
// be predeclared, and then we reuse the same ResponseWriter.Header()
// map to mean both Headers and Trailers.  When it's time to write the
// Trailers, we pick out the fields of Headers that were declared as
// trailers. That worked for a while, until we found the first major
// user of Trailers in the wild: gRPC (using them only over http2),
// and gRPC libraries permit setting trailers mid-stream without
// predeclaring them. So: change of plans. We still permit the old
// way, but we also permit this hack: if a Header() key begins with
// "Trailer:", the suffix of that key is a Trailer. Because ':' is an
// invalid token byte anyway, there is no ambiguity. (And it's already
// filtered out) It's mildly hacky, but not terrible.
//
// This method runs after the Handler is done and promotes any Header
// fields to be trailers.
func (rws *responseWriterState) promoteUndeclaredTrailers() <span class="cov8" title="1">{
        for k, vv := range rws.handlerHeader </span><span class="cov8" title="1">{
                if !strings.HasPrefix(k, TrailerPrefix) </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov0" title="0">trailerKey := strings.TrimPrefix(k, TrailerPrefix)
                rws.declareTrailer(trailerKey)
                rws.handlerHeader[http.CanonicalHeaderKey(trailerKey)] = vv</span>
        }

        <span class="cov8" title="1">if len(rws.trailers) &gt; 1 </span><span class="cov0" title="0">{
                sorter := sorterPool.Get().(*sorter)
                sorter.SortStrings(rws.trailers)
                sorterPool.Put(sorter)
        }</span>
}

func (w *responseWriter) Flush() error <span class="cov8" title="1">{
        rws := w.rws
        if rws == nil </span><span class="cov0" title="0">{
                panic("Header called after Handler finished")</span>
        }
        <span class="cov8" title="1">if rws.bw.Buffered() &gt; 0 </span><span class="cov8" title="1">{
                if err := rws.bw.Flush(); err != nil </span><span class="cov8" title="1">{
                        // Ignore the error. The frame writer already knows.
                        return nil
                }</span>
        } else<span class="cov8" title="1"> {
                // The bufio.Writer won't call chunkWriter.Write
                // (writeChunk with zero bytes, so we have to do it
                // ourselves to force the HTTP response header and/or
                // final DATA frame (with END_STREAM) to be sent.
                rws.writeChunk(nil)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (w *responseWriter) CloseNotify() &lt;-chan bool <span class="cov8" title="1">{
        rws := w.rws
        if rws == nil </span><span class="cov0" title="0">{
                panic("CloseNotify called after Handler finished")</span>
        }
        <span class="cov8" title="1">rws.closeNotifierMu.Lock()
        ch := rws.closeNotifierCh
        if ch == nil </span><span class="cov8" title="1">{
                ch = make(chan bool, 1)
                rws.closeNotifierCh = ch
                cw := rws.stream.cw
                go func() </span><span class="cov8" title="1">{
                        cw.Wait() // wait for close
                        ch &lt;- true
                }</span>()
        }
        <span class="cov8" title="1">rws.closeNotifierMu.Unlock()
        return ch</span>
}

func (w *responseWriter) Header() http.Header <span class="cov8" title="1">{
        rws := w.rws
        if rws == nil </span><span class="cov0" title="0">{
                panic("Header called after Handler finished")</span>
        }
        <span class="cov8" title="1">if rws.handlerHeader == nil </span><span class="cov8" title="1">{
                rws.handlerHeader = make(http.Header)
        }</span>
        <span class="cov8" title="1">return rws.handlerHeader</span>
}

func (w *responseWriter) WriteHeader(code int) <span class="cov8" title="1">{
        rws := w.rws
        if rws == nil </span><span class="cov0" title="0">{
                panic("WriteHeader called after Handler finished")</span>
        }
        <span class="cov8" title="1">rws.writeHeader(code)</span>
}

func (rws *responseWriterState) writeHeader(code int) <span class="cov8" title="1">{
        if !rws.wroteHeader </span><span class="cov8" title="1">{
                rws.wroteHeader = true
                rws.status = code
                if len(rws.handlerHeader) &gt; 0 </span><span class="cov8" title="1">{
                        rws.snapHeader = cloneHeader(rws.handlerHeader)
                }</span>
        }
}

// clone header excluding HopHeaders
func cloneHeader(h http.Header) http.Header <span class="cov8" title="1">{
        h2 := make(http.Header, len(h))
        for k, vv := range h </span><span class="cov8" title="1">{
                // ignore connection specific headers. For more information,
                // see RFC 7540 section 8.1.2.2
                if HopHeaders[k] </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">vv2 := make([]string, len(vv))
                copy(vv2, vv)
                h2[k] = vv2</span>
        }
        <span class="cov8" title="1">return h2</span>
}

// The Life Of A Write is like this:
//
// * Handler calls w.Write or w.WriteString -&gt;
// * -&gt; rws.bw (*bufio.Writer) -&gt;
// * (Handler might call Flush)
// * -&gt; chunkWriter{rws}
// * -&gt; responseWriterState.writeChunk(p []byte)
// * -&gt; responseWriterState.writeChunk (most of the magic; see comment there)
func (w *responseWriter) Write(p []byte) (n int, err error) <span class="cov8" title="1">{
        return w.write(len(p), p, "")
}</span>

func (w *responseWriter) WriteString(s string) (n int, err error) <span class="cov8" title="1">{
        return w.write(len(s), nil, s)
}</span>

// either dataB or dataS is non-zero.
func (w *responseWriter) write(lenData int, dataB []byte, dataS string) (n int, err error) <span class="cov8" title="1">{
        rws := w.rws
        if rws == nil </span><span class="cov0" title="0">{
                panic("Write called after Handler finished")</span>
        }
        <span class="cov8" title="1">if !rws.wroteHeader </span><span class="cov8" title="1">{
                w.WriteHeader(200)
        }</span>
        <span class="cov8" title="1">if !bodyAllowedForStatus(rws.status) </span><span class="cov0" title="0">{
                return 0, http.ErrBodyNotAllowed
        }</span>
        <span class="cov8" title="1">rws.wroteBytes += int64(len(dataB)) + int64(len(dataS)) // only one can be set
        if rws.sentContentLen != 0 &amp;&amp; rws.wroteBytes &gt; rws.sentContentLen </span><span class="cov0" title="0">{
                // TODO: send a RST_STREAM
                return 0, errors.New("http2: handler wrote more than declared Content-Length")
        }</span>

        <span class="cov8" title="1">if dataB != nil </span><span class="cov8" title="1">{
                return rws.bw.Write(dataB)
        }</span>
        <span class="cov8" title="1">return rws.bw.WriteString(dataS)</span>
}

func (w *responseWriter) handlerDone() <span class="cov8" title="1">{
        rws := w.rws
        rws.handlerDone = true
        w.Flush()
        w.rws = nil
        rws.Reset()
        responseWriterStatePool.Put(rws)
}</span>

// foreachHeaderElement splits v according to the "#rule" construction
// in RFC 2616 section 2.1 and calls fn for each non-empty element.
func foreachHeaderElement(v string, fn func(string)) <span class="cov0" title="0">{
        v = textproto.TrimString(v)
        if v == "" </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if !strings.Contains(v, ",") </span><span class="cov0" title="0">{
                fn(v)
                return
        }</span>
        <span class="cov0" title="0">for _, f := range strings.Split(v, ",") </span><span class="cov0" title="0">{
                if f = textproto.TrimString(f); f != "" </span><span class="cov0" title="0">{
                        fn(f)
                }</span>
        }
}

// From http://httpwg.org/specs/rfc7540.html#rfc.section.8.1.2.2
var connHeaders = []string{
        "Connection",
        "Keep-Alive",
        "Proxy-Connection",
        "Transfer-Encoding",
        "Upgrade",
}

// disable checkValidHTTP2Request or not
var disableConnHeaderCheck bool = false

func DisableConnHeaderCheck() <span class="cov0" title="0">{
        disableConnHeaderCheck = true
}</span>

// checkValidHTTP2Request checks whether req is a valid HTTP/2 request,
// per RFC 7540 Section 8.1.2.2.
// The returned error is reported to users.
func checkValidHTTP2Request(req *http.Request) error <span class="cov8" title="1">{
        for _, h := range connHeaders </span><span class="cov8" title="1">{
                if _, ok := req.Header[h]; ok </span><span class="cov8" title="1">{
                        return fmt.Errorf("request header %q is not valid in HTTP/2", h)
                }</span>
        }
        <span class="cov8" title="1">te := req.Header["Te"]
        if len(te) &gt; 0 &amp;&amp; (len(te) &gt; 1 || (te[0] != "trailers" &amp;&amp; te[0] != "")) </span><span class="cov8" title="1">{
                return errors.New(`request header "TE" may only be "trailers" in HTTP/2`)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func new400Handler(err error) http.HandlerFunc <span class="cov8" title="1">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                http.Error(w, err.Error(), http.StatusBadRequest)
        }</span>
}
</pre>
		
		<pre class="file" id="file63" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package bfe_http2

import (
        "github.com/baidu/go-lib/web-monitor/metrics"
)

type Http2State struct {
        H2TimeoutPreface                   *metrics.Counter
        H2TimeoutSetting                   *metrics.Counter
        H2TimeoutConn                      *metrics.Counter
        H2TimeoutReadStream                *metrics.Counter
        H2TimeoutWriteStream               *metrics.Counter
        H2ErrGotReset                      *metrics.Counter
        H2ErrMaxStreamPerConn              *metrics.Counter
        H2ErrMaxHeaderListSize             *metrics.Counter
        H2ErrMaxHeaderUriSize              *metrics.Counter
        H2PanicConn                        *metrics.Counter
        H2PanicStream                      *metrics.Counter
        H2ReqHeaderOriginalSize            *metrics.Counter
        H2ReqHeaderCompressSize            *metrics.Counter
        H2ResHeaderOriginalSize            *metrics.Counter
        H2ResHeaderCompressSize            *metrics.Counter
        H2ConnOverload                     *metrics.Counter
        H2ReqOverload                      *metrics.Counter
        H2ConnExceedMaxQueuedControlFrames *metrics.Counter
}

var state Http2State

func GetHttp2State() *Http2State <span class="cov0" title="0">{
        return &amp;state
}</span>
</pre>
		
		<pre class="file" id="file64" style="display: none">// Copyright (c) 2019 Baidu, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package bfe_http2

import (
        "github.com/bfenetworks/bfe/bfe_http"
        "golang.org/x/net/http2"
        "net/http"
)

// Transport is a Wrapper class for http2.Transport
// Why this needs?
// BFE customizes http.Request &amp;&amp; http.Response as bfe_http.Request &amp;&amp; bfe_http.Response,
// cannot use http2.Transport.RoundTrip directly
type Transport struct {
        T *http2.Transport
}

// RoundTrip is a wrapper function for http2.Transport.RoundTrip
func (t *Transport) RoundTrip(r *bfe_http.Request) (*bfe_http.Response, error) <span class="cov0" title="0">{
        req := http.Request{
                Method:           r.Method,
                URL:              r.URL,
                Proto:            r.Proto,
                ProtoMajor:       r.ProtoMajor,
                ProtoMinor:       r.ProtoMinor,
                Header:           http.Header{},
                Body:             r.Body,
                ContentLength:    r.ContentLength,
                TransferEncoding: r.TransferEncoding,
                Close:            r.Close,
                Host:             r.Host,
                Form:             r.Form,
                PostForm:         r.PostForm,
                MultipartForm:    r.MultipartForm,
                Trailer:          http.Header{},
                RemoteAddr:       r.RemoteAddr,
                RequestURI:       r.RequestURI,
        }
        for k, v := range r.Header </span><span class="cov0" title="0">{
                req.Header[k] = v
        }</span>
        <span class="cov0" title="0">for k, v := range r.Trailer </span><span class="cov0" title="0">{
                req.Trailer[k] = v
        }</span>
        <span class="cov0" title="0">res, err := t.T.RoundTrip(&amp;req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">resp := bfe_http.Response{
                Status:           res.Status,
                StatusCode:       res.StatusCode,
                Proto:            res.Proto,
                ProtoMajor:       res.ProtoMajor,
                ProtoMinor:       res.ProtoMinor,
                Header:           bfe_http.Header{},
                Body:             res.Body,
                ContentLength:    res.ContentLength,
                TransferEncoding: res.TransferEncoding,
                Close:            res.Close,
                Request:          r,
                // trailer header is set after body closed, use pointer to acquire trailer header outside
                H2Trailer: &amp;res.Trailer,
        }
        for k, v := range res.Header </span><span class="cov0" title="0">{
                resp.Header[k] = v
        }</span>
        <span class="cov0" title="0">return &amp;resp, nil</span>
}
</pre>
		
		<pre class="file" id="file65" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Copyright 2014 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package bfe_http2

import (
        "bytes"
        "fmt"
        "log"
        "time"
)

import (
        http "github.com/bfenetworks/bfe/bfe_http"
        "github.com/bfenetworks/bfe/bfe_http2/hpack"
)

// writeFramer is implemented by any type that is used to write frames.
type writeFramer interface {
        writeFrame(writeContext) error
}

// writeContext is the interface needed by the various frame writer
// types below. All the writeFrame methods below are scheduled via the
// frame writing scheduler (see writeScheduler in writesched.go).
//
// This interface is implemented by *serverConn.
//
// TODO: decide whether to a) use this in the client code (which didn't
// end up using this yet, because it has a simpler design, not
// currently implementing priorities), or b) delete this and
// make the server code a bit more concrete.
type writeContext interface {
        Framer() *Framer
        Flush() error
        CloseConn() error
        // HeaderEncoder returns an HPACK encoder that writes to the
        // returned buffer.
        HeaderEncoder() (*hpack.Encoder, *bytes.Buffer)
}

// endsStream reports whether the given frame writer w will locally
// close the stream.
func endsStream(w writeFramer) bool <span class="cov8" title="1">{
        switch v := w.(type) </span>{
        case *writeData:<span class="cov8" title="1">
                return v.endStream</span>
        case *writeResHeaders:<span class="cov8" title="1">
                return v.endStream</span>
        case nil:<span class="cov0" title="0">
                // This can only happen if the caller reuses w after it's
                // been intentionally nil'ed out to prevent use. Keep this
                // here to catch future refactoring breaking it.
                panic("endsStream called on nil writeFramer")</span>
        }
        <span class="cov8" title="1">return false</span>
}

type flushFrameWriter struct{}

func (flushFrameWriter) writeFrame(ctx writeContext) error <span class="cov8" title="1">{
        return ctx.Flush()
}</span>

type closeFrameWriter struct{}

func (closeFrameWriter) writeFrame(ctx writeContext) error <span class="cov0" title="0">{
        return ctx.CloseConn()
}</span>

type writeSettings []Setting

func (s writeSettings) writeFrame(ctx writeContext) error <span class="cov8" title="1">{
        return ctx.Framer().WriteSettings([]Setting(s)...)
}</span>

type writeGoAway struct {
        maxStreamID uint32
        code        ErrCode
}

func (p *writeGoAway) writeFrame(ctx writeContext) error <span class="cov8" title="1">{
        err := ctx.Framer().WriteGoAway(p.maxStreamID, p.code, nil)
        if p.code != 0 </span><span class="cov8" title="1">{
                ctx.Flush() // ignore error: we're hanging up on them anyway
                time.Sleep(50 * time.Millisecond)
                ctx.CloseConn()
        }</span>
        <span class="cov8" title="1">return err</span>
}

type writeData struct {
        streamID  uint32
        p         []byte
        endStream bool
}

func (w *writeData) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("writeData(stream=%d, p=%d, endStream=%v)", w.streamID, len(w.p), w.endStream)
}</span>

func (w *writeData) writeFrame(ctx writeContext) error <span class="cov8" title="1">{
        return ctx.Framer().WriteData(w.streamID, w.endStream, w.p)
}</span>

// handlerPanicRST is the message sent from handler goroutines when
// the handler panics.
type handlerPanicRST struct {
        StreamID uint32
}

func (hp handlerPanicRST) writeFrame(ctx writeContext) error <span class="cov0" title="0">{
        return ctx.Framer().WriteRSTStream(hp.StreamID, ErrCodeInternal)
}</span>

func (se StreamError) writeFrame(ctx writeContext) error <span class="cov8" title="1">{
        return ctx.Framer().WriteRSTStream(se.StreamID, se.Code)
}</span>

type writePingAck struct{ pf *PingFrame }

func (w writePingAck) writeFrame(ctx writeContext) error <span class="cov8" title="1">{
        return ctx.Framer().WritePing(true, w.pf.Data)
}</span>

type writeSettingsAck struct{}

func (writeSettingsAck) writeFrame(ctx writeContext) error <span class="cov8" title="1">{
        return ctx.Framer().WriteSettingsAck()
}</span>

// writeResHeaders is a request to write a HEADERS and 0+ CONTINUATION frames
// for HTTP response headers or trailers from a server handler.
type writeResHeaders struct {
        streamID    uint32
        httpResCode int         // 0 means no ":status" line
        h           http.Header // may be nil
        trailers    []string    // if non-nil, which keys of h to write. nil means all.
        endStream   bool

        date          string
        contentType   string
        contentLength string
}

func encKV(enc *hpack.Encoder, k, v string) int <span class="cov8" title="1">{
        if VerboseLogs </span><span class="cov0" title="0">{
                log.Printf("http2: server encoding header %q = %q", k, v)
        }</span>
        <span class="cov8" title="1">enc.WriteField(hpack.HeaderField{Name: k, Value: v})
        return len(k) + len(v)</span> // size of original header field
}

func (w *writeResHeaders) writeFrame(ctx writeContext) error <span class="cov8" title="1">{
        headerSize := 0 // original header size
        enc, buf := ctx.HeaderEncoder()
        buf.Reset()

        if w.httpResCode != 0 </span><span class="cov8" title="1">{
                encKV(enc, ":status", httpCodeString(w.httpResCode))
        }</span>

        <span class="cov8" title="1">headerSize += encodeHeaders(enc, w.h, w.trailers)

        if w.contentType != "" </span><span class="cov8" title="1">{
                headerSize += encKV(enc, "content-type", w.contentType)
        }</span>
        <span class="cov8" title="1">if w.contentLength != "" </span><span class="cov8" title="1">{
                headerSize += encKV(enc, "content-length", w.contentLength)
        }</span>
        <span class="cov8" title="1">if w.date != "" </span><span class="cov8" title="1">{
                headerSize += encKV(enc, "date", w.date)
        }</span>

        <span class="cov8" title="1">headerBlock := buf.Bytes()
        if len(headerBlock) == 0 &amp;&amp; w.trailers == nil </span><span class="cov0" title="0">{
                panic("unexpected empty hpack")</span>
        }

        <span class="cov8" title="1">state.H2ResHeaderOriginalSize.Inc(uint(headerSize))
        state.H2ResHeaderCompressSize.Inc(uint(len(headerBlock)))

        // For now we're lazy and just pick the minimum MAX_FRAME_SIZE
        // that all peers must support (16KB). Later we could care
        // more and send larger frames if the peer advertised it, but
        // there's little point. Most headers are small anyway (so we
        // generally won't have CONTINUATION frames), and extra frames
        // only waste 9 bytes anyway.
        const maxFrameSize = 16384

        first := true
        for len(headerBlock) &gt; 0 </span><span class="cov8" title="1">{
                frag := headerBlock
                if len(frag) &gt; maxFrameSize </span><span class="cov8" title="1">{
                        frag = frag[:maxFrameSize]
                }</span>
                <span class="cov8" title="1">headerBlock = headerBlock[len(frag):]
                endHeaders := len(headerBlock) == 0
                var err error
                if first </span><span class="cov8" title="1">{
                        first = false
                        err = ctx.Framer().WriteHeaders(HeadersFrameParam{
                                StreamID:      w.streamID,
                                BlockFragment: frag,
                                EndStream:     w.endStream,
                                EndHeaders:    endHeaders,
                        })
                }</span> else<span class="cov8" title="1"> {
                        err = ctx.Framer().WriteContinuation(w.streamID, endHeaders, frag)
                }</span>
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

type write100ContinueHeadersFrame struct {
        streamID uint32
}

func (w write100ContinueHeadersFrame) writeFrame(ctx writeContext) error <span class="cov8" title="1">{
        enc, buf := ctx.HeaderEncoder()
        buf.Reset()
        encKV(enc, ":status", "100")
        return ctx.Framer().WriteHeaders(HeadersFrameParam{
                StreamID:      w.streamID,
                BlockFragment: buf.Bytes(),
                EndStream:     false,
                EndHeaders:    true,
        })
}</span>

type writeWindowUpdate struct {
        streamID uint32 // or 0 for conn-level
        n        uint32
}

func (wu writeWindowUpdate) writeFrame(ctx writeContext) error <span class="cov8" title="1">{
        return ctx.Framer().WriteWindowUpdate(wu.streamID, wu.n)
}</span>

func (wu *writeWindowUpdate) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("writeWindowUpdate(stream=%d, n=%d)", wu.streamID, wu.n)
}</span>

func encodeHeaders(enc *hpack.Encoder, h http.Header, keys []string) int <span class="cov8" title="1">{
        headerSize := 0 // original header size
        if keys == nil </span><span class="cov8" title="1">{
                sorter := sorterPool.Get().(*sorter)
                // Using defer here, since the returned keys from the
                // sorter.Keys method is only valid until the sorter
                // is returned:
                defer sorterPool.Put(sorter)
                keys = sorter.Keys(h)
        }</span>
        <span class="cov8" title="1">for _, k := range keys </span><span class="cov8" title="1">{
                vv := h[k]
                k = lowerHeader(k)
                if !validHeaderFieldName(k) </span><span class="cov8" title="1">{
                        // TODO: return an error? golang.org/issue/14048
                        // For now just omit it.
                        continue</span>
                }
                <span class="cov8" title="1">isTE := k == "transfer-encoding"
                for _, v := range vv </span><span class="cov8" title="1">{
                        if !validHeaderFieldValue(v) </span><span class="cov8" title="1">{
                                // TODO: return an error? golang.org/issue/14048
                                // For now just omit it.
                                continue</span>
                        }
                        // TODO: more of "8.1.2.2 Connection-Specific Header Fields"
                        <span class="cov8" title="1">if isTE &amp;&amp; v != "trailers" </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">headerSize += encKV(enc, k, v)</span>
                }
        }
        <span class="cov8" title="1">return headerSize</span>
}
</pre>
		
		<pre class="file" id="file66" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Copyright 2014 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package bfe_http2

import "fmt"

// frameWriteMsg is a request to write a frame.
type frameWriteMsg struct {
        // write is the interface value that does the writing, once the
        // writeScheduler (below) has decided to select this frame
        // to write. The write functions are all defined in write.go.
        write writeFramer

        stream *stream // used for prioritization. nil for non-stream frames.

        // done, if non-nil, must be a buffered channel with space for
        // 1 message and is sent the return value from write (or an
        // earlier error) when the frame has been written.
        done chan error
}

// isControl reports whether wr is a control frame for MaxQueuedControlFrames
// purposes. That includes non-stream frames and RST_STREAM frames.
func (wr frameWriteMsg) isControl() bool <span class="cov8" title="1">{
        return wr.stream == nil
}</span>

// for debugging only:
func (wm frameWriteMsg) String() string <span class="cov0" title="0">{
        var streamID uint32
        if wm.stream != nil </span><span class="cov0" title="0">{
                streamID = wm.stream.id
        }</span>
        <span class="cov0" title="0">var des string
        if s, ok := wm.write.(fmt.Stringer); ok </span><span class="cov0" title="0">{
                des = s.String()
        }</span> else<span class="cov0" title="0"> {
                des = fmt.Sprintf("%T", wm.write)
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("[frameWriteMsg stream=%d, ch=%v, type: %v]", streamID, wm.done != nil, des)</span>
}

// writeScheduler tracks pending frames to write, priorities, and decides
// the next one to use. It is not thread-safe.
type writeScheduler struct {
        // zero are frames not associated with a specific stream.
        // They're sent before any stream-specific freams.
        zero writeQueue

        // maxFrameSize is the maximum size of a DATA frame
        // we'll write. Must be non-zero and between 16K-16M.
        maxFrameSize uint32

        // sq contains the stream-specific queues, keyed by stream ID.
        // when a stream is idle, it's deleted from the map.
        sq map[uint32]*writeQueue

        // canSend is a slice of memory that's reused between frame
        // scheduling decisions to hold the list of writeQueues (from sq)
        // which have enough flow control data to send. After canSend is
        // built, the best is selected.
        canSend []*writeQueue

        // pool of empty queues for reuse.
        queuePool []*writeQueue
}

func (ws *writeScheduler) putEmptyQueue(q *writeQueue) <span class="cov8" title="1">{
        if len(q.s) != 0 </span><span class="cov0" title="0">{
                panic("queue must be empty")</span>
        }
        <span class="cov8" title="1">ws.queuePool = append(ws.queuePool, q)</span>
}

func (ws *writeScheduler) getEmptyQueue() *writeQueue <span class="cov8" title="1">{
        ln := len(ws.queuePool)
        if ln == 0 </span><span class="cov8" title="1">{
                return new(writeQueue)
        }</span>
        <span class="cov8" title="1">q := ws.queuePool[ln-1]
        ws.queuePool = ws.queuePool[:ln-1]
        return q</span>
}

func (ws *writeScheduler) empty() bool <span class="cov0" title="0">{ return ws.zero.empty() &amp;&amp; len(ws.sq) == 0 }</span>

func (ws *writeScheduler) add(wm frameWriteMsg) <span class="cov8" title="1">{
        st := wm.stream
        if st == nil </span><span class="cov8" title="1">{
                ws.zero.push(wm)
        }</span> else<span class="cov8" title="1"> {
                ws.streamQueue(st.id).push(wm)
        }</span>
}

func (ws *writeScheduler) streamQueue(streamID uint32) *writeQueue <span class="cov8" title="1">{
        if q, ok := ws.sq[streamID]; ok </span><span class="cov8" title="1">{
                return q
        }</span>
        <span class="cov8" title="1">if ws.sq == nil </span><span class="cov8" title="1">{
                ws.sq = make(map[uint32]*writeQueue)
        }</span>
        <span class="cov8" title="1">q := ws.getEmptyQueue()
        ws.sq[streamID] = q
        return q</span>
}

// take returns the most important frame to write and removes it from the scheduler.
// It is illegal to call this if the scheduler is empty or if there are no connection-level
// flow control bytes available.
func (ws *writeScheduler) take() (wm frameWriteMsg, ok bool) <span class="cov8" title="1">{
        if ws.maxFrameSize == 0 </span><span class="cov0" title="0">{
                panic("internal error: ws.maxFrameSize not initialized or invalid")</span>
        }

        // If there any frames not associated with streams, prefer those first.
        // These are usually SETTINGS, etc.
        <span class="cov8" title="1">if !ws.zero.empty() </span><span class="cov8" title="1">{
                return ws.zero.shift(), true
        }</span>
        <span class="cov8" title="1">if len(ws.sq) == 0 </span><span class="cov8" title="1">{
                return
        }</span>

        // Next, prioritize frames on streams that aren't DATA frames (no cost).
        <span class="cov8" title="1">for id, q := range ws.sq </span><span class="cov8" title="1">{
                if q.firstIsNoCost() </span><span class="cov8" title="1">{
                        return ws.takeFrom(id, q)
                }</span>
        }

        // Now, all that remains are DATA frames with non-zero bytes to
        // send. So pick the best one.
        <span class="cov8" title="1">if len(ws.canSend) != 0 </span><span class="cov0" title="0">{
                panic("should be empty")</span>
        }
        <span class="cov8" title="1">for _, q := range ws.sq </span><span class="cov8" title="1">{
                if n := ws.streamWritableBytes(q); n &gt; 0 </span><span class="cov8" title="1">{
                        ws.canSend = append(ws.canSend, q)
                }</span>
        }
        <span class="cov8" title="1">if len(ws.canSend) == 0 </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">defer ws.zeroCanSend()

        // TODO: find the best queue
        q := ws.canSend[0]

        return ws.takeFrom(q.streamID(), q)</span>
}

// zeroCanSend is deferred from take.
func (ws *writeScheduler) zeroCanSend() <span class="cov8" title="1">{
        for i := range ws.canSend </span><span class="cov8" title="1">{
                ws.canSend[i] = nil
        }</span>
        <span class="cov8" title="1">ws.canSend = ws.canSend[:0]</span>
}

// streamWritableBytes returns the number of DATA bytes we could write
// from the given queue's stream, if this stream/queue were
// selected. It is an error to call this if q's head isn't a
// *writeData.
func (ws *writeScheduler) streamWritableBytes(q *writeQueue) int32 <span class="cov8" title="1">{
        wm := q.head()
        ret := wm.stream.flow.available() // max we can write
        if ret == 0 </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">if int32(ws.maxFrameSize) &lt; ret </span><span class="cov8" title="1">{
                ret = int32(ws.maxFrameSize)
        }</span>
        <span class="cov8" title="1">if ret == 0 </span><span class="cov0" title="0">{
                panic("internal error: ws.maxFrameSize not initialized or invalid")</span>
        }
        <span class="cov8" title="1">wd := wm.write.(*writeData)
        if len(wd.p) &lt; int(ret) </span><span class="cov8" title="1">{
                ret = int32(len(wd.p))
        }</span>
        <span class="cov8" title="1">return ret</span>
}

func (ws *writeScheduler) takeFrom(id uint32, q *writeQueue) (wm frameWriteMsg, ok bool) <span class="cov8" title="1">{
        wm = q.head()
        // If the first item in this queue costs flow control tokens
        // and we don't have enough, write as much as we can.
        if wd, ok := wm.write.(*writeData); ok &amp;&amp; len(wd.p) &gt; 0 </span><span class="cov8" title="1">{
                allowed := wm.stream.flow.available() // max we can write
                if allowed == 0 </span><span class="cov0" title="0">{
                        // No quota available. Caller can try the next stream.
                        return frameWriteMsg{}, false
                }</span>
                <span class="cov8" title="1">if int32(ws.maxFrameSize) &lt; allowed </span><span class="cov8" title="1">{
                        allowed = int32(ws.maxFrameSize)
                }</span>
                // TODO: further restrict the allowed size, because even if
                // the peer says it's okay to write 16MB data frames, we might
                // want to write smaller ones to properly weight competing
                // streams' priorities.

                <span class="cov8" title="1">if len(wd.p) &gt; int(allowed) </span><span class="cov8" title="1">{
                        wm.stream.flow.take(allowed)
                        chunk := wd.p[:allowed]
                        wd.p = wd.p[allowed:]
                        // Make up a new write message of a valid size, rather
                        // than shifting one off the queue.
                        return frameWriteMsg{
                                stream: wm.stream,
                                write: &amp;writeData{
                                        streamID: wd.streamID,
                                        p:        chunk,
                                        // even if the original had endStream set, there
                                        // arebytes remaining because len(wd.p) &gt; allowed,
                                        // so we know endStream is false:
                                        endStream: false,
                                },
                                // our caller is blocking on the final DATA frame, not
                                // these intermediates, so no need to wait:
                                done: nil,
                        }, true
                }</span>
                <span class="cov8" title="1">wm.stream.flow.take(int32(len(wd.p)))</span>
        }

        <span class="cov8" title="1">q.shift()
        if q.empty() </span><span class="cov8" title="1">{
                ws.putEmptyQueue(q)
                delete(ws.sq, id)
        }</span>
        <span class="cov8" title="1">return wm, true</span>
}

func (ws *writeScheduler) forgetStream(id uint32) <span class="cov8" title="1">{
        q, ok := ws.sq[id]
        if !ok </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">delete(ws.sq, id)

        // But keep it for others later.
        for i := range q.s </span><span class="cov8" title="1">{
                q.s[i] = frameWriteMsg{}
        }</span>
        <span class="cov8" title="1">q.s = q.s[:0]
        ws.putEmptyQueue(q)</span>
}

type writeQueue struct {
        s []frameWriteMsg
}

// streamID returns the stream ID for a non-empty stream-specific queue.
func (q *writeQueue) streamID() uint32 <span class="cov8" title="1">{ return q.s[0].stream.id }</span>

func (q *writeQueue) empty() bool <span class="cov8" title="1">{ return len(q.s) == 0 }</span>

func (q *writeQueue) push(wm frameWriteMsg) <span class="cov8" title="1">{
        q.s = append(q.s, wm)
}</span>

// head returns the next item that would be removed by shift.
func (q *writeQueue) head() frameWriteMsg <span class="cov8" title="1">{
        if len(q.s) == 0 </span><span class="cov0" title="0">{
                panic("invalid use of queue")</span>
        }
        <span class="cov8" title="1">return q.s[0]</span>
}

func (q *writeQueue) shift() frameWriteMsg <span class="cov8" title="1">{
        if len(q.s) == 0 </span><span class="cov0" title="0">{
                panic("invalid use of queue")</span>
        }
        <span class="cov8" title="1">wm := q.s[0]
        // TODO: less copy-happy queue.
        copy(q.s, q.s[1:])
        q.s[len(q.s)-1] = frameWriteMsg{}
        q.s = q.s[:len(q.s)-1]
        return wm</span>
}

func (q *writeQueue) firstIsNoCost() bool <span class="cov8" title="1">{
        if df, ok := q.s[0].write.(*writeData); ok </span><span class="cov8" title="1">{
                return len(df.p) == 0
        }</span>
        <span class="cov8" title="1">return true</span>
}
</pre>
		
		<pre class="file" id="file67" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// callback framework for bfe

package bfe_module

import (
        "fmt"
)

import (
        "github.com/baidu/go-lib/log"
)

import (
        "github.com/bfenetworks/bfe/bfe_util/json"
)

// Callback point.
const (
        HandleAccept = iota
        HandleHandshake
        HandleBeforeLocation
        HandleFoundProduct
        HandleAfterLocation
        HandleForward
        HandleReadResponse
        HandleRequestFinish
        HandleFinish
)

func CallbackPointName(point int) string <span class="cov8" title="1">{
        switch point </span>{
        case HandleAccept:<span class="cov8" title="1">
                return "HandleAccept"</span>
        case HandleHandshake:<span class="cov8" title="1">
                return "HandleHandshake"</span>
        case HandleBeforeLocation:<span class="cov8" title="1">
                return "HandleBeforeLocation"</span>
        case HandleFoundProduct:<span class="cov8" title="1">
                return "HandleFoundProduct"</span>
        case HandleAfterLocation:<span class="cov8" title="1">
                return "HandleAfterLocation"</span>
        case HandleForward:<span class="cov8" title="1">
                return "HandleForward"</span>
        case HandleReadResponse:<span class="cov8" title="1">
                return "HandleReadResponse"</span>
        case HandleRequestFinish:<span class="cov8" title="1">
                return "HandleRequestFinish"</span>
        case HandleFinish:<span class="cov8" title="1">
                return "HandleFinish"</span>
        default:<span class="cov8" title="1">
                return "HandleUnknown"</span>
        }
}

type BfeCallbacks struct {
        callbacks map[int]*HandlerList
}

// NewBfeCallbacks creates a BfeCallbacks.
func NewBfeCallbacks() *BfeCallbacks <span class="cov8" title="1">{
        // create bfeCallbacks
        bfeCallbacks := new(BfeCallbacks)
        bfeCallbacks.callbacks = make(map[int]*HandlerList)

        // create handler list for each callback point
        // for HandlesAccept
        bfeCallbacks.callbacks[HandleAccept] = NewHandlerList(HandlersAccept)
        bfeCallbacks.callbacks[HandleHandshake] = NewHandlerList(HandlersAccept)

        // for HandlersRequest
        bfeCallbacks.callbacks[HandleBeforeLocation] = NewHandlerList(HandlersRequest)
        bfeCallbacks.callbacks[HandleFoundProduct] = NewHandlerList(HandlersRequest)
        bfeCallbacks.callbacks[HandleAfterLocation] = NewHandlerList(HandlersRequest)

        // for HandlersForward
        bfeCallbacks.callbacks[HandleForward] = NewHandlerList(HandlersForward)

        // for HandlersResponse
        bfeCallbacks.callbacks[HandleReadResponse] = NewHandlerList(HandlersResponse)
        bfeCallbacks.callbacks[HandleRequestFinish] = NewHandlerList(HandlersResponse)

        // for HandlersFinish
        bfeCallbacks.callbacks[HandleFinish] = NewHandlerList(HandlersFinish)

        return bfeCallbacks
}</span>

// AddFilter adds filter to given callback point.
func (bcb *BfeCallbacks) AddFilter(point int, f interface{}) error <span class="cov8" title="1">{
        hl, ok := bcb.callbacks[point]

        if !ok </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid callback point[%d]", point)
        }</span>

        <span class="cov8" title="1">var err error
        switch hl.handlerType </span>{
        case HandlersAccept:<span class="cov8" title="1">
                err = hl.AddAcceptFilter(f)</span>
        case HandlersRequest:<span class="cov8" title="1">
                err = hl.AddRequestFilter(f)</span>
        case HandlersForward:<span class="cov8" title="1">
                err = hl.AddForwardFilter(f)</span>
        case HandlersResponse:<span class="cov8" title="1">
                err = hl.AddResponseFilter(f)</span>
        case HandlersFinish:<span class="cov8" title="1">
                err = hl.AddFinishFilter(f)</span>
        default:<span class="cov8" title="1">
                err = fmt.Errorf("invalid type of handler list[%d]", hl.handlerType)</span>
        }
        <span class="cov8" title="1">return err</span>
}

// GetHandlerList gets handler list for given callback point
func (bcb *BfeCallbacks) GetHandlerList(point int) *HandlerList <span class="cov8" title="1">{
        hl, ok := bcb.callbacks[point]

        if !ok </span><span class="cov8" title="1">{
                log.Logger.Warn("GetHandlerList():invalid callback point[%d]", point)
                return nil
        }</span>

        <span class="cov8" title="1">return hl</span>
}

// ModuleHandlersGetJSON get info of handlers
func (bcb *BfeCallbacks) ModuleHandlersGetJSON() ([]byte, error) <span class="cov8" title="1">{
        cbs := make(map[string][]string)

        for point, hl := range bcb.callbacks </span><span class="cov8" title="1">{
                pointName := fmt.Sprintf("%d#%s", point, CallbackPointName(point))
                handlerNames := make([]string, 0)
                for e := hl.handlers.Front(); e != nil; e = e.Next() </span><span class="cov0" title="0">{
                        handlerNames = append(handlerNames, fmt.Sprintf("%s", e.Value))
                }</span>
                <span class="cov8" title="1">cbs[pointName] = handlerNames</span>
        }

        <span class="cov8" title="1">return json.Marshal(cbs)</span>
}
</pre>
		
		<pre class="file" id="file68" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Copyright (c) 2012 ngmoco:) inc.
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the "Software"),
// to deal in the Software without restriction, including without limitation
// the rights to use, copy, modify, merge, publish, distribute, sublicense,
// and/or sell copies of the Software, and to permit persons to whom the
// Software is furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

// bfe_filter.go define filter for various scenarios.
//  AcceptFilter: filter after accept connection from client
//  RequestFilter: filter after get http request from client
//  ForwardFilter: filter before forward http request to backend
//  ResponseFilter: filter after get http response from backend
//  FinishFilter: filter before close connection from client
//
// Part of the code is borrowed from falcore.

package bfe_module

import (
        "reflect"
        "runtime"
)

import (
        "github.com/bfenetworks/bfe/bfe_basic"
        "github.com/bfenetworks/bfe/bfe_http"
)

// RequestFilter filters incoming requests and return a response or nil.
// Filters are chained together into a HandlerList.
type RequestFilter interface {
        FilterRequest(request *bfe_basic.Request) (int, *bfe_http.Response)
}

// NewRequestFilter create a Filter by passed func.
func NewRequestFilter(f func(request *bfe_basic.Request) (int, *bfe_http.Response)) RequestFilter <span class="cov8" title="1">{
        rf := new(genericRequestFilter)
        rf.f = f
        return rf
}</span>

type genericRequestFilter struct {
        f func(request *bfe_basic.Request) (int, *bfe_http.Response)
}

func (f *genericRequestFilter) FilterRequest(request *bfe_basic.Request) (int, *bfe_http.Response) <span class="cov8" title="1">{
        return f.f(request)
}</span>

func (f *genericRequestFilter) String() string <span class="cov0" title="0">{
        ptr := reflect.ValueOf(f.f).Pointer()
        return runtime.FuncForPC(ptr).Name()
}</span>

// ResponseFilter filters outgoing responses. This can be used to modify the response
// before it is sent.
type ResponseFilter interface {
        FilterResponse(req *bfe_basic.Request, res *bfe_http.Response) int
}

// NewResponseFilter creates a Filter by passed func
func NewResponseFilter(f func(req *bfe_basic.Request, res *bfe_http.Response) int) ResponseFilter <span class="cov8" title="1">{
        rf := new(genericResponseFilter)
        rf.f = f
        return rf
}</span>

type genericResponseFilter struct {
        f func(req *bfe_basic.Request, res *bfe_http.Response) int
}

func (f *genericResponseFilter) FilterResponse(req *bfe_basic.Request, res *bfe_http.Response) int <span class="cov8" title="1">{
        return f.f(req, res)
}</span>

func (f *genericResponseFilter) String() string <span class="cov0" title="0">{
        ptr := reflect.ValueOf(f.f).Pointer()
        return runtime.FuncForPC(ptr).Name()
}</span>

// AcceptFilter filters incoming connections.
type AcceptFilter interface {
        FilterAccept(*bfe_basic.Session) int
}

// NewAcceptFilter creates a Filter by passed func
func NewAcceptFilter(f func(session *bfe_basic.Session) int) AcceptFilter <span class="cov8" title="1">{
        rf := new(genericAcceptFilter)
        rf.f = f
        return rf
}</span>

type genericAcceptFilter struct {
        f func(session *bfe_basic.Session) int
}

func (f *genericAcceptFilter) FilterAccept(session *bfe_basic.Session) int <span class="cov8" title="1">{
        return f.f(session)
}</span>

func (f *genericAcceptFilter) String() string <span class="cov0" title="0">{
        ptr := reflect.ValueOf(f.f).Pointer()
        return runtime.FuncForPC(ptr).Name()
}</span>

// ForwardFilter filters to forward request
type ForwardFilter interface {
        FilterForward(*bfe_basic.Request) int
}

// NewForwardFilter create a Filter by passed func
func NewForwardFilter(f func(req *bfe_basic.Request) int) ForwardFilter <span class="cov8" title="1">{
        rf := new(genericForwardFilter)
        rf.f = f
        return rf
}</span>

type genericForwardFilter struct {
        f func(req *bfe_basic.Request) int
}

func (f *genericForwardFilter) FilterForward(req *bfe_basic.Request) int <span class="cov8" title="1">{
        return f.f(req)
}</span>

func (f *genericForwardFilter) String() string <span class="cov0" title="0">{
        ptr := reflect.ValueOf(f.f).Pointer()
        return runtime.FuncForPC(ptr).Name()
}</span>

// FinishFilter filters finished session(connection)
type FinishFilter interface {
        FilterFinish(*bfe_basic.Session) int
}

// NewFinishFilter create a Filter by passed func.
func NewFinishFilter(f func(session *bfe_basic.Session) int) FinishFilter <span class="cov8" title="1">{
        rf := new(genericFinishFilter)
        rf.f = f
        return rf
}</span>

type genericFinishFilter struct {
        f func(session *bfe_basic.Session) int
}

func (f *genericFinishFilter) FilterFinish(session *bfe_basic.Session) int <span class="cov8" title="1">{
        return f.f(session)
}</span>

func (f *genericFinishFilter) String() string <span class="cov0" title="0">{
        ptr := reflect.ValueOf(f.f).Pointer()
        return runtime.FuncForPC(ptr).Name()
}</span>
</pre>
		
		<pre class="file" id="file69" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// list of callback filters

package bfe_module

import (
        "container/list"
        "fmt"
)

import (
        "github.com/baidu/go-lib/log"
)

import (
        "github.com/bfenetworks/bfe/bfe_basic"
        "github.com/bfenetworks/bfe/bfe_http"
)

// HandlerList type.
const (
        // HandlersAccept for AcceptFilter
        HandlersAccept = iota
        // HandlersRequest for RequestFilter
        HandlersRequest
        // HandlersForward for ForwardFilter
        HandlersForward
        // HandlersResponse for ResponseFilter
        HandlersResponse
        // HandlersFinish for FinishFilter
        HandlersFinish
)

// Return value of handler.
const (
        // BfeHandlerFinish to close the connection after response
        BfeHandlerFinish = iota
        // BfeHandlerGoOn to go on next handler
        BfeHandlerGoOn
        // BfeHandlerRedirect to redirect
        BfeHandlerRedirect
        // BfeHandlerResponse to send response
        BfeHandlerResponse
        // BfeHandlerClose to close the connection directly, with no data sent.
        BfeHandlerClose
)

type HandlerList struct {
        handlerType int        /* type of handlers */
        handlers    *list.List /* list of handlers */
}

// NewHandlerList creates a HandlerList.
func NewHandlerList(handlerType int) *HandlerList <span class="cov8" title="1">{
        handlers := new(HandlerList)

        handlers.handlerType = handlerType
        handlers.handlers = list.New()

        return handlers
}</span>

// FilterAccept filters accept with HandlerList.
func (hl *HandlerList) FilterAccept(session *bfe_basic.Session) int <span class="cov8" title="1">{
        retVal := BfeHandlerGoOn

LOOP:
        for e := hl.handlers.Front(); e != nil; e = e.Next() </span><span class="cov8" title="1">{
                switch filter := e.Value.(type) </span>{
                case AcceptFilter:<span class="cov8" title="1">
                        retVal = filter.FilterAccept(session)
                        if retVal != BfeHandlerGoOn </span><span class="cov0" title="0">{
                                break LOOP</span>
                        }
                default:<span class="cov0" title="0">
                        log.Logger.Error("%v (%T) is not a AcceptFilter\n",
                                e.Value, e.Value)
                        break LOOP</span>
                }
        }
        <span class="cov8" title="1">return retVal</span>
}

// FilterRequest filters request with HandlerList.
func (hl *HandlerList) FilterRequest(req *bfe_basic.Request) (int, *bfe_http.Response) <span class="cov8" title="1">{
        var res *bfe_http.Response
        retVal := BfeHandlerGoOn

LOOP:
        for e := hl.handlers.Front(); e != nil; e = e.Next() </span><span class="cov8" title="1">{
                switch filter := e.Value.(type) </span>{
                case RequestFilter:<span class="cov8" title="1">
                        retVal, res = filter.FilterRequest(req)
                        if retVal != BfeHandlerGoOn </span><span class="cov0" title="0">{
                                break LOOP</span>
                        }
                default:<span class="cov0" title="0">
                        log.Logger.Error("%v (%T) is not a RequestFilter\n",
                                e.Value, e.Value)
                        break LOOP</span>
                }
        }
        <span class="cov8" title="1">return retVal, res</span>
}

// FilterForward filters forward with HandlerList.
func (hl *HandlerList) FilterForward(req *bfe_basic.Request) int <span class="cov8" title="1">{
        retVal := BfeHandlerGoOn

LOOP:
        for e := hl.handlers.Front(); e != nil; e = e.Next() </span><span class="cov8" title="1">{
                switch filter := e.Value.(type) </span>{
                case ForwardFilter:<span class="cov8" title="1">
                        retVal = filter.FilterForward(req)
                        if retVal != BfeHandlerGoOn </span><span class="cov8" title="1">{
                                break LOOP</span>
                        }
                default:<span class="cov0" title="0">
                        log.Logger.Error("%v (%T) is not a ForwardFilter\n",
                                e.Value, e.Value)
                        break LOOP</span>
                }
        }
        <span class="cov8" title="1">return retVal</span>
}

// FilterResponse filters request with HandlerList.
func (hl *HandlerList) FilterResponse(req *bfe_basic.Request, res *bfe_http.Response) int <span class="cov8" title="1">{
        retVal := BfeHandlerGoOn

LOOP:
        for e := hl.handlers.Front(); e != nil; e = e.Next() </span><span class="cov8" title="1">{
                switch filter := e.Value.(type) </span>{
                case ResponseFilter:<span class="cov8" title="1">
                        retVal = filter.FilterResponse(req, res)
                        if retVal != BfeHandlerGoOn </span><span class="cov8" title="1">{
                                break LOOP</span>
                        }
                default:<span class="cov0" title="0">
                        log.Logger.Error("%v (%T) is not a ResponseFilter\n",
                                e.Value, e.Value)
                        break LOOP</span>
                }
        }
        <span class="cov8" title="1">return retVal</span>
}

// FilterFinish filters finished session with HandlerList.
func (hl *HandlerList) FilterFinish(session *bfe_basic.Session) int <span class="cov8" title="1">{
        retVal := BfeHandlerGoOn

LOOP:
        for e := hl.handlers.Front(); e != nil; e = e.Next() </span><span class="cov8" title="1">{
                switch filter := e.Value.(type) </span>{
                case FinishFilter:<span class="cov8" title="1">
                        retVal = filter.FilterFinish(session)
                        if retVal != BfeHandlerGoOn </span><span class="cov8" title="1">{
                                break LOOP</span>
                        }
                default:<span class="cov0" title="0">
                        log.Logger.Error("%v (%T) is not a FinishFilter\n",
                                e.Value, e.Value)
                        break LOOP</span>
                }
        }
        <span class="cov8" title="1">return retVal</span>
}

// AddAcceptFilter adds accept filter to handler list.
func (hl *HandlerList) AddAcceptFilter(f interface{}) error <span class="cov8" title="1">{
        callback, ok := f.(func(session *bfe_basic.Session) int)
        if !ok </span><span class="cov8" title="1">{
                return fmt.Errorf("AddAcceptFilter():invalid callback func")
        }</span>

        <span class="cov8" title="1">hl.handlers.PushBack(NewAcceptFilter(callback))
        return nil</span>
}

// AddRequestFilter adds request filter to handler list.
func (hl *HandlerList) AddRequestFilter(f interface{}) error <span class="cov8" title="1">{
        callback, ok := f.(func(req *bfe_basic.Request) (int, *bfe_http.Response))
        if !ok </span><span class="cov8" title="1">{
                return fmt.Errorf("AddRequestFilter():invalid callback func")
        }</span>

        <span class="cov8" title="1">hl.handlers.PushBack(NewRequestFilter(callback))
        return nil</span>
}

// AddForwardFilter adds forward filter to handler list.
func (hl *HandlerList) AddForwardFilter(f interface{}) error <span class="cov8" title="1">{
        callback, ok := f.(func(req *bfe_basic.Request) int)
        if !ok </span><span class="cov8" title="1">{
                return fmt.Errorf("AddForwardFilter():invalid callback func")
        }</span>

        <span class="cov8" title="1">hl.handlers.PushBack(NewForwardFilter(callback))
        return nil</span>
}

// AddResponseFilter adds response filter to handler list.
func (hl *HandlerList) AddResponseFilter(f interface{}) error <span class="cov8" title="1">{
        callback, ok := f.(func(req *bfe_basic.Request, res *bfe_http.Response) int)
        if !ok </span><span class="cov8" title="1">{
                return fmt.Errorf("AddResponseFilter():invalid callback func")
        }</span>

        <span class="cov8" title="1">hl.handlers.PushBack(NewResponseFilter(callback))
        return nil</span>
}

// AddFinishFilter adds finish filter to handler list.
func (hl *HandlerList) AddFinishFilter(f interface{}) error <span class="cov8" title="1">{
        callback, ok := f.(func(session *bfe_basic.Session) int)
        if !ok </span><span class="cov8" title="1">{
                return fmt.Errorf("AddFinishFilter():invalid callback func")
        }</span>

        <span class="cov8" title="1">hl.handlers.PushBack(NewFinishFilter(callback))
        return nil</span>
}
</pre>
		
		<pre class="file" id="file70" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// module framework for bfe

package bfe_module

import (
        "fmt"
        "path"
)

import (
        "github.com/baidu/go-lib/log"
        "github.com/baidu/go-lib/web-monitor/web_monitor"
)

import (
        "github.com/bfenetworks/bfe/bfe_util/json"
)

type BfeModule interface {
        // Name return name of module.
        Name() string

        // Init initializes the module.
        //
        // Params:
        //      - cbs: callback handlers. for register call back function
        //      - whs: web monitor handlers. for register web monitor handler
        //      - cr: config root path. for get config path of module
        Init(cbs *BfeCallbacks, whs *web_monitor.WebHandlers, cr string) error
}

// moduleMap holds mappings from mod_name to module.
var moduleMap = make(map[string]BfeModule)

// modulesAll is an ordered list of all module names.
var modulesAll = make([]string, 0)

// modulesEnabled is list of enabled module names.
var modulesEnabled = make([]string, 0)

// AddModule adds module to moduleMap and modulesAll.
func AddModule(module BfeModule) <span class="cov8" title="1">{
        moduleMap[module.Name()] = module
        modulesAll = append(modulesAll, module.Name())
}</span>

type BfeModules struct {
        workModules map[string]BfeModule // work modules, configure in bfe conf file
}

// NewBfeModules create new BfeModules
func NewBfeModules() *BfeModules <span class="cov8" title="1">{
        bfeModules := new(BfeModules)
        bfeModules.workModules = make(map[string]BfeModule)

        return bfeModules
}</span>

// RegisterModule register work module, only work module be inited
func (bm *BfeModules) RegisterModule(name string) error <span class="cov8" title="1">{
        module, ok := moduleMap[name]
        if !ok </span><span class="cov8" title="1">{
                return fmt.Errorf("no module for %s", name)
        }</span>

        <span class="cov8" title="1">bm.workModules[name] = module

        return nil</span>
}

// GetModule get work module by name.
func (bm *BfeModules) GetModule(name string) BfeModule <span class="cov8" title="1">{
        return bm.workModules[name]
}</span>

// Init initializes bfe modules.
//
// Params:
//     - cbs: BfeCallbacks
//     - whs: WebHandlers
//     - cr : root path for config
func (bm *BfeModules) Init(cbs *BfeCallbacks, whs *web_monitor.WebHandlers, cr string) error <span class="cov8" title="1">{
        // go through ALL available module names
        // It is IMPORTANT to do init by the order defined in modulesAll
        for _, name := range modulesAll </span><span class="cov8" title="1">{
                // check whether this module is enabled
                module, ok := bm.workModules[name]
                if ok </span><span class="cov8" title="1">{
                        // do init for this module
                        err := module.Init(cbs, whs, cr)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Logger.Error("Err in module.init() for %s [%s]",
                                        module.Name(), err.Error())
                                return err
                        }</span>
                        <span class="cov8" title="1">log.Logger.Info("%s:Init() OK", module.Name())

                        // add to modulesEnabled
                        modulesEnabled = append(modulesEnabled, name)</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

// ModConfPath get full path of module config file.
//
// format: confRoot/&lt;modName&gt;/&lt;modName&gt;.conf
//
// e.g., confRoot = "/home/bfe/conf", modName = "mod_access"
// return "/home/bfe/conf/mod_access/mod_access.conf"
func ModConfPath(confRoot string, modName string) string <span class="cov8" title="1">{
        confPath := path.Join(confRoot, modName, modName+".conf")
        return confPath
}</span>

// ModConfDir get dir for module config.
//
// format: confRoot/&lt;modName&gt;
//
// e.g., confRoot = "/home/bfe/conf", modName = "mod_access"
// return "/home/bfe/conf/mod_access"
func ModConfDir(confRoot string, modName string) string <span class="cov8" title="1">{
        confDir := path.Join(confRoot, modName)
        return confDir
}</span>

// ModuleStatusGetJSON get modules Available and modules Enabled.
func ModuleStatusGetJSON() ([]byte, error) <span class="cov8" title="1">{
        status := make(map[string][]string)
        status["available"] = modulesAll
        status["enabled"] = modulesEnabled
        return json.Marshal(status)
}</span>
</pre>
		
		<pre class="file" id="file71" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package bfe_module

import (
        "fmt"
        goplugin "plugin"
)

import (
        "github.com/baidu/go-lib/log"
        "github.com/baidu/go-lib/web-monitor/web_monitor"
)

import (
        "github.com/bfenetworks/bfe/bfe_util/semver"
)

type BfePlugins struct {
        workPlugins map[string]*PluginInfo // work plugins, configure in bfe conf file
}

// NewBfePlugins create new Plugins
func NewBfePlugins() *BfePlugins <span class="cov0" title="0">{
        pl := new(BfePlugins)
        pl.workPlugins = make(map[string]*PluginInfo)

        return pl
}</span>

// RegisterPlugin loads a plugin created with `go build -buildmode=plugin`
func (p *BfePlugins) RegisterPlugin(path string, bfeVersion string) error <span class="cov0" title="0">{
        plugin, err := goplugin.Open(path)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("RegisterPlugin Open plugin path %v err:%v", path, err)
        }</span>

        <span class="cov0" title="0">nameSym, err := plugin.Lookup("Name")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("RegisterPlugin Lookup Name err:%v", err)
        }</span>

        <span class="cov0" title="0">versionSym, err := plugin.Lookup("Version")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("RegisterPlugin Lookup Version err:%v", err)
        }</span>

        <span class="cov0" title="0">initSym, err := plugin.Lookup("Init")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("RegisterPlugin Lookup Init err:%v", err)
        }</span>

        <span class="cov0" title="0">version := *versionSym.(*string)

        // Compare versions bfe major version and plugin major version
        bfeVer, err := semver.New(bfeVersion)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("RegisterPlugin bfe version err:%v", err)
        }</span>
        <span class="cov0" title="0">pluginVer, err := semver.New(version)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("RegisterPlugin plugin version err:%v", err)
        }</span>
        <span class="cov0" title="0">if bfeVer.CompareMajor(pluginVer) != 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("RegisterPlugin Major version not match, bfe:%s, plugin:%s", bfeVersion, version)
        }</span>

        <span class="cov0" title="0">pluginInfo := &amp;PluginInfo{
                Name:    *nameSym.(*string),
                Version: version,
                Path:    path,
                Init:    initSym.(func(cbs *BfeCallbacks, whs *web_monitor.WebHandlers, cr string) error),
        }
        p.workPlugins[pluginInfo.Name] = pluginInfo

        return nil</span>
}

// Init initializes bfe plugins.
//
// Params:
//     - cbs: BfeCallbacks
//     - whs: WebHandlers
//     - cr : root path for config
func (p *BfePlugins) Init(cbs *BfeCallbacks, whs *web_monitor.WebHandlers, cr string) error <span class="cov0" title="0">{
        for _, pl := range p.workPlugins </span><span class="cov0" title="0">{
                if err := pl.Init(cbs, whs, cr); err != nil </span><span class="cov0" title="0">{
                        log.Logger.Error("Err in plugin.init() for %s [%s]",
                                pl.Name, err.Error())
                        return err
                }</span>

                <span class="cov0" title="0">log.Logger.Info("%s:Init() Version:%s OK", pl.Name, pl.Version)</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file72" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_access

import (
        "fmt"
)

import (
        gcfg "gopkg.in/gcfg.v1"
)

import (
        "github.com/bfenetworks/bfe/bfe_util/access_log"
)

// ConfModAccess holds the config of access module.
type ConfModAccess struct {
        Log access_log.LogConfig

        Template struct {
                RequestTemplate string // access log format string
                SessionTemplate string // session finish log format string
        }
}

// ConfLoad loads config of access module from file.
func ConfLoad(filePath string, confRoot string) (*ConfModAccess, error) <span class="cov8" title="1">{
        var err error
        var cfg ConfModAccess

        err = gcfg.ReadFileInto(&amp;cfg, filePath)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;cfg, err
        }</span>

        <span class="cov8" title="1">err = cfg.Check(confRoot)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;cfg, err
        }</span>

        <span class="cov8" title="1">cfg.Convert()

        return &amp;cfg, nil</span>
}

func (cfg *ConfModAccess) Check(confRoot string) error <span class="cov8" title="1">{
        err := cfg.Log.Check(confRoot)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if cfg.Template.RequestTemplate == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("ModAccess.RequestTemplate not set")
        }</span>

        <span class="cov8" title="1">if cfg.Template.SessionTemplate == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("ModAccess.SessionTemplate not set")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (cfg *ConfModAccess) Convert() <span class="cov8" title="1">{
        switch cfg.Template.RequestTemplate </span>{
        case "COMMON":<span class="cov0" title="0">
                cfg.Template.RequestTemplate = "$host - - $request_time \"$request_line\" $status_code $res_len"</span>
        case "COMBINED":<span class="cov0" title="0">
                cfg.Template.RequestTemplate = "$host - - $request_time \"$request_line\" $status_code $res_len \"${Referer}req_header\" \"${User-Agent}req_header\""</span>
        }
}

func checkLogFmt(item LogFmtItem, logFmtType string) error <span class="cov0" title="0">{
        if logFmtType != Request &amp;&amp; logFmtType != Session </span><span class="cov0" title="0">{
                return fmt.Errorf("logFmtType should be Request or Session")
        }</span>

        <span class="cov0" title="0">domain, found := fmtItemDomainTable[item.Type]
        if !found </span><span class="cov0" title="0">{
                return fmt.Errorf("type : (%d, %s) not configured in domain table",
                        item.Type, item.Key)
        }</span>

        <span class="cov0" title="0">if domain != DomainAll &amp;&amp; domain != logFmtType </span><span class="cov0" title="0">{
                return fmt.Errorf("type : (%d, %s) should not in request finish log",
                        item.Type, item.Key)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func tokenTypeGet(templatePtr *string, offset int) (int, int, error) <span class="cov8" title="1">{
        templateLen := len(*templatePtr)

        for key, logItemType := range fmtTable </span><span class="cov8" title="1">{
                n := len(key)
                if offset+n &gt; templateLen </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">if key == (*templatePtr)[offset:(offset+n)] </span><span class="cov8" title="1">{
                        return logItemType, offset + n - 1, nil
                }</span>
        }

        <span class="cov0" title="0">return -1, -1, fmt.Errorf("no such log item format type : %s", *templatePtr)</span>
}

func parseBracketToken(templatePtr *string, offset int) (LogFmtItem, int, error) <span class="cov8" title="1">{
        length := len(*templatePtr)

        var endOfBracket int
        for endOfBracket = offset + 1; endOfBracket &lt; length; endOfBracket++ </span><span class="cov8" title="1">{
                if (*templatePtr)[endOfBracket] == '}' </span><span class="cov8" title="1">{
                        break</span>
                }
        }

        <span class="cov8" title="1">if endOfBracket &gt;= length </span><span class="cov0" title="0">{
                return LogFmtItem{}, -1, fmt.Errorf("log format: { must be terminated by a }")
        }</span>

        <span class="cov8" title="1">if endOfBracket == (length - 1) </span><span class="cov0" title="0">{
                return LogFmtItem{}, -1, fmt.Errorf("log format: } must followed a character")
        }</span>

        <span class="cov8" title="1">key := (*templatePtr)[offset+1 : endOfBracket]

        logItemType, end, err := tokenTypeGet(templatePtr, endOfBracket+1)
        if err != nil </span><span class="cov0" title="0">{
                return LogFmtItem{}, -1, err
        }</span>

        <span class="cov8" title="1">return LogFmtItem{key, logItemType}, end, nil</span>
}

func parseLogTemplate(logTemplate string) ([]LogFmtItem, error) <span class="cov0" title="0">{
        reqFmts := []LogFmtItem{}

        start := 0
        templateLen := len(logTemplate)
        var token string

        for i := 0; i &lt; templateLen; i++ </span><span class="cov0" title="0">{
                if logTemplate[i] != '$' </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">if (i + 1) == templateLen </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("log format: $ must followed with a character")
                }</span>

                <span class="cov0" title="0">if start &lt;= (i - 1) </span><span class="cov0" title="0">{
                        token = logTemplate[start:i]
                        item := LogFmtItem{token, FormatString}
                        reqFmts = append(reqFmts, item)
                }</span>

                <span class="cov0" title="0">if logTemplate[i+1] == '{' </span><span class="cov0" title="0">{
                        item, end, err := parseBracketToken(&amp;logTemplate, i+1)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">reqFmts = append(reqFmts, item)
                        i = end
                        start = end + 1</span>

                } else<span class="cov0" title="0"> {
                        logItemType, end, err := tokenTypeGet(&amp;logTemplate, i+1)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov0" title="0">token = logTemplate[(i + 1) : end+1]
                        item := LogFmtItem{token, logItemType}
                        reqFmts = append(reqFmts, item)

                        i = end
                        start = end + 1</span>
                }
        }

        <span class="cov0" title="0">if start &lt; templateLen </span><span class="cov0" title="0">{
                token = logTemplate[start:templateLen]
                item := LogFmtItem{token, FormatString}
                reqFmts = append(reqFmts, item)
        }</span>

        <span class="cov0" title="0">return reqFmts, nil</span>
}
</pre>
		
		<pre class="file" id="file73" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_access

import (
        "bytes"
        "fmt"
)

import (
        "github.com/bfenetworks/bfe/bfe_basic"
        "github.com/bfenetworks/bfe/bfe_http"
        "github.com/bfenetworks/bfe/bfe_module"
        "github.com/bfenetworks/bfe/bfe_util/access_log"
)

import (
        "github.com/baidu/go-lib/log/log4go"
        "github.com/baidu/go-lib/web-monitor/web_monitor"
)

type ModuleAccess struct {
        name   string
        logger log4go.Logger
        conf   *ConfModAccess

        reqFmts     []LogFmtItem
        sessionFmts []LogFmtItem
}

func NewModuleAccess() *ModuleAccess <span class="cov0" title="0">{
        m := new(ModuleAccess)
        m.name = "mod_access"
        return m
}</span>

func (m *ModuleAccess) Name() string <span class="cov0" title="0">{
        return m.name
}</span>

func (m *ModuleAccess) ParseConfig(conf *ConfModAccess) error <span class="cov0" title="0">{
        var err error

        m.reqFmts, err = parseLogTemplate(conf.Template.RequestTemplate)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init(): RequestTemplate %s", m.name, err.Error())
        }</span>

        <span class="cov0" title="0">m.sessionFmts, err = parseLogTemplate(conf.Template.SessionTemplate)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init(): SessionTemplate %s", m.name, err.Error())
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (m *ModuleAccess) Init(cbs *bfe_module.BfeCallbacks, whs *web_monitor.WebHandlers,
        cr string) error <span class="cov0" title="0">{
        var err error
        var conf *ConfModAccess

        confPath := bfe_module.ModConfPath(cr, m.name)
        if conf, err = ConfLoad(confPath, cr); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: cond load err %s", m.name, err.Error())
        }</span>

        <span class="cov0" title="0">return m.init(conf, cbs, whs)</span>
}

func (m *ModuleAccess) init(conf *ConfModAccess, cbs *bfe_module.BfeCallbacks, whs *web_monitor.WebHandlers) error <span class="cov0" title="0">{
        var err error

        if err = m.ParseConfig(conf); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init(): ParseConfig %s", m.name, err.Error())
        }</span>

        <span class="cov0" title="0">m.conf = conf

        if err = m.CheckLogFormat(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init(): CheckLogFormat %s", m.name, err.Error())
        }</span>

        <span class="cov0" title="0">m.logger, err = access_log.LoggerInit(conf.Log)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init(): create logger", m.name)
        }</span>

        <span class="cov0" title="0">err = cbs.AddFilter(bfe_module.HandleRequestFinish, m.requestLogHandler)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init(): AddFilter(m. requestLogHandler): %s", m.name, err.Error())
        }</span>

        <span class="cov0" title="0">err = cbs.AddFilter(bfe_module.HandleFinish, m.sessionLogHandler)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init(): AddFilter(m.sessionLogHandler): %s", m.name, err.Error())
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (m *ModuleAccess) CheckLogFormat() error <span class="cov0" title="0">{
        for _, item := range m.reqFmts </span><span class="cov0" title="0">{
                err := checkLogFmt(item, Request)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">for _, item := range m.sessionFmts </span><span class="cov0" title="0">{
                err := checkLogFmt(item, Session)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (m *ModuleAccess) requestLogHandler(req *bfe_basic.Request, res *bfe_http.Response) int <span class="cov0" title="0">{
        byteStr := bytes.NewBuffer(nil)

        for _, item := range m.reqFmts </span><span class="cov0" title="0">{
                switch item.Type </span>{
                case FormatString:<span class="cov0" title="0">
                        byteStr.WriteString(item.Key)</span>
                case FormatTime:<span class="cov0" title="0">
                        onLogFmtTime(m, byteStr)</span>
                default:<span class="cov0" title="0">
                        handler, found := fmtHandlerTable[item.Type]
                        if found </span><span class="cov0" title="0">{
                                h := handler.(func(*ModuleAccess, *LogFmtItem, *bytes.Buffer,
                                        *bfe_basic.Request, *bfe_http.Response) error)
                                h(m, &amp;item, byteStr, req, res)
                        }</span>
                }
        }

        <span class="cov0" title="0">m.logger.Info(byteStr.String())

        return bfe_module.BfeHandlerGoOn</span>
}

func (m *ModuleAccess) sessionLogHandler(session *bfe_basic.Session) int <span class="cov0" title="0">{
        byteStr := bytes.NewBuffer(nil)

        for _, item := range m.sessionFmts </span><span class="cov0" title="0">{
                switch item.Type </span>{
                case FormatString:<span class="cov0" title="0">
                        byteStr.WriteString(item.Key)</span>
                case FormatTime:<span class="cov0" title="0">
                        onLogFmtTime(m, byteStr)</span>
                default:<span class="cov0" title="0">
                        handler, found := fmtHandlerTable[item.Type]
                        if found </span><span class="cov0" title="0">{
                                h := handler.(func(*ModuleAccess, *LogFmtItem, *bytes.Buffer,
                                        *bfe_basic.Session) error)
                                h(m, &amp;item, byteStr, session)
                        }</span>
                }
        }

        <span class="cov0" title="0">m.logger.Info(byteStr.String())

        return bfe_module.BfeHandlerGoOn</span>
}
</pre>
		
		<pre class="file" id="file74" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_access

import (
        "bytes"
        "errors"
        "fmt"
        "strings"
        "time"
)

import (
        "github.com/bfenetworks/bfe/bfe_basic"
        "github.com/bfenetworks/bfe/bfe_http"
)

func onLogFmtAllServeTime(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
        req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov0" title="0">{
        if req == nil </span><span class="cov0" title="0">{
                return errors.New("req is nil")
        }</span>
        <span class="cov0" title="0">if req.Stat == nil </span><span class="cov0" title="0">{
                return errors.New("req.Stat is nil")
        }</span>

        <span class="cov0" title="0">now := time.Now()
        ms := now.Sub(req.Stat.ReadReqStart).Nanoseconds() / 1000000
        msg := fmt.Sprintf("%d", ms)
        buff.WriteString(msg)

        return nil</span>
}

func onLogFmtRequestTime(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
        req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov0" title="0">{
        if req == nil </span><span class="cov0" title="0">{
                return errors.New("req is nil")
        }</span>
        <span class="cov0" title="0">if req.Stat == nil </span><span class="cov0" title="0">{
                return errors.New("req.Stat is nil")
        }</span>

        <span class="cov0" title="0">t := req.Stat.ReadReqStart.Format("[02/Jan/2006:15:04:05 -0700]")
        buff.WriteString(t)
        return nil</span>
}

func onLogFmtRequestLine(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
        req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov0" title="0">{
        if req == nil </span><span class="cov0" title="0">{
                return errors.New("req is nil")
        }</span>
        <span class="cov0" title="0">if req.HttpRequest == nil </span><span class="cov0" title="0">{
                return errors.New("req.HttpRequest is nil")
        }</span>

        <span class="cov0" title="0">l := fmt.Sprintf("%s %s %s", req.HttpRequest.Method, req.HttpRequest.RequestURI, req.HttpRequest.Proto)
        buff.WriteString(l)
        return nil</span>
}

func onLogFmtBackend(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
        req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov0" title="0">{
        if req == nil </span><span class="cov0" title="0">{
                return errors.New("req is nil")
        }</span>

        <span class="cov0" title="0">msg := fmt.Sprintf("%s,%s,%s,%s", req.Backend.ClusterName, req.Backend.SubclusterName,
                req.Backend.BackendAddr, req.Backend.BackendName)
        buff.WriteString(msg)

        return nil</span>
}

func onLogFmtReqBodyLen(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
        req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov0" title="0">{
        if req == nil </span><span class="cov0" title="0">{
                return errors.New("req is nil")
        }</span>
        <span class="cov0" title="0">if req.Stat == nil </span><span class="cov0" title="0">{
                return errors.New("req.Stat is nil")
        }</span>

        <span class="cov0" title="0">msg := fmt.Sprintf("%d", req.Stat.BodyLenIn)
        buff.WriteString(msg)

        return nil</span>
}

func onLogFmtResBodyLen(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
        req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov0" title="0">{
        if req == nil </span><span class="cov0" title="0">{
                return errors.New("req is nil")
        }</span>
        <span class="cov0" title="0">if req.Stat == nil </span><span class="cov0" title="0">{
                return errors.New("req.Stat is nil")
        }</span>

        <span class="cov0" title="0">msg := fmt.Sprintf("%d", req.Stat.BodyLenOut)
        buff.WriteString(msg)

        return nil</span>
}

func onLogFmtClusterDuration(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
        req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov0" title="0">{
        if req == nil </span><span class="cov0" title="0">{
                return errors.New("req is nil")
        }</span>
        <span class="cov0" title="0">if req.Stat == nil </span><span class="cov0" title="0">{
                return errors.New("req.Stat is nil")
        }</span>

        <span class="cov0" title="0">ms := req.Stat.ClusterEnd.Sub(req.Stat.ClusterStart).Nanoseconds() / 1000000
        msg := fmt.Sprintf("%d", ms)
        buff.WriteString(msg)

        return nil</span>
}

func onLogFmtClusterName(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
        req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov0" title="0">{
        if req == nil </span><span class="cov0" title="0">{
                return errors.New("req is nil")
        }</span>

        <span class="cov0" title="0">msg := "-"
        if req.Backend.ClusterName != "" </span><span class="cov0" title="0">{
                msg = req.Backend.ClusterName
        }</span>
        <span class="cov0" title="0">buff.WriteString(msg)

        return nil</span>
}

func onLogFmtConnectBackendTime(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
        req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov0" title="0">{
        if req == nil || req.OutRequest == nil </span><span class="cov0" title="0">{
                return errors.New("req is nil")
        }</span>
        <span class="cov0" title="0">if req.OutRequest.State == nil </span><span class="cov0" title="0">{
                return errors.New("req.OutRequest.State is nil")
        }</span>

        <span class="cov0" title="0">msg := "-"
        stat := req.OutRequest.State
        ms := stat.ConnectBackendEnd.Sub(stat.ConnectBackendStart).Nanoseconds() / 1000000
        if ms &gt;= 0 </span><span class="cov0" title="0">{
                msg = fmt.Sprintf("%d", ms)
        }</span>

        <span class="cov0" title="0">buff.WriteString(msg)

        return nil</span>
}

func onLogFmtHost(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
        req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov0" title="0">{
        if req == nil </span><span class="cov0" title="0">{
                return errors.New("req is nil")
        }</span>
        <span class="cov0" title="0">if req.HttpRequest == nil </span><span class="cov0" title="0">{
                return errors.New("req.HttpRequest is nil")
        }</span>

        <span class="cov0" title="0">buff.WriteString(req.HttpRequest.Host)

        return nil</span>
}

func onLogFmtIsTrustip(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
        req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov0" title="0">{
        if req == nil </span><span class="cov0" title="0">{
                return errors.New("req is nil")
        }</span>

        <span class="cov0" title="0">msg := fmt.Sprintf("%v", req.Session.TrustSource())
        buff.WriteString(msg)

        return nil</span>
}

func onLogFmtLastBackendDuration(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
        req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov0" title="0">{
        if req == nil </span><span class="cov0" title="0">{
                return errors.New("req is nil")
        }</span>
        <span class="cov0" title="0">if req.Stat == nil </span><span class="cov0" title="0">{
                return errors.New("req.Stat is nil")
        }</span>

        <span class="cov0" title="0">ms := req.Stat.BackendEnd.Sub(req.Stat.BackendStart).Nanoseconds() / 1000000
        msg := fmt.Sprintf("%d", ms)
        buff.WriteString(msg)

        return nil</span>
}

func onLogFmtLogId(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
        req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov0" title="0">{
        if req == nil </span><span class="cov0" title="0">{
                return errors.New("req is nil")
        }</span>

        <span class="cov0" title="0">msg := req.LogId
        buff.WriteString(msg)

        return nil</span>
}

func onLogFmtNthReqInSession(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
        req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov0" title="0">{
        if req == nil </span><span class="cov0" title="0">{
                return errors.New("req is nil")
        }</span>

        <span class="cov0" title="0">msg := "-"
        if req.HttpRequest != nil &amp;&amp; req.HttpRequest.State != nil </span><span class="cov0" title="0">{
                msg = fmt.Sprintf("%d", req.HttpRequest.State.SerialNumber)
        }</span>
        <span class="cov0" title="0">buff.WriteString(msg)

        return nil</span>
}

func onLogFmtStatusCode(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
        req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov0" title="0">{
        if req == nil </span><span class="cov0" title="0">{
                return errors.New("req is nil")
        }</span>

        <span class="cov0" title="0">msg := "-"
        if res != nil </span><span class="cov0" title="0">{
                msg = fmt.Sprintf("%d", res.StatusCode)
        }</span>
        <span class="cov0" title="0">buff.WriteString(msg)

        return nil</span>
}

func onLogFmtProduct(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
        req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov0" title="0">{
        if req == nil </span><span class="cov0" title="0">{
                return errors.New("req is nil")
        }</span>

        <span class="cov0" title="0">msg := "-"
        if req.Route.Product != "" </span><span class="cov0" title="0">{
                msg = req.Route.Product
        }</span>

        <span class="cov0" title="0">buff.WriteString(msg)

        return nil</span>
}

func onLogFmtProxyDelayTime(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
        req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov0" title="0">{
        if req == nil </span><span class="cov0" title="0">{
                return errors.New("req is nil")
        }</span>
        <span class="cov0" title="0">if req.Stat == nil </span><span class="cov0" title="0">{
                return errors.New("req.Stat is nil")
        }</span>

        <span class="cov0" title="0">msg := "-"
        if !req.Stat.BackendFirst.IsZero() </span><span class="cov0" title="0">{
                ms := req.Stat.BackendFirst.Sub(req.Stat.ReadReqEnd).Nanoseconds() / 1000000
                msg = fmt.Sprintf("%d", ms)
        }</span>
        <span class="cov0" title="0">buff.WriteString(msg)

        return nil</span>
}

func onLogFmtReadReqDuration(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
        req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov0" title="0">{
        if req == nil </span><span class="cov0" title="0">{
                return errors.New("req is nil")
        }</span>
        <span class="cov0" title="0">if req.Stat == nil </span><span class="cov0" title="0">{
                return errors.New("req.Stat is nil")
        }</span>

        <span class="cov0" title="0">ms := req.Stat.ReadReqEnd.Sub(req.Stat.ReadReqStart).Nanoseconds() / 1000000
        msg := fmt.Sprintf("%d", ms)
        buff.WriteString(msg)

        return nil</span>
}

func onLogFmtReadWriteSrvTime(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
        req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov0" title="0">{
        if req == nil </span><span class="cov0" title="0">{
                return errors.New("req is nil")
        }</span>
        <span class="cov0" title="0">if req.Stat == nil </span><span class="cov0" title="0">{
                return errors.New("req.Stat is nil")
        }</span>

        <span class="cov0" title="0">msg := "-"
        if !req.Stat.BackendStart.IsZero() </span><span class="cov0" title="0">{
                now := time.Now()
                ms := now.Sub(req.Stat.BackendStart).Nanoseconds() / 1000000
                msg = fmt.Sprintf("%d", ms)
        }</span>

        <span class="cov0" title="0">buff.WriteString(msg)

        return nil</span>
}

func onLogFmtRedirect(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
        req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov0" title="0">{
        if req == nil </span><span class="cov0" title="0">{
                return errors.New("req is nil")
        }</span>

        <span class="cov0" title="0">msg := "-"
        if req.Redirect.Url != "" </span><span class="cov0" title="0">{
                msg = fmt.Sprintf("%s,%d", req.Redirect.Url, req.Redirect.Code)
        }</span>
        <span class="cov0" title="0">buff.WriteString(msg)

        return nil</span>
}

func onLogFmtClientIp(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
        req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov0" title="0">{
        if req == nil </span><span class="cov0" title="0">{
                return errors.New("req is nil")
        }</span>

        <span class="cov0" title="0">msg := "-"
        if req.RemoteAddr != nil </span><span class="cov0" title="0">{
                msg = req.RemoteAddr.IP.String()
        }</span>
        <span class="cov0" title="0">buff.WriteString(msg)

        return nil</span>
}

func onLogFmtReqCookie(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
        req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov0" title="0">{
        if req == nil </span><span class="cov0" title="0">{
                return errors.New("req is nil")
        }</span>

        <span class="cov0" title="0">msg := "-"
        if co, ok := req.Cookie(logItem.Key); ok </span><span class="cov0" title="0">{
                msg = co.Value
        }</span>
        <span class="cov0" title="0">buff.WriteString(msg)

        return nil</span>
}

func onLogFmtErrorCode(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
        req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov0" title="0">{
        if req == nil </span><span class="cov0" title="0">{
                return errors.New("req is nil")
        }</span>

        <span class="cov0" title="0">msg := buildErrorMsg(req.ErrCode, req.ErrMsg)
        buff.WriteString(msg)

        return nil</span>
}

func onLogFmtReqHeaderLen(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
        req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov0" title="0">{
        if req == nil </span><span class="cov0" title="0">{
                return errors.New("req is nil")
        }</span>
        <span class="cov0" title="0">if req.Stat == nil </span><span class="cov0" title="0">{
                return errors.New("req.Stat is nil")
        }</span>

        <span class="cov0" title="0">msg := fmt.Sprintf("%d", req.Stat.HeaderLenIn)
        buff.WriteString(msg)

        return nil</span>
}

func onLogFmtRequestHeader(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
        req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov0" title="0">{
        if req == nil </span><span class="cov0" title="0">{
                return errors.New("req is nil")
        }</span>
        <span class="cov0" title="0">if req.HttpRequest == nil </span><span class="cov0" title="0">{
                return errors.New("req.HttpRequest is nil")
        }</span>

        <span class="cov0" title="0">msg := "-"
        if data := req.HttpRequest.Header.Get(logItem.Key); data != "" </span><span class="cov0" title="0">{
                msg = data
        }</span>
        <span class="cov0" title="0">buff.WriteString(msg)

        return nil</span>
}

func onLogFmtRequestUri(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
        req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov0" title="0">{
        if req == nil </span><span class="cov0" title="0">{
                return errors.New("req is nil")
        }</span>
        <span class="cov0" title="0">if req.HttpRequest == nil </span><span class="cov0" title="0">{
                return errors.New("req.HttpRequest is nil")
        }</span>

        <span class="cov0" title="0">buff.WriteString(req.HttpRequest.RequestURI)

        return nil</span>
}

func onLogFmtResCookie(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
        req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov0" title="0">{
        if req == nil </span><span class="cov0" title="0">{
                return errors.New("req is nil")
        }</span>

        <span class="cov0" title="0">if res == nil </span><span class="cov0" title="0">{
                buff.WriteString("-")
                return nil
        }</span>

        <span class="cov0" title="0">msg := "-"
        cookies := res.Cookies()
        for _, co := range cookies </span><span class="cov0" title="0">{
                if co.Name == logItem.Key </span><span class="cov0" title="0">{
                        msg = co.Value
                        break</span>
                }
        }

        <span class="cov0" title="0">buff.WriteString(msg)

        return nil</span>
}

func onLogFmtResDuration(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
        req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov0" title="0">{
        if req == nil </span><span class="cov0" title="0">{
                return errors.New("req is nil")
        }</span>
        <span class="cov0" title="0">if req.Stat == nil </span><span class="cov0" title="0">{
                return errors.New("req.Stat is nil")
        }</span>

        <span class="cov0" title="0">ms := req.Stat.ResponseEnd.Sub(req.Stat.ResponseStart).Nanoseconds() / 1000000
        msg := fmt.Sprintf("%d", ms)
        buff.WriteString(msg)

        return nil</span>
}

func onLogFmtResProto(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
        req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov0" title="0">{
        if req == nil </span><span class="cov0" title="0">{
                return errors.New("req is nil")
        }</span>

        <span class="cov0" title="0">msg := "-"
        if res != nil </span><span class="cov0" title="0">{
                msg = res.Proto
        }</span>
        <span class="cov0" title="0">buff.WriteString(msg)

        return nil</span>
}

func onLogFmtResponseHeader(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
        req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov0" title="0">{
        if req == nil </span><span class="cov0" title="0">{
                return errors.New("req is nil")
        }</span>

        <span class="cov0" title="0">if res == nil </span><span class="cov0" title="0">{
                buff.WriteString("-")
                return nil
        }</span>

        <span class="cov0" title="0">msg := "-"
        data, found := res.Header[logItem.Key]
        if found </span><span class="cov0" title="0">{
                msg = strings.Join(data, ",")
        }</span>
        <span class="cov0" title="0">buff.WriteString(msg)

        return nil</span>
}

func onLogFmtResHeaderLen(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
        req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov0" title="0">{
        if req == nil </span><span class="cov0" title="0">{
                return errors.New("req is nil")
        }</span>

        <span class="cov0" title="0">if req.Stat == nil </span><span class="cov0" title="0">{
                return errors.New("req.Stat is nil")
        }</span>

        <span class="cov0" title="0">msg := "-"
        if res != nil </span><span class="cov0" title="0">{
                msg = fmt.Sprintf("%d", req.Stat.HeaderLenOut)
        }</span>

        <span class="cov0" title="0">buff.WriteString(msg)

        return nil</span>
}

func onLogFmtResLen(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
        req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov0" title="0">{
        if req == nil </span><span class="cov0" title="0">{
                return errors.New("req is nil")
        }</span>
        <span class="cov0" title="0">if req.Stat == nil </span><span class="cov0" title="0">{
                return errors.New("req.Stat is nil")
        }</span>

        <span class="cov0" title="0">msg := "-"
        if res != nil </span><span class="cov0" title="0">{
                msg = fmt.Sprintf("%d", req.Stat.HeaderLenOut+req.Stat.BodyLenOut)
        }</span>
        <span class="cov0" title="0">buff.WriteString(msg)
        return nil</span>
}

func onLogFmtResStatus(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
        req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov0" title="0">{
        if req == nil </span><span class="cov0" title="0">{
                return errors.New("req is nil")
        }</span>

        <span class="cov0" title="0">msg := "-"
        if res != nil </span><span class="cov0" title="0">{
                msg = res.Status
        }</span>
        <span class="cov0" title="0">buff.WriteString(msg)

        return nil</span>
}

func onLogFmtRetryNum(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
        req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov0" title="0">{
        if req == nil </span><span class="cov0" title="0">{
                return errors.New("req is nil")
        }</span>

        <span class="cov0" title="0">msg := fmt.Sprintf("%d", req.RetryTime)
        buff.WriteString(msg)

        return nil</span>
}

func onLogFmtServerAddr(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
        req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov0" title="0">{
        if req == nil </span><span class="cov0" title="0">{
                return errors.New("req is nil")
        }</span>

        <span class="cov0" title="0">msg := "-"
        if req.Connection != nil </span><span class="cov0" title="0">{
                msg = req.Connection.LocalAddr().String()
        }</span>
        <span class="cov0" title="0">buff.WriteString(msg)

        return nil</span>
}

func onLogFmtSinceSessionTime(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
        req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov0" title="0">{
        if req == nil </span><span class="cov0" title="0">{
                return errors.New("req is nil")
        }</span>

        <span class="cov0" title="0">if req.Session == nil </span><span class="cov0" title="0">{
                return errors.New("req.Session is nil")
        }</span>

        <span class="cov0" title="0">ms := time.Since(req.Session.StartTime).Nanoseconds() / 1000000
        msg := fmt.Sprintf("%d", ms)
        buff.WriteString(msg)

        return nil</span>
}

func onLogFmtSubclusterName(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
        req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov0" title="0">{
        if req == nil </span><span class="cov0" title="0">{
                return errors.New("req is nil")
        }</span>

        <span class="cov0" title="0">buff.WriteString(req.Backend.SubclusterName)

        return nil</span>
}

func onLogFmtTime(m *ModuleAccess, buff *bytes.Buffer) error <span class="cov0" title="0">{
        now := time.Now()
        timeNowStr := fmt.Sprintf("%04d-%02d-%02d %02d:%02d:%02d",
                now.Year(), now.Month(), now.Day(),
                now.Hour(), now.Minute(), now.Second())
        buff.WriteString(timeNowStr)

        return nil
}</span>

func onLogFmtVip(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
        req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov0" title="0">{
        if req == nil </span><span class="cov0" title="0">{
                return errors.New("req is nil")
        }</span>

        <span class="cov0" title="0">msg := "-"
        if req.Session.Vip != nil </span><span class="cov0" title="0">{
                if vip := req.Session.Vip.String(); len(vip) != 0 </span><span class="cov0" title="0">{
                        msg = vip
                }</span>
        }
        <span class="cov0" title="0">buff.WriteString(msg)

        return nil</span>
}

func onLogFmtUrl(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
        req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov0" title="0">{
        if req == nil </span><span class="cov0" title="0">{
                return errors.New("req is nil")
        }</span>
        <span class="cov0" title="0">if req.HttpRequest == nil </span><span class="cov0" title="0">{
                return errors.New("req.HttpRequest is nil")
        }</span>

        <span class="cov0" title="0">buff.WriteString(req.HttpRequest.URL.String())

        return nil</span>
}

func onLogFmtWriteSrvTime(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
        req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov0" title="0">{
        if req == nil </span><span class="cov0" title="0">{
                return errors.New("req is nil")
        }</span>
        <span class="cov0" title="0">if req.Stat == nil </span><span class="cov0" title="0">{
                return errors.New("req.Stat is nil")
        }</span>

        <span class="cov0" title="0">ms := req.Stat.BackendEnd.Sub(req.Stat.BackendStart).Nanoseconds() / 1000000
        msg := fmt.Sprintf("%d", ms)
        buff.WriteString(msg)

        return nil</span>
}
</pre>
		
		<pre class="file" id="file75" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_access

import (
        "bytes"
        "encoding/hex"
        "errors"
        "fmt"
)

import (
        "github.com/bfenetworks/bfe/bfe_basic"
)

func onLogFmtSesClientIp(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
        session *bfe_basic.Session) error <span class="cov0" title="0">{
        if session == nil </span><span class="cov0" title="0">{
                return errors.New("session is nil")
        }</span>

        <span class="cov0" title="0">buff.WriteString(session.RemoteAddr.String())

        return nil</span>
}

func onLogFmtSesEndTime(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
        session *bfe_basic.Session) error <span class="cov0" title="0">{
        if session == nil </span><span class="cov0" title="0">{
                return errors.New("session is nil")
        }</span>

        <span class="cov0" title="0">buff.WriteString(session.EndTime.String())

        return nil</span>
}

func buildErrorMsg(err error, errMsg string) string <span class="cov0" title="0">{
        msg := "-"
        if err != nil </span><span class="cov0" title="0">{
                msg = err.Error()
                if len(errMsg) != 0 </span><span class="cov0" title="0">{
                        msg += "," + errMsg
                }</span>
        }

        <span class="cov0" title="0">return msg</span>
}

func onLogFmtSesErrorCode(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
        session *bfe_basic.Session) error <span class="cov0" title="0">{
        if session == nil </span><span class="cov0" title="0">{
                return errors.New("session is nil")
        }</span>

        <span class="cov0" title="0">errMsg, errCode := session.GetError()
        msg := buildErrorMsg(errCode, errMsg)
        buff.WriteString(msg)

        return nil</span>
}

func onLogFmtSesIsSecure(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
        session *bfe_basic.Session) error <span class="cov0" title="0">{
        if session == nil </span><span class="cov0" title="0">{
                return errors.New("session is nil")
        }</span>

        <span class="cov0" title="0">msg := fmt.Sprintf("%v", session.IsSecure)
        buff.WriteString(msg)

        return nil</span>
}

func onLogFmtSesKeepAliveNum(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
        session *bfe_basic.Session) error <span class="cov0" title="0">{
        if session == nil </span><span class="cov0" title="0">{
                return errors.New("session is nil")
        }</span>

        <span class="cov0" title="0">msg := fmt.Sprintf("%d", session.ReqNum())
        buff.WriteString(msg)

        return nil</span>
}

func onLogFmtSesOverhead(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
        session *bfe_basic.Session) error <span class="cov0" title="0">{
        if session == nil </span><span class="cov0" title="0">{
                return errors.New("session is nil")
        }</span>

        <span class="cov0" title="0">msg := session.Overhead.String()
        buff.WriteString(msg)

        return nil</span>
}

func onLogFmtSesReadTotal(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
        session *bfe_basic.Session) error <span class="cov0" title="0">{
        if session == nil </span><span class="cov0" title="0">{
                return errors.New("session is nil")
        }</span>

        <span class="cov0" title="0">msg := fmt.Sprintf("%d", session.ReadTotal())
        buff.WriteString(msg)

        return nil</span>
}

func onLogFmtSesTLSClientRandom(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
        session *bfe_basic.Session) error <span class="cov0" title="0">{
        if session == nil </span><span class="cov0" title="0">{
                return errors.New("session is nil")
        }</span>

        <span class="cov0" title="0">msg := "-"
        if session.TlsState != nil </span><span class="cov0" title="0">{
                msg = hex.EncodeToString(session.TlsState.ClientRandom)
        }</span>
        <span class="cov0" title="0">buff.WriteString(msg)

        return nil</span>
}

func onLogFmtSesTLSServerRandom(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
        session *bfe_basic.Session) error <span class="cov0" title="0">{
        if session == nil </span><span class="cov0" title="0">{
                return errors.New("session is nil")
        }</span>

        <span class="cov0" title="0">msg := "-"
        if session.TlsState != nil </span><span class="cov0" title="0">{
                msg = hex.EncodeToString(session.TlsState.ServerRandom)
        }</span>
        <span class="cov0" title="0">buff.WriteString(msg)

        return nil</span>
}

func onLogFmtSesUse100(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
        session *bfe_basic.Session) error <span class="cov0" title="0">{
        if session == nil </span><span class="cov0" title="0">{
                return errors.New("session is nil")
        }</span>

        <span class="cov0" title="0">msg := fmt.Sprintf("%v", session.Use100Continue)
        buff.WriteString(msg)

        return nil</span>
}

func onLogFmtSesWriteTotal(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
        session *bfe_basic.Session) error <span class="cov0" title="0">{
        if session == nil </span><span class="cov0" title="0">{
                return errors.New("session is nil")
        }</span>

        <span class="cov0" title="0">msg := fmt.Sprintf("%d", session.WriteTotal())
        buff.WriteString(msg)

        return nil</span>
}

func onLogFmtSesStartTime(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
        session *bfe_basic.Session) error <span class="cov0" title="0">{
        if session == nil </span><span class="cov0" title="0">{
                return errors.New("session is nil")
        }</span>

        <span class="cov0" title="0">buff.WriteString(session.StartTime.String())

        return nil</span>
}
</pre>
		
		<pre class="file" id="file76" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_auth_basic

import (
        "bufio"
        "fmt"
        "os"
        "strings"
)

import (
        "github.com/bfenetworks/bfe/bfe_basic/condition"
        "github.com/bfenetworks/bfe/bfe_util/json"
)

type AuthBasicRuleFile struct {
        Cond     string
        UserFile string
        Realm    string
}

type AuthBasicRule struct {
        Cond       condition.Condition
        UserPasswd map[string]string
        Realm      string
}

type RuleFileList []AuthBasicRuleFile
type RuleList []AuthBasicRule

type ProductRulesFile map[string]*RuleFileList
type ProductRules map[string]*RuleList

type AuthBasicConfFile struct {
        Version *string
        Config  *ProductRulesFile
}

type AuthBasicConf struct {
        Version string
        Config  ProductRules
}

func readUserFile(filename string) (map[string]string, error) <span class="cov8" title="1">{
        file, err := os.Open(filename)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        userPasswd := make(map[string]string)
        scanner := bufio.NewScanner(file)
        for scanner.Scan() </span><span class="cov8" title="1">{
                line := strings.Trim(scanner.Text(), " \t")
                if len(line) == 0 || strings.Contains(line, "#") </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">parts := strings.Split(line, ":")
                if len(parts) != 2 &amp;&amp; len(parts) != 3 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("Format error, \"%s\".", line)
                }</span>

                <span class="cov8" title="1">userPasswd[strings.TrimSpace(parts[0])] = strings.TrimSpace(parts[1])</span>
        }

        <span class="cov8" title="1">return userPasswd, nil</span>
}

func AuthBasicRuleCheck(conf AuthBasicRuleFile) error <span class="cov8" title="1">{
        if len(conf.Cond) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("Cond empty.")
        }</span>

        <span class="cov8" title="1">if len(conf.UserFile) == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("UserFile empty.")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func RuleListCheck(conf *RuleFileList) error <span class="cov8" title="1">{
        for index, rule := range *conf </span><span class="cov8" title="1">{
                err := AuthBasicRuleCheck(rule)
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("AuthBasicRule: %d, %v", index, err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func ProductRulesCheck(conf *ProductRulesFile) error <span class="cov8" title="1">{
        for product, ruleList := range *conf </span><span class="cov8" title="1">{
                if ruleList == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("no RuleList for product: %s", product)
                }</span>

                <span class="cov8" title="1">err := RuleListCheck(ruleList)
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("invalid product rules:%s, %v", product, err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func AuthBasicConfCheck(conf AuthBasicConfFile) error <span class="cov8" title="1">{
        var err error

        if conf.Version == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("no Version")
        }</span>

        <span class="cov8" title="1">if conf.Config == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("no Config")
        }</span>

        <span class="cov8" title="1">err = ProductRulesCheck(conf.Config)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("Config: %v", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func ruleConvert(ruleFile AuthBasicRuleFile) (AuthBasicRule, error) <span class="cov8" title="1">{
        rule := AuthBasicRule{}

        cond, err := condition.Build(ruleFile.Cond)
        if err != nil </span><span class="cov0" title="0">{
                return rule, err
        }</span>

        <span class="cov8" title="1">rule.Cond = cond
        rule.UserPasswd, err = readUserFile(ruleFile.UserFile)
        if err != nil </span><span class="cov0" title="0">{
                return rule, err
        }</span>
        <span class="cov8" title="1">rule.Realm = ruleFile.Realm
        if len(rule.Realm) == 0 </span><span class="cov0" title="0">{
                rule.Realm = "Restricted"
        }</span>

        <span class="cov8" title="1">return rule, nil</span>
}

func ruleListConvert(ruleFileList *RuleFileList) (*RuleList, error) <span class="cov8" title="1">{
        ruleList := new(RuleList)
        *ruleList = make([]AuthBasicRule, 0)

        for _, ruleFile := range *ruleFileList </span><span class="cov8" title="1">{
                rule, err := ruleConvert(ruleFile)
                if err != nil </span><span class="cov0" title="0">{
                        return ruleList, err
                }</span>
                <span class="cov8" title="1">*ruleList = append(*ruleList, rule)</span>
        }

        <span class="cov8" title="1">return ruleList, nil</span>
}

func AuthBasicConfLoad(filename string) (AuthBasicConf, error) <span class="cov8" title="1">{
        var conf AuthBasicConf

        file, err := os.Open(filename)
        if err != nil </span><span class="cov0" title="0">{
                return conf, err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        decoder := json.NewDecoder(file)

        var config AuthBasicConfFile
        err = decoder.Decode(&amp;config)
        if err != nil </span><span class="cov0" title="0">{
                return conf, err
        }</span>

        <span class="cov8" title="1">err = AuthBasicConfCheck(config)
        if err != nil </span><span class="cov8" title="1">{
                return conf, err
        }</span>

        <span class="cov8" title="1">conf.Version = *config.Version
        conf.Config = make(ProductRules)

        for product, ruleFileList := range *config.Config </span><span class="cov8" title="1">{
                ruleList, err := ruleListConvert(ruleFileList)
                if err != nil </span><span class="cov0" title="0">{
                        return conf, err
                }</span>
                <span class="cov8" title="1">conf.Config[product] = ruleList</span>
        }

        <span class="cov8" title="1">return conf, nil</span>
}
</pre>
		
		<pre class="file" id="file77" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_auth_basic

import (
        "sync"
)

type AuthBasicRuleTable struct {
        lock         sync.RWMutex
        version      string
        productRules ProductRules
}

func NewAuthBasicRuleTable() *AuthBasicRuleTable <span class="cov8" title="1">{
        t := new(AuthBasicRuleTable)
        t.productRules = make(ProductRules)
        return t
}</span>

func (t *AuthBasicRuleTable) Update(conf AuthBasicConf) <span class="cov8" title="1">{
        t.lock.Lock()
        t.version = conf.Version
        t.productRules = conf.Config
        t.lock.Unlock()
}</span>

func (t *AuthBasicRuleTable) Search(product string) (*RuleList, bool) <span class="cov8" title="1">{
        t.lock.RLock()
        productRules := t.productRules
        t.lock.RUnlock()

        rules, ok := productRules[product]
        return rules, ok
}</span>
</pre>
		
		<pre class="file" id="file78" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_auth_basic

import (
        "github.com/baidu/go-lib/log"
        gcfg "gopkg.in/gcfg.v1"
)

import (
        "github.com/bfenetworks/bfe/bfe_util"
)

type ConfModAuthBasic struct {
        Basic struct {
                DataPath string
        }

        Log struct {
                OpenDebug bool
        }
}

func ConfLoad(filePath string, confRoot string) (*ConfModAuthBasic, error) <span class="cov8" title="1">{
        var err error
        var cfg ConfModAuthBasic

        err = gcfg.ReadFileInto(&amp;cfg, filePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">err = cfg.Check(confRoot)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;cfg, nil</span>
}

func (cfg *ConfModAuthBasic) Check(confRoot string) error <span class="cov8" title="1">{
        if cfg.Basic.DataPath == "" </span><span class="cov0" title="0">{
                log.Logger.Warn("ModAuthBasic.DataPath not set, use default value")
                cfg.Basic.DataPath = "mod_auth_basic/auth_basic_rule.data"
        }</span>

        <span class="cov8" title="1">cfg.Basic.DataPath = bfe_util.ConfPathProc(cfg.Basic.DataPath, confRoot)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file79" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_auth_basic

import (
        "fmt"
        "net/url"
)

import (
        auth "github.com/abbot/go-http-auth"
        "github.com/baidu/go-lib/log"
        "github.com/baidu/go-lib/web-monitor/metrics"
        "github.com/baidu/go-lib/web-monitor/web_monitor"
)

import (
        "github.com/bfenetworks/bfe/bfe_basic"
        "github.com/bfenetworks/bfe/bfe_http"
        "github.com/bfenetworks/bfe/bfe_module"
)

const (
        ModAuthBasic = "mod_auth_basic"
)

type ModuleAuthBasicState struct {
        ReqAuthRuleHit   *metrics.Counter
        ReqAuthChallenge *metrics.Counter
        ReqAuthSuccess   *metrics.Counter
        ReqAuthFailure   *metrics.Counter
}

type ModuleAuthBasic struct {
        name       string
        state      ModuleAuthBasicState
        metrics    metrics.Metrics
        configPath string
        ruleTable  *AuthBasicRuleTable
}

var (
        openDebug = false
)

func NewModuleAuthBasic() *ModuleAuthBasic <span class="cov8" title="1">{
        m := new(ModuleAuthBasic)
        m.name = ModAuthBasic
        m.metrics.Init(&amp;m.state, ModAuthBasic, 0)
        m.ruleTable = NewAuthBasicRuleTable()
        return m
}</span>

func (m *ModuleAuthBasic) Name() string <span class="cov0" title="0">{
        return m.name
}</span>

func (m *ModuleAuthBasic) loadConfData(query url.Values) error <span class="cov8" title="1">{
        path := query.Get("path")
        if path == "" </span><span class="cov8" title="1">{
                path = m.configPath
        }</span>

        <span class="cov8" title="1">conf, err := AuthBasicConfLoad(path)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error in AuthBasicConfLoad(%s): %v", path, err)
        }</span>

        <span class="cov8" title="1">m.ruleTable.Update(conf)
        return nil</span>
}

func (m *ModuleAuthBasic) getState(params map[string][]string) ([]byte, error) <span class="cov0" title="0">{
        s := m.metrics.GetAll()
        return s.Format(params)
}</span>

func (m *ModuleAuthBasic) getStateDiff(params map[string][]string) ([]byte, error) <span class="cov0" title="0">{
        s := m.metrics.GetDiff()
        return s.Format(params)
}</span>

func (m *ModuleAuthBasic) monitorHandlers() map[string]interface{} <span class="cov8" title="1">{
        handlers := map[string]interface{}{
                m.name:           m.getState,
                m.name + ".diff": m.getStateDiff,
        }
        return handlers
}</span>

func (m *ModuleAuthBasic) checkAuthCredentials(req *bfe_basic.Request,
        rule *AuthBasicRule) bool <span class="cov8" title="1">{
        httpRequest := req.HttpRequest
        username, passwd, ok := httpRequest.BasicAuth()
        if !ok </span><span class="cov8" title="1">{
                m.state.ReqAuthChallenge.Inc(1)
                return false
        }</span>
        <span class="cov8" title="1">if openDebug </span><span class="cov8" title="1">{
                log.Logger.Debug("%s check auth, username[%s], passwd[%s]", m.name, username, passwd)
        }</span>

        <span class="cov8" title="1">hashedPasswd, ok := rule.UserPasswd[username]
        if !ok </span><span class="cov0" title="0">{
                if openDebug </span><span class="cov0" title="0">{
                        log.Logger.Debug("%s check passwd, no username[%s]", m.name, username)
                }</span>
                <span class="cov0" title="0">m.state.ReqAuthFailure.Inc(1)
                return false</span>
        }

        <span class="cov8" title="1">if !auth.CheckSecret(passwd, hashedPasswd) </span><span class="cov0" title="0">{
                m.state.ReqAuthFailure.Inc(1)
                return false
        }</span>

        <span class="cov8" title="1">m.state.ReqAuthSuccess.Inc(1)
        return true</span>
}

func (m *ModuleAuthBasic) createUnauthorizedResp(req *bfe_basic.Request,
        rule *AuthBasicRule) *bfe_http.Response <span class="cov8" title="1">{
        resp := bfe_basic.CreateInternalResp(req, bfe_http.StatusUnauthorized)
        resp.Header.Set("WWW-Authenticate", fmt.Sprintf("Basic realm=\"%s\"", rule.Realm))
        return resp
}</span>

func (m *ModuleAuthBasic) authBasicHandler(req *bfe_basic.Request) (int, *bfe_http.Response) <span class="cov8" title="1">{
        rules, ok := m.ruleTable.Search(req.Route.Product)
        if !ok </span><span class="cov0" title="0">{
                return bfe_module.BfeHandlerGoOn, nil
        }</span>

        <span class="cov8" title="1">for _, rule := range *rules </span><span class="cov8" title="1">{
                if rule.Cond.Match(req) </span><span class="cov8" title="1">{
                        m.state.ReqAuthRuleHit.Inc(1)

                        if !m.checkAuthCredentials(req, &amp;rule) </span><span class="cov8" title="1">{
                                return bfe_module.BfeHandlerResponse, m.createUnauthorizedResp(req, &amp;rule)
                        }</span>
                        <span class="cov8" title="1">return bfe_module.BfeHandlerGoOn, nil</span>
                }
        }

        <span class="cov8" title="1">return bfe_module.BfeHandlerGoOn, nil</span>
}

func (m *ModuleAuthBasic) Init(cbs *bfe_module.BfeCallbacks, whs *web_monitor.WebHandlers,
        cr string) error <span class="cov8" title="1">{
        var err error
        var cfg *ConfModAuthBasic

        confPath := bfe_module.ModConfPath(cr, m.name)
        if cfg, err = ConfLoad(confPath, cr); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: conf load err: %v", m.name, err)
        }</span>

        <span class="cov8" title="1">m.configPath = cfg.Basic.DataPath
        openDebug = cfg.Log.OpenDebug

        if err = m.loadConfData(nil); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("err in loadConfData(): %v", err)
        }</span>

        <span class="cov8" title="1">err = cbs.AddFilter(bfe_module.HandleFoundProduct, m.authBasicHandler)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init(): AddFilter(m.authBasicHandler): %v", m.name, err)
        }</span>

        <span class="cov8" title="1">err = web_monitor.RegisterHandlers(whs, web_monitor.WebHandleMonitor, m.monitorHandlers())
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init():RegisterHandlers(m.monitorHandlers): %v", m.name, err)
        }</span>

        <span class="cov8" title="1">err = whs.RegisterHandler(web_monitor.WebHandleReload, m.name, m.loadConfData)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init(): RegisterHandler(m.loadConfData): %v", m.name, err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file80" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_auth_jwt

import (
        "fmt"
        "io/ioutil"
        "os"
)

import (
        "github.com/golang-jwt/jwt"
        jose "gopkg.in/square/go-jose.v2"
)

import (
        "github.com/bfenetworks/bfe/bfe_basic/condition"
        "github.com/bfenetworks/bfe/bfe_util/json"
)

type AuthJWTRuleFile struct {
        Cond    string
        KeyFile string // JSON Web Key file
        Realm   string // security realm
}

type keyProvider struct {
        key *jose.JSONWebKey
}

func (p *keyProvider) provideKey(token *jwt.Token) (interface{}, error) <span class="cov8" title="1">{
        return p.key.Key, nil
}</span>

type AuthJWTRule struct {
        Cond  condition.Condition
        Keys  []keyProvider
        Realm string
}

type RuleFileList []AuthJWTRuleFile
type RuleList []AuthJWTRule

type ProductRulesFile map[string]*RuleFileList
type ProductRules map[string]*RuleList

type AuthJWTConfFile struct {
        Version *string
        Config  *ProductRulesFile
}

type AuthJWTConf struct {
        Version string
        Config  ProductRules
}

// Read JSON Web Key file.
// The file must follow the format described by https://tools.ietf.org/html/rfc7517s
func readKeyFile(filename string) ([]keyProvider, error) <span class="cov8" title="1">{
        var keyProviders []keyProvider
        var keys []*jose.JSONWebKey

        data, err := ioutil.ReadFile(filename)
        if err != nil </span><span class="cov0" title="0">{
                return keyProviders, err
        }</span>

        <span class="cov8" title="1">err = json.Unmarshal(data, &amp;keys)
        if err != nil </span><span class="cov8" title="1">{
                return keyProviders, err
        }</span>

        <span class="cov8" title="1">for _, key := range keys </span><span class="cov8" title="1">{
                keyProviders = append(keyProviders, keyProvider{key: key})
        }</span>

        <span class="cov8" title="1">return keyProviders, nil</span>
}

func AuthJWTRuleCheck(conf AuthJWTRuleFile) error <span class="cov8" title="1">{
        if len(conf.Cond) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("Cond empty.")
        }</span>

        <span class="cov8" title="1">if len(conf.KeyFile) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("KeyFile empty.")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func RuleListCheck(conf *RuleFileList) error <span class="cov8" title="1">{
        for index, rule := range *conf </span><span class="cov8" title="1">{
                err := AuthJWTRuleCheck(rule)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("AuthJWTRule: %d, %v", index, err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func ProductRulesCheck(conf *ProductRulesFile) error <span class="cov8" title="1">{
        for product, ruleList := range *conf </span><span class="cov8" title="1">{
                if ruleList == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("no RuleList for product: %s", product)
                }</span>

                <span class="cov8" title="1">err := RuleListCheck(ruleList)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid product rules:%s, %v", product, err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func AuthJWTConfCheck(conf AuthJWTConfFile) error <span class="cov8" title="1">{
        var err error

        if conf.Version == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("no Version")
        }</span>

        <span class="cov8" title="1">if conf.Config == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("no Config")
        }</span>

        <span class="cov8" title="1">err = ProductRulesCheck(conf.Config)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Config: %v", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func ruleConvert(ruleFile AuthJWTRuleFile) (AuthJWTRule, error) <span class="cov8" title="1">{
        rule := AuthJWTRule{}

        cond, err := condition.Build(ruleFile.Cond)
        if err != nil </span><span class="cov0" title="0">{
                return rule, err
        }</span>

        <span class="cov8" title="1">rule.Cond = cond
        rule.Keys, err = readKeyFile(ruleFile.KeyFile)
        if err != nil </span><span class="cov8" title="1">{
                return rule, err
        }</span>
        <span class="cov8" title="1">rule.Realm = ruleFile.Realm
        if len(rule.Realm) == 0 </span><span class="cov0" title="0">{
                rule.Realm = "Restricted"
        }</span>

        <span class="cov8" title="1">return rule, nil</span>
}

func ruleListConvert(ruleFileList *RuleFileList) (*RuleList, error) <span class="cov8" title="1">{
        ruleList := new(RuleList)
        *ruleList = make([]AuthJWTRule, 0)

        for _, ruleFile := range *ruleFileList </span><span class="cov8" title="1">{
                rule, err := ruleConvert(ruleFile)
                if err != nil </span><span class="cov8" title="1">{
                        return ruleList, err
                }</span>
                <span class="cov8" title="1">*ruleList = append(*ruleList, rule)</span>
        }

        <span class="cov8" title="1">return ruleList, nil</span>
}

func AuthJWTConfLoad(filename string) (AuthJWTConf, error) <span class="cov8" title="1">{
        var conf AuthJWTConf

        file, err := os.Open(filename)
        if err != nil </span><span class="cov0" title="0">{
                return conf, err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        decoder := json.NewDecoder(file)

        var config AuthJWTConfFile
        err = decoder.Decode(&amp;config)
        if err != nil </span><span class="cov0" title="0">{
                return conf, err
        }</span>

        <span class="cov8" title="1">err = AuthJWTConfCheck(config)
        if err != nil </span><span class="cov0" title="0">{
                return conf, err
        }</span>

        <span class="cov8" title="1">conf.Version = *config.Version
        conf.Config = make(ProductRules)

        for product, ruleFileList := range *config.Config </span><span class="cov8" title="1">{
                ruleList, err := ruleListConvert(ruleFileList)
                if err != nil </span><span class="cov8" title="1">{
                        return conf, err
                }</span>
                <span class="cov8" title="1">conf.Config[product] = ruleList</span>
        }

        <span class="cov8" title="1">return conf, nil</span>
}
</pre>
		
		<pre class="file" id="file81" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_auth_jwt

import (
        "sync"
)

type AuthJWTRuleTable struct {
        lock         sync.RWMutex
        version      string
        productRules ProductRules
}

func NewAuthJWTRuleTable() *AuthJWTRuleTable <span class="cov8" title="1">{
        t := new(AuthJWTRuleTable)
        t.productRules = make(ProductRules)
        return t
}</span>

func (t *AuthJWTRuleTable) Update(conf AuthJWTConf) <span class="cov8" title="1">{
        t.lock.Lock()
        t.version = conf.Version
        t.productRules = conf.Config
        t.lock.Unlock()
}</span>

func (t *AuthJWTRuleTable) Search(product string) (*RuleList, bool) <span class="cov8" title="1">{
        t.lock.RLock()
        productRules := t.productRules
        t.lock.RUnlock()

        rules, ok := productRules[product]
        return rules, ok
}</span>
</pre>
		
		<pre class="file" id="file82" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_auth_jwt

import (
        "github.com/baidu/go-lib/log"
        gcfg "gopkg.in/gcfg.v1"
)

import (
        "github.com/bfenetworks/bfe/bfe_util"
)

type ConfModAuthJWT struct {
        Basic struct {
                DataPath string
        }

        Log struct {
                OpenDebug bool
        }
}

func ConfLoad(filePath string, confRoot string) (*ConfModAuthJWT, error) <span class="cov8" title="1">{
        var err error
        var cfg ConfModAuthJWT

        err = gcfg.ReadFileInto(&amp;cfg, filePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">err = cfg.Check(confRoot)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;cfg, nil</span>
}

func (cfg *ConfModAuthJWT) Check(confRoot string) error <span class="cov8" title="1">{
        if cfg.Basic.DataPath == "" </span><span class="cov0" title="0">{
                log.Logger.Warn("ModAuthJWT.DataPath not set, use default value")
                cfg.Basic.DataPath = "mod_auth_jwt/auth_jwt_rule.data"
        }</span>

        <span class="cov8" title="1">cfg.Basic.DataPath = bfe_util.ConfPathProc(cfg.Basic.DataPath, confRoot)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file83" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_auth_jwt

import (
        "fmt"
        "net/url"
        "strings"
)

import (
        "github.com/baidu/go-lib/log"
        "github.com/baidu/go-lib/web-monitor/metrics"
        "github.com/baidu/go-lib/web-monitor/web_monitor"
        "github.com/golang-jwt/jwt"
)

import (
        "github.com/bfenetworks/bfe/bfe_basic"
        "github.com/bfenetworks/bfe/bfe_http"
        "github.com/bfenetworks/bfe/bfe_module"
)

const (
        ModAuthJWT = "mod_auth_jwt"
)

type ModuleAuthJWTState struct {
        ReqAuthRuleHit                *metrics.Counter
        ReqAuthNoAuthorization        *metrics.Counter
        ReqAuthAuthorizationFormatErr *metrics.Counter
        ReqAuthSuccess                *metrics.Counter
        ReqAuthFailure                *metrics.Counter
}

type ModuleAuthJWT struct {
        name       string
        state      ModuleAuthJWTState
        metrics    metrics.Metrics
        configPath string
        ruleTable  *AuthJWTRuleTable
}

var (
        openDebug = false
)

func NewModuleAuthJWT() *ModuleAuthJWT <span class="cov8" title="1">{
        m := new(ModuleAuthJWT)
        m.name = ModAuthJWT
        m.metrics.Init(&amp;m.state, ModAuthJWT, 0)
        m.ruleTable = NewAuthJWTRuleTable()
        return m
}</span>

func (m *ModuleAuthJWT) Name() string <span class="cov0" title="0">{
        return m.name
}</span>

func (m *ModuleAuthJWT) loadConfData(query url.Values) error <span class="cov8" title="1">{
        path := query.Get("path")
        if path == "" </span><span class="cov8" title="1">{
                path = m.configPath
        }</span>

        <span class="cov8" title="1">conf, err := AuthJWTConfLoad(path)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error in AuthJWTConfLoad(%s): %v", path, err)
        }</span>

        <span class="cov8" title="1">m.ruleTable.Update(conf)
        return nil</span>
}

func (m *ModuleAuthJWT) getState(params map[string][]string) ([]byte, error) <span class="cov0" title="0">{
        s := m.metrics.GetAll()
        return s.Format(params)
}</span>

func (m *ModuleAuthJWT) getStateDiff(params map[string][]string) ([]byte, error) <span class="cov0" title="0">{
        s := m.metrics.GetDiff()
        return s.Format(params)
}</span>

func (m *ModuleAuthJWT) monitorHandlers() map[string]interface{} <span class="cov8" title="1">{
        handlers := map[string]interface{}{
                m.name:           m.getState,
                m.name + ".diff": m.getStateDiff,
        }
        return handlers
}</span>

func (m *ModuleAuthJWT) getToken(req *bfe_basic.Request) (string, error) <span class="cov8" title="1">{
        authHeader := req.HttpRequest.Header.Get("Authorization")
        if authHeader == "" </span><span class="cov8" title="1">{
                m.state.ReqAuthNoAuthorization.Inc(1)
                return "", fmt.Errorf("No Authorization header.")
        }</span>

        <span class="cov8" title="1">authValue := strings.Split(authHeader, " ")
        if len(authValue) != 2 </span><span class="cov0" title="0">{
                m.state.ReqAuthAuthorizationFormatErr.Inc(1)
                return "", fmt.Errorf("Authorization header format error.")
        }</span>

        <span class="cov8" title="1">if authValue[0] != "Bearer" </span><span class="cov0" title="0">{
                m.state.ReqAuthAuthorizationFormatErr.Inc(1)
                return "", fmt.Errorf("Authorization type[%s] error.", authValue[0])
        }</span>

        <span class="cov8" title="1">return authValue[1], nil</span>
}

func (m *ModuleAuthJWT) validateToken(token string, rule *AuthJWTRule) error <span class="cov8" title="1">{
        for _, key := range rule.Keys </span><span class="cov8" title="1">{
                parsedToken, err := jwt.Parse(token, key.provideKey)
                if err != nil </span><span class="cov8" title="1">{
                        if openDebug </span><span class="cov8" title="1">{
                                log.Logger.Debug("%s: parse token error: %v, kid: %s", m.name, err, key.key.KeyID)
                        }</span>
                        <span class="cov8" title="1">continue</span>
                }

                // Both signature and time based claims "exp, iat, nbf" are valid.
                <span class="cov8" title="1">if parsedToken.Valid &amp;&amp; parsedToken.Claims.Valid() == nil </span><span class="cov8" title="1">{
                        return nil
                }</span>
        }

        <span class="cov8" title="1">return fmt.Errorf("token[%s] invalid", token)</span>
}

func (m *ModuleAuthJWT) checkAuthCredentials(req *bfe_basic.Request, rule *AuthJWTRule) error <span class="cov8" title="1">{
        token, err := m.getToken(req)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return m.validateToken(token, rule)</span>
}

func (m *ModuleAuthJWT) createUnauthorizedResp(req *bfe_basic.Request,
        rule *AuthJWTRule) *bfe_http.Response <span class="cov8" title="1">{
        resp := bfe_basic.CreateInternalResp(req, bfe_http.StatusUnauthorized)
        resp.Header.Set("WWW-Authenticate", fmt.Sprintf("Bearer realm=\"%s\"", rule.Realm))
        return resp
}</span>

func (m *ModuleAuthJWT) authJWTHandler(req *bfe_basic.Request) (int, *bfe_http.Response) <span class="cov8" title="1">{
        rules, ok := m.ruleTable.Search(req.Route.Product)
        if !ok </span><span class="cov0" title="0">{
                return bfe_module.BfeHandlerGoOn, nil
        }</span>

        <span class="cov8" title="1">for _, rule := range *rules </span><span class="cov8" title="1">{
                if rule.Cond.Match(req) </span><span class="cov8" title="1">{
                        m.state.ReqAuthRuleHit.Inc(1)

                        err := m.checkAuthCredentials(req, &amp;rule)
                        if err != nil </span><span class="cov8" title="1">{
                                if openDebug </span><span class="cov8" title="1">{
                                        log.Logger.Debug("%s: check auth jwt error: %v", m.name, err)
                                }</span>

                                <span class="cov8" title="1">m.state.ReqAuthFailure.Inc(1)
                                return bfe_module.BfeHandlerResponse, m.createUnauthorizedResp(req, &amp;rule)</span>
                        }

                        <span class="cov8" title="1">m.state.ReqAuthSuccess.Inc(1)
                        return bfe_module.BfeHandlerGoOn, nil</span>
                }
        }

        <span class="cov8" title="1">return bfe_module.BfeHandlerGoOn, nil</span>
}

func (m *ModuleAuthJWT) Init(cbs *bfe_module.BfeCallbacks, whs *web_monitor.WebHandlers,
        cr string) error <span class="cov8" title="1">{
        var err error
        var cfg *ConfModAuthJWT

        confPath := bfe_module.ModConfPath(cr, m.name)
        if cfg, err = ConfLoad(confPath, cr); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: conf load err: %v", m.name, err)
        }</span>

        <span class="cov8" title="1">m.configPath = cfg.Basic.DataPath
        openDebug = cfg.Log.OpenDebug

        if err = m.loadConfData(nil); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("err in loadConfData(): %v", err)
        }</span>

        <span class="cov8" title="1">err = cbs.AddFilter(bfe_module.HandleFoundProduct, m.authJWTHandler)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init(): AddFilter(m.authJWTHandler): %v", m.name, err)
        }</span>

        <span class="cov8" title="1">err = web_monitor.RegisterHandlers(whs, web_monitor.WebHandleMonitor, m.monitorHandlers())
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init():RegisterHandlers(m.monitorHandlers): %v", m.name, err)
        }</span>

        <span class="cov8" title="1">err = whs.RegisterHandler(web_monitor.WebHandleReload, m.name, m.loadConfData)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init(): RegisterHandler(m.loadConfData): %v", m.name, err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file84" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_auth_request

import (
        "fmt"
        "os"
)

import (
        "github.com/bfenetworks/bfe/bfe_basic/condition"
        "github.com/bfenetworks/bfe/bfe_util/json"
)

type AuthRequestRuleFile struct {
        Version string
        Config  ProductRuleRawList // product =&gt; raw rule list
}

type AuthRequestRuleConf struct {
        Version string
        Config  ProductRuleList // product =&gt; rule list
}

type AuthRequestRuleRaw struct {
        Cond   string // condition
        Enable bool   // whether enable auth request
}

type ProductRuleRawList map[string]RuleRawList // product =&gt; raw rule list
type RuleRawList []AuthRequestRuleRaw          // raw rule list

func AuthRequestRuleCheck(authRequestRuleFile *AuthRequestRuleFile) error <span class="cov8" title="1">{
        if authRequestRuleFile == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("authRequestRuleFile is nil")
        }</span>

        <span class="cov8" title="1">if len(authRequestRuleFile.Version) == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("no Version")
        }</span>

        <span class="cov8" title="1">if authRequestRuleFile.Config == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("no Config")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func ruleConvert(rawRule AuthRequestRuleRaw) (*AuthRequestRule, error) <span class="cov8" title="1">{
        cond, err := condition.Build(rawRule.Cond)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var rule AuthRequestRule
        rule.Cond = cond
        rule.Enable = rawRule.Enable

        return &amp;rule, nil</span>
}

func ruleListConvert(rawRuleList RuleRawList) (AuthRequestRuleList, error) <span class="cov8" title="1">{
        ruleList := AuthRequestRuleList{}
        for i, rawRule := range rawRuleList </span><span class="cov8" title="1">{
                rule, err := ruleConvert(rawRule)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("rule [%d] error: %v", i, err)
                }</span>

                <span class="cov8" title="1">ruleList = append(ruleList, *rule)</span>
        }

        <span class="cov8" title="1">return ruleList, nil</span>
}

func AuthRequestRuleFileLoad(filename string) (*AuthRequestRuleConf, error) <span class="cov8" title="1">{
        var ruleFile AuthRequestRuleFile
        var ruleConf AuthRequestRuleConf

        file, err := os.Open(filename)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        decoder := json.NewDecoder(file)

        err = decoder.Decode(&amp;ruleFile)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">err = AuthRequestRuleCheck(&amp;ruleFile)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">ruleConf.Version = ruleFile.Version
        ruleConf.Config = make(ProductRuleList)

        for product, ruleFileList := range ruleFile.Config </span><span class="cov8" title="1">{
                ruleList, err := ruleListConvert(ruleFileList)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("product[%s] rule error: %v", product, err)
                }</span>
                <span class="cov8" title="1">ruleConf.Config[product] = ruleList</span>
        }

        <span class="cov8" title="1">return &amp;ruleConf, nil</span>
}
</pre>
		
		<pre class="file" id="file85" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_auth_request

import (
        "sync"
)

import (
        "github.com/bfenetworks/bfe/bfe_basic/condition"
)

type AuthRequestRuleTable struct {
        lock        sync.RWMutex
        version     string
        productRule ProductRuleList // product =&gt; rule list
}

type AuthRequestRule struct {
        Cond   condition.Condition
        Enable bool
}

type ProductRuleList map[string]AuthRequestRuleList // product =&gt; rule list
type AuthRequestRuleList []AuthRequestRule          // rule list

func NewAuthRequestRuleTable() *AuthRequestRuleTable <span class="cov8" title="1">{
        t := new(AuthRequestRuleTable)
        t.productRule = make(ProductRuleList)
        return t
}</span>

func (t *AuthRequestRuleTable) Update(ruleConf *AuthRequestRuleConf) <span class="cov8" title="1">{
        t.lock.Lock()
        t.version = ruleConf.Version
        t.productRule = ruleConf.Config
        t.lock.Unlock()
}</span>

func (t *AuthRequestRuleTable) Search(product string) (AuthRequestRuleList, bool) <span class="cov8" title="1">{
        t.lock.RLock()
        ruleList, ok := t.productRule[product]
        t.lock.RUnlock()

        return ruleList, ok
}</span>
</pre>
		
		<pre class="file" id="file86" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_auth_request

import (
        "fmt"
        "net/url"
)

import (
        "github.com/baidu/go-lib/log"
        "gopkg.in/gcfg.v1"
)

import (
        "github.com/bfenetworks/bfe/bfe_util"
)

const (
        defaultDataPath = "mod_auth_request/auth_request_rule.data"
)

type ConfModAuthRequest struct {
        Basic struct {
                DataPath    string // path of rule data
                AuthAddress string // address of auth server
                AuthTimeout int    // timeout for auth request (in ms)
        }

        Log struct {
                OpenDebug bool
        }
}

func ConfLoad(filePath string, confRoot string) (*ConfModAuthRequest, error) <span class="cov8" title="1">{
        var err error
        var cfg ConfModAuthRequest

        err = gcfg.ReadFileInto(&amp;cfg, filePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">err = cfg.Check(confRoot)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;cfg, nil</span>
}

func (cfg *ConfModAuthRequest) Check(confRoot string) error <span class="cov8" title="1">{
        if len(cfg.Basic.DataPath) == 0 </span><span class="cov0" title="0">{
                cfg.Basic.DataPath = defaultDataPath
                log.Logger.Warn("ModAuthRequest.DataPath not set, use default value: %s", defaultDataPath)
        }</span>

        <span class="cov8" title="1">cfg.Basic.DataPath = bfe_util.ConfPathProc(cfg.Basic.DataPath, confRoot)

        if len(cfg.Basic.AuthAddress) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("ModAuthRequest.AuthAddress not set")
        }</span>
        <span class="cov8" title="1">_, err := url.Parse(cfg.Basic.AuthAddress)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ModAuthRequest.AuthAddress is not a correct url")
        }</span>

        <span class="cov8" title="1">if cfg.Basic.AuthTimeout &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("ModAuthRequest.AuthTimeout must &gt; 0")
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file87" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_auth_request

import (
        "errors"
        "fmt"
        "net/http"
        "net/url"
        "path/filepath"
        "time"
)

import (
        "github.com/baidu/go-lib/log"
        "github.com/baidu/go-lib/web-monitor/delay_counter"
        "github.com/baidu/go-lib/web-monitor/metrics"
        "github.com/baidu/go-lib/web-monitor/web_monitor"
)

import (
        "github.com/bfenetworks/bfe/bfe_basic"
        "github.com/bfenetworks/bfe/bfe_http"
        "github.com/bfenetworks/bfe/bfe_module"
)

const (
        ModAuthRequest         = "mod_auth_request"
        DiffInterval           = 20 // interval for diff counter (in seconds)
        DelayConterInterval    = 60 // interval for moving current to past (in s)
        DelayCounterBucketSize = 1  // size of delay counter bucket (in ms)
        DelayCounterBucketNum  = 20 // number of delay counter bucket

        XForwardedMethod = "X-Forwarded-Method"
        XForwardedURI    = "X-Forwarded-Uri"
)

var (
        openDebug = false

        ErrAuthRequest = errors.New("AUTH_REQ_FORBIDDEN")
)

type ModuleAuthRequestState struct {
        AuthRequestChecked      *metrics.Counter
        AuthRequestPass         *metrics.Counter
        AuthRequestForbidden    *metrics.Counter
        AuthRequestUnauthorized *metrics.Counter
        AuthRequestFail         *metrics.Counter
        AuthRequestUncertain    *metrics.Counter
}

type ModuleAuthRequest struct {
        name      string
        conf      *ConfModAuthRequest
        ruleTable *AuthRequestRuleTable

        authClient http.Client // auth client, use default roundtrip

        state   ModuleAuthRequestState // module state
        metrics metrics.Metrics

        delay *delay_counter.DelayRecent // delay distribution for auth service
}

func NewModuleAuthRequest() *ModuleAuthRequest <span class="cov8" title="1">{
        m := new(ModuleAuthRequest)
        m.name = ModAuthRequest
        m.ruleTable = NewAuthRequestRuleTable()

        m.metrics.Init(&amp;m.state, ModAuthRequest, DiffInterval)

        m.delay = new(delay_counter.DelayRecent)
        m.delay.Init(DelayConterInterval, DelayCounterBucketSize, DelayCounterBucketNum)
        m.delay.SetKeyPrefix(ModAuthRequest)

        return m
}</span>

func (m *ModuleAuthRequest) Name() string <span class="cov0" title="0">{
        return m.name
}</span>

func (m *ModuleAuthRequest) loadRuleData(query url.Values) (string, error) <span class="cov8" title="1">{
        // get file path
        path := query.Get("path")
        if path == "" </span><span class="cov8" title="1">{
                // use default
                path = m.conf.Basic.DataPath
        }</span>

        // load from config file
        <span class="cov8" title="1">conf, err := AuthRequestRuleFileLoad(path)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("%s: AuthRequestRuleFileLoad(%s) error: %v", m.name, path, err)
        }</span>

        // update to rule table
        <span class="cov8" title="1">m.ruleTable.Update(conf)

        _, fileName := filepath.Split(path)
        return fmt.Sprintf("%s=%s", fileName, conf.Version), nil</span>
}

func removeHopHeaders(headers http.Header) <span class="cov8" title="1">{
        for _, h := range bfe_basic.HopHeaders </span><span class="cov8" title="1">{
                headers.Del(h)
        }</span>
}

func (m *ModuleAuthRequest) createAuthRequest(originReq *bfe_basic.Request) *http.Request <span class="cov8" title="1">{
        authReq, _ := http.NewRequest(http.MethodGet, m.conf.Basic.AuthAddress, nil)

        // copy header from origin request header
        bfe_http.CopyHeader(bfe_http.Header(authReq.Header), originReq.HttpRequest.Header)

        // remove hop headers
        removeHopHeaders(authReq.Header)

        // remove Content-Length header
        authReq.Header.Del("Content-Length")

        xMethod := originReq.HttpRequest.Header.Get(XForwardedMethod)
        if xMethod != "" </span><span class="cov0" title="0">{
                authReq.Header.Set(XForwardedMethod, xMethod)
        }</span> else<span class="cov8" title="1"> {
                authReq.Header.Set(XForwardedMethod, originReq.HttpRequest.Method)
        }</span>

        <span class="cov8" title="1">xUri := originReq.HttpRequest.Header.Get(XForwardedURI)
        if xUri != "" </span><span class="cov0" title="0">{
                authReq.Header.Set(XForwardedURI, xUri)
        }</span> else<span class="cov8" title="1"> {
                authReq.Header.Set(XForwardedURI, originReq.HttpRequest.URL.RequestURI())
        }</span>

        <span class="cov8" title="1">if openDebug </span><span class="cov0" title="0">{
                log.Logger.Info("%s: auth request header: [%v]", m.name, authReq.Header)
        }</span>

        <span class="cov8" title="1">return authReq</span>
}

func (m *ModuleAuthRequest) callAuthService(forwardReq *http.Request) (*http.Response, error) <span class="cov8" title="1">{
        startTime := time.Now()
        defer m.delay.AddBySub(startTime, time.Now())

        resp, err := m.authClient.Do(forwardReq)
        if err != nil </span><span class="cov0" title="0">{
                log.Logger.Info("%s: auth request failed: %v", m.name, err)
                return resp, err
        }</span>

        <span class="cov8" title="1">return resp, nil</span>
}

func (m *ModuleAuthRequest) genAuthForbiddenResp(req *bfe_basic.Request, resp *http.Response) *bfe_http.Response <span class="cov8" title="1">{
        forbiddenResp := bfe_basic.CreateInternalResp(req, resp.StatusCode)
        if resp.StatusCode == bfe_http.StatusUnauthorized </span><span class="cov8" title="1">{
                if wwwAuth := resp.Header.Get("WWW-Authenticate"); len(wwwAuth) &gt; 0 </span><span class="cov8" title="1">{
                        forbiddenResp.Header.Set("WWW-Authenticate", wwwAuth)
                }</span>
                <span class="cov8" title="1">m.state.AuthRequestUnauthorized.Inc(1)
                return forbiddenResp</span>
        }

        <span class="cov8" title="1">if resp.StatusCode == bfe_http.StatusForbidden </span><span class="cov0" title="0">{
                m.state.AuthRequestForbidden.Inc(1)
                return forbiddenResp
        }</span>

        // if the service response code is 2XX, the access is allowed.
        <span class="cov8" title="1">if resp.StatusCode/100 == 2 </span><span class="cov8" title="1">{
                m.state.AuthRequestPass.Inc(1)
                return nil
        }</span>

        // if any other response code returned is considered an error
        <span class="cov8" title="1">m.state.AuthRequestUncertain.Inc(1)
        if openDebug </span><span class="cov0" title="0">{
                log.Logger.Info("%s: auth response is not expected, resp code[%d]", m.name, resp.StatusCode)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// forward request to auth server
func (m *ModuleAuthRequest) forwardAuthServer(req *bfe_basic.Request) *bfe_http.Response <span class="cov8" title="1">{
        // create auth request
        authReq := m.createAuthRequest(req)

        // call auth service
        resp, err := m.callAuthService(authReq)
        if err != nil </span><span class="cov0" title="0">{
                m.state.AuthRequestFail.Inc(1)
                return nil
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        return m.genAuthForbiddenResp(req, resp)</span>
}

func (m *ModuleAuthRequest) authRequestHandler(req *bfe_basic.Request) (int, *bfe_http.Response) <span class="cov8" title="1">{
        rules, ok := m.ruleTable.Search(req.Route.Product)
        if !ok </span><span class="cov0" title="0">{
                return bfe_module.BfeHandlerGoOn, nil
        }</span>

        <span class="cov8" title="1">for _, rule := range rules </span><span class="cov8" title="1">{
                if rule.Enable &amp;&amp; rule.Cond.Match(req) </span><span class="cov8" title="1">{
                        m.state.AuthRequestChecked.Inc(1)

                        // check request is denied
                        if resp := m.forwardAuthServer(req); resp != nil </span><span class="cov8" title="1">{
                                req.ErrCode = ErrAuthRequest
                                return bfe_module.BfeHandlerResponse, resp
                        }</span>
                }
        }

        <span class="cov0" title="0">return bfe_module.BfeHandlerGoOn, nil</span>
}

func (m *ModuleAuthRequest) reloadHandlers() map[string]interface{} <span class="cov8" title="1">{
        handlers := map[string]interface{}{
                m.name: m.loadRuleData,
        }
        return handlers
}</span>

func (m *ModuleAuthRequest) getState(params map[string][]string) ([]byte, error) <span class="cov0" title="0">{
        s := m.metrics.GetAll()
        return s.Format(params)
}</span>

func (m *ModuleAuthRequest) getStateDiff(params map[string][]string) ([]byte, error) <span class="cov0" title="0">{
        s := m.metrics.GetDiff()
        return s.Format(params)
}</span>

func (m *ModuleAuthRequest) getDelay(query url.Values) ([]byte, error) <span class="cov0" title="0">{
        delay := m.delay
        return delay.FormatOutput(query)
}</span>

// all monitor handlers
func (m *ModuleAuthRequest) monitorHandlers() map[string]interface{} <span class="cov8" title="1">{
        handlers := map[string]interface{}{
                m.name:            m.getState,
                m.name + ".diff":  m.getStateDiff,
                m.name + ".delay": m.getDelay,
        }
        return handlers
}</span>

func (m *ModuleAuthRequest) init(conf *ConfModAuthRequest, cbs *bfe_module.BfeCallbacks, whs *web_monitor.WebHandlers) error <span class="cov8" title="1">{
        var err error

        _, err = m.loadRuleData(nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">err = cbs.AddFilter(bfe_module.HandleFoundProduct, m.authRequestHandler)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init(): AddFilter(m.authRequestHandler): %v", m.name, err)
        }</span>

        <span class="cov8" title="1">err = web_monitor.RegisterHandlers(whs, web_monitor.WebHandleMonitor, m.monitorHandlers())
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init():RegisterHandlers(m.reloadHandlers): %v", m.name, err)
        }</span>

        <span class="cov8" title="1">err = web_monitor.RegisterHandlers(whs, web_monitor.WebHandleReload, m.reloadHandlers())
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init():RegisterHandlers(m.reloadHandlers): %v", m.name, err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (m *ModuleAuthRequest) Init(cbs *bfe_module.BfeCallbacks, whs *web_monitor.WebHandlers, cr string) error <span class="cov8" title="1">{
        var err error
        var conf *ConfModAuthRequest

        confPath := bfe_module.ModConfPath(cr, m.name)
        if conf, err = ConfLoad(confPath, cr); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: conf load err %s", m.name, err.Error())
        }</span>

        <span class="cov8" title="1">m.conf = conf
        openDebug = conf.Log.OpenDebug

        m.authClient = http.Client{
                CheckRedirect: func(*http.Request, []*http.Request) error </span><span class="cov0" title="0">{
                        // disable redirect
                        return http.ErrUseLastResponse
                }</span>,
                Timeout: time.Duration(m.conf.Basic.AuthTimeout) * time.Millisecond,
        }
        <span class="cov8" title="1">return m.init(conf, cbs, whs)</span>
}
</pre>
		
		<pre class="file" id="file88" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_block

import (
        "errors"
        "fmt"
)

type ActionFile struct {
        Cmd    *string  // command of action
        Params []string // params of action
}

type Action struct {
        Cmd    string   // command of action
        Params []string // params of action
}

func ActionFileCheck(conf *ActionFile) error <span class="cov8" title="1">{
        var paramsLenCheck int

        // check command
        if conf.Cmd == nil </span><span class="cov0" title="0">{
                return errors.New("no Cmd")
        }</span>

        // validate command, and get how many params should exist for each command
        <span class="cov8" title="1">switch *conf.Cmd </span>{
        case "CLOSE":<span class="cov8" title="1">
                paramsLenCheck = 0</span>
        case "ALLOW":<span class="cov8" title="1">
                paramsLenCheck = 0</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("invalid cmd:%s", *conf.Cmd)</span>
        }

        // check params
        <span class="cov8" title="1">if conf.Params == nil </span><span class="cov0" title="0">{
                return errors.New("no Params")
        }</span>

        <span class="cov8" title="1">if paramsLenCheck != -1 </span><span class="cov8" title="1">{
                paramsLen := len(conf.Params)
                if paramsLenCheck != paramsLen </span><span class="cov0" title="0">{
                        return fmt.Errorf("num of params:[ok:%d, now:%d]", paramsLenCheck, paramsLen)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func actionConvert(actionFile ActionFile) Action <span class="cov8" title="1">{
        action := Action{}
        action.Cmd = *actionFile.Cmd
        action.Params = actionFile.Params
        return action
}</span>
</pre>
		
		<pre class="file" id="file89" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_block

import (
        "github.com/baidu/go-lib/log"
        gcfg "gopkg.in/gcfg.v1"
)

import (
        "github.com/bfenetworks/bfe/bfe_util"
)

type ConfModBlock struct {
        Basic struct {
                ProductRulePath string // path of product block rule data
                IPBlocklistPath string // path of ip blocklist data
        }

        Log struct {
                OpenDebug bool //  whether open debug
        }
}

// ConfLoad loads config from config file
func ConfLoad(filePath string, confRoot string) (*ConfModBlock, error) <span class="cov8" title="1">{
        var cfg ConfModBlock
        var err error

        // read config from file
        err = gcfg.ReadFileInto(&amp;cfg, filePath)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;cfg, err
        }</span>

        // check conf of mod_block
        <span class="cov8" title="1">err = cfg.Check(confRoot)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;cfg, err
        }</span>

        <span class="cov8" title="1">return &amp;cfg, nil</span>
}

func (cfg *ConfModBlock) Check(confRoot string) error <span class="cov8" title="1">{
        return ConfModBlockCheck(cfg, confRoot)
}</span>

func ConfModBlockCheck(cfg *ConfModBlock, confRoot string) error <span class="cov8" title="1">{
        if cfg.Basic.ProductRulePath == "" </span><span class="cov8" title="1">{
                log.Logger.Warn("ModBlock.ProductRulePath not set, use default value")
                cfg.Basic.ProductRulePath = "mod_block/block_rules.data"
        }</span>
        <span class="cov8" title="1">cfg.Basic.ProductRulePath = bfe_util.ConfPathProc(cfg.Basic.ProductRulePath, confRoot)

        if cfg.Basic.IPBlocklistPath == "" </span><span class="cov8" title="1">{
                log.Logger.Warn("ModBlock.IPBlocklistPath not set, use default value")
                cfg.Basic.IPBlocklistPath = "mod_block/ip_blocklist.data"
        }</span>
        <span class="cov8" title="1">cfg.Basic.IPBlocklistPath = bfe_util.ConfPathProc(cfg.Basic.IPBlocklistPath, confRoot)

        return nil</span>
}
</pre>
		
		<pre class="file" id="file90" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_block

import (
        "fmt"
)

import (
        "github.com/bfenetworks/bfe/bfe_util/ipdict"
        "github.com/bfenetworks/bfe/bfe_util/ipdict/txt_load"
)

// GlobalIPTableLoad loads global ip table.
func GlobalIPTableLoad(path string) (*ipdict.IPItems, error) <span class="cov8" title="1">{
        var items *ipdict.IPItems
        var err error

        // load dict file
        txtLoader := txt_load.NewTxtFileLoader(path)
        curVersion := "" // initial version ""
        items, err = txtLoader.CheckAndLoad(curVersion)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("load dict: %s", err.Error())
        }</span>

        <span class="cov8" title="1">return items, nil</span>
}
</pre>
		
		<pre class="file" id="file91" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_block

import (
        "errors"
        "fmt"
        "net/url"
)

import (
        "github.com/baidu/go-lib/log"
        "github.com/baidu/go-lib/web-monitor/metrics"
        "github.com/baidu/go-lib/web-monitor/web_monitor"
)

import (
        "github.com/bfenetworks/bfe/bfe_basic"
        "github.com/bfenetworks/bfe/bfe_http"
        "github.com/bfenetworks/bfe/bfe_module"
        "github.com/bfenetworks/bfe/bfe_util/ipdict"
)

const (
        ModBlock     = "mod_block"
        CtxBlockInfo = "mod_block.block_info"
)

var (
        ErrBlock = errors.New("BLOCK")
)

var (
        openDebug = false
)

type ModuleBlockState struct {
        ConnTotal    *metrics.Counter // all connnetion checked
        ConnAccept   *metrics.Counter // connection passed
        ConnRefuse   *metrics.Counter // connection refused
        ReqTotal     *metrics.Counter // all request in
        ReqAccept    *metrics.Counter // request accepted
        ReqRefuse    *metrics.Counter // request refused
        WrongCommand *metrics.Counter // request with condition satisfied, but wrong command
}

type BlockInfo struct {
        BlockRuleName string // block rule name
}

type ModuleBlock struct {
        name    string           // name of module
        state   ModuleBlockState // module state
        metrics metrics.Metrics

        productRulePath string // path of block rule data file
        ipBlocklistPath string // path of ip blocklist data file

        ruleTable *ProductRuleTable // table for product block rules
        ipTable   *ipdict.IPTable   // table for global ip blocklist
}

func NewModuleBlock() *ModuleBlock <span class="cov8" title="1">{
        m := new(ModuleBlock)
        m.name = ModBlock
        m.metrics.Init(&amp;m.state, ModBlock, 0)

        m.ruleTable = NewProductRuleTable()
        m.ipTable = ipdict.NewIPTable()

        return m
}</span>

func (m *ModuleBlock) Name() string <span class="cov0" title="0">{
        return m.name
}</span>

// loadGlobalIPTable loads global ip blocklist.
func (m *ModuleBlock) loadGlobalIPTable(query url.Values) error <span class="cov8" title="1">{
        // get reload file path
        path := query.Get("path")
        if path == "" </span><span class="cov8" title="1">{
                // use default
                path = m.ipBlocklistPath
        }</span>

        // load data
        <span class="cov8" title="1">items, err := GlobalIPTableLoad(path)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("err in GlobalIPTableLoad(%s):%s", path, err)
        }</span>

        <span class="cov8" title="1">m.ipTable.Update(items)
        return nil</span>
}

// loadProductRuleConf load from config file.
func (m *ModuleBlock) loadProductRuleConf(query url.Values) error <span class="cov8" title="1">{
        // get path
        path := query.Get("path")
        if path == "" </span><span class="cov8" title="1">{
                // use default
                path = m.productRulePath
        }</span>

        // load file
        <span class="cov8" title="1">conf, err := ProductRuleConfLoad(path)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("err in ProductRuleConfLoad(%s):%s", path, err)
        }</span>

        <span class="cov8" title="1">m.ruleTable.Update(conf)
        return nil</span>
}

// globalBlockHandler is a handler for doing global block.
func (m *ModuleBlock) globalBlockHandler(session *bfe_basic.Session) int <span class="cov8" title="1">{
        if openDebug </span><span class="cov8" title="1">{
                log.Logger.Debug("%s check connection (remote: %v)",
                        m.name, session.RemoteAddr)
        }</span>
        <span class="cov8" title="1">m.state.ConnTotal.Inc(1)

        clientIP := session.RemoteAddr.IP
        if m.ipTable.Search(clientIP) </span><span class="cov8" title="1">{
                session.SetError(ErrBlock, "connection blocked")
                log.Logger.Debug("%s refuse connection (remote: %v)",
                        m.name, session.RemoteAddr)
                m.state.ConnRefuse.Inc(1)
                return bfe_module.BfeHandlerClose
        }</span>

        <span class="cov8" title="1">if openDebug </span><span class="cov8" title="1">{
                log.Logger.Debug("%s accept connection (remote: %v)",
                        m.name, session.RemoteAddr)
        }</span>
        <span class="cov8" title="1">m.state.ConnAccept.Inc(1)
        return bfe_module.BfeHandlerGoOn</span>
}

// productBlockHandler is a handler for doing product block.
func (m *ModuleBlock) productBlockHandler(request *bfe_basic.Request) (
        int, *bfe_http.Response) <span class="cov8" title="1">{
        if openDebug </span><span class="cov8" title="1">{
                log.Logger.Debug("%s check request", m.name)
        }</span>
        <span class="cov8" title="1">m.state.ReqTotal.Inc(1)

        // check global rules for given request
        rules, ok := m.ruleTable.Search(bfe_basic.GlobalProduct)
        if ok </span><span class="cov0" title="0">{ // rules found
                retVal, isMatch, resp := m.productRulesProcess(request, rules)
                if isMatch </span><span class="cov0" title="0">{
                        return retVal, resp
                }</span>
        }
        // check product rules for given request
        <span class="cov8" title="1">rules, ok = m.ruleTable.Search(request.Route.Product)
        if !ok </span><span class="cov8" title="1">{ // no rules found
                if openDebug </span><span class="cov8" title="1">{
                        log.Logger.Debug("%s product %s not found, just pass",
                                m.name, request.Route.Product)
                }</span>
                <span class="cov8" title="1">return bfe_module.BfeHandlerGoOn, nil</span>
        }

        <span class="cov8" title="1">retVal, isMatch, resp := m.productRulesProcess(request, rules)
        if !isMatch </span><span class="cov0" title="0">{
                m.state.ReqAccept.Inc(1)
        }</span>
        <span class="cov8" title="1">return retVal, resp</span>
}

func (m *ModuleBlock) productRulesProcess(req *bfe_basic.Request, rules *blockRuleList) (
        int, bool, *bfe_http.Response) <span class="cov8" title="1">{
        for _, rule := range *rules </span><span class="cov8" title="1">{
                if openDebug </span><span class="cov8" title="1">{
                        log.Logger.Debug("%s process rule: %v", m.name, rule)
                }</span>

                // rule condition is satisfied ?
                <span class="cov8" title="1">if rule.Cond.Match(req) </span><span class="cov8" title="1">{
                        // set block info name
                        blockInfo := &amp;BlockInfo{BlockRuleName: rule.Name}
                        req.SetContext(CtxBlockInfo, blockInfo)

                        switch rule.Action.Cmd </span>{
                        case "ALLOW":<span class="cov0" title="0">
                                if openDebug </span><span class="cov0" title="0">{
                                        log.Logger.Debug("%s accept request", m.name)
                                }</span>
                                <span class="cov0" title="0">m.state.ReqAccept.Inc(1)
                                return bfe_module.BfeHandlerGoOn, true, nil</span>
                        case "CLOSE":<span class="cov8" title="1">
                                req.ErrCode = ErrBlock
                                log.Logger.Debug("%s block connection (rule:%v, remote:%s)",
                                        m.name, rule, req.RemoteAddr)
                                m.state.ReqRefuse.Inc(1)
                                return bfe_module.BfeHandlerClose, true, nil</span>
                        default:<span class="cov0" title="0">
                                if openDebug </span><span class="cov0" title="0">{
                                        log.Logger.Debug("%s unknown block command (%s), just pass",
                                                rule.Action.Cmd)
                                }</span>
                                <span class="cov0" title="0">m.state.WrongCommand.Inc(1)</span>
                        }
                }
        }

        <span class="cov0" title="0">if openDebug </span><span class="cov0" title="0">{
                log.Logger.Debug("%s accept request", m.name)
        }</span>
        <span class="cov0" title="0">return bfe_module.BfeHandlerGoOn, false, nil</span>
}

func (m *ModuleBlock) getState(params map[string][]string) ([]byte, error) <span class="cov8" title="1">{
        s := m.metrics.GetAll()
        return s.Format(params)
}</span>

func (m *ModuleBlock) getStateDiff(params map[string][]string) ([]byte, error) <span class="cov0" title="0">{
        s := m.metrics.GetDiff()
        return s.Format(params)
}</span>

func (m *ModuleBlock) monitorHandlers() map[string]interface{} <span class="cov8" title="1">{
        handlers := map[string]interface{}{
                m.name:           m.getState,
                m.name + ".diff": m.getStateDiff,
        }
        return handlers
}</span>

func (m *ModuleBlock) reloadHandlers() map[string]interface{} <span class="cov8" title="1">{
        handlers := map[string]interface{}{
                m.name + ".global_ip_table":    m.loadGlobalIPTable,
                m.name + ".product_rule_table": m.loadProductRuleConf,
        }
        return handlers
}</span>

func (m *ModuleBlock) Init(cbs *bfe_module.BfeCallbacks, whs *web_monitor.WebHandlers,
        cr string) error <span class="cov8" title="1">{
        var conf *ConfModBlock
        var err error

        // load module config
        confPath := bfe_module.ModConfPath(cr, m.name)
        if conf, err = ConfLoad(confPath, cr); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: conf load err %s", m.name, err.Error())
        }</span>

        <span class="cov8" title="1">m.productRulePath = conf.Basic.ProductRulePath
        m.ipBlocklistPath = conf.Basic.IPBlocklistPath
        openDebug = conf.Log.OpenDebug

        // load conf data
        if err = m.loadGlobalIPTable(nil); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: loadGlobalIPTable() err %s", m.name, err.Error())
        }</span>
        <span class="cov8" title="1">if err = m.loadProductRuleConf(nil); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: loadProductRuleConf() err %s", m.name, err.Error())
        }</span>

        // register handler
        <span class="cov8" title="1">err = cbs.AddFilter(bfe_module.HandleAccept, m.globalBlockHandler)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init(): AddFilter(m.globalBlockHandler): %s", m.name, err.Error())
        }</span>

        <span class="cov8" title="1">err = cbs.AddFilter(bfe_module.HandleFoundProduct, m.productBlockHandler)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init(): AddFilter(m.productBlockHandler): %s", m.name, err.Error())
        }</span>

        // register web handler for monitor
        <span class="cov8" title="1">err = web_monitor.RegisterHandlers(whs, web_monitor.WebHandleMonitor, m.monitorHandlers())
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init():RegisterHandlers(m.monitorHandlers): %s", m.name, err.Error())
        }</span>
        // register web handler for reload
        <span class="cov8" title="1">err = web_monitor.RegisterHandlers(whs, web_monitor.WebHandleReload, m.reloadHandlers())
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init():RegisterHandlers(m.reloadHandlers): %s", m.name, err.Error())
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file92" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_block

import (
        "errors"
        "fmt"
        "os"
)

import (
        "github.com/bfenetworks/bfe/bfe_basic/condition"
        "github.com/bfenetworks/bfe/bfe_util/json"
)

type blockRuleFile struct {
        Cond   *string     // condition for block
        Name   *string     // block rule name
        Action *ActionFile // action for block
}

type blockRule struct {
        Cond   condition.Condition // condition for block
        Name   string              // block rule name
        Action Action              // action for block
}

type blockRuleFileList []blockRuleFile
type blockRuleList []blockRule

type ProductRulesFile map[string]*blockRuleFileList // product =&gt; list of block rules
type ProductRules map[string]*blockRuleList

type productRuleConfFile struct {
        Version *string // version of the config
        Config  *ProductRulesFile
}

type productRuleConf struct {
        Version string       // version of the config
        Config  ProductRules // product rules for block
}

func blockRuleCheck(conf blockRuleFile) error <span class="cov8" title="1">{
        // check Cond
        if conf.Cond == nil </span><span class="cov0" title="0">{
                return errors.New("no Cond")
        }</span>

        // check Name
        <span class="cov8" title="1">if conf.Name == nil </span><span class="cov0" title="0">{
                return errors.New("no Name")
        }</span>

        // check Actions
        <span class="cov8" title="1">if conf.Action == nil </span><span class="cov0" title="0">{
                return errors.New("no Action")
        }</span>

        <span class="cov8" title="1">if err := ActionFileCheck(conf.Action); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Action:%s", err.Error())
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func blockRuleListCheck(conf *blockRuleFileList) error <span class="cov8" title="1">{
        ruleNameMap := make(map[string]bool)
        for index, rule := range *conf </span><span class="cov8" title="1">{
                err := blockRuleCheck(rule)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("blockRule:%d, %s", index, err.Error())
                }</span>

                // check rule name for one product
                <span class="cov8" title="1">if _, ok := ruleNameMap[*rule.Name]; ok </span><span class="cov8" title="1">{
                        return fmt.Errorf("blockRule:%d, two rules have same name[%s]!", index, *rule.Name)
                }</span>
                <span class="cov8" title="1">ruleNameMap[*rule.Name] = true</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func productRulesCheck(conf *ProductRulesFile) error <span class="cov8" title="1">{
        for product, ruleList := range *conf </span><span class="cov8" title="1">{
                if ruleList == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("no blockRuleList for product:%s", product)
                }</span>

                <span class="cov8" title="1">err := blockRuleListCheck(ruleList)
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("ProductRules:%s, %s", product, err.Error())
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func productRuleConfCheck(conf productRuleConfFile) error <span class="cov8" title="1">{
        var err error

        // check Version
        if conf.Version == nil </span><span class="cov0" title="0">{
                return errors.New("no Version")
        }</span>

        // check Config
        <span class="cov8" title="1">if conf.Config == nil </span><span class="cov0" title="0">{
                return errors.New("no Config")
        }</span>

        <span class="cov8" title="1">err = productRulesCheck(conf.Config)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("Config:%s", err.Error())
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func ruleConvert(ruleFile blockRuleFile) (blockRule, error) <span class="cov8" title="1">{
        rule := blockRule{}

        cond, err := condition.Build(*ruleFile.Cond)
        if err != nil </span><span class="cov0" title="0">{
                return rule, err
        }</span>
        <span class="cov8" title="1">rule.Cond = cond
        rule.Name = *ruleFile.Name
        rule.Action = actionConvert(*ruleFile.Action)
        return rule, nil</span>
}

func ruleListConvert(ruleFileList *blockRuleFileList) (*blockRuleList, error) <span class="cov8" title="1">{
        ruleList := new(blockRuleList)
        *ruleList = make([]blockRule, 0)

        for _, ruleFile := range *ruleFileList </span><span class="cov8" title="1">{
                rule, err := ruleConvert(ruleFile)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">*ruleList = append(*ruleList, rule)</span>
        }

        <span class="cov8" title="1">return ruleList, nil</span>
}

// ProductRuleConfLoad load block rule config from file.
func ProductRuleConfLoad(filename string) (productRuleConf, error) <span class="cov8" title="1">{
        var conf productRuleConf
        var err error

        // open the file
        file, err := os.Open(filename)
        if err != nil </span><span class="cov0" title="0">{
                return conf, err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        // decode the file
        decoder := json.NewDecoder(file)
        var config productRuleConfFile
        err = decoder.Decode(&amp;config)
        if err != nil </span><span class="cov8" title="1">{
                return conf, err
        }</span>

        // check config
        <span class="cov8" title="1">err = productRuleConfCheck(config)
        if err != nil </span><span class="cov8" title="1">{
                return conf, err
        }</span>

        // convert config
        <span class="cov8" title="1">conf.Version = *config.Version
        conf.Config = make(ProductRules)
        for product, ruleFileList := range *config.Config </span><span class="cov8" title="1">{
                ruleList, err := ruleListConvert(ruleFileList)
                if err != nil </span><span class="cov0" title="0">{
                        return conf, err
                }</span>
                <span class="cov8" title="1">conf.Config[product] = ruleList</span>
        }

        <span class="cov8" title="1">return conf, nil</span>
}
</pre>
		
		<pre class="file" id="file93" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_block

import (
        "sync"
)

type ProductRuleTable struct {
        lock         sync.RWMutex
        version      string
        productRules ProductRules
}

func NewProductRuleTable() *ProductRuleTable <span class="cov8" title="1">{
        t := new(ProductRuleTable)
        t.productRules = make(ProductRules)
        return t
}</span>

func (t *ProductRuleTable) Update(conf productRuleConf) <span class="cov8" title="1">{
        t.lock.Lock()
        t.version = conf.Version
        t.productRules = conf.Config
        t.lock.Unlock()
}</span>

func (t *ProductRuleTable) Search(product string) (*blockRuleList, bool) <span class="cov8" title="1">{
        t.lock.RLock()
        productRules := t.productRules
        t.lock.RUnlock()

        rules, ok := productRules[product]
        return rules, ok
}</span>
</pre>
		
		<pre class="file" id="file94" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_compress

import (
        "compress/gzip"
        "errors"
        "fmt"
)

import (
        "github.com/andybalholm/brotli"
)

const (
        ActionGzip   = "GZIP"
        ActionBrotli = "BROTLI"
)

type ActionFile struct {
        Cmd       *string
        Quality   *int
        FlushSize *int
}

type Action struct {
        Cmd       string
        Quality   int
        FlushSize int
}

func ActionFileCheck(conf *ActionFile) error <span class="cov8" title="1">{
        if conf.Cmd == nil </span><span class="cov0" title="0">{
                return errors.New("no Cmd")
        }</span>

        <span class="cov8" title="1">switch *conf.Cmd </span>{
        case ActionGzip:<span class="cov8" title="1">
                if *conf.Quality &lt; gzip.HuffmanOnly || *conf.Quality &gt; gzip.BestCompression </span><span class="cov0" title="0">{
                        return fmt.Errorf("Quality should be [%d, %d]",
                                gzip.HuffmanOnly, gzip.BestCompression)
                }</span>
        case ActionBrotli:<span class="cov0" title="0">
                if *conf.Quality &lt; brotli.BestSpeed || *conf.Quality &gt; brotli.BestCompression </span><span class="cov0" title="0">{
                        return fmt.Errorf("Quality should be [%d, %d]",
                                brotli.BestSpeed, brotli.BestCompression)
                }</span>
        default:<span class="cov8" title="1">
                return fmt.Errorf("invalid cmd: %s", *conf.Cmd)</span>
        }

        <span class="cov8" title="1">if *conf.FlushSize &lt; 64 || *conf.FlushSize &gt; 4096 </span><span class="cov0" title="0">{
                return fmt.Errorf("FlushSize should be [64, 4096]")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func actionConvert(actionFile ActionFile) Action <span class="cov8" title="1">{
        action := Action{}
        action.Cmd = *actionFile.Cmd
        action.Quality = *actionFile.Quality
        action.FlushSize = *actionFile.FlushSize
        return action
}</span>
</pre>
		
		<pre class="file" id="file95" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_compress

import (
        "bytes"
        "io"
)

import (
        "github.com/andybalholm/brotli"
)

type BrotliFilter struct {
        source    io.ReadCloser
        writer    *brotli.Writer
        buffer    bytes.Buffer
        flushSize int64
        closed    bool
}

func NewBrotliFilter(source io.ReadCloser, level int, size int) (b *BrotliFilter, err error) <span class="cov0" title="0">{
        b = new(BrotliFilter)
        b.writer = brotli.NewWriterLevel(&amp;b.buffer, level)
        b.source = source
        b.flushSize = int64(size)
        return b, nil
}</span>

func (b *BrotliFilter) Read(p []byte) (n int, err error) <span class="cov0" title="0">{
        c, err := io.CopyN(b.writer, b.source, b.flushSize)
        if err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">if c != 0 </span><span class="cov0" title="0">{
                if err := b.writer.Flush(); err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
        } else<span class="cov0" title="0"> if !b.closed </span><span class="cov0" title="0">{
                b.closed = true
                if err := b.writer.Close(); err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
        }

        <span class="cov0" title="0">return b.buffer.Read(p)</span>
}

func (b *BrotliFilter) Close() error <span class="cov0" title="0">{
        if err := b.source.Close(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file96" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_compress

import (
        "errors"
        "fmt"
        "os"
)

import (
        "github.com/bfenetworks/bfe/bfe_basic/condition"
        "github.com/bfenetworks/bfe/bfe_util/json"
)

type compressRuleFile struct {
        Cond   *string
        Action *ActionFile
}

type compressRule struct {
        Cond   condition.Condition
        Action Action
}

type compressRuleFileList []compressRuleFile
type compressRuleList []compressRule

type ProductRulesFile map[string]*compressRuleFileList
type ProductRules map[string]*compressRuleList

type productRuleConfFile struct {
        Version *string
        Config  *ProductRulesFile
}

type productRuleConf struct {
        Version string
        Config  ProductRules
}

func compressRuleCheck(conf compressRuleFile) error <span class="cov8" title="1">{
        if conf.Cond == nil </span><span class="cov0" title="0">{
                return errors.New("no Cond")
        }</span>

        <span class="cov8" title="1">if conf.Action == nil </span><span class="cov0" title="0">{
                return errors.New("no Action")
        }</span>
        <span class="cov8" title="1">if err := ActionFileCheck(conf.Action); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func compressRuleListCheck(conf *compressRuleFileList) error <span class="cov8" title="1">{
        for index, rule := range *conf </span><span class="cov8" title="1">{
                err := compressRuleCheck(rule)
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("compressRule: %d, %v", index, err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func productRulesCheck(conf *ProductRulesFile) error <span class="cov8" title="1">{
        for product, ruleList := range *conf </span><span class="cov8" title="1">{
                if ruleList == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("no compressRuleList for product: %s", product)
                }</span>

                <span class="cov8" title="1">err := compressRuleListCheck(ruleList)
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("ProductRules: %s, %v", product, err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func productRuleConfCheck(conf productRuleConfFile) error <span class="cov8" title="1">{
        var err error

        if conf.Version == nil </span><span class="cov0" title="0">{
                return errors.New("no Version")
        }</span>

        <span class="cov8" title="1">if conf.Config == nil </span><span class="cov0" title="0">{
                return errors.New("no Config")
        }</span>

        <span class="cov8" title="1">err = productRulesCheck(conf.Config)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("Config: %v", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func ruleConvert(ruleFile compressRuleFile) (compressRule, error) <span class="cov8" title="1">{
        rule := compressRule{}

        cond, err := condition.Build(*ruleFile.Cond)
        if err != nil </span><span class="cov0" title="0">{
                return rule, err
        }</span>
        <span class="cov8" title="1">rule.Cond = cond
        rule.Action = actionConvert(*ruleFile.Action)
        return rule, nil</span>
}

func ruleListConvert(ruleFileList *compressRuleFileList) (*compressRuleList, error) <span class="cov8" title="1">{
        ruleList := new(compressRuleList)
        *ruleList = make([]compressRule, 0)

        for _, ruleFile := range *ruleFileList </span><span class="cov8" title="1">{
                rule, err := ruleConvert(ruleFile)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">*ruleList = append(*ruleList, rule)</span>
        }

        <span class="cov8" title="1">return ruleList, nil</span>
}

func ProductRuleConfLoad(filename string) (productRuleConf, error) <span class="cov8" title="1">{
        var conf productRuleConf
        var err error

        file, err := os.Open(filename)
        if err != nil </span><span class="cov0" title="0">{
                return conf, err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        decoder := json.NewDecoder(file)
        var config productRuleConfFile
        err = decoder.Decode(&amp;config)
        if err != nil </span><span class="cov0" title="0">{
                return conf, err
        }</span>

        <span class="cov8" title="1">err = productRuleConfCheck(config)
        if err != nil </span><span class="cov8" title="1">{
                return conf, err
        }</span>

        <span class="cov8" title="1">conf.Version = *config.Version
        conf.Config = make(ProductRules)
        for product, ruleFileList := range *config.Config </span><span class="cov8" title="1">{
                ruleList, err := ruleListConvert(ruleFileList)
                if err != nil </span><span class="cov0" title="0">{
                        return conf, err
                }</span>
                <span class="cov8" title="1">conf.Config[product] = ruleList</span>
        }

        <span class="cov8" title="1">return conf, nil</span>
}
</pre>
		
		<pre class="file" id="file97" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_compress

import (
        "sync"
)

type CompressRuleTable struct {
        lock         sync.RWMutex
        version      string
        productRules ProductRules
}

func NewCompressRuleTable() *CompressRuleTable <span class="cov8" title="1">{
        t := new(CompressRuleTable)
        t.productRules = make(ProductRules)
        return t
}</span>

func (t *CompressRuleTable) Update(conf productRuleConf) <span class="cov8" title="1">{
        t.lock.Lock()
        t.version = conf.Version
        t.productRules = conf.Config
        t.lock.Unlock()
}</span>

func (t *CompressRuleTable) Search(product string) (*compressRuleList, bool) <span class="cov8" title="1">{
        t.lock.RLock()
        productRules := t.productRules
        t.lock.RUnlock()

        rules, ok := productRules[product]
        return rules, ok
}</span>
</pre>
		
		<pre class="file" id="file98" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_compress

import (
        "github.com/baidu/go-lib/log"
        gcfg "gopkg.in/gcfg.v1"
)

import (
        "github.com/bfenetworks/bfe/bfe_util"
)

type ConfModCompress struct {
        Basic struct {
                ProductRulePath string
        }

        Log struct {
                OpenDebug bool
        }
}

func (cfg *ConfModCompress) Check(confRoot string) error <span class="cov8" title="1">{
        if cfg.Basic.ProductRulePath == "" </span><span class="cov0" title="0">{
                log.Logger.Warn("ModCompress.ProductRulePath not set, use default value")
                cfg.Basic.ProductRulePath = "mod_compress/compress_rule.data"
        }</span>

        <span class="cov8" title="1">cfg.Basic.ProductRulePath = bfe_util.ConfPathProc(cfg.Basic.ProductRulePath, confRoot)

        return nil</span>
}

func ConfLoad(filePath string, confRoot string) (*ConfModCompress, error) <span class="cov8" title="1">{
        var cfg ConfModCompress
        var err error

        err = gcfg.ReadFileInto(&amp;cfg, filePath)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;cfg, err
        }</span>

        <span class="cov8" title="1">err = cfg.Check(confRoot)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;cfg, err
        }</span>

        <span class="cov8" title="1">return &amp;cfg, nil</span>
}
</pre>
		
		<pre class="file" id="file99" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_compress

import (
        "bytes"
        "compress/gzip"
        "io"
)

type GzipFilter struct {
        source    io.ReadCloser
        writer    *gzip.Writer
        buffer    bytes.Buffer
        flushSize int64
        closed    bool
}

func NewGzipFilter(source io.ReadCloser, level int, size int) (b *GzipFilter, err error) <span class="cov8" title="1">{
        b = new(GzipFilter)
        b.writer, err = gzip.NewWriterLevel(&amp;b.buffer, level)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">b.source = source
        b.flushSize = int64(size)
        return b, nil</span>
}

func (b *GzipFilter) Read(p []byte) (n int, err error) <span class="cov8" title="1">{
        c, err := io.CopyN(b.writer, b.source, b.flushSize)
        if err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov8" title="1">if c != 0 </span><span class="cov8" title="1">{
                if err := b.writer.Flush(); err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
        } else<span class="cov8" title="1"> if !b.closed </span><span class="cov8" title="1">{
                b.closed = true
                if err := b.writer.Close(); err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
        }

        <span class="cov8" title="1">return b.buffer.Read(p)</span>
}

func (b *GzipFilter) Close() error <span class="cov8" title="1">{
        if err := b.source.Close(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file100" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_compress

import (
        "errors"
        "fmt"
        "net/url"
)

import (
        "github.com/baidu/go-lib/log"
        "github.com/baidu/go-lib/web-monitor/metrics"
        "github.com/baidu/go-lib/web-monitor/web_monitor"
)

import (
        "github.com/bfenetworks/bfe/bfe_basic"
        "github.com/bfenetworks/bfe/bfe_http"
        "github.com/bfenetworks/bfe/bfe_module"
)

const (
        // support encode type of Accept-Encoding header
        EncodeGzip   = "gzip"
        EncodeBrotli = "br"

        // support encode type of Content-Encoding header
        EncodeIdentity = "identity"

        ModCompress = "mod_compress"
)

var (
        openDebug = false
)

type ModuleCompressState struct {
        ReqTotal              *metrics.Counter
        ReqSupportCompress    *metrics.Counter
        ReqMatchCompressRule  *metrics.Counter
        ResEncodeCompress     *metrics.Counter
        ResEncodeGzipCompress *metrics.Counter
        ResEncodeBrCompress   *metrics.Counter
}

type ModuleCompress struct {
        name      string
        conf      *ConfModCompress
        ruleTable *CompressRuleTable
        state     ModuleCompressState
        metrics   metrics.Metrics
}

func NewModuleCompress() *ModuleCompress <span class="cov8" title="1">{
        m := new(ModuleCompress)
        m.name = ModCompress
        m.metrics.Init(&amp;m.state, ModCompress, 0)
        m.ruleTable = NewCompressRuleTable()
        return m
}</span>

func (m *ModuleCompress) Name() string <span class="cov0" title="0">{
        return m.name
}</span>

func (m *ModuleCompress) loadProductRuleConf(query url.Values) error <span class="cov8" title="1">{
        path := query.Get("path")
        if path == "" </span><span class="cov8" title="1">{
                path = m.conf.Basic.ProductRulePath
        }</span>

        <span class="cov8" title="1">conf, err := ProductRuleConfLoad(path)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("err in ProductRuleConfLoad(%s): %s", path, err)
        }</span>

        <span class="cov8" title="1">m.ruleTable.Update(conf)
        return nil</span>
}

func checkSupportCompress(acceptEncoding string) bool <span class="cov8" title="1">{
        return checkSupportGzipCompress(acceptEncoding) || checkSupportBrotliCompress(acceptEncoding)
}</span>

func checkSupportGzipCompress(acceptEncoding string) bool <span class="cov8" title="1">{
        return bfe_http.HasToken(acceptEncoding, EncodeGzip)
}</span>

func checkSupportBrotliCompress(acceptEncoding string) bool <span class="cov0" title="0">{
        return bfe_http.HasToken(acceptEncoding, EncodeBrotli)
}</span>

func (m *ModuleCompress) getCompressRule(req *bfe_basic.Request) (*compressRule, error) <span class="cov8" title="1">{
        if openDebug </span><span class="cov8" title="1">{
                log.Logger.Debug("%s check request", m.name)
        }</span>
        <span class="cov8" title="1">m.state.ReqTotal.Inc(1)

        rules, ok := m.ruleTable.Search(req.Route.Product)
        if !ok </span><span class="cov0" title="0">{
                if openDebug </span><span class="cov0" title="0">{
                        log.Logger.Debug("%s product %s not found, just pass", m.name, req.Route.Product)
                }</span>
                <span class="cov0" title="0">return nil, errors.New("no compress rule")</span>
        }

        <span class="cov8" title="1">for _, rule := range *rules </span><span class="cov8" title="1">{
                if openDebug </span><span class="cov8" title="1">{
                        log.Logger.Debug("%s process rule: %v", m.name, rule)
                }</span>

                <span class="cov8" title="1">if rule.Cond.Match(req) </span><span class="cov8" title="1">{
                        m.state.ReqMatchCompressRule.Inc(1)
                        return &amp;rule, nil
                }</span>
        }

        <span class="cov0" title="0">return nil, errors.New("no matched rule")</span>
}

func (m *ModuleCompress) compressHandler(req *bfe_basic.Request, res *bfe_http.Response) int <span class="cov8" title="1">{
        acceptEncoding := req.HttpRequest.Header.GetDirect("Accept-Encoding")
        if !checkSupportCompress(acceptEncoding) </span><span class="cov0" title="0">{
                return bfe_module.BfeHandlerGoOn
        }</span>
        <span class="cov8" title="1">m.state.ReqSupportCompress.Inc(1)

        contentEncoding := res.Header.GetDirect("Content-Encoding")
        if len(contentEncoding) != 0 &amp;&amp; contentEncoding != EncodeIdentity </span><span class="cov0" title="0">{
                return bfe_module.BfeHandlerGoOn
        }</span>

        <span class="cov8" title="1">rule, err := m.getCompressRule(req)
        if err != nil </span><span class="cov0" title="0">{
                return bfe_module.BfeHandlerGoOn
        }</span>

        <span class="cov8" title="1">switch rule.Action.Cmd </span>{
        case ActionGzip:<span class="cov8" title="1">
                if !checkSupportGzipCompress(acceptEncoding) </span><span class="cov0" title="0">{
                        return bfe_module.BfeHandlerGoOn
                }</span>

                <span class="cov8" title="1">res.Body, err = NewGzipFilter(res.Body, rule.Action.Quality, rule.Action.FlushSize)
                if err != nil </span><span class="cov0" title="0">{
                        return bfe_module.BfeHandlerGoOn
                }</span>

                <span class="cov8" title="1">res.Header.Set("Content-Encoding", EncodeGzip)
                m.state.ResEncodeGzipCompress.Inc(1)</span>
        case ActionBrotli:<span class="cov0" title="0">
                if !checkSupportBrotliCompress(acceptEncoding) </span><span class="cov0" title="0">{
                        return bfe_module.BfeHandlerGoOn
                }</span>

                <span class="cov0" title="0">res.Body, err = NewBrotliFilter(res.Body, rule.Action.Quality, rule.Action.FlushSize)
                if err != nil </span><span class="cov0" title="0">{
                        return bfe_module.BfeHandlerGoOn
                }</span>

                <span class="cov0" title="0">res.Header.Set("Content-Encoding", EncodeBrotli)
                m.state.ResEncodeBrCompress.Inc(1)</span>
        default:<span class="cov0" title="0">
                return bfe_module.BfeHandlerGoOn</span>
        }

        <span class="cov8" title="1">res.Header.Del("Content-Length")
        m.state.ResEncodeCompress.Inc(1)

        return bfe_module.BfeHandlerGoOn</span>
}

func (m *ModuleCompress) getState(params map[string][]string) ([]byte, error) <span class="cov0" title="0">{
        s := m.metrics.GetAll()
        return s.Format(params)
}</span>

func (m *ModuleCompress) getStateDiff(params map[string][]string) ([]byte, error) <span class="cov0" title="0">{
        s := m.metrics.GetDiff()
        return s.Format(params)
}</span>

func (m *ModuleCompress) monitorHandlers() map[string]interface{} <span class="cov8" title="1">{
        handlers := map[string]interface{}{
                m.name:           m.getState,
                m.name + ".diff": m.getStateDiff,
        }
        return handlers
}</span>

func (m *ModuleCompress) reloadHandlers() map[string]interface{} <span class="cov8" title="1">{
        handlers := map[string]interface{}{
                m.name: m.loadProductRuleConf,
        }
        return handlers
}</span>

func (m *ModuleCompress) Init(cbs *bfe_module.BfeCallbacks, whs *web_monitor.WebHandlers,
        cr string) error <span class="cov8" title="1">{
        var err error

        confPath := bfe_module.ModConfPath(cr, m.name)
        if m.conf, err = ConfLoad(confPath, cr); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: conf load err %v", m.name, err)
        }</span>
        <span class="cov8" title="1">openDebug = m.conf.Log.OpenDebug

        if err = m.loadProductRuleConf(nil); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: loadProductRuleConf() err %v", m.name, err)
        }</span>

        <span class="cov8" title="1">err = cbs.AddFilter(bfe_module.HandleReadResponse, m.compressHandler)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init(): AddFilter(m.compressHandler): %v", m.name, err)
        }</span>

        <span class="cov8" title="1">err = web_monitor.RegisterHandlers(whs, web_monitor.WebHandleMonitor, m.monitorHandlers())
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init(): RegisterHandlers(m.monitorHandlers): %v", m.name, err)
        }</span>

        <span class="cov8" title="1">err = web_monitor.RegisterHandlers(whs, web_monitor.WebHandleReload, m.reloadHandlers())
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init(): RegisterHandlers(m.reloadHandlerr): %v", m.name, err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file101" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_cors

import (
        "gopkg.in/gcfg.v1"
)

import (
        "github.com/baidu/go-lib/log"
)

import (
        "github.com/bfenetworks/bfe/bfe_util"
)

const (
        defaultDataPath = "mod_cors/cors_rule.data"
)

type ConfModCors struct {
        Basic struct {
                DataPath string // path of rule data
        }

        Log struct {
                OpenDebug bool
        }
}

func ConfLoad(filePath string, confRoot string) (*ConfModCors, error) <span class="cov8" title="1">{
        var err error
        var cfg ConfModCors

        err = gcfg.ReadFileInto(&amp;cfg, filePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">err = cfg.Check(confRoot)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;cfg, nil</span>
}

func (cfg *ConfModCors) Check(confRoot string) error <span class="cov8" title="1">{
        if len(cfg.Basic.DataPath) == 0 </span><span class="cov0" title="0">{
                cfg.Basic.DataPath = defaultDataPath
                log.Logger.Warn("ModCors.DataPath not set, use default value: %s", defaultDataPath)
        }</span>

        <span class="cov8" title="1">cfg.Basic.DataPath = bfe_util.ConfPathProc(cfg.Basic.DataPath, confRoot)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file102" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_cors

import (
        "fmt"
        "net/http"
        "os"
        "strings"
)

import (
        "github.com/bfenetworks/bfe/bfe_basic/condition"
        "github.com/bfenetworks/bfe/bfe_util/json"
)

type CorsRuleFile struct {
        Version string
        Config  ProductRuleRawList // product -&gt; raw rule list
}

type CorsRuleConf struct {
        Version string
        Config  ProductRuleList // product -&gt; rule list
}

type CorsRuleRaw struct {
        Cond string // condition

        // AccessControlAllowOrigins specifies either a single origin, which tells browsers to
        // allow that origin to access the resource; or else — for requests without credentials —
        // the "*" wildcard, to tell browsers to allow any origin to access the resource
        AccessControlAllowOrigins []string

        // AccessControlAllowCredentials Indicates whether or not the response to the request can be exposed
        AccessControlAllowCredentials bool

        // AccessControlExposeHeaders lets a server whitelist headers that browsers are allowed to access.
        AccessControlExposeHeaders []string

        // AccessControlAllowMethods specifies the method or methods allowed when accessing the resource.
        // This is used in response to a preflight request.
        AccessControlAllowMethods []string

        // AccessControlAllowHeaders indicates which HTTP headers can be used when making the actual request.
        // This is used in response to a preflight request.
        AccessControlAllowHeaders []string

        // AccessControlMaxAge indicates how long the results of a preflight request can be cached.
        // This is used in response to a preflight request.
        AccessControlMaxAge *int
}

type ProductRuleRawList map[string]RuleRawList // product =&gt; raw rule list
type RuleRawList []CorsRuleRaw

var (
        supportedMethod = map[string]bool{
                http.MethodGet:     true,
                http.MethodHead:    true,
                http.MethodPost:    true,
                http.MethodPut:     true,
                http.MethodDelete:  true,
                http.MethodConnect: true,
                http.MethodOptions: true,
                http.MethodTrace:   true,
                http.MethodPatch:   true,
        }
)

func CorsRuleCheck(corsRuleFile *CorsRuleFile) error <span class="cov8" title="1">{
        if corsRuleFile == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("corsRuleFile is nil")
        }</span>

        <span class="cov8" title="1">if len(corsRuleFile.Version) == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("no Version")
        }</span>

        <span class="cov8" title="1">if corsRuleFile.Config == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("no Config")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func ruleConvert(rawRule CorsRuleRaw) (*CorsRule, error) <span class="cov8" title="1">{
        cond, err := condition.Build(rawRule.Cond)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var rule CorsRule
        rule.Cond = cond

        if len(rawRule.AccessControlAllowOrigins) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("AccessControlAllowOrigins not set")
        }</span>

        <span class="cov8" title="1">rule.AccessControlAllowOriginMap = make(map[string]bool)

        // &lt;origin&gt;:          Specifies the list of supported origin
        // * (wildcard): For requests without credentials, the literal value "*" can be specified, as a wildcard;
        //                                    the value tells browsers to allow requesting code from any origin to access the resource.
        //                             Attempting to use the wildcard with credentials will result in an error.
        // null:                  Specifies the origin "null".
        // %origin:          Specifies the origin from the request header "Origin"
        for _, allowOrigin := range rawRule.AccessControlAllowOrigins </span><span class="cov8" title="1">{
                if strings.HasPrefix(allowOrigin, "%") &amp;&amp; allowOrigin != "%origin" </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("AccessControlAllowOrigins %s is not supported", allowOrigin)
                }</span>

                <span class="cov8" title="1">if strings.Contains(allowOrigin, "*") &amp;&amp; len(allowOrigin) != 1 </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("AccessControlAllowOrigins %s is not supported", allowOrigin)
                }</span>

                <span class="cov8" title="1">if allowOrigin == "*" &amp;&amp; rawRule.AccessControlAllowCredentials </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("AccessControlAllowCredentials can not be true when AccessControlAllowOrigins is *")
                }</span>

                <span class="cov8" title="1">if (allowOrigin == "null" || allowOrigin == "*") &amp;&amp; len(rawRule.AccessControlAllowOrigins) != 1 </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("AccessControlAllowOrigins can only contain one element when AccessControlAllowOrigins is null or *")
                }</span>

                <span class="cov8" title="1">rule.AccessControlAllowOriginMap[allowOrigin] = true</span>
        }

        // &lt;header-name&gt;: The name of a supported request header. The header may list any number of headers
        // * (wildcard):  The value "*" only counts as a special wildcard value for requests without credentials
        //                                   (requests without HTTP cookies or HTTP authentication information).
        //                                   In requests with credentials, it is treated as the literal header name "*" without special semantics.
        //                                   Note that the Authorization header can't be wildcarded and always needs to be listed explicitly.
        <span class="cov8" title="1">for _, allowHeader := range rawRule.AccessControlAllowHeaders </span><span class="cov8" title="1">{
                if strings.Contains(allowHeader, "*") &amp;&amp; len(allowHeader) != 1 </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("AccessControlAllowHeaders %s is not supported", allowHeader)
                }</span>

                <span class="cov8" title="1">if allowHeader == "*" &amp;&amp; len(rawRule.AccessControlAllowHeaders) != 1 </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("AccessControlAllowHeaders can only contain one element when AccessControlAllowHeaders is *")
                }</span>
        }
        <span class="cov8" title="1">rule.AccessControlAllowHeaders = rawRule.AccessControlAllowHeaders

        // &lt;header-name&gt;: A list of exposed headers consisting of zero or more header names other than the CORS-safelisted request headers
        //                                   that the resource might use and can be exposed.
        // * (wildcard):  The value "*" only counts as a special wildcard value for requests without credentials
        //                                   (requests without HTTP cookies or HTTP authentication information).
        //                                   In requests with credentials, it is treated as the literal header name "*" without special semantics.
        //                                    Note that the Authorization header can't be wildcarded and always needs to be listed explicitly.
        for _, exposeHeader := range rawRule.AccessControlExposeHeaders </span><span class="cov8" title="1">{
                if strings.Contains(exposeHeader, "*") &amp;&amp; len(exposeHeader) != 1 </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("AccessControlExposeHeaders %s is not supported", exposeHeader)
                }</span>

                <span class="cov8" title="1">if exposeHeader == "*" &amp;&amp; len(rawRule.AccessControlExposeHeaders) != 1 </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("AccessControlExposeHeaders can only contain one element when AccessControlExposeHeaders is *")
                }</span>
        }
        <span class="cov8" title="1">rule.AccessControlExposeHeaders = rawRule.AccessControlExposeHeaders

        // &lt;method&gt;:          list of the allowed HTTP request methods.
        // * (wildcard): The value "*" only counts as a special wildcard value for requests without
        //                                  credentials (requests without HTTP cookies or HTTP authentication information).
        //                                  In requests with credentials, it is treated as the literal method name "*" without special semantics.
        for _, allowMethod := range rawRule.AccessControlAllowMethods </span><span class="cov8" title="1">{
                if strings.Contains(allowMethod, "*") &amp;&amp; len(allowMethod) != 1 </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("AccessControlAllowMethods %s is not supported", allowMethod)
                }</span>

                <span class="cov8" title="1">if allowMethod == "*" &amp;&amp; len(rawRule.AccessControlAllowMethods) != 1 </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("AccessControlAllowMethods can only contain one element when AccessControlAllowMethods is *")
                }</span>

                <span class="cov0" title="0">if allowMethod != "*" </span><span class="cov0" title="0">{
                        if _, ok := supportedMethod[allowMethod]; !ok </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("AccessControlAllowMethods %s is not supported", allowMethod)
                        }</span>
                }
        }
        <span class="cov8" title="1">rule.AccessControlAllowMethods = rawRule.AccessControlAllowMethods

        // Maximum number of seconds the results can be cached.
        // Firefox caps this at 24 hours (86400 seconds).
        // Chromium (prior to v76) caps at 10 minutes (600 seconds).
        // Chromium (starting in v76) caps at 2 hours (7200 seconds).
        // Chromium also specifies a default value of 5 seconds.
        // A value of -1 will disable caching, requiring a preflight OPTIONS check for all calls.
        if rawRule.AccessControlMaxAge != nil </span><span class="cov8" title="1">{
                if *rawRule.AccessControlMaxAge &lt; -1 || *rawRule.AccessControlMaxAge &gt; 86400 </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("AccessControlMaxAge must be in [-1, 86400]")
                }</span>
                <span class="cov8" title="1">rule.AccessControlMaxAge = rawRule.AccessControlMaxAge</span>
        }

        <span class="cov8" title="1">rule.AccessControlAllowCredentials = rawRule.AccessControlAllowCredentials
        return &amp;rule, nil</span>
}

func ruleListConvert(rawRuleList RuleRawList) (CorsRuleList, error) <span class="cov8" title="1">{
        ruleList := CorsRuleList{}
        for i, rawRule := range rawRuleList </span><span class="cov8" title="1">{
                rule, err := ruleConvert(rawRule)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("rule [%d] error: %v", i, err)
                }</span>

                <span class="cov8" title="1">ruleList = append(ruleList, *rule)</span>
        }

        <span class="cov8" title="1">return ruleList, nil</span>
}

func CorsRuleFileLoad(filename string) (*CorsRuleConf, error) <span class="cov8" title="1">{
        var corsRuleFile CorsRuleFile
        var corsRuleConf CorsRuleConf

        file, err := os.Open(filename)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        decoder := json.NewDecoder(file)
        err = decoder.Decode(&amp;corsRuleFile)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">err = CorsRuleCheck(&amp;corsRuleFile)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">corsRuleConf.Version = corsRuleFile.Version
        corsRuleConf.Config = make(ProductRuleList)

        for product, ruleFileList := range corsRuleFile.Config </span><span class="cov8" title="1">{
                ruleList, err := ruleListConvert(ruleFileList)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("product[%s] rule error: %v", product, err)
                }</span>
                <span class="cov8" title="1">corsRuleConf.Config[product] = ruleList</span>
        }

        <span class="cov8" title="1">return &amp;corsRuleConf, nil</span>
}
</pre>
		
		<pre class="file" id="file103" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_cors

import (
        "sync"
)

import (
        "github.com/bfenetworks/bfe/bfe_basic/condition"
)

type CorsRuleTable struct {
        lock        sync.RWMutex
        version     string
        productRule ProductRuleList // product =&gt; rule list
}

type CorsRule struct {
        Cond                          condition.Condition
        AccessControlAllowOriginMap   map[string]bool
        AccessControlAllowCredentials bool
        AccessControlExposeHeaders    []string
        AccessControlAllowMethods     []string
        AccessControlAllowHeaders     []string
        AccessControlMaxAge           *int
}

type ProductRuleList map[string]CorsRuleList // product =&gt; list of cors rule list
type CorsRuleList []CorsRule

func NewCorsRuleTable() *CorsRuleTable <span class="cov8" title="1">{
        t := new(CorsRuleTable)
        t.productRule = make(ProductRuleList)
        return t
}</span>

func (t *CorsRuleTable) Update(ruleConf *CorsRuleConf) <span class="cov8" title="1">{
        t.lock.Lock()
        t.version = ruleConf.Version
        t.productRule = ruleConf.Config
        t.lock.Unlock()
}</span>

func (t *CorsRuleTable) Search(product string) (CorsRuleList, bool) <span class="cov8" title="1">{
        t.lock.RLock()
        ruleList, ok := t.productRule[product]
        t.lock.RUnlock()

        return ruleList, ok
}</span>
</pre>
		
		<pre class="file" id="file104" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_cors

import (
        "fmt"
        "net/http"
        "net/url"
        "path/filepath"
        "strconv"
        "strings"
)

import (
        "github.com/baidu/go-lib/log"
        "github.com/baidu/go-lib/web-monitor/metrics"
        "github.com/baidu/go-lib/web-monitor/web_monitor"
)

import (
        "github.com/bfenetworks/bfe/bfe_basic"
        "github.com/bfenetworks/bfe/bfe_http"
        "github.com/bfenetworks/bfe/bfe_module"
)

const (
        ModCors                             = "mod_cors"
        HeaderAccessControlAllowOrigin      = "Access-Control-Allow-Origin"
        HeaderAccessControlAllowCredentials = "Access-Control-Allow-Credentials"
        HeaderAccessControlAllowMethods     = "Access-Control-Allow-Methods"
        HeaderAccessControlAllowHeaders     = "Access-Control-Allow-Headers"
        HeaderAccessControlMaxAge           = "Access-Control-Max-Age"
        HeaderAccessControlExposeHeaders    = "Access-Control-Expose-Headers"
        HeaderAccessControlRequestMethod    = "Access-Control-Request-Method"
        HeaderOrigin                        = "Origin"
        HeaderVary                          = "Vary"
)

type ModuleCorsState struct {
        ReqCorsRuleHit       *metrics.Counter
        ReqPreFlightHit      *metrics.Counter
        ReqAllowOriginHit    *metrics.Counter
        ReqNotAllowOriginHit *metrics.Counter
}

var (
        openDebug = false
)

type ModuleCors struct {
        name      string
        conf      *ConfModCors
        ruleTable *CorsRuleTable
        state     ModuleCorsState
        metrics   metrics.Metrics
}

func NewModuleCors() *ModuleCors <span class="cov8" title="1">{
        m := new(ModuleCors)
        m.name = ModCors
        m.ruleTable = NewCorsRuleTable()
        m.metrics.Init(&amp;m.state, ModCors, 0)
        return m
}</span>

func (m *ModuleCors) Name() string <span class="cov0" title="0">{
        return m.name
}</span>

func (m *ModuleCors) loadRuleData(query url.Values) (string, error) <span class="cov8" title="1">{
        // get file path
        path := query.Get("path")
        if path == "" </span><span class="cov8" title="1">{
                // use default
                path = m.conf.Basic.DataPath
        }</span>

        // load from config file
        <span class="cov8" title="1">conf, err := CorsRuleFileLoad(path)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("%s: CorsRuleFileLoad(%s) error: %v", m.name, path, err)
        }</span>

        // update to rule table
        <span class="cov8" title="1">m.ruleTable.Update(conf)

        _, fileName := filepath.Split(path)
        return fmt.Sprintf("%s=%s", fileName, conf.Version), nil</span>
}

// Add `Origin` in the Vary response header, to indicate to clients that server responses will differ based on the value
// of the Origin request header
func addVaryHeader(rspHeader bfe_http.Header) <span class="cov8" title="1">{
        varyValue := rspHeader.Get(HeaderVary)
        if len(varyValue) == 0 </span><span class="cov8" title="1">{
                rspHeader.Set(HeaderVary, HeaderOrigin)
                return
        }</span>

        <span class="cov8" title="1">if varyValue == "*" </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">needAddOrigin := true
        items := strings.Split(varyValue, ",")
        for _, item := range items </span><span class="cov8" title="1">{
                if strings.TrimSpace(item) == HeaderOrigin </span><span class="cov8" title="1">{
                        needAddOrigin = false
                        break</span>
                }
        }

        <span class="cov8" title="1">if needAddOrigin </span><span class="cov0" title="0">{
                varyValue += fmt.Sprintf(",%s", HeaderOrigin)
        }</span>
}

// set response header for preflight request
func (m *ModuleCors) setRespHeaderForPreflght(request *bfe_basic.Request, rspHeader bfe_http.Header, rule *CorsRule) <span class="cov8" title="1">{
        origin := request.HttpRequest.Header.Get(HeaderOrigin)
        allow, matchedOrigin := matchOriginAllowed(origin, rule)
        if !allow </span><span class="cov0" title="0">{
                m.state.ReqNotAllowOriginHit.Inc(1)
                return
        }</span>
        <span class="cov8" title="1">m.state.ReqAllowOriginHit.Inc(1)

        rspHeader.Set(HeaderAccessControlAllowOrigin, matchedOrigin)

        if rule.AccessControlAllowCredentials </span><span class="cov8" title="1">{
                rspHeader.Set(HeaderAccessControlAllowCredentials, "true")
        }</span>

        <span class="cov8" title="1">if len(rule.AccessControlAllowMethods) &gt; 0 </span><span class="cov8" title="1">{
                rspHeader.Set(HeaderAccessControlAllowMethods, strings.Join(rule.AccessControlAllowMethods, ","))
        }</span>

        <span class="cov8" title="1">if len(rule.AccessControlAllowHeaders) &gt; 0 </span><span class="cov8" title="1">{
                rspHeader.Set(HeaderAccessControlAllowHeaders, strings.Join(rule.AccessControlAllowHeaders, ","))
        }</span>

        <span class="cov8" title="1">if rule.AccessControlMaxAge != nil </span><span class="cov8" title="1">{
                rspHeader.Set(HeaderAccessControlMaxAge, strconv.Itoa(*rule.AccessControlMaxAge))
        }</span>

        <span class="cov8" title="1">addVaryHeader(rspHeader)</span>
}

// set response header for non-preflight request
func (m *ModuleCors) setRespHeaderForNonPreflight(request *bfe_basic.Request, rspHeader bfe_http.Header, rule *CorsRule) <span class="cov8" title="1">{
        origin := request.HttpRequest.Header.Get(HeaderOrigin)
        allow, matchedOrigin := matchOriginAllowed(origin, rule)
        if !allow </span><span class="cov0" title="0">{
                m.state.ReqNotAllowOriginHit.Inc(1)
                return
        }</span>
        <span class="cov8" title="1">m.state.ReqAllowOriginHit.Inc(1)

        rspHeader.Set(HeaderAccessControlAllowOrigin, matchedOrigin)

        if rule.AccessControlAllowCredentials </span><span class="cov8" title="1">{
                rspHeader.Set(HeaderAccessControlAllowCredentials, "true")
        }</span>

        <span class="cov8" title="1">if len(rule.AccessControlExposeHeaders) &gt; 0 </span><span class="cov8" title="1">{
                rspHeader.Set(HeaderAccessControlExposeHeaders, strings.Join(rule.AccessControlExposeHeaders, ","))
        }</span>

        <span class="cov8" title="1">addVaryHeader(rspHeader)</span>
}

func (m *ModuleCors) corsHandler(request *bfe_basic.Request, response *bfe_http.Response) int <span class="cov8" title="1">{
        // cors request must carry header "origin"
        if request.HttpRequest.Header.Get(HeaderOrigin) == "" </span><span class="cov0" title="0">{
                return bfe_module.BfeHandlerGoOn
        }</span>

        // preflight request has processed by corsPreflightHandler, no need to deal it
        <span class="cov8" title="1">if checkCorsPreflight(request) </span><span class="cov0" title="0">{
                return bfe_module.BfeHandlerGoOn
        }</span>

        <span class="cov8" title="1">rules, ok := m.ruleTable.Search(request.Route.Product)
        if !ok </span><span class="cov0" title="0">{
                return bfe_module.BfeHandlerGoOn
        }</span>

        <span class="cov8" title="1">for index, rule := range rules </span><span class="cov8" title="1">{
                if rule.Cond.Match(request) </span><span class="cov8" title="1">{
                        if openDebug </span><span class="cov0" title="0">{
                                log.Logger.Info("%s hit product[%s] cors rule[%d]",
                                        request.HttpRequest.Host+request.HttpRequest.URL.RequestURI(), request.Route.Product, index)
                        }</span>

                        <span class="cov8" title="1">m.state.ReqCorsRuleHit.Inc(1)

                        // set cors header for response
                        m.setRespHeaderForNonPreflight(request, response.Header, &amp;rule)
                        break</span>
                }
        }

        <span class="cov8" title="1">return bfe_module.BfeHandlerGoOn</span>
}

func checkCorsPreflight(request *bfe_basic.Request) bool <span class="cov8" title="1">{
        if request.HttpRequest.Method != http.MethodOptions </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">if request.HttpRequest.Header.Get(HeaderOrigin) == "" </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">if _, ok := supportedMethod[request.HttpRequest.Header.Get(HeaderAccessControlRequestMethod)]; !ok </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">return true</span>
}

func matchOriginAllowed(origin string, rule *CorsRule) (bool, string) <span class="cov8" title="1">{
        if _, ok := rule.AccessControlAllowOriginMap["%origin"]; ok </span><span class="cov0" title="0">{
                return true, origin
        }</span>

        <span class="cov8" title="1">if _, ok := rule.AccessControlAllowOriginMap["*"]; ok </span><span class="cov8" title="1">{
                return true, "*"
        }</span>

        <span class="cov8" title="1">if _, ok := rule.AccessControlAllowOriginMap[origin]; ok </span><span class="cov8" title="1">{
                return true, origin
        }</span>

        <span class="cov0" title="0">return false, ""</span>
}

func (m *ModuleCors) createCorsPreflightResponse(request *bfe_basic.Request, rule *CorsRule) *bfe_http.Response <span class="cov0" title="0">{
        m.state.ReqPreFlightHit.Inc(1)

        resp := bfe_basic.CreateInternalResp(request, bfe_http.StatusNoContent)

        m.setRespHeaderForPreflght(request, resp.Header, rule)

        return resp
}</span>

func (m *ModuleCors) corsPreflightHandler(request *bfe_basic.Request) (int, *bfe_http.Response) <span class="cov0" title="0">{
        if !checkCorsPreflight(request) </span><span class="cov0" title="0">{
                return bfe_module.BfeHandlerGoOn, nil
        }</span>

        <span class="cov0" title="0">rules, ok := m.ruleTable.Search(request.Route.Product)
        if !ok </span><span class="cov0" title="0">{
                return bfe_module.BfeHandlerGoOn, nil
        }</span>

        <span class="cov0" title="0">for index, rule := range rules </span><span class="cov0" title="0">{
                if rule.Cond.Match(request) </span><span class="cov0" title="0">{
                        if openDebug </span><span class="cov0" title="0">{
                                log.Logger.Info("%s hit product[%s] cors rule[%d]",
                                        request.HttpRequest.Host+request.HttpRequest.URL.String(), request.Route.Product, index)
                        }</span>

                        <span class="cov0" title="0">m.state.ReqCorsRuleHit.Inc(1)

                        resp := m.createCorsPreflightResponse(request, &amp;rule)

                        return bfe_module.BfeHandlerResponse, resp</span>
                }
        }

        <span class="cov0" title="0">return bfe_module.BfeHandlerGoOn, nil</span>
}

func (m *ModuleCors) getState(params map[string][]string) ([]byte, error) <span class="cov0" title="0">{
        s := m.metrics.GetAll()
        return s.Format(params)
}</span>

func (m *ModuleCors) getStateDiff(params map[string][]string) ([]byte, error) <span class="cov0" title="0">{
        s := m.metrics.GetDiff()
        return s.Format(params)
}</span>

func (m *ModuleCors) monitorHandlers() map[string]interface{} <span class="cov8" title="1">{
        handlers := map[string]interface{}{
                m.name:           m.getState,
                m.name + ".diff": m.getStateDiff,
        }
        return handlers
}</span>

func (m *ModuleCors) reloadHandlers() map[string]interface{} <span class="cov8" title="1">{
        handlers := map[string]interface{}{
                m.name: m.loadRuleData,
        }
        return handlers
}</span>

func (m *ModuleCors) Init(cbs *bfe_module.BfeCallbacks, whs *web_monitor.WebHandlers, cr string) error <span class="cov8" title="1">{
        var err error
        var conf *ConfModCors

        confPath := bfe_module.ModConfPath(cr, m.name)
        if conf, err = ConfLoad(confPath, cr); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: conf load err %s", m.name, err.Error())
        }</span>

        <span class="cov8" title="1">m.conf = conf
        openDebug = conf.Log.OpenDebug

        _, err = m.loadRuleData(nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">err = cbs.AddFilter(bfe_module.HandleFoundProduct, m.corsPreflightHandler)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init(): AddFilter(m.corsPreflightHandler): %v", m.name, err)
        }</span>

        <span class="cov8" title="1">err = cbs.AddFilter(bfe_module.HandleReadResponse, m.corsHandler)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init(): AddFilter(m.corsHandler): %v", m.name, err)
        }</span>

        <span class="cov8" title="1">err = web_monitor.RegisterHandlers(whs, web_monitor.WebHandleMonitor, m.monitorHandlers())
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init():RegisterHandlers(m.reloadHandlers): %v", m.name, err)
        }</span>

        <span class="cov8" title="1">err = web_monitor.RegisterHandlers(whs, web_monitor.WebHandleReload, m.reloadHandlers())
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init():RegisterHandlers(m.reloadHandlers): %v", m.name, err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file105" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_doh

import (
        "fmt"
        "net"
)

import (
        gcfg "gopkg.in/gcfg.v1"
)

import (
        "github.com/bfenetworks/bfe/bfe_basic/condition"
)

type DnsConf struct {
        Address  string
        RetryMax int
        Timeout  int // In Millisecond.
}

type ConfModDoh struct {
        Basic struct {
                Cond string
        }

        Dns DnsConf

        Log struct {
                OpenDebug bool
        }
}

func ConfLoad(filePath string, confRoot string) (*ConfModDoh, error) <span class="cov8" title="1">{
        var err error
        var cfg ConfModDoh

        err = gcfg.ReadFileInto(&amp;cfg, filePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">err = cfg.Check()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;cfg, nil</span>
}

func (cfg *ConfModDoh) Check() error <span class="cov8" title="1">{
        _, err := condition.Build(cfg.Basic.Cond)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if cfg.Dns.RetryMax &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("RetryMax should &gt;= 0.")
        }</span>

        <span class="cov8" title="1">if cfg.Dns.Timeout &lt; 1 </span><span class="cov0" title="0">{
                return fmt.Errorf("Timeout should &gt; 0.")
        }</span>

        <span class="cov8" title="1">_, err = net.ResolveUDPAddr("udp", cfg.Dns.Address)
        return err</span>
}
</pre>
		
		<pre class="file" id="file106" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_doh

import (
        "time"
)

import (
        "github.com/baidu/go-lib/log"
        "github.com/miekg/dns"
)

import (
        "github.com/bfenetworks/bfe/bfe_basic"
        "github.com/bfenetworks/bfe/bfe_http"
)

type DnsFetcher interface {
        Fetch(req *bfe_basic.Request) (*bfe_http.Response, error)
}

type DnsClient struct {
        address  string
        retryMax int
        client   dns.Client
}

func NewDnsClient(dnsConf *DnsConf) *DnsClient <span class="cov8" title="1">{
        dnsClient := new(DnsClient)
        dnsClient.address = dnsConf.Address
        dnsClient.retryMax = dnsConf.RetryMax
        dnsClient.client = dns.Client{
                Net:     "udp",
                Timeout: time.Duration(dnsConf.Timeout) * time.Millisecond,
                UDPSize: dns.MaxMsgSize,
        }

        return dnsClient
}</span>

func (c *DnsClient) exchangeWithRetry(msg *dns.Msg) (*dns.Msg, error) <span class="cov0" title="0">{
        var reply *dns.Msg
        var err error

        for retry := 0; retry &lt; c.retryMax+1; retry++ </span><span class="cov0" title="0">{
                reply, _, err = c.client.Exchange(msg, c.address)
                if err == nil </span><span class="cov0" title="0">{
                        return reply, nil
                }</span>

                <span class="cov0" title="0">if openDebug </span><span class="cov0" title="0">{
                        log.Logger.Debug("dns client: Exchange error: %v, retry: %d", err, retry)
                }</span>
        }

        <span class="cov0" title="0">return nil, err</span>
}

func (c *DnsClient) Fetch(req *bfe_basic.Request) (*bfe_http.Response, error) <span class="cov0" title="0">{
        msg, err := RequestToDnsMsg(req)
        if err != nil </span><span class="cov0" title="0">{
                if openDebug </span><span class="cov0" title="0">{
                        log.Logger.Debug("dns client: RequestToDnsMsg error: %v", err)
                }</span>

                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov0" title="0">reply, err := c.exchangeWithRetry(msg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">resp, err := DnsMsgToResponse(req, reply)
        if err != nil </span><span class="cov0" title="0">{
                if openDebug </span><span class="cov0" title="0">{
                        log.Logger.Debug("dns client: DnsMsgToResponse error: %v", err)
                }</span>

                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov0" title="0">return resp, nil</span>
}
</pre>
		
		<pre class="file" id="file107" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_doh

import (
        "bytes"
        "encoding/base64"
        "fmt"
        "io"
        "io/ioutil"
        "strconv"
)

import (
        "github.com/miekg/dns"
)

import (
        "github.com/bfenetworks/bfe/bfe_basic"
        "github.com/bfenetworks/bfe/bfe_http"
)

const DnsMessage = "application/dns-message"

var maxPostMsgLength int64 = 8192

func unpackMsg(buf []byte) (*dns.Msg, error) <span class="cov8" title="1">{
        m := new(dns.Msg)
        err := m.Unpack(buf)
        return m, err
}</span>

func requestToMsgPost(req *bfe_http.Request) (*dns.Msg, error) <span class="cov8" title="1">{
        bodyReader := io.LimitedReader{R: req.Body, N: maxPostMsgLength}
        buf, err := ioutil.ReadAll(&amp;bodyReader)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return unpackMsg(buf)</span>
}

func requestToMsgGet(req *bfe_http.Request) (*dns.Msg, error) <span class="cov8" title="1">{
        values := req.URL.Query()
        dnsQuery, ok := values["dns"]
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("\"dns\" query not found")
        }</span>
        <span class="cov8" title="1">if len(dnsQuery) != 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("multiple \"dns\" query values found")
        }</span>

        <span class="cov8" title="1">buf, err := base64.RawURLEncoding.DecodeString(dnsQuery[0])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return unpackMsg(buf)</span>
}

func setClientSubnet(req *bfe_basic.Request, dnsMsg *dns.Msg) <span class="cov8" title="1">{
        if req.RemoteAddr == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">cip := req.RemoteAddr.IP
        if req.ClientAddr != nil </span><span class="cov0" title="0">{
                cip = req.ClientAddr.IP
        }</span>

        <span class="cov8" title="1">var family uint16 = 1
        var sourceNetmask uint8 = 32
        if cip.To16() != nil </span><span class="cov8" title="1">{
                family = 2
                sourceNetmask = 128
        }</span>

        <span class="cov8" title="1">subnet := &amp;dns.EDNS0_SUBNET{
                Code:          dns.EDNS0SUBNET,
                Family:        family,
                SourceNetmask: sourceNetmask,
                SourceScope:   0,
                Address:       cip,
        }

        opt := new(dns.OPT)
        opt.Hdr.Name = "."
        opt.Hdr.Rrtype = dns.TypeOPT
        opt.SetUDPSize(dns.DefaultMsgSize)
        opt.Option = append(opt.Option, subnet)
        dnsMsg.Extra = append(dnsMsg.Extra, opt)</span>
}

func RequestToDnsMsg(req *bfe_basic.Request) (*dns.Msg, error) <span class="cov8" title="1">{
        var dnsMsg *dns.Msg
        var err error

        httpRequest := req.HttpRequest
        switch httpRequest.Method </span>{
        case "GET":<span class="cov8" title="1">
                dnsMsg, err = requestToMsgGet(httpRequest)</span>
        case "POST":<span class="cov8" title="1">
                dnsMsg, err = requestToMsgPost(httpRequest)</span>
        default:<span class="cov0" title="0">
                err = fmt.Errorf("unsupported method: %s", httpRequest.Method)</span>
        }
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">setClientSubnet(req, dnsMsg)
        return dnsMsg, nil</span>
}

func getTTL(msg *dns.Msg) uint32 <span class="cov8" title="1">{
        if len(msg.Answer) &lt; 1 </span><span class="cov0" title="0">{
                return 0
        }</span>

        // Use the smallest TTL in the Answer section.
        // See section 5.1 of RFC 8484.
        <span class="cov8" title="1">ttl := msg.Answer[0].Header().Ttl
        for i := 1; i &lt; len(msg.Answer); i++ </span><span class="cov8" title="1">{
                if ttl &gt; msg.Answer[i].Header().Ttl </span><span class="cov8" title="1">{
                        ttl = msg.Answer[i].Header().Ttl
                }</span>
        }

        <span class="cov8" title="1">return ttl</span>
}

func DnsMsgToResponse(req *bfe_basic.Request, msg *dns.Msg) (*bfe_http.Response, error) <span class="cov8" title="1">{
        data, err := msg.Pack()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">resp := bfe_basic.CreateInternalResp(req, bfe_http.StatusOK)
        resp.Header.Set("Content-Type", DnsMessage)
        resp.Header.Set("Cache-Control", fmt.Sprintf("max-age=%d", getTTL(msg)))
        resp.Header.Set("Content-Length", strconv.Itoa(len(data)))
        resp.Body = ioutil.NopCloser(bytes.NewReader(data))
        return resp, nil</span>
}
</pre>
		
		<pre class="file" id="file108" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_doh

import (
        "fmt"
)

import (
        "github.com/baidu/go-lib/web-monitor/metrics"
        "github.com/baidu/go-lib/web-monitor/web_monitor"
)

import (
        "github.com/bfenetworks/bfe/bfe_basic"
        "github.com/bfenetworks/bfe/bfe_basic/condition"
        "github.com/bfenetworks/bfe/bfe_http"
        "github.com/bfenetworks/bfe/bfe_module"
)

const (
        ModDoh = "mod_doh"
)

var (
        openDebug = false
)

type ModuleDohState struct {
        DohRequest          *metrics.Counter
        DohRequestNotSecure *metrics.Counter
        FetchDnsErr         *metrics.Counter
}

type ModuleDoh struct {
        name       string
        state      ModuleDohState
        metrics    metrics.Metrics
        conf       *ConfModDoh
        cond       condition.Condition
        dnsFetcher DnsFetcher
}

func NewModuleDoh() *ModuleDoh <span class="cov8" title="1">{
        m := new(ModuleDoh)
        m.name = ModDoh
        m.metrics.Init(&amp;m.state, ModDoh, 0)
        return m
}</span>

func (m *ModuleDoh) Name() string <span class="cov0" title="0">{
        return m.name
}</span>

func (m *ModuleDoh) getState(params map[string][]string) ([]byte, error) <span class="cov0" title="0">{
        s := m.metrics.GetAll()
        return s.Format(params)
}</span>

func (m *ModuleDoh) getStateDiff(params map[string][]string) ([]byte, error) <span class="cov0" title="0">{
        s := m.metrics.GetDiff()
        return s.Format(params)
}</span>

func (m *ModuleDoh) monitorHandlers() map[string]interface{} <span class="cov8" title="1">{
        handlers := map[string]interface{}{
                m.name:           m.getState,
                m.name + ".diff": m.getStateDiff,
        }
        return handlers
}</span>

func (m *ModuleDoh) dohHandler(req *bfe_basic.Request) (int, *bfe_http.Response) <span class="cov8" title="1">{
        if !m.cond.Match(req) </span><span class="cov0" title="0">{
                return bfe_module.BfeHandlerGoOn, nil
        }</span>

        <span class="cov8" title="1">m.state.DohRequest.Inc(1)
        if !req.Session.IsSecure </span><span class="cov0" title="0">{
                m.state.DohRequestNotSecure.Inc(1)
                return bfe_module.BfeHandlerResponse,
                        bfe_basic.CreateInternalResp(req, bfe_http.StatusForbidden)
        }</span>

        <span class="cov8" title="1">resp, err := m.dnsFetcher.Fetch(req)
        if err != nil </span><span class="cov0" title="0">{
                m.state.FetchDnsErr.Inc(1)
                return bfe_module.BfeHandlerResponse,
                        bfe_basic.CreateInternalResp(req, bfe_http.StatusInternalServerError)
        }</span>

        <span class="cov8" title="1">return bfe_module.BfeHandlerResponse, resp</span>
}

func (m *ModuleDoh) Init(cbs *bfe_module.BfeCallbacks, whs *web_monitor.WebHandlers,
        cr string) error <span class="cov8" title="1">{
        var err error
        var cfg *ConfModDoh

        confPath := bfe_module.ModConfPath(cr, m.name)
        if cfg, err = ConfLoad(confPath, cr); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init(): conf load err: %v", m.name, err)
        }</span>
        <span class="cov8" title="1">openDebug = cfg.Log.OpenDebug
        m.conf = cfg
        m.dnsFetcher = NewDnsClient(&amp;cfg.Dns)

        if m.cond, err = condition.Build(cfg.Basic.Cond); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init(): err in condition Build(): %v", m.name, err)
        }</span>

        <span class="cov8" title="1">err = cbs.AddFilter(bfe_module.HandleFoundProduct, m.dohHandler)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init(): AddFilter(m.dohHandler): %v", m.name, err)
        }</span>

        <span class="cov8" title="1">err = web_monitor.RegisterHandlers(whs, web_monitor.WebHandleMonitor, m.monitorHandlers())
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init():RegisterHandlers(m.monitorHandlers): %v", m.name, err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file109" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_errors

import (
        "errors"
        "fmt"
        "io/ioutil"
        "net/url"
        "strconv"
        "strings"
)

import (
        "github.com/bfenetworks/bfe/bfe_basic"
        "github.com/bfenetworks/bfe/bfe_http"
        "github.com/bfenetworks/bfe/bfe_util"
)

const (
        RETURN   = "RETURN"
        REDIRECT = "REDIRECT"
)

type ActionFile struct {
        Cmd    *string  // command of action
        Params []string // params of action
}

type Action struct {
        Cmd string // command of action

        // for RETURN action
        StatusCode  int    // status code
        ContentType string // content type
        ContentData string // content data

        // for REDIRECT action
        RedirectUrl string
}

type ActionFileList []ActionFile

// ActionFileCheck check ActionFile, return nil if check ok
func ActionFileCheck(conf ActionFile) error <span class="cov0" title="0">{
        // check command
        if conf.Cmd == nil </span><span class="cov0" title="0">{
                return errors.New("no Cmd")
        }</span>

        // check params
        <span class="cov0" title="0">switch *conf.Cmd </span>{
        case RETURN:<span class="cov0" title="0">
                // check number of params: statusCode, contentType, contentData
                if len(conf.Params) != 3 </span><span class="cov0" title="0">{
                        return fmt.Errorf("params num should be 3 (%d)", len(conf.Params))
                }</span>

                // check response code
                <span class="cov0" title="0">responseCode, err := strconv.Atoi(conf.Params[0])
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("Params[0]: invalid status code:%s", conf.Params[0])
                }</span>
                <span class="cov0" title="0">if bfe_http.StatusTextGet(responseCode) == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("params[0]: invalid status code:%s", conf.Params[0])
                }</span>

                <span class="cov0" title="0">codeClass := responseCode / 100
                if codeClass != 2 &amp;&amp; codeClass != 4 &amp;&amp; codeClass != 5 </span><span class="cov0" title="0">{
                        return fmt.Errorf("params[0]: status code should be 2XX/4XX/5XX:%s", conf.Params[0])
                }</span>

                // check content data
                <span class="cov0" title="0">if err := bfe_util.CheckStaticFile(conf.Params[2], MaxPageSize); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("params[2] err:%s", err.Error())
                }</span>

        case REDIRECT:<span class="cov0" title="0">
                if len(conf.Params) != 1 </span><span class="cov0" title="0">{
                        return fmt.Errorf("params num should be 1 (%d)", len(conf.Params))
                }</span>
                <span class="cov0" title="0">if _, err := url.Parse(conf.Params[0]); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid url: %s", err)
                }</span>

        default:<span class="cov0" title="0">
                return fmt.Errorf("invalid command: %s", *conf.Cmd)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// ActionFileListCheck check ActionFileList, return nil if check ok
func ActionFileListCheck(actionList *ActionFileList) error <span class="cov0" title="0">{
        if len(*actionList) != 1 </span><span class="cov0" title="0">{
                return fmt.Errorf("ActionFileList: should contain 1 actions")
        }</span>

        <span class="cov0" title="0">actions := *actionList
        if err := ActionFileCheck(actions[0]); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ActionFileList: %s", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func actionConvert(actionFile ActionFile) Action <span class="cov8" title="1">{
        action := Action{}
        action.Cmd = *actionFile.Cmd

        switch action.Cmd </span>{
        case RETURN:<span class="cov8" title="1">
                // convert status code
                action.StatusCode, _ = strconv.Atoi(actionFile.Params[0])

                // convert content type
                action.ContentType = actionFile.Params[1]

                // convert content data
                rawData, _ := ioutil.ReadFile(actionFile.Params[2])
                action.ContentData = string(rawData)</span>

        case REDIRECT:<span class="cov0" title="0">
                action.RedirectUrl = actionFile.Params[0]</span>
        }

        <span class="cov8" title="1">return action</span>
}

func actionsConvert(actionFiles ActionFileList) []Action <span class="cov0" title="0">{
        actions := make([]Action, 0)
        for _, actionFile := range actionFiles </span><span class="cov0" title="0">{
                action := actionConvert(actionFile)
                actions = append(actions, action)
        }</span>
        <span class="cov0" title="0">return actions</span>
}

func ErrorsActionsDo(req *bfe_basic.Request, actions []Action) <span class="cov0" title="0">{
        action := actions[0] // should contain 1 action
        switch action.Cmd </span>{
        case RETURN:<span class="cov0" title="0">
                doReturn(req, action)</span>
        case REDIRECT:<span class="cov0" title="0">
                doRedirect(req, action)</span>
        }
}

func doReturn(req *bfe_basic.Request, action Action) <span class="cov8" title="1">{
        prepareResponse(req)
        res := req.HttpResponse
        res.StatusCode = action.StatusCode
        if len(action.ContentType) != 0 </span><span class="cov8" title="1">{
                res.Header.Set("Content-Type", action.ContentType)
        }</span>

        <span class="cov8" title="1">content := action.ContentData
        res.Header.Set("Content-Length", strconv.Itoa(len(content)))
        res.Body = ioutil.NopCloser(strings.NewReader(content))</span>
}

func doRedirect(req *bfe_basic.Request, action Action) <span class="cov0" title="0">{
        prepareResponse(req)
        res := req.HttpResponse
        res.StatusCode = 302
        res.ContentLength = 0
        res.Header.Set("Location", action.RedirectUrl)
        res.Body = bfe_http.EofReader
}</span>

func prepareResponse(req *bfe_basic.Request) <span class="cov8" title="1">{
        res := req.HttpResponse
        if res.Body != nil </span><span class="cov0" title="0">{
                res.Body.Close()
        }</span>

        <span class="cov8" title="1">res.Header = make(bfe_http.Header)
        res.Header.Set("Server", "bfe")
        res.Trailer = nil
        res.TransferEncoding = nil
        res.TLS = nil</span>
}
</pre>
		
		<pre class="file" id="file110" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_errors

import (
        "github.com/baidu/go-lib/log"
        "github.com/bfenetworks/bfe/bfe_util"
        gcfg "gopkg.in/gcfg.v1"
)

type ConfModErrors struct {
        Basic struct {
                DataPath string // path of config data
        }

        Log struct {
                OpenDebug bool
        }
}

// ConfLoad load config from config file
func ConfLoad(filePath string, confRoot string) (*ConfModErrors, error) <span class="cov0" title="0">{
        var err error
        var cfg ConfModErrors

        // read config from file
        err = gcfg.ReadFileInto(&amp;cfg, filePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // check conf of mod_errors
        <span class="cov0" title="0">err = cfg.Check(confRoot)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;cfg, nil</span>
}

func (cfg *ConfModErrors) Check(confRoot string) error <span class="cov0" title="0">{
        if cfg.Basic.DataPath == "" </span><span class="cov0" title="0">{
                log.Logger.Warn("ModErrors.DataPath not set, use default value")
                cfg.Basic.DataPath = "mod_errors/mod_errors.data"
        }</span>

        <span class="cov0" title="0">cfg.Basic.DataPath = bfe_util.ConfPathProc(cfg.Basic.DataPath, confRoot)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file111" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_errors

import (
        "errors"
        "fmt"
        "os"
)

import (
        "github.com/bfenetworks/bfe/bfe_basic/condition"
        "github.com/bfenetworks/bfe/bfe_util/json"
)

type ErrorsRuleFile struct {
        Cond    *string         // condition for errors
        Actions *ActionFileList // list of actions
}

type ErrorsRule struct {
        Cond    condition.Condition // condition for errors
        Actions []Action            // list of actions
}

type RuleFileList []ErrorsRuleFile
type RuleList []ErrorsRule

type ProductRulesFile map[string]*RuleFileList // product =&gt; list of errors rules
type ProductRules map[string]*RuleList         // product =&gt; list of errors rules

type ErrorsConfFile struct {
        Version *string // version of the config
        Config  *ProductRulesFile
}

type ErrorsConf struct {
        Version string       // version of the config
        Config  ProductRules // product rules for errors
}

// ErrorsRuleCheck check errors rule
func ErrorsRuleCheck(conf ErrorsRuleFile) error <span class="cov0" title="0">{
        var err error

        // check Cond
        if conf.Cond == nil </span><span class="cov0" title="0">{
                return errors.New("no Cond")
        }</span>

        // check Actions
        <span class="cov0" title="0">if conf.Actions == nil </span><span class="cov0" title="0">{
                return errors.New("no Actions")
        }</span>

        <span class="cov0" title="0">err = ActionFileListCheck(conf.Actions)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Actions:%s", err.Error())
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// RuleListCheck check RuleList
func RuleListCheck(conf *RuleFileList) error <span class="cov0" title="0">{
        for index, rule := range *conf </span><span class="cov0" title="0">{
                err := ErrorsRuleCheck(rule)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("ErrorsRule:%d, %s", index, err.Error())
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// ProductRulesCheck check ProductRules
func ProductRulesCheck(conf *ProductRulesFile) error <span class="cov0" title="0">{
        for product, ruleList := range *conf </span><span class="cov0" title="0">{
                if ruleList == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("no RuleList for product:%s", product)
                }</span>

                <span class="cov0" title="0">err := RuleListCheck(ruleList)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid product rules:%s, %s", product, err.Error())
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// ErrorsConfCheck check ErrorsConf
func ErrorsConfCheck(conf ErrorsConfFile) error <span class="cov0" title="0">{
        var err error

        // check Version
        if conf.Version == nil </span><span class="cov0" title="0">{
                return errors.New("no Version")
        }</span>

        // check Config
        <span class="cov0" title="0">if conf.Config == nil </span><span class="cov0" title="0">{
                return errors.New("no Config")
        }</span>

        <span class="cov0" title="0">err = ProductRulesCheck(conf.Config)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Config:%s", err.Error())
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func ruleConvert(ruleFile ErrorsRuleFile) (ErrorsRule, error) <span class="cov0" title="0">{
        rule := ErrorsRule{}

        if ruleFile.Cond == nil </span><span class="cov0" title="0">{
                return rule, fmt.Errorf("cond not set")
        }</span>
        <span class="cov0" title="0">cond, err := condition.Build(*ruleFile.Cond)
        if err != nil </span><span class="cov0" title="0">{
                return rule, err
        }</span>

        <span class="cov0" title="0">rule.Cond = cond
        rule.Actions = actionsConvert(*ruleFile.Actions)

        return rule, nil</span>
}

func ruleListConvert(ruleFileList *RuleFileList) (*RuleList, error) <span class="cov0" title="0">{
        ruleList := new(RuleList)
        *ruleList = make([]ErrorsRule, 0)

        for _, ruleFile := range *ruleFileList </span><span class="cov0" title="0">{
                rule, err := ruleConvert(ruleFile)
                if err != nil </span><span class="cov0" title="0">{
                        return ruleList, err
                }</span>
                <span class="cov0" title="0">*ruleList = append(*ruleList, rule)</span>
        }

        <span class="cov0" title="0">return ruleList, nil</span>
}

// ErrorsConfLoad load errors config from file
func ErrorsConfLoad(filename string) (ErrorsConf, error) <span class="cov0" title="0">{
        var conf ErrorsConf

        // open the file
        file, err := os.Open(filename)
        if err != nil </span><span class="cov0" title="0">{
                return conf, err
        }</span>
        <span class="cov0" title="0">defer file.Close()

        // decode the file
        decoder := json.NewDecoder(file)

        var config ErrorsConfFile
        err = decoder.Decode(&amp;config)
        if err != nil </span><span class="cov0" title="0">{
                return conf, err
        }</span>

        // check config
        <span class="cov0" title="0">err = ErrorsConfCheck(config)
        if err != nil </span><span class="cov0" title="0">{
                return conf, err
        }</span>

        // convert config
        <span class="cov0" title="0">conf.Version = *config.Version
        conf.Config = make(ProductRules)

        for product, ruleFileList := range *config.Config </span><span class="cov0" title="0">{
                ruleList, err := ruleListConvert(ruleFileList)
                if err != nil </span><span class="cov0" title="0">{
                        return conf, err
                }</span>
                <span class="cov0" title="0">conf.Config[product] = ruleList</span>
        }

        <span class="cov0" title="0">return conf, nil</span>
}
</pre>
		
		<pre class="file" id="file112" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_errors

import (
        "sync"
)

type ErrorsRuleTable struct {
        lock         sync.RWMutex
        version      string
        productRules ProductRules
}

func NewErrorsRuleTable() *ErrorsRuleTable <span class="cov0" title="0">{
        t := new(ErrorsRuleTable)
        t.productRules = make(ProductRules)
        return t
}</span>

func (t *ErrorsRuleTable) Update(conf ErrorsConf) <span class="cov0" title="0">{
        t.lock.Lock()
        t.version = conf.Version
        t.productRules = conf.Config
        t.lock.Unlock()
}</span>

// Search find rules for given product
func (t *ErrorsRuleTable) Search(product string) (*RuleList, bool) <span class="cov0" title="0">{
        t.lock.RLock()
        productRules := t.productRules
        t.lock.RUnlock()

        rules, ok := productRules[product]
        return rules, ok
}</span>
</pre>
		
		<pre class="file" id="file113" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_errors

import (
        "fmt"
        "net/url"
)

import (
        "github.com/baidu/go-lib/log"
        "github.com/baidu/go-lib/web-monitor/web_monitor"
)

import (
        "github.com/bfenetworks/bfe/bfe_basic"
        "github.com/bfenetworks/bfe/bfe_http"
        "github.com/bfenetworks/bfe/bfe_module"
)

var (
        openDebug = false
)

const (
        MaxPageSize = 2 * 1024 * 1024
)

type ModuleErrors struct {
        name       string           // name of module
        configPath string           // path of config file
        ruleTable  *ErrorsRuleTable // table of errors rules
}

func NewModuleErrors() *ModuleErrors <span class="cov0" title="0">{
        m := new(ModuleErrors)
        m.name = "mod_errors"
        m.ruleTable = NewErrorsRuleTable()
        return m
}</span>

func (m *ModuleErrors) Name() string <span class="cov0" title="0">{
        return m.name
}</span>

func (m *ModuleErrors) loadConfData(query url.Values) error <span class="cov0" title="0">{
        // get file path
        path := query.Get("path")
        if path == "" </span><span class="cov0" title="0">{
                path = m.configPath // use default
        }</span>

        // load from config file
        <span class="cov0" title="0">conf, err := ErrorsConfLoad(path)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("err in ErrorsConfLoad(%s):%s", path, err.Error())
        }</span>

        // update to rule table
        <span class="cov0" title="0">m.ruleTable.Update(conf)
        return nil</span>
}

func (m *ModuleErrors) errorsHandler(req *bfe_basic.Request, resp *bfe_http.Response) int <span class="cov0" title="0">{
        if req.HttpResponse == nil </span><span class="cov0" title="0">{
                // never go here
                log.Logger.Debug("%s:errorsHandler(): no response found", m.name)
                return bfe_module.BfeHandlerGoOn
        }</span>

        <span class="cov0" title="0">rules, ok := m.ruleTable.Search(req.Route.Product)
        if !ok </span><span class="cov0" title="0">{
                return bfe_module.BfeHandlerGoOn
        }</span>

        <span class="cov0" title="0">for _, rule := range *rules </span><span class="cov0" title="0">{
                // condition is satisfiled?
                if rule.Cond.Match(req) </span><span class="cov0" title="0">{
                        // do actions of the rule
                        ErrorsActionsDo(req, rule.Actions)
                        return bfe_module.BfeHandlerGoOn
                }</span>
        }
        <span class="cov0" title="0">return bfe_module.BfeHandlerGoOn</span>
}

func (m *ModuleErrors) Init(cbs *bfe_module.BfeCallbacks, whs *web_monitor.WebHandlers,
        cr string) error <span class="cov0" title="0">{
        var err error
        var cfg *ConfModErrors

        confPath := bfe_module.ModConfPath(cr, m.name)
        if cfg, err = ConfLoad(confPath, cr); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: conf load err %s", m.name, err.Error())
        }</span>

        <span class="cov0" title="0">openDebug = cfg.Log.OpenDebug

        m.configPath = cfg.Basic.DataPath

        // load from config file to rule table
        if err = m.loadConfData(nil); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("err in loadConfData(): %s", err.Error())
        }</span>

        // register handler
        <span class="cov0" title="0">err = cbs.AddFilter(bfe_module.HandleReadResponse, m.errorsHandler)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init(): AddFilter(m.errorsHandler): %s", m.name, err.Error())
        }</span>

        // register web handler for reload
        <span class="cov0" title="0">err = whs.RegisterHandler(web_monitor.WebHandleReload, m.name, m.loadConfData)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init(): RegisterHandler(m.loadConfData): %s", m.name, err.Error())
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file114" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_geo

import (
        "github.com/baidu/go-lib/log"
        "gopkg.in/gcfg.v1"
)

import (
        "github.com/bfenetworks/bfe/bfe_util"
)

type ConfModGeo struct {
        Basic struct {
                GeoDBPath string // path of geolocation database
        }

        Log struct {
                OpenDebug bool
        }
}

// ConfLoad loads config of geo module from file.
func ConfLoad(filePath string, confRoot string) (*ConfModGeo, error) <span class="cov8" title="1">{
        var err error
        var cfg ConfModGeo

        err = gcfg.ReadFileInto(&amp;cfg, filePath)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;cfg, err
        }</span>

        <span class="cov8" title="1">err = cfg.Check(confRoot)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;cfg, err
        }</span>

        <span class="cov8" title="1">return &amp;cfg, nil</span>
}

// Check validates module config
func (cfg *ConfModGeo) Check(confRoot string) error <span class="cov8" title="1">{
        return ConfModBlockCheck(cfg, confRoot)
}</span>

func ConfModBlockCheck(cfg *ConfModGeo, confRoot string) error <span class="cov8" title="1">{
        if cfg.Basic.GeoDBPath == "" </span><span class="cov8" title="1">{
                // if GeoDBPath not set, default use mod_geo/geo.db
                // geo.db is GeoLite2 data created by MaxMind, available from https://dev.maxmind.com/geoip/geoip2/geolite2/
                log.Logger.Warn("ModGeo.GeoDBPath not set, use default value")
                cfg.Basic.GeoDBPath = GeoDBDefaultPath
        }</span>
        <span class="cov8" title="1">cfg.Basic.GeoDBPath = bfe_util.ConfPathProc(cfg.Basic.GeoDBPath, confRoot)

        return nil</span>
}
</pre>
		
		<pre class="file" id="file115" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// determine user geolocation by IP address using geolocation database

package mod_geo

import (
        "fmt"
        "net/url"
        "strconv"
        "sync"
)

import (
        "github.com/baidu/go-lib/log"
        "github.com/baidu/go-lib/web-monitor/metrics"
        "github.com/baidu/go-lib/web-monitor/web_monitor"
        "github.com/oschwald/geoip2-golang"
)

import (
        "github.com/bfenetworks/bfe/bfe_basic"
        "github.com/bfenetworks/bfe/bfe_http"
        "github.com/bfenetworks/bfe/bfe_module"
)

const (
        ModGeo = "mod_geo"

        GeoDBDefaultPath = "mod_geo/geo.db"
)

var (
        CtxCountryIsoCode     = "mod_geo.country_iso_code"
        CtxSubdivisionIsoCode = "mod_geo.subdivision_iso_code"
        CtxCityName           = "mod_geo.city_name"
        CtxLatitude           = "mod_geo.latitude"
        CtxLongitude          = "mod_geo.longitude"
)

var (
        openDebug = false
)

type ModuleGeoIdState struct {
        ErrReloadGeoDatabase *metrics.Counter // counter for reload geolocation database
        ErrGetGeoInfo        *metrics.Counter // counter for get geolocation information
}

type ModuleGeo struct {
        name string // module name

        dataFilePath string         // path of geolocation database data
        geoDB        *geoip2.Reader // geolocation database
        lock         sync.RWMutex

        metrics metrics.Metrics  // monitor metrics
        state   ModuleGeoIdState // module state
}

func NewModuleGeo() *ModuleGeo <span class="cov8" title="1">{
        m := new(ModuleGeo)
        m.name = ModGeo
        m.metrics.Init(&amp;m.state, ModGeo, 0)
        return m
}</span>

func (m *ModuleGeo) Name() string <span class="cov8" title="1">{
        return m.name
}</span>

func (m *ModuleGeo) loadConfData(query url.Values) error <span class="cov8" title="1">{
        // get file path
        path := query.Get("path")
        if path == "" </span><span class="cov8" title="1">{
                // use default
                path = m.dataFilePath
        }</span>

        // load geolocation database
        <span class="cov8" title="1">geoDB, err := geoip2.Open(path)
        if err != nil </span><span class="cov8" title="1">{
                m.state.ErrReloadGeoDatabase.Inc(1)
                return fmt.Errorf("%s: geolocation database load err %s", m.name, err.Error())
        }</span>
        <span class="cov8" title="1">m.lock.Lock()
        m.geoDB = geoDB
        m.lock.Unlock()

        return nil</span>
}

// geoHandler is a handler for setting geolocation information.
func (m *ModuleGeo) geoHandler(req *bfe_basic.Request) (int, *bfe_http.Response) <span class="cov8" title="1">{
        if req.ClientAddr == nil </span><span class="cov0" title="0">{
                if openDebug </span><span class="cov0" title="0">{
                        log.Logger.Debug("%s: req.ClientAddr is nil", m.name)
                }</span>

                <span class="cov0" title="0">return bfe_module.BfeHandlerGoOn, nil</span>
        }

        <span class="cov8" title="1">m.lock.RLock()
        geoDB := m.geoDB
        m.lock.RUnlock()

        // get geolocation based on client IP address using geolocation database
        cityInfo, err := geoDB.City(req.ClientAddr.IP)
        if err != nil </span><span class="cov0" title="0">{
                m.state.ErrGetGeoInfo.Inc(1)

                if openDebug </span><span class="cov0" title="0">{
                        log.Logger.Debug("%s: get city info err: %s", m.name, err)
                }</span>

                <span class="cov0" title="0">return bfe_module.BfeHandlerGoOn, nil</span>
        }

        <span class="cov8" title="1">m.setGeoInfoToReqContext(req, cityInfo)

        return bfe_module.BfeHandlerGoOn, nil</span>
}

func (m *ModuleGeo) setGeoInfoToReqContext(req *bfe_basic.Request, cityInfo *geoip2.City) <span class="cov8" title="1">{
        var conturyIsoCode string
        var subdivisionIsoCode string
        var cityName string
        var latitude string
        var longitude string

        // get country iso code
        conturyIsoCode = cityInfo.Country.IsoCode

        // get subdivision iso code
        if len(cityInfo.Subdivisions) &gt; 0 </span><span class="cov0" title="0">{
                subdivisionIsoCode = cityInfo.Subdivisions[0].IsoCode
        }</span>

        // get city name
        <span class="cov8" title="1">cityName = cityInfo.City.Names["en"]

        // get latitude and longitude
        latitude = strconv.FormatFloat(cityInfo.Location.Latitude, 'f', -1, 64)
        longitude = strconv.FormatFloat(cityInfo.Location.Longitude, 'f', -1, 64)

        // set request context
        req.SetContext(CtxCountryIsoCode, conturyIsoCode)
        req.SetContext(CtxSubdivisionIsoCode, subdivisionIsoCode)
        req.SetContext(CtxCityName, cityName)
        req.SetContext(CtxLatitude, latitude)
        req.SetContext(CtxLongitude, longitude)

        if openDebug </span><span class="cov0" title="0">{
                log.Logger.Debug("%s: the geolocation information: countryIsoCode(%s), subdivisionIsoCode(%s),"+
                        "cityName(%s), longitude(%s) and latitude(%s)",
                        m.name, conturyIsoCode, subdivisionIsoCode, cityName, latitude, longitude)
        }</span>
}

func (m *ModuleGeo) getState(params map[string][]string) ([]byte, error) <span class="cov0" title="0">{
        s := m.metrics.GetAll()
        return s.Format(params)
}</span>

func (m *ModuleGeo) Init(cbs *bfe_module.BfeCallbacks, whs *web_monitor.WebHandlers,
        cr string) error <span class="cov8" title="1">{
        var conf *ConfModGeo
        var err error

        // load config
        confPath := bfe_module.ModConfPath(cr, m.name)
        if conf, err = ConfLoad(confPath, cr); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: conf load err %s", m.name, err.Error())
        }</span>
        <span class="cov8" title="1">m.dataFilePath = conf.Basic.GeoDBPath

        openDebug = conf.Log.OpenDebug

        // read geolocation database
        if err = m.loadConfData(nil); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: geolocation database load err %s", m.name, err.Error())
        }</span>

        // register handler
        <span class="cov8" title="1">err = cbs.AddFilter(bfe_module.HandleBeforeLocation, m.geoHandler)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init(): AddFilter(m.rewriteHandler): %s", m.name, err.Error())
        }</span>

        // register web handler for reload
        <span class="cov8" title="1">err = whs.RegisterHandler(web_monitor.WebHandleReload, m.name, m.loadConfData)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init(): RegisterHandler(m.loadConfData): %s", m.name, err.Error())
        }</span>
        // register web handler for monitor
        <span class="cov8" title="1">err = whs.RegisterHandler(web_monitor.WebHandleMonitor, m.name, m.getState)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init(): RegisterHandler(m.getState): %s", m.name, err.Error())
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file116" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_header

import (
        "errors"
        "fmt"
        "net/url"
        "strconv"
        "strings"
        "time"
)

import (
        "github.com/bfenetworks/bfe/bfe_basic"
        "github.com/bfenetworks/bfe/bfe_http"
        "github.com/bfenetworks/bfe/bfe_net/textproto"
)

type ActionFile struct {
        Cmd    *string // command of action
        Params []string
}

type Action struct {
        Cmd    string   // command of action (for header set/add/del)
        Params []string // params of action ([header, value] or [header])
}

type ActionFileList []ActionFile

func ActionFileCheck(conf ActionFile) error <span class="cov8" title="1">{
        // check command
        if conf.Cmd == nil </span><span class="cov0" title="0">{
                return errors.New("no Cmd")
        }</span>

        // validate command, and get how many params should exist for each command
        <span class="cov8" title="1">switch *conf.Cmd </span>{
        case "REQ_HEADER_SET",
                "REQ_HEADER_ADD",
                "REQ_HEADER_RENAME",
                "RSP_HEADER_SET",
                "RSP_HEADER_ADD",
                "RSP_HEADER_RENAME":<span class="cov8" title="1">

                // header and value
                if len(conf.Params) != 2 </span><span class="cov8" title="1">{
                        return fmt.Errorf("num of params:[ok:2, now:%d]", len(conf.Params))
                }</span>
        case "REQ_HEADER_DEL",
                "RSP_HEADER_DEL":<span class="cov8" title="1">
                // header
                if len(conf.Params) != 1 </span><span class="cov0" title="0">{
                        return fmt.Errorf("num of params:[ok:1, now:%d]", len(conf.Params))
                }</span>

        case "REQ_HEADER_MOD",
                "RSP_HEADER_MOD":<span class="cov0" title="0">

                // check params for req/rsp_header_mod. eg.
                // - REQ_HEADER_MOD: [scheme_set, referer, http]
                // - RSP_HEADER_MOD: [scheme_set, location, https]
                // - REQ_HEADER_MOD: [query_add, referer, key, value]
                if err := checkHeaderModParams(conf.Params); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("checkHeaderModParams: %s", err.Error())
                }</span>

        case ReqCookieSet:<span class="cov8" title="1">
                if len(conf.Params) != 2 </span><span class="cov0" title="0">{
                        return fmt.Errorf("num of params:[ok:2, now:%d]", len(conf.Params))
                }</span>

        case ReqCookieDel:<span class="cov8" title="1">
                if len(conf.Params) != 1 </span><span class="cov0" title="0">{
                        return fmt.Errorf("num of params:[ok:1, now:%d]", len(conf.Params))
                }</span>

        case RspCookieDel:<span class="cov8" title="1">
                if len(conf.Params) != 3 </span><span class="cov0" title="0">{
                        return fmt.Errorf("num of params:[ok:1, now:%d]", len(conf.Params))
                }</span>

        case RspCookieSet:<span class="cov8" title="1">
                if len(conf.Params) != 8 </span><span class="cov0" title="0">{
                        return fmt.Errorf("num of params:[ok:6, now:%d]", len(conf.Params))
                }</span>
                <span class="cov8" title="1">if _, err := time.Parse(time.RFC1123, conf.Params[4]); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("expires format error, should be RFC1123 format")
                }</span>
                <span class="cov8" title="1">if _, err := strconv.Atoi(conf.Params[5]); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("type of max age should be int")
                }</span>
                <span class="cov8" title="1">if _, err := strconv.ParseBool(conf.Params[6]); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("type of http only should be bool")
                }</span>
                <span class="cov8" title="1">if _, err := strconv.ParseBool(conf.Params[7]); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("type of secure should be bool")
                }</span>

        default:<span class="cov0" title="0">
                return fmt.Errorf("invalid cmd:%s", *conf.Cmd)</span>
        }

        <span class="cov8" title="1">for _, p := range conf.Params </span><span class="cov8" title="1">{
                if len(p) == 0 </span><span class="cov0" title="0">{
                        return errors.New("empty Params")
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func checkHeaderModParams(params []string) error <span class="cov0" title="0">{
        // - REQ_HEADER_MOD: [scheme_set, referer, http]
        // - RSP_HEADER_MOD: [scheme_set, location, https]
        // - REQ_HEADER_MOD: [query_add, referer, key, value]
        if len(params) != 3 &amp;&amp; len(params) != 4 </span><span class="cov0" title="0">{
                return fmt.Errorf("num of params:[ok:3 or 4, now:%d]", len(params))
        }</span>

        <span class="cov0" title="0">headerModCmd := strings.ToUpper(params[0])
        headerKey := textproto.CanonicalMIMEHeaderKey(params[1])

        switch headerModCmd </span>{
        case "SCHEME_SET":<span class="cov0" title="0">
                // scheme_set must have 3 params
                if len(params) != 3 </span><span class="cov0" title="0">{
                        return fmt.Errorf("scheme_set should have 3 params, now: %d", len(params))
                }</span>

                // only referer/location support scheme_set
                <span class="cov0" title="0">if headerKey != "Referer" &amp;&amp; headerKey != "Location" </span><span class="cov0" title="0">{
                        return fmt.Errorf("scheme_set only support referer/location, now: %s", headerKey)
                }</span>

                // scheme_set only support http/https
                <span class="cov0" title="0">if params[2] != "http" &amp;&amp; params[2] != "https" </span><span class="cov0" title="0">{
                        return fmt.Errorf("scheme_set only support http/https, now: %s", params[2])
                }</span>

        case "QUERY_ADD":<span class="cov0" title="0">
                // query_add must have 4 params
                if len(params) != 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("query_add should have 4 params, now: %d", len(params))
                }</span>

                // only referer/location support query_add
                <span class="cov0" title="0">if headerKey != "Referer" &amp;&amp; headerKey != "Location" </span><span class="cov0" title="0">{
                        return fmt.Errorf("query_add only support referer/location, now: %s", headerKey)
                }</span>

        default:<span class="cov0" title="0">
                return fmt.Errorf("invalid headerModCmd:%s", headerModCmd)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func ActionFileListCheck(conf *ActionFileList) error <span class="cov8" title="1">{
        for index, action := range *conf </span><span class="cov8" title="1">{
                err := ActionFileCheck(action)
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("ActionFileList:%d, %s", index, err.Error())
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// expectPercent returns index of '%', otherwise return
// last index of str
func expectPercent(str string) int <span class="cov8" title="1">{
        index := 0
        for _, c := range str </span><span class="cov8" title="1">{
                if c != '%' </span><span class="cov8" title="1">{
                        index++
                        continue</span>
                }
                <span class="cov0" title="0">break</span>
        }

        <span class="cov8" title="1">return index</span>
}

const variableCharset = "abcdefghijklmnopqrstuvwxyz0123456789_"

func expectVariableParam(str string) int <span class="cov0" title="0">{
        index := 0
        // variable param, variable now only has
        // characters [a-z] and '_'
        for _, c := range str </span><span class="cov0" title="0">{
                if !strings.Contains(variableCharset, string(c)) </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">index++</span>
        }

        <span class="cov0" title="0">return index</span>
}

// splitParam splits string "__bsi=%bfe_ssl_info;max-age=3600;
// domain=%bfe_domain_auto" to separate strings
// "__bsi="
// "%bfe_ssl_info"
// ";max-age=3600"
func splitParam(param string) []string <span class="cov8" title="1">{
        params := make([]string, 0)
        paramBegin := 0
        index := 0

        for </span><span class="cov8" title="1">{
                paramBegin = index
                if paramBegin &gt;= len(param) </span><span class="cov8" title="1">{
                        break</span>
                }
                // normal text
                <span class="cov8" title="1">if param[index] != '%' </span><span class="cov8" title="1">{
                        index++
                        index += expectPercent(param[index:])
                }</span> else<span class="cov0" title="0"> if index++; index &lt; len(param) </span><span class="cov0" title="0">{
                        if param[index] == '%' </span><span class="cov0" title="0">{
                                // escape text
                                index++
                                index += expectPercent(param[index:])
                        }</span> else<span class="cov0" title="0"> {
                                // variable param
                                index += expectVariableParam(param[index:])
                        }</span>
                }

                <span class="cov8" title="1">params = append(params, param[paramBegin:index])</span>
        }

        <span class="cov8" title="1">return params</span>
}

func preProcessParams(param string) ([]string, error) <span class="cov8" title="1">{
        /* second param has three schema:
                 * bfe_vip:   no '%' prefix
             * %bfe_vip:  has '%' prefix
             * %%bfe_vip: has '%%' prefix
                 * here, we only process second schema, such as %bfe_vip
                 * other two, return directly
        */

        params := splitParam(param)

        for _, p := range params </span><span class="cov8" title="1">{

                //header value variable
                if strings.HasPrefix(p, "%") &amp;&amp; !strings.HasPrefix(p, "%%") </span><span class="cov0" title="0">{
                        varHeaderVal := strings.ToLower(p)
                        if _, found := VariableHandlers[varHeaderVal[1:]]; !found </span><span class="cov0" title="0">{
                                // not valid header value variable
                                err := fmt.Errorf("command's second param is not valid: %s", p)
                                return params, err
                        }</span>
                }
        }

        <span class="cov8" title="1">return params, nil</span>
}

func getHeaderValue(req *bfe_basic.Request, action Action) string <span class="cov8" title="1">{
        var value string

        if len(action.Params) &lt;= 1 </span><span class="cov8" title="1">{
                return ""
        }</span>

        // concatenate sepate strings to a whole one
        // if a variable param, decode it first
        <span class="cov8" title="1">for _, p := range action.Params[1:] </span><span class="cov8" title="1">{
                if strings.HasPrefix(p, "%") </span><span class="cov0" title="0">{
                        if handler, found := VariableHandlers[p[1:]]; found </span><span class="cov0" title="0">{
                                value += handler(req)
                        }</span> else<span class="cov0" title="0"> {
                                value += p[1:]
                        }</span>
                } else<span class="cov8" title="1"> {
                        value += p
                }</span>
        }

        <span class="cov8" title="1">return value</span>
}

// modify header value by action.
func modHeaderValue(value string, action Action) string <span class="cov8" title="1">{
        var headerVal string
        headerModCmd := action.Params[0]

        // set scheme
        if headerModCmd == "SCHEME_SET" </span><span class="cov8" title="1">{
                // action.Params[2]: scheme
                headerVal = setScheme(value, action.Params[2])
        }</span>

        // add query
        <span class="cov8" title="1">if headerModCmd == "QUERY_ADD" </span><span class="cov8" title="1">{
                // action.Params[2]: key
                // action.Params[3]: value
                headerVal = addQuery(value, action.Params[2], action.Params[3])
        }</span>

        <span class="cov8" title="1">return headerVal</span>
}

// setScheme set uri scheme.
func setScheme(uri string, scheme string) string <span class="cov8" title="1">{
        var i int

        // check uri start by http:// or https://
        if !(strings.HasPrefix(uri, "http://") || strings.HasPrefix(uri, "https://")) </span><span class="cov0" title="0">{
                return uri
        }</span>

        // find scheme end
        <span class="cov8" title="1">if i = strings.Index(uri, ":"); i == -1 </span><span class="cov0" title="0">{
                // return raw uri
                return uri
        }</span>

        // uri = scheme + rest
        <span class="cov8" title="1">uri = scheme + uri[i:]

        return uri</span>
}

// addQuery add query for uri.
func addQuery(uri string, key string, val string) string <span class="cov8" title="1">{
        // parse uri
        u, err := url.Parse(uri)
        if err != nil </span><span class="cov0" title="0">{
                // return raw uri
                return uri
        }</span>

        <span class="cov8" title="1">if u.RawQuery == "" </span><span class="cov8" title="1">{
                u.RawQuery = key + "=" + val
        }</span> else<span class="cov8" title="1"> {
                u.RawQuery = u.RawQuery + "&amp;" + key + "=" + val
        }</span>

        <span class="cov8" title="1">return u.String()</span>
}

func actionConvert(actionFile ActionFile) (Action, error) <span class="cov8" title="1">{
        action := Action{}
        action.Cmd = *actionFile.Cmd

        switch action.Cmd </span>{
        case "REQ_HEADER_SET", "REQ_HEADER_ADD",
                "RSP_HEADER_SET", "RSP_HEADER_ADD":<span class="cov8" title="1">
                // - REQ_HEADER_SET: [referer,  http://bfe.baidu.com]
                // - RSP_HEADER_SET: [set-cookie, __bsi=%bfe_ssl_info; max-age=3600;]
                key := textproto.CanonicalMIMEHeaderKey(actionFile.Params[0])
                values, err := preProcessParams(actionFile.Params[1])
                if err != nil </span><span class="cov0" title="0">{
                        return action, err
                }</span>

                // append key values
                <span class="cov8" title="1">action.Params = append(action.Params, key)
                action.Params = append(action.Params, values...)</span>
        case "REQ_HEADER_RENAME", "RSP_HEADER_RENAME":<span class="cov8" title="1">
                originalKey := textproto.CanonicalMIMEHeaderKey(actionFile.Params[0])
                newKey := textproto.CanonicalMIMEHeaderKey(actionFile.Params[1])
                action.Params = append(action.Params, originalKey)
                action.Params = append(action.Params, newKey)</span>
        case "REQ_HEADER_DEL", "RSP_HEADER_DEL":<span class="cov8" title="1">
                // - REQ_HEADER_DEL: [referer]
                // - RSP_HEADER_DEL: [location]
                key := textproto.CanonicalMIMEHeaderKey(actionFile.Params[0])

                // append key
                action.Params = append(action.Params, key)</span>

        case "REQ_HEADER_MOD", "RSP_HEADER_MOD":<span class="cov0" title="0">
                // - REQ_HEADER_MOD: [scheme_set, referer, http]
                // - RSP_HEADER_MOD: [scheme_set, location, https]
                // - REQ_HEADER_MOD: [query_add, referer, key, value]
                cmd := strings.ToUpper(actionFile.Params[0])
                key := textproto.CanonicalMIMEHeaderKey(actionFile.Params[1])

                action.Params = append(action.Params, cmd)
                action.Params = append(action.Params, key)
                action.Params = append(action.Params, actionFile.Params[2:]...)</span>

        case ReqCookieSet, ReqCookieDel,
                RspCookieSet, RspCookieDel:<span class="cov8" title="1">
                action.Params = actionFile.Params</span>

        default:<span class="cov0" title="0">
                return action, fmt.Errorf("invalid cmd:%s", action.Cmd)</span>
        }

        <span class="cov8" title="1">return action, nil</span>
}

func actionsConvert(actionFiles ActionFileList) ([]Action, error) <span class="cov8" title="1">{
        actions := make([]Action, 0)

        for _, actionFile := range actionFiles </span><span class="cov8" title="1">{
                action, err := actionConvert(actionFile)
                if err != nil </span><span class="cov0" title="0">{
                        return actions, err
                }</span>
                <span class="cov8" title="1">actions = append(actions, action)</span>
        }

        <span class="cov8" title="1">return actions, nil</span>
}

func HeaderActionDo(h *bfe_http.Header, cmd string, headerName string, value string) <span class="cov8" title="1">{
        switch cmd </span>{
        // insert or modify
        case "HEADER_SET", "HEADER_MOD":<span class="cov8" title="1">
                headerSet(h, headerName, value)</span>
        // append
        case "HEADER_ADD":<span class="cov8" title="1">
                headerAdd(h, headerName, value)</span>
        // delete
        case "HEADER_DEL":<span class="cov8" title="1">
                headerDel(h, headerName)</span>
        case "HEADER_RENAME":<span class="cov8" title="1">
                headerRename(h, headerName, value)</span>
        }
}

func getHeader(req *bfe_basic.Request, headerType int) (h *bfe_http.Header) <span class="cov8" title="1">{
        switch headerType </span>{
        case ReqHeader:<span class="cov8" title="1">
                h = &amp;req.HttpRequest.Header</span>
        case RspHeader:<span class="cov8" title="1">
                h = &amp;req.HttpResponse.Header</span>
        }

        <span class="cov8" title="1">return h</span>
}

func processHeader(req *bfe_basic.Request, headerType int, action Action) <span class="cov8" title="1">{
        var key string
        var value string
        var cmd string

        h := getHeader(req, headerType)

        cmd = action.Cmd[4:]

        switch cmd </span>{
        case "HEADER_MOD":<span class="cov8" title="1">
                key = action.Params[1]
                // get header value
                if value = h.Get(key); value == "" </span><span class="cov0" title="0">{
                        // if req do not have this header, continue
                        return
                }</span>
                // mod header value
                <span class="cov8" title="1">value = modHeaderValue(value, action)</span>
        case "HEADER_RENAME":<span class="cov8" title="1">
                originalKey, newKey := action.Params[0], action.Params[1]
                if h.Get(originalKey) == "" || h.Get(newKey) != "" </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov8" title="1">key, value = originalKey, newKey</span>
        default:<span class="cov8" title="1">
                key = action.Params[0]
                value = getHeaderValue(req, action)</span>
        }

        // trim action.Cmd prefix REQ_ and RSP_
        <span class="cov8" title="1">HeaderActionDo(h, cmd, key, value)</span>
}

func processCookie(req *bfe_basic.Request, headerType int, action Action) <span class="cov8" title="1">{
        if headerType == ReqHeader </span><span class="cov8" title="1">{
                ReqCookieActionDo(req, action)
                return
        }</span>
        <span class="cov8" title="1">RspCookieActionDo(req, action)</span>
}

func HeaderActionsDo(req *bfe_basic.Request, headerType int, actions []Action) <span class="cov8" title="1">{
        for _, action := range actions </span><span class="cov8" title="1">{
                if strings.Contains(action.Cmd, "HEADER") </span><span class="cov8" title="1">{
                        processHeader(req, headerType, action)
                }</span> else<span class="cov8" title="1"> {
                        processCookie(req, headerType, action)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file117" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_header

import (
        "strconv"
        "strings"
        "time"
)

import (
        "github.com/bfenetworks/bfe/bfe_basic"
        "github.com/bfenetworks/bfe/bfe_http"
)

const (
        ReqCookieSet = "REQ_COOKIE_SET"
        ReqCookieDel = "REQ_COOKIE_DEL"
        RspCookieSet = "RSP_COOKIE_SET"
        RspCookieDel = "RSP_COOKIE_DEL"
)

func getCookieValue(req *bfe_basic.Request, value string) string <span class="cov8" title="1">{
        if strings.HasPrefix(value, "%") </span><span class="cov0" title="0">{
                if cookieHandler, ok := VariableHandlers[value[1:]]; ok </span><span class="cov0" title="0">{
                        return cookieHandler(req)
                }</span>
        }

        <span class="cov8" title="1">return value</span>
}

func reqAddCookie(req *bfe_basic.Request, cookie *bfe_http.Cookie) <span class="cov8" title="1">{
        req.HttpRequest.AddCookie(cookie)
        if req.CookieMap != nil </span><span class="cov0" title="0">{
                req.CookieMap[cookie.Name] = cookie
        }</span>
}

func isReqCookieExist(req *bfe_http.Request, cookieName string) bool <span class="cov8" title="1">{
        _, err := req.Cookie(cookieName)
        return err == nil
}</span>

func reqSetCookie(req *bfe_basic.Request, cookie *bfe_http.Cookie) <span class="cov8" title="1">{
        if !isReqCookieExist(req.HttpRequest, cookie.Name) </span><span class="cov8" title="1">{
                reqAddCookie(req, cookie)
                return
        }</span>

        <span class="cov8" title="1">cookies := req.HttpRequest.Cookies()
        req.HttpRequest.Header.Del("Cookie")

        for i := 0; i &lt; len(cookies); i++ </span><span class="cov8" title="1">{
                if cookies[i].Name == cookie.Name </span><span class="cov8" title="1">{
                        cookies[i].Value = cookie.Value
                }</span>
                <span class="cov8" title="1">req.HttpRequest.AddCookie(cookies[i])</span>
        }

        <span class="cov8" title="1">if req.CookieMap != nil </span><span class="cov0" title="0">{
                req.CookieMap[cookie.Name] = cookie
        }</span>
}

func reqDelCookie(req *bfe_basic.Request, cookie *bfe_http.Cookie) <span class="cov8" title="1">{
        if !isReqCookieExist(req.HttpRequest, cookie.Name) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">cookies := req.HttpRequest.Cookies()
        req.HttpRequest.Header.Del("Cookie")

        for i := 0; i &lt; len(cookies); i++ </span><span class="cov8" title="1">{
                if cookies[i].Name == cookie.Name </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov0" title="0">req.HttpRequest.AddCookie(cookies[i])</span>
        }

        <span class="cov8" title="1">if req.CookieMap != nil </span><span class="cov0" title="0">{
                delete(req.CookieMap, cookie.Name)
        }</span>
}

func rspAddCookie(rsp *bfe_http.Response, cookie *bfe_http.Cookie) <span class="cov8" title="1">{
        rsp.Header.Add("Set-Cookie", cookie.String())
}</span>

func isRspCookieExist(rsp *bfe_http.Response, cookie *bfe_http.Cookie) bool <span class="cov8" title="1">{
        cookies := rsp.Cookies()
        for _, rspCookie := range cookies </span><span class="cov8" title="1">{
                if rspCookie.Name == cookie.Name &amp;&amp;
                        rspCookie.Path == cookie.Path &amp;&amp;
                        rspCookie.Domain == cookie.Domain </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func rspSetCookie(rsp *bfe_http.Response, cookie *bfe_http.Cookie) <span class="cov8" title="1">{
        if !isRspCookieExist(rsp, cookie) </span><span class="cov8" title="1">{
                rspAddCookie(rsp, cookie)
                return
        }</span>

        <span class="cov8" title="1">cookies := rsp.Cookies()
        rsp.Header.Del("Set-Cookie")

        for i := 0; i &lt; len(cookies); i++ </span><span class="cov8" title="1">{
                if cookies[i].Name == cookie.Name </span><span class="cov8" title="1">{
                        cookies[i] = cookie
                }</span>
                <span class="cov8" title="1">rspAddCookie(rsp, cookies[i])</span>
        }
}

func rspDelCookie(rsp *bfe_http.Response, cookie *bfe_http.Cookie) <span class="cov8" title="1">{
        if !isRspCookieExist(rsp, cookie) </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">cookies := rsp.Cookies()
        rsp.Header.Del("Set-Cookie")

        for i := 0; i &lt; len(cookies); i++ </span><span class="cov8" title="1">{
                if cookies[i].Name == cookie.Name </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">rspAddCookie(rsp, cookies[i])</span>
        }
}

func buildCookie(req *bfe_basic.Request, action Action) *bfe_http.Cookie <span class="cov8" title="1">{
        cookie := &amp;bfe_http.Cookie{
                Name: action.Params[0],
        }

        if action.Cmd == ReqCookieDel </span><span class="cov8" title="1">{
                return cookie
        }</span>

        <span class="cov8" title="1">if action.Cmd == RspCookieDel </span><span class="cov8" title="1">{
                cookie.Domain = action.Params[1]
                cookie.Path = action.Params[2]
                return cookie
        }</span>

        <span class="cov8" title="1">cookie.Value = getCookieValue(req, action.Params[1])
        if action.Cmd == ReqCookieSet </span><span class="cov8" title="1">{
                return cookie
        }</span>

        <span class="cov8" title="1">cookie.Domain = action.Params[2]
        cookie.Path = action.Params[3]
        cookie.Expires, _ = time.Parse(time.RFC1123, action.Params[4])
        cookie.MaxAge, _ = strconv.Atoi(action.Params[5])
        cookie.HttpOnly, _ = strconv.ParseBool(action.Params[6])
        cookie.Secure, _ = strconv.ParseBool(action.Params[7])
        return cookie</span>
}

func ReqCookieActionDo(req *bfe_basic.Request, action Action) <span class="cov8" title="1">{
        cookie := buildCookie(req, action)
        switch action.Cmd </span>{
        case ReqCookieSet:<span class="cov8" title="1">
                reqSetCookie(req, cookie)</span>
        case ReqCookieDel:<span class="cov8" title="1">
                reqDelCookie(req, cookie)</span>
        }
}

func RspCookieActionDo(req *bfe_basic.Request, action Action) <span class="cov8" title="1">{
        cookie := buildCookie(req, action)
        switch action.Cmd </span>{
        case RspCookieSet:<span class="cov8" title="1">
                rspSetCookie(req.HttpResponse, cookie)</span>
        case RspCookieDel:<span class="cov8" title="1">
                rspDelCookie(req.HttpResponse, cookie)</span>
        }
}
</pre>
		
		<pre class="file" id="file118" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_header

import (
        "github.com/bfenetworks/bfe/bfe_http"
)

// insert or modify existing header
func headerSet(h *bfe_http.Header, key string, value string) <span class="cov8" title="1">{
        h.Set(key, value)
}</span>

// append #value to existing header or insert a new one
func headerAdd(h *bfe_http.Header, key string, value string) <span class="cov8" title="1">{
        h.Add(key, value)
}</span>

// delete header specified by key
func headerDel(h *bfe_http.Header, key string) <span class="cov8" title="1">{
        h.Del(key)
}</span>

// rename header originalKey to newKey
func headerRename(h *bfe_http.Header, originalKey, newKey string) <span class="cov8" title="1">{
        val := h.Get(originalKey)
        h.Set(newKey, val)
        h.Del(originalKey)
}</span>
</pre>
		
		<pre class="file" id="file119" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_header

import (
        "crypto/x509"
        "encoding/asn1"
        "encoding/hex"
        "fmt"
        "net"
        "os"
        "strconv"
)

import (
        "github.com/bfenetworks/bfe/bfe_basic"
        "github.com/bfenetworks/bfe/bfe_modules/mod_geo"
        "github.com/bfenetworks/bfe/bfe_tls"
        "github.com/bfenetworks/bfe/bfe_util"
)

type HeaderValueHandler func(req *bfe_basic.Request) string

const (
        Unknown = "unknown"
)

var VariableHandlers = map[string]HeaderValueHandler{
        // for client
        "bfe_client_ip":    getClientIp,
        "bfe_client_port":  getClientPort,
        "bfe_request_host": getRequestHost,

        // for conn info
        "bfe_session_id": getSessionId,
        "bfe_log_id":     getLogId,
        "bfe_cip":        getClientIp, // client ip (alias for bfe_clientip)
        "bfe_vip":        getBfeVip,   // virtual ip
        "bfe_bip":        getBfeBip,   // balancer ip
        "bfe_rip":        getBfeRip,   // bfe ip

        // for bfe
        "bfe_server_name": getBfeServerName,

        // for backend
        "bfe_cluster":      getBfeCluster,
        "bfe_backend_info": getBfeBackendInfo,

        // for tls
        "bfe_ssl_resume":                          getBfeSslResume,
        "bfe_ssl_cipher":                          getBfeSslCipher,
        "bfe_ssl_version":                         getBfeSslVersion,
        "bfe_ssl_ja3_raw":                         getBfeSslJa3Raw,
        "bfe_ssl_ja3_hash":                        getBfeSslJa3Hash,
        "bfe_protocol":                            getBfeProtocol,
        "client_cert_serial_number":               getClientCertSerialNumber,
        "client_cert_subject_title":               getClientCertSubjectTitle,
        "client_cert_subject_common_name":         getClientCertSubjectCommonName,
        "client_cert_subject_organization":        getClientCertSubjectOrganization,
        "client_cert_subject_organizational_unit": getClientCertSubjectOrganizationalUnit,
        "client_cert_subject_province":            getClientCertSubjectProvince,
        "client_cert_subject_country":             getClientCertSubjectCountry,
        "client_cert_subject_locality":            getClientCertSubjectLocality,

        // for geo
        "bfe_client_geo_country_iso_code":     getClientGeoCountryIsoCode,
        "bfe_client_geo_subdivision_iso_code": getClientGeoSubdivisionIsoCode,
        "bfe_client_geo_city_name":            getClientGeoCityName,
        "bfe_client_geo_latitude":             getClientGeoLatitude,
        "bfe_client_geo_longitude":            getClientGeoLongitude,
}

func uint16ToStr(u16 uint16) string <span class="cov0" title="0">{
        b := make([]byte, 2)
        b[0] = byte(u16 &gt;&gt; 8)
        b[1] = byte(u16)

        return hex.EncodeToString(b)
}</span>

// get clientip
func getClientIp(req *bfe_basic.Request) string <span class="cov0" title="0">{
        if req.ClientAddr == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return req.ClientAddr.IP.String()</span>
}

// get client port
func getClientPort(req *bfe_basic.Request) string <span class="cov0" title="0">{
        if req.ClientAddr == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return strconv.Itoa(req.ClientAddr.Port)</span>
}

// get request host
func getRequestHost(req *bfe_basic.Request) string <span class="cov0" title="0">{
        return req.HttpRequest.Host
}</span>

func getProto(proto string) string <span class="cov0" title="0">{
        switch proto </span>{
        case "spdy/2":<span class="cov0" title="0">
                return "20"</span>
        case "spdy/3":<span class="cov0" title="0">
                return "30"</span>
        case "spdy/3.1":<span class="cov0" title="0">
                return "31"</span>
        case "h2":<span class="cov0" title="0">
                return "h2"</span>
        case "stream":<span class="cov0" title="0">
                return "st"</span>
        default:<span class="cov0" title="0">
                return "00"</span>
        }
}

func getReqTime(req *bfe_basic.Request) int <span class="cov0" title="0">{
        // when send request to backend, Stat.BackendEnd is not set yet,
        // diff is negative
        diff := req.Stat.BackendEnd.Sub(req.Stat.ReadReqStart)
        if diff &lt;= 0 </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">return int(diff / 1000000)</span>
}

func getConnReused(req *bfe_basic.Request) string <span class="cov0" title="0">{
        state := req.HttpRequest.State
        if state == nil </span><span class="cov0" title="0">{
                return "U" // unknown
        }</span>
        <span class="cov0" title="0">if state.SerialNumber == 1 </span><span class="cov0" title="0">{
                return "N"
        }</span>
        <span class="cov0" title="0">return "R"</span>
}

func getConnResume(state *bfe_tls.ConnectionState) string <span class="cov0" title="0">{
        if !state.DidResume </span><span class="cov0" title="0">{
                return "N"
        }</span>
        <span class="cov0" title="0">return "R"</span>
}

func getBfeSslResume(req *bfe_basic.Request) string <span class="cov0" title="0">{
        if req.Session.TlsState == nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">state := req.Session.TlsState
        return getConnResume(state)</span>
}

// get tls cipher suite
func getBfeSslCipher(req *bfe_basic.Request) string <span class="cov0" title="0">{
        if req.Session.TlsState == nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">state := req.Session.TlsState
        return bfe_tls.CipherSuiteTextForOpenSSL(state.CipherSuite)</span>
}

// get tls version
func getBfeSslVersion(req *bfe_basic.Request) string <span class="cov0" title="0">{
        if req.Session.TlsState == nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">state := req.Session.TlsState
        return bfe_tls.VersionTextForOpenSSL(state.Version)</span>
}

// get tls ja3 string
func getBfeSslJa3Raw(req *bfe_basic.Request) string <span class="cov0" title="0">{
        if req.Session.TlsState == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">state := req.Session.TlsState
        return state.JA3Raw</span>
}

// get tls ja3 hash
func getBfeSslJa3Hash(req *bfe_basic.Request) string <span class="cov0" title="0">{
        if req.Session.TlsState == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">state := req.Session.TlsState
        return state.JA3Hash</span>
}

// get protocol for application level
func getBfeProtocol(req *bfe_basic.Request) string <span class="cov0" title="0">{
        return req.Protocol()
}</span>

// get client cert
func getClientCert(req *bfe_basic.Request) *x509.Certificate <span class="cov0" title="0">{
        tlsState := req.Session.TlsState
        if tlsState == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if len(tlsState.PeerCertificates) &lt; 1 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return tlsState.PeerCertificates[0]</span>
}

var (
        oidTitle = asn1.ObjectIdentifier{2, 5, 4, 12}
)

// get value of cert extension
func getCertExtVal(cert *x509.Certificate, oid asn1.ObjectIdentifier) []byte <span class="cov0" title="0">{
        for _, extn := range cert.Extensions </span><span class="cov0" title="0">{
                if extn.Id.Equal(oid) </span><span class="cov0" title="0">{
                        return extn.Value
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// get serial number of client cert
func getClientCertSerialNumber(req *bfe_basic.Request) string <span class="cov0" title="0">{
        clientCert := getClientCert(req)
        if clientCert == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return clientCert.SerialNumber.String()</span>
}

// get subject title of client cert
func getClientCertSubjectTitle(req *bfe_basic.Request) string <span class="cov0" title="0">{
        clientCert := getClientCert(req)
        if clientCert == nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">subject := clientCert.Subject
        for _, name := range subject.Names </span><span class="cov0" title="0">{
                if !name.Type.Equal(oidTitle) </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if val, ok := name.Value.(string); ok </span><span class="cov0" title="0">{
                        return val
                }</span>
        }
        <span class="cov0" title="0">return ""</span>
}

func getClientCertSubjectCommonName(req *bfe_basic.Request) string <span class="cov0" title="0">{
        clientCert := getClientCert(req)
        if clientCert == nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">return clientCert.Subject.CommonName</span>
}

func getClientCertSubjectOrganization(req *bfe_basic.Request) string <span class="cov0" title="0">{
        clientCert := getClientCert(req)
        if clientCert == nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">if len(clientCert.Subject.Organization) &gt; 0 </span><span class="cov0" title="0">{
                return clientCert.Subject.Organization[0]
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func getClientCertSubjectOrganizationalUnit(req *bfe_basic.Request) string <span class="cov0" title="0">{
        clientCert := getClientCert(req)
        if clientCert == nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">if len(clientCert.Subject.OrganizationalUnit) &gt; 0 </span><span class="cov0" title="0">{
                return clientCert.Subject.OrganizationalUnit[0]
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func getClientCertSubjectProvince(req *bfe_basic.Request) string <span class="cov0" title="0">{
        clientCert := getClientCert(req)
        if clientCert == nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">if len(clientCert.Subject.Province) &gt; 0 </span><span class="cov0" title="0">{
                return clientCert.Subject.Province[0]
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func getClientCertSubjectCountry(req *bfe_basic.Request) string <span class="cov0" title="0">{
        clientCert := getClientCert(req)
        if clientCert == nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">if len(clientCert.Subject.Country) &gt; 0 </span><span class="cov0" title="0">{
                return clientCert.Subject.Country[0]
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func getClientCertSubjectLocality(req *bfe_basic.Request) string <span class="cov0" title="0">{
        clientCert := getClientCert(req)
        if clientCert == nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">if len(clientCert.Subject.Locality) &gt; 0 </span><span class="cov0" title="0">{
                return clientCert.Subject.Locality[0]
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func getClientCertExtVal(req *bfe_basic.Request, oid asn1.ObjectIdentifier) string <span class="cov0" title="0">{
        clientCert := getClientCert(req)
        if clientCert == nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">extnVal := getCertExtVal(clientCert, oid)
        if extnVal == nil </span><span class="cov0" title="0">{
                return "nil"
        }</span>

        <span class="cov0" title="0">return hex.EncodeToString(extnVal)</span>
}

func getBfeCluster(req *bfe_basic.Request) string <span class="cov0" title="0">{
        return req.Route.ClusterName
}</span>

func getBfeVip(req *bfe_basic.Request) string <span class="cov0" title="0">{
        if req.Session.Vip != nil </span><span class="cov0" title="0">{
                return req.Session.Vip.String()
        }</span>

        <span class="cov0" title="0">return Unknown</span>
}

func getAddressFetcher(conn net.Conn) bfe_util.AddressFetcher <span class="cov0" title="0">{
        if c, ok := conn.(*bfe_tls.Conn); ok </span><span class="cov0" title="0">{
                conn = c.GetNetConn()
        }</span>
        <span class="cov0" title="0">if f, ok := conn.(bfe_util.AddressFetcher); ok </span><span class="cov0" title="0">{
                return f
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func getBfeBip(req *bfe_basic.Request) string <span class="cov0" title="0">{
        f := getAddressFetcher(req.Session.Connection)
        if f == nil </span><span class="cov0" title="0">{
                return Unknown
        }</span>

        <span class="cov0" title="0">baddr := f.BalancerAddr()
        if baddr == nil </span><span class="cov0" title="0">{
                return Unknown
        }</span>
        <span class="cov0" title="0">bip, _, err := net.SplitHostPort(baddr.String())
        if err != nil </span><span class="cov0" title="0">{ /* never come here */
                return Unknown
        }</span>

        <span class="cov0" title="0">return bip</span>
}

func getBfeRip(req *bfe_basic.Request) string <span class="cov0" title="0">{
        conn := req.Session.Connection
        raddr := conn.LocalAddr()
        rip, _, err := net.SplitHostPort(raddr.String())
        if err != nil </span><span class="cov0" title="0">{ /* never come here */
                return Unknown
        }</span>

        <span class="cov0" title="0">return rip</span>
}

func getBfeBackendInfo(req *bfe_basic.Request) string <span class="cov0" title="0">{
        return fmt.Sprintf("ClusterName:%s,SubClusterName:%s,BackendName:%s(%s)",
                req.Backend.ClusterName, req.Backend.SubclusterName,
                req.Backend.BackendName, req.Backend.BackendAddr)
}</span>

func getBfeServerName(req *bfe_basic.Request) string <span class="cov0" title="0">{
        hostname, err := os.Hostname()
        if err != nil </span><span class="cov0" title="0">{
                return Unknown
        }</span>

        <span class="cov0" title="0">return hostname</span>
}

func getSessionId(req *bfe_basic.Request) string <span class="cov0" title="0">{
        return req.Session.SessionId
}</span>

func getLogId(req *bfe_basic.Request) string <span class="cov0" title="0">{
        return req.LogId
}</span>

func getClientGeoCountryIsoCode(req *bfe_basic.Request) string <span class="cov0" title="0">{
        countryIsoCode := req.GetContext(mod_geo.CtxCountryIsoCode)
        if countryIsoCode == nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">return countryIsoCode.(string)</span>
}

func getClientGeoSubdivisionIsoCode(req *bfe_basic.Request) string <span class="cov0" title="0">{
        subdivisionIsoCode := req.GetContext(mod_geo.CtxSubdivisionIsoCode)
        if subdivisionIsoCode == nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">return subdivisionIsoCode.(string)</span>
}

func getClientGeoCityName(req *bfe_basic.Request) string <span class="cov0" title="0">{
        cityName := req.GetContext(mod_geo.CtxCityName)
        if cityName == nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">return cityName.(string)</span>
}

func getClientGeoLatitude(req *bfe_basic.Request) string <span class="cov0" title="0">{
        latitude := req.GetContext(mod_geo.CtxLatitude)
        if latitude == nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">return latitude.(string)</span>
}

func getClientGeoLongitude(req *bfe_basic.Request) string <span class="cov0" title="0">{
        longitude := req.GetContext(mod_geo.CtxLongitude)
        if longitude == nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">return longitude.(string)</span>
}
</pre>
		
		<pre class="file" id="file120" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_header

import (
        "github.com/baidu/go-lib/log"
        gcfg "gopkg.in/gcfg.v1"
)

import (
        "github.com/bfenetworks/bfe/bfe_util"
)

type ConfModHeader struct {
        Basic struct {
                DataPath             string // path of config data (mod_header)
                DisableDefaultHeader bool   // disable default header or not
        }

        Log struct {
                OpenDebug bool
        }
}

func ConfLoad(filePath string, confRoot string) (*ConfModHeader, error) <span class="cov8" title="1">{
        var err error
        var cfg ConfModHeader

        // read config from file
        err = gcfg.ReadFileInto(&amp;cfg, filePath)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;cfg, err
        }</span>

        // check conf of mod_header
        <span class="cov8" title="1">err = cfg.Check(confRoot)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;cfg, err
        }</span>

        <span class="cov8" title="1">return &amp;cfg, nil</span>
}

func (cfg *ConfModHeader) Check(confRoot string) error <span class="cov8" title="1">{
        if cfg.Basic.DataPath == "" </span><span class="cov8" title="1">{
                log.Logger.Warn("ModHeader.DataPath not set, use default value")
                cfg.Basic.DataPath = "mod_header/mod_header.data"
        }</span>

        <span class="cov8" title="1">cfg.Basic.DataPath = bfe_util.ConfPathProc(cfg.Basic.DataPath, confRoot)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file121" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_header

import (
        "net"
        "strings"
)

import (
        "github.com/bfenetworks/bfe/bfe_basic"
)

func modHeaderForwardedAddr(req *bfe_basic.Request) <span class="cov8" title="1">{
        if clientHost := req.HttpRequest.Host; clientHost != "" </span><span class="cov8" title="1">{
                if prior, existHost := req.HttpRequest.Header[bfe_basic.HeaderForwardedHost]; existHost </span><span class="cov0" title="0">{
                        clientHost = strings.Join(prior, ", ") + ", " + clientHost
                }</span>
                <span class="cov8" title="1">req.HttpRequest.Header.Set(bfe_basic.HeaderForwardedHost, clientHost)</span>
        }

        <span class="cov8" title="1">if clientIP, clientPort, err := net.SplitHostPort(req.HttpRequest.RemoteAddr); err == nil </span><span class="cov0" title="0">{
                if prior, existIP := req.HttpRequest.Header[bfe_basic.HeaderForwardedFor]; existIP </span><span class="cov0" title="0">{
                        clientIP = strings.Join(prior, ", ") + ", " + clientIP
                }</span>
                <span class="cov0" title="0">req.HttpRequest.Header.Set(bfe_basic.HeaderForwardedFor, clientIP)

                if priorPort, existPort := req.HttpRequest.Header[bfe_basic.HeaderForwardedPort]; existPort </span><span class="cov0" title="0">{
                        clientPort = strings.Join(priorPort, ", ") + ", " + clientPort
                }</span>
                <span class="cov0" title="0">req.HttpRequest.Header.Set(bfe_basic.HeaderForwardedPort, clientPort)</span>
        }
}

func setHeaderRealAddr(req *bfe_basic.Request, clientIP string, clientPort string) <span class="cov0" title="0">{
        req.HttpRequest.Header.Set(bfe_basic.HeaderRealIP, clientIP)
        req.HttpRequest.Header.Set(bfe_basic.HeaderRealPort, clientPort)
}</span>

func setHeaderBfeIP(req *bfe_basic.Request) <span class="cov8" title="1">{
        localip := req.Connection.LocalAddr().(*net.TCPAddr).IP.String()
        req.HttpRequest.Header.Set(bfe_basic.HeaderBfeIP, localip)
}</span>
</pre>
		
		<pre class="file" id="file122" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_header

import (
        "errors"
        "fmt"
        "os"
        "strings"
)

import (
        "github.com/bfenetworks/bfe/bfe_basic/condition"
        "github.com/bfenetworks/bfe/bfe_util/json"
)

type HeaderRuleFile struct {
        Cond    *string         // condition for header
        Actions *ActionFileList // list of actions
        Last    *bool           // if true, not to check the next rule in the list if
        // the condition is satisfied
}

type HeaderRule struct {
        Cond    condition.Condition // condition for header
        Actions []Action            // list of actions
        Last    bool                // if true, not to check the next rule in the list if
        // the condition is satisfied
}

type RuleFileList []HeaderRuleFile
type RuleList []HeaderRule

type ProductRulesFile map[string]*RuleFileList // product =&gt; list of header rules
type ProductRules map[string][]*RuleList       // product =&gt; list of header rules

type HeaderConfFile struct {
        Version *string // version of the config
        Config  *ProductRulesFile
}

type HeaderConf struct {
        Version string       // version of the config
        Config  ProductRules // product rules for header
}

func HeaderRuleCheck(conf HeaderRuleFile) error <span class="cov8" title="1">{
        var err error

        // check Cond
        if conf.Cond == nil </span><span class="cov8" title="1">{
                return errors.New("no Cond")
        }</span>

        // check Actions
        <span class="cov8" title="1">if conf.Actions == nil || len(*conf.Actions) == 0 </span><span class="cov8" title="1">{
                return errors.New("no Actions")
        }</span>

        <span class="cov8" title="1">err = ActionFileListCheck(conf.Actions)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Actions:%s", err.Error())
        }</span>

        // check Last
        <span class="cov8" title="1">if conf.Last == nil </span><span class="cov8" title="1">{
                return errors.New("no Last")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func RuleListCheck(conf *RuleFileList) error <span class="cov8" title="1">{
        for index, rule := range *conf </span><span class="cov8" title="1">{
                err := HeaderRuleCheck(rule)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("HeaderRule:%d, %s", index, err.Error())
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func ProductRulesCheck(conf *ProductRulesFile) error <span class="cov8" title="1">{
        for product, ruleList := range *conf </span><span class="cov8" title="1">{
                if ruleList == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("no RuleList for product:%s", product)
                }</span>

                <span class="cov8" title="1">err := RuleListCheck(ruleList)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("ProductRules:%s, %s", product, err.Error())
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func HeaderConfCheck(conf HeaderConfFile) error <span class="cov8" title="1">{
        var err error

        // check Version
        if conf.Version == nil </span><span class="cov0" title="0">{
                return errors.New("no Version")
        }</span>

        // check Config
        <span class="cov8" title="1">if conf.Config == nil </span><span class="cov0" title="0">{
                return errors.New("no Config")
        }</span>

        <span class="cov8" title="1">err = ProductRulesCheck(conf.Config)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Config:%s", err.Error())
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func ruleConvert(ruleFile HeaderRuleFile) (HeaderRule, error) <span class="cov8" title="1">{
        rule := HeaderRule{}

        if ruleFile.Cond == nil </span><span class="cov0" title="0">{
                return rule, fmt.Errorf("cond not set")
        }</span>
        <span class="cov8" title="1">cond, err := condition.Build(*ruleFile.Cond)
        if err != nil </span><span class="cov0" title="0">{
                return rule, err
        }</span>

        <span class="cov8" title="1">rule.Cond = cond
        rule.Actions, err = actionsConvert(*ruleFile.Actions)
        if err != nil </span><span class="cov0" title="0">{
                return rule, err
        }</span>
        <span class="cov8" title="1">rule.Last = *ruleFile.Last

        return rule, nil</span>
}

func ruleListConvert(ruleFileList *RuleFileList) (*RuleList, error) <span class="cov8" title="1">{
        ruleList := new(RuleList)
        *ruleList = make([]HeaderRule, 0)

        for _, ruleFile := range *ruleFileList </span><span class="cov8" title="1">{
                rule, err := ruleConvert(ruleFile)
                if err != nil </span><span class="cov0" title="0">{
                        return ruleList, err
                }</span>
                <span class="cov8" title="1">*ruleList = append(*ruleList, rule)</span>
        }

        <span class="cov8" title="1">return ruleList, nil</span>
}

func initRuleLists() []*RuleList <span class="cov8" title="1">{
        ruleLists := make([]*RuleList, TotalType)

        for i := 0; i &lt; len(ruleLists); i++ </span><span class="cov8" title="1">{
                ruleList := make(RuleList, 0)
                ruleLists[i] = &amp;ruleList
        }</span>

        <span class="cov8" title="1">return ruleLists</span>
}

func getHeaderType(cmd string) int <span class="cov8" title="1">{
        if strings.HasPrefix(cmd, "REQ_") </span><span class="cov8" title="1">{
                return ReqHeader
        }</span>

        <span class="cov8" title="1">return RspHeader</span>
}

func classifyRuleByAction(rule HeaderRule) RuleList <span class="cov8" title="1">{
        ruleList := make(RuleList, TotalType)
        for i := 0; i &lt; len(ruleList); i++ </span><span class="cov8" title="1">{
                ruleList[i].Cond = rule.Cond
                ruleList[i].Last = rule.Last
        }</span>

        <span class="cov8" title="1">for _, action := range rule.Actions </span><span class="cov8" title="1">{
                headerType := getHeaderType(action.Cmd)
                ruleList[headerType].Actions = append(ruleList[headerType].Actions, action)
        }</span>

        <span class="cov8" title="1">return ruleList</span>
}

func classifyRules(ruleList *RuleList) []*RuleList <span class="cov8" title="1">{
        ruleLists := initRuleLists()

        for _, rule := range *ruleList </span><span class="cov8" title="1">{
                ruleList := classifyRuleByAction(rule)

                for i := 0; i &lt; len(ruleLists); i++ </span><span class="cov8" title="1">{
                        if len(ruleList[i].Actions) != 0 </span><span class="cov8" title="1">{
                                *ruleLists[i] = append(*ruleLists[i], ruleList[i])
                        }</span>
                }
        }

        <span class="cov8" title="1">return ruleLists</span>
}

// HeaderConfLoad loads config of header from file.
func HeaderConfLoad(filename string) (HeaderConf, error) <span class="cov8" title="1">{
        var conf HeaderConf
        var err error

        /* open the file    */
        file, err1 := os.Open(filename)

        if err1 != nil </span><span class="cov8" title="1">{
                return conf, err1
        }</span>

        /* decode the file  */
        <span class="cov8" title="1">decoder := json.NewDecoder(file)

        var config HeaderConfFile
        err = decoder.Decode(&amp;config)
        file.Close()

        if err != nil </span><span class="cov0" title="0">{
                return conf, err
        }</span>

        // check config
        <span class="cov8" title="1">err = HeaderConfCheck(config)
        if err != nil </span><span class="cov0" title="0">{
                return conf, err
        }</span>

        /* convert config   */
        <span class="cov8" title="1">conf.Version = *config.Version
        conf.Config = make(ProductRules)

        for product, ruleFileList := range *config.Config </span><span class="cov8" title="1">{
                ruleList, err := ruleListConvert(ruleFileList)
                if err != nil </span><span class="cov0" title="0">{
                        return conf, err
                }</span>

                <span class="cov8" title="1">conf.Config[product] = classifyRules(ruleList)</span>
        }

        <span class="cov8" title="1">return conf, nil</span>
}
</pre>
		
		<pre class="file" id="file123" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_header

import (
        "sync"
)

type HeaderTable struct {
        lock         sync.RWMutex
        version      string
        productRules ProductRules
}

func NewHeaderTable() *HeaderTable <span class="cov8" title="1">{
        t := new(HeaderTable)
        t.productRules = make(ProductRules)
        return t
}</span>

func (t *HeaderTable) Update(conf HeaderConf) <span class="cov8" title="1">{
        t.lock.Lock()

        t.version = conf.Version
        t.productRules = conf.Config

        t.lock.Unlock()
}</span>

func (t *HeaderTable) Search(product string) ([]*RuleList, bool) <span class="cov8" title="1">{
        t.lock.RLock()
        productRules := t.productRules
        t.lock.RUnlock()

        rules, ok := productRules[product]
        return rules, ok
}</span>
</pre>
		
		<pre class="file" id="file124" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_header

import (
        "fmt"
        "net/url"
        "strconv"
)

import (
        "github.com/baidu/go-lib/log"
        "github.com/baidu/go-lib/web-monitor/web_monitor"
)

import (
        "github.com/bfenetworks/bfe/bfe_basic"
        "github.com/bfenetworks/bfe/bfe_http"
        "github.com/bfenetworks/bfe/bfe_module"
)

const (
        ReqHeader = iota
        RspHeader
        TotalType
)

const (
        GlobalProduct = "global"
)

var (
        openDebug = false
)

type ModuleHeader struct {
        name                 string       // name of module
        configPath           string       // path of config file
        disableDefaultHeader bool         // disable add default header
        ruleTable            *HeaderTable // table of header rules
}

func NewModuleHeader() *ModuleHeader <span class="cov8" title="1">{
        m := new(ModuleHeader)
        m.name = "mod_header"
        m.ruleTable = NewHeaderTable()
        return m
}</span>

func (m *ModuleHeader) Name() string <span class="cov8" title="1">{
        return m.name
}</span>

func (m *ModuleHeader) loadConfData(query url.Values) error <span class="cov8" title="1">{
        // get file path
        path := query.Get("path")
        if path == "" </span><span class="cov8" title="1">{
                // use default
                path = m.configPath
        }</span>

        // load from config file
        <span class="cov8" title="1">conf, err := HeaderConfLoad(path)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("err in HeaderConfLoad(%s):%s", path, err.Error())
        }</span>

        // update to rule table
        <span class="cov8" title="1">m.ruleTable.Update(conf)

        return nil</span>
}

func DoHeader(req *bfe_basic.Request, headerType int, ruleList *RuleList) <span class="cov8" title="1">{
        for _, rule := range *ruleList </span><span class="cov8" title="1">{
                // rule condition is satisfied ?
                if rule.Cond.Match(req) </span><span class="cov8" title="1">{
                        // do actions of the rule
                        HeaderActionsDo(req, headerType, rule.Actions)

                        // flag of last is true?
                        if rule.Last </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
        }
}

func (m *ModuleHeader) applyProductRule(request *bfe_basic.Request, headerType int, product string) <span class="cov8" title="1">{
        // find rules for given product
        rules, ok := m.ruleTable.Search(product)
        if ok </span><span class="cov8" title="1">{
                h := getHeader(request, headerType)
                if openDebug </span><span class="cov0" title="0">{
                        log.Logger.Debug("%s:before:headers=%s", m.name, *h)
                }</span>

                <span class="cov8" title="1">DoHeader(request, headerType, rules[headerType])

                if openDebug </span><span class="cov0" title="0">{
                        log.Logger.Debug("%s:after:headers=%s", m.name, *h)
                }</span>
        }
}

func (m *ModuleHeader) setDefaultHeader(request *bfe_basic.Request) <span class="cov8" title="1">{
        if openDebug </span><span class="cov0" title="0">{
                log.Logger.Debug("setDefaultHeader():src ip=%s, isTrustIP=%t",
                        request.RemoteAddr.String(), request.Session.TrustSource())
        }</span>

        // set client addr
        <span class="cov8" title="1">modHeaderForwardedAddr(request)
        if request.ClientAddr != nil </span><span class="cov0" title="0">{
                setHeaderRealAddr(request, request.ClientAddr.IP.String(), strconv.Itoa(request.ClientAddr.Port))
        }</span>

        // set bfe ip
        <span class="cov8" title="1">setHeaderBfeIP(request)</span>
}

func (m *ModuleHeader) reqHeaderHandler(request *bfe_basic.Request) (int, *bfe_http.Response) <span class="cov8" title="1">{
        // if disableDefaultHeader is true
        // do not Set default header
        if !m.disableDefaultHeader </span><span class="cov8" title="1">{
                m.setDefaultHeader(request)
        }</span>

        // apply global rule first
        <span class="cov8" title="1">m.applyProductRule(request, ReqHeader, GlobalProduct)

        // product specific rule will overwrite global rule for HEADER_SET action
        m.applyProductRule(request, ReqHeader, request.Route.Product)

        return bfe_module.BfeHandlerGoOn, nil</span>
}

func (m *ModuleHeader) rspHeaderHandler(request *bfe_basic.Request, res *bfe_http.Response) int <span class="cov8" title="1">{
        // apply global rule first
        m.applyProductRule(request, RspHeader, GlobalProduct)

        // product specific rule will overwrite global rule for HEADER_SET action
        m.applyProductRule(request, RspHeader, request.Route.Product)

        return bfe_module.BfeHandlerGoOn
}</span>

func (m *ModuleHeader) Init(cbs *bfe_module.BfeCallbacks, whs *web_monitor.WebHandlers,
        cr string) error <span class="cov8" title="1">{
        var err error
        var conf *ConfModHeader

        confPath := bfe_module.ModConfPath(cr, m.name)
        if conf, err = ConfLoad(confPath, cr); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: conf load err %s", m.name, err.Error())
        }</span>

        <span class="cov8" title="1">return m.init(conf, cbs, whs)</span>
}

func (m *ModuleHeader) init(cfg *ConfModHeader, cbs *bfe_module.BfeCallbacks,
        whs *web_monitor.WebHandlers) error <span class="cov8" title="1">{
        openDebug = cfg.Log.OpenDebug

        m.configPath = cfg.Basic.DataPath
        // set add default header or not
        m.disableDefaultHeader = cfg.Basic.DisableDefaultHeader

        // load from config file to rule table
        if err := m.loadConfData(nil); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("err in loadConfData(): %s", err.Error())
        }</span>

        // register handler
        <span class="cov8" title="1">err := cbs.AddFilter(bfe_module.HandleAfterLocation, m.reqHeaderHandler)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init(): AddFilter(m.headerHandler): %s", m.name, err.Error())
        }</span>

        // register handler
        <span class="cov8" title="1">err = cbs.AddFilter(bfe_module.HandleReadResponse, m.rspHeaderHandler)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init(): AddFilter(m.respHeaderHandler): %s", m.name, err.Error())
        }</span>

        // register web handler for reload
        <span class="cov8" title="1">err = whs.RegisterHandler(web_monitor.WebHandleReload, m.name, m.loadConfData)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init(): RegisterHandler(m.loadConfData): %s", m.name, err.Error())
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file125" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_http_code

import (
        "fmt"
        "net/url"
)

import (
        "github.com/baidu/go-lib/web-monitor/metrics"
        "github.com/baidu/go-lib/web-monitor/web_monitor"
)

import (
        "github.com/bfenetworks/bfe/bfe_basic"
        "github.com/bfenetworks/bfe/bfe_http"
        "github.com/bfenetworks/bfe/bfe_module"
)

const (
        ModHttpCode = "mod_http_code"
)

// ModuleHttpCodeState holds the counters of HTTP status code.
type ModuleHttpCodeState struct {
        All2XX *metrics.Counter
        All3XX *metrics.Counter
        All4XX *metrics.Counter
        All5XX *metrics.Counter
}

// ModuleHttpCode counts HTTP status code.
type ModuleHttpCode struct {
        name    string              // name of module
        state   ModuleHttpCodeState // module state
        metrics metrics.Metrics     // module metrics
}

// NewModuleHttpCode returns a new ModuleHttpCode.
func NewModuleHttpCode() *ModuleHttpCode <span class="cov8" title="1">{
        m := new(ModuleHttpCode)
        m.name = ModHttpCode
        m.metrics.Init(&amp;m.state, ModHttpCode, 0)
        return m
}</span>

// Name returns the name of ModuleHttpCode.
func (m *ModuleHttpCode) Name() string <span class="cov8" title="1">{
        return m.name
}</span>

func (m *ModuleHttpCode) getState(query url.Values) ([]byte, error) <span class="cov0" title="0">{
        d := m.metrics.GetAll()
        return d.Format(query)
}</span>

func (m *ModuleHttpCode) getStateDiff(query url.Values) ([]byte, error) <span class="cov0" title="0">{
        d := m.metrics.GetDiff()
        return d.Format(query)
}</span>

func (m *ModuleHttpCode) monitorHandlers() map[string]interface{} <span class="cov8" title="1">{
        handlers := map[string]interface{}{
                m.name:           m.getState,
                m.name + ".diff": m.getStateDiff,
        }

        return handlers
}</span>

// Init initializes ModuleHttpCode.
func (m *ModuleHttpCode) Init(cbs *bfe_module.BfeCallbacks,
        whs *web_monitor.WebHandlers, cr string) error <span class="cov8" title="1">{
        var err error

        // register handler
        err = cbs.AddFilter(bfe_module.HandleRequestFinish, m.requestFinish)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init(): AddFilter(m.requestFinish): %v", m.name, err)
        }</span>

        // register web handlers for monitor
        <span class="cov8" title="1">err = web_monitor.RegisterHandlers(whs, web_monitor.WebHandleMonitor, m.monitorHandlers())
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init(): RegisterHandlers(m.monitorHandlers): %v", m.name, err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (m *ModuleHttpCode) requestFinish(req *bfe_basic.Request, res *bfe_http.Response) int <span class="cov8" title="1">{
        if req.HttpResponse == nil </span><span class="cov0" title="0">{
                return bfe_module.BfeHandlerGoOn
        }</span>

        <span class="cov8" title="1">statusCode := req.HttpResponse.StatusCode
        switch statusCode / 100 </span>{
        case 2:<span class="cov8" title="1">
                m.state.All2XX.Inc(1)</span>
        case 3:<span class="cov0" title="0">
                m.state.All3XX.Inc(1)</span>
        case 4:<span class="cov0" title="0">
                m.state.All4XX.Inc(1)</span>
        case 5:<span class="cov0" title="0">
                m.state.All5XX.Inc(1)</span>
        }

        <span class="cov8" title="1">return bfe_module.BfeHandlerGoOn</span>
}
</pre>
		
		<pre class="file" id="file126" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_key_log

import (
        gcfg "gopkg.in/gcfg.v1"
)

import (
        "github.com/bfenetworks/bfe/bfe_util/access_log"
)

// ConfModKeyLog represents the basic config for mod_key_log.
type ConfModKeyLog struct {
        Basic struct {
                DataPath string // path of config data (key_log)
        }
        Log access_log.LogConfig
}

// Check validates module config
func (cfg *ConfModKeyLog) Check(confRoot string) error <span class="cov0" title="0">{
        return cfg.Log.Check(confRoot)
}</span>

// ConfLoad loads config from file
func ConfLoad(filePath string, confRoot string) (*ConfModKeyLog, error) <span class="cov0" title="0">{
        var cfg ConfModKeyLog
        var err error

        // read config from file
        err = gcfg.ReadFileInto(&amp;cfg, filePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // check config
        <span class="cov0" title="0">err = cfg.Check(confRoot)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;cfg, nil</span>
}
</pre>
		
		<pre class="file" id="file127" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_key_log

import (
        "errors"
        "fmt"
        "os"
)

import (
        "github.com/bfenetworks/bfe/bfe_basic/condition"
        "github.com/bfenetworks/bfe/bfe_util/json"
)

type KeyLogRuleFile struct {
        Cond *string // condition for key_log
}

type KeyLogRule struct {
        Cond condition.Condition // condition for key_log
}

type RuleFileList []KeyLogRuleFile
type RuleList []KeyLogRule

type ProductRulesFile map[string]*RuleFileList // product =&gt; list of key_log rules
type ProductRules map[string]*RuleList         // product =&gt; list of key_log rules

type KeyLogConfFile struct {
        Version *string // version of the config
        Config  *ProductRulesFile
}

type keyLogConf struct {
        Version string       // version of the config
        Config  ProductRules // product rules for key_log
}

func keyLogRuleCheck(conf KeyLogRuleFile) error <span class="cov8" title="1">{
        // check Cond
        if conf.Cond == nil </span><span class="cov8" title="1">{
                return errors.New("no Cond")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func RuleListCheck(conf *RuleFileList) error <span class="cov8" title="1">{
        for index, rule := range *conf </span><span class="cov8" title="1">{
                err := keyLogRuleCheck(rule)
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("keyLogRule:%d, %s", index, err.Error())
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func ProductRulesCheck(conf *ProductRulesFile) error <span class="cov8" title="1">{
        for product, ruleList := range *conf </span><span class="cov8" title="1">{
                if ruleList == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("no RuleList for product:%s", product)
                }</span>

                <span class="cov8" title="1">err := RuleListCheck(ruleList)
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("ProductRules:%s, %s", product, err.Error())
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func KeyLogConfCheck(conf KeyLogConfFile) error <span class="cov8" title="1">{
        var err error

        // check Version
        if conf.Version == nil </span><span class="cov0" title="0">{
                return errors.New("no Version")
        }</span>

        // check Config
        <span class="cov8" title="1">if conf.Config == nil </span><span class="cov0" title="0">{
                return errors.New("no Config")
        }</span>

        <span class="cov8" title="1">err = ProductRulesCheck(conf.Config)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("Config:%s", err.Error())
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func ruleConvert(ruleFile KeyLogRuleFile) (KeyLogRule, error) <span class="cov8" title="1">{
        rule := KeyLogRule{}

        cond, err := condition.Build(*ruleFile.Cond)
        if err != nil </span><span class="cov0" title="0">{
                return rule, err
        }</span>
        <span class="cov8" title="1">rule.Cond = cond

        return rule, nil</span>
}

func ruleListConvert(ruleFileList *RuleFileList) (*RuleList, error) <span class="cov8" title="1">{
        ruleList := new(RuleList)
        *ruleList = make([]KeyLogRule, 0)

        for _, ruleFile := range *ruleFileList </span><span class="cov8" title="1">{
                rule, err := ruleConvert(ruleFile)
                if err != nil </span><span class="cov0" title="0">{
                        return ruleList, err
                }</span>
                <span class="cov8" title="1">*ruleList = append(*ruleList, rule)</span>
        }

        <span class="cov8" title="1">return ruleList, nil</span>
}

// keyLogConfLoad loads config of key_log from file.
func keyLogConfLoad(filename string) (keyLogConf, error) <span class="cov8" title="1">{
        var conf keyLogConf
        var err error

        // open the file
        file, err1 := os.Open(filename)
        if err1 != nil </span><span class="cov0" title="0">{
                return conf, err1
        }</span>
        <span class="cov8" title="1">defer file.Close()

        // decode the file
        decoder := json.NewDecoder(file)
        var config KeyLogConfFile
        err = decoder.Decode(&amp;config)
        if err != nil </span><span class="cov0" title="0">{
                return conf, err
        }</span>

        // check config
        <span class="cov8" title="1">err = KeyLogConfCheck(config)
        if err != nil </span><span class="cov8" title="1">{
                return conf, err
        }</span>

        // convert config
        <span class="cov8" title="1">conf.Version = *config.Version
        conf.Config = make(ProductRules)
        for product, ruleFileList := range *config.Config </span><span class="cov8" title="1">{
                ruleList, err := ruleListConvert(ruleFileList)
                if err != nil </span><span class="cov0" title="0">{
                        return conf, err
                }</span>
                <span class="cov8" title="1">conf.Config[product] = ruleList</span>
        }

        <span class="cov8" title="1">return conf, nil</span>
}
</pre>
		
		<pre class="file" id="file128" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_key_log

import (
        "sync"
)

type KeyLogTable struct {
        lock         sync.RWMutex
        version      string
        productRules ProductRules
}

func NewKeyLogTable() *KeyLogTable <span class="cov0" title="0">{
        t := new(KeyLogTable)
        t.productRules = make(ProductRules)
        return t
}</span>

func (t *KeyLogTable) Update(conf keyLogConf) <span class="cov0" title="0">{
        t.lock.Lock()

        t.version = conf.Version
        t.productRules = conf.Config

        t.lock.Unlock()
}</span>

func (t *KeyLogTable) Search(product string) (*RuleList, bool) <span class="cov0" title="0">{
        t.lock.RLock()
        productRules := t.productRules
        t.lock.RUnlock()

        rules, ok := productRules[product]
        return rules, ok
}</span>
</pre>
		
		<pre class="file" id="file129" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_key_log

import (
        "encoding/hex"
        "fmt"
        "net/url"
        "path/filepath"
)

import (
        "github.com/baidu/go-lib/log/log4go"
        "github.com/baidu/go-lib/web-monitor/web_monitor"
)

import (
        "github.com/bfenetworks/bfe/bfe_basic"
        "github.com/bfenetworks/bfe/bfe_module"
        "github.com/bfenetworks/bfe/bfe_util/access_log"
)

// ModuleKeyLog writes key logs in NSS key log format so that external
// programs(eg. wireshark) can decrypt TLS connections for trouble shooting.
//
// For more information about NSS key log format, see:
// https://developer.mozilla.org/en-US/docs/Mozilla/Projects/NSS/Key_Log_Format
type ModuleKeyLog struct {
        name   string         // module name
        conf   *ConfModKeyLog // module config
        logger log4go.Logger  // key logger

        dataConfigPath string       // path of data config file
        ruleTable      *KeyLogTable // table of key_log rules

}

func NewModuleKeyLog() *ModuleKeyLog <span class="cov0" title="0">{
        m := new(ModuleKeyLog)
        m.name = "mod_key_log"
        m.ruleTable = NewKeyLogTable()
        return m
}</span>

func (m *ModuleKeyLog) Name() string <span class="cov0" title="0">{
        return m.name
}</span>

func (m *ModuleKeyLog) logTlsKey(session *bfe_basic.Session) int <span class="cov0" title="0">{
        if m.isNeedKeyLog(session) </span><span class="cov0" title="0">{
                tlsState := session.TlsState
                if tlsState == nil </span><span class="cov0" title="0">{
                        return bfe_module.BfeHandlerGoOn
                }</span>
                // key log format: &lt;label&gt; &lt;ClientRandom&gt; &lt;MasterSecret&gt;
                <span class="cov0" title="0">keyLog := fmt.Sprintf("CLIENT_RANDOM %s %s",
                        hex.EncodeToString(tlsState.ClientRandom), // connection id
                        hex.EncodeToString(tlsState.MasterSecret)) // connection master secret
                m.logger.Info(keyLog)</span>
        }
        <span class="cov0" title="0">return bfe_module.BfeHandlerGoOn</span>
}

// isNeedKeyLog Determine if you need to print the key log
func (m *ModuleKeyLog) isNeedKeyLog(session *bfe_basic.Session) bool <span class="cov0" title="0">{
        rules, ok := m.ruleTable.Search(session.Product)
        if !ok </span><span class="cov0" title="0">{
                rules, ok = m.ruleTable.Search(bfe_basic.GlobalProduct)
        }</span>
        <span class="cov0" title="0">if !ok </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">req := &amp;bfe_basic.Request{
                Session: session,
        }
        for _, rule := range *rules </span><span class="cov0" title="0">{
                // rule condition is satisfied ?
                if rule.Cond.Match(req) </span><span class="cov0" title="0">{
                        // do actions of the rule
                        // todo

                        // finish key_log rules process
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func (m *ModuleKeyLog) Init(cbs *bfe_module.BfeCallbacks, whs *web_monitor.WebHandlers,
        cr string) error <span class="cov0" title="0">{
        var conf *ConfModKeyLog
        var err error

        // load config
        confPath := bfe_module.ModConfPath(cr, m.name)
        if conf, err = ConfLoad(confPath, cr); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: conf load err %s", m.name, err.Error())
        }</span>
        <span class="cov0" title="0">m.conf = conf
        m.dataConfigPath = conf.Basic.DataPath

        // load from data config file to rule table
        if _, err := m.loadConfData(nil); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("err in loadConfData(): %s", err.Error())
        }</span>

        // init logger
        <span class="cov0" title="0">m.logger, err = access_log.LoggerInit(m.conf.Log)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init():create logger:%s", m.name, err.Error())
        }</span>

        // register handler
        <span class="cov0" title="0">err = cbs.AddFilter(bfe_module.HandleHandshake, m.logTlsKey)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init(): AddFilter(m.logTlsKey): %s", m.name, err.Error())
        }</span>

        // register web handler for reload
        <span class="cov0" title="0">err = whs.RegisterHandler(web_monitor.WebHandleReload, m.name, m.loadConfData)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init(): RegisterHandler(m.loadConfData): %s", m.name, err.Error())
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (m *ModuleKeyLog) loadConfData(query url.Values) (string, error) <span class="cov0" title="0">{
        // get file path
        path := query.Get("path")
        if path == "" </span><span class="cov0" title="0">{
                // use default
                path = m.dataConfigPath
        }</span>

        // load from config file
        <span class="cov0" title="0">conf, err := keyLogConfLoad(path)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("err in keyLogConfLoad(%s):%s", path, err.Error())
        }</span>

        // update to rule table
        <span class="cov0" title="0">m.ruleTable.Update(conf)

        _, fileName := filepath.Split(path)
        return fmt.Sprintf("%s=%s", fileName, conf.Version), nil</span>
}
</pre>
		
		<pre class="file" id="file130" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_markdown

import (
        "github.com/baidu/go-lib/log"
        "gopkg.in/gcfg.v1"
)
import (
        "github.com/bfenetworks/bfe/bfe_util"
)

const DefaultRulePath = "mod_markdown/markdown_rule.data"

type ConfModMarkdown struct {
        Basic struct {
                // md product rule data path
                ProductRulePath string
        }
        Log struct {
                // open debug log
                OpenDebug bool
        }
}

func (cfg *ConfModMarkdown) Check(confRoot string) error <span class="cov8" title="1">{
        if cfg.Basic.ProductRulePath == "" </span><span class="cov8" title="1">{
                log.Logger.Warn("ConfModMarkdown.ProductRulePath not set, use default value")
                cfg.Basic.ProductRulePath = DefaultRulePath
        }</span>

        <span class="cov8" title="1">cfg.Basic.ProductRulePath = bfe_util.ConfPathProc(cfg.Basic.ProductRulePath, confRoot)

        return nil</span>
}

func ConfLoad(filePath string, confRoot string) (*ConfModMarkdown, error) <span class="cov8" title="1">{
        var cfg ConfModMarkdown
        err := gcfg.ReadFileInto(&amp;cfg, filePath)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">err = cfg.Check(confRoot)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;cfg, nil</span>
}
</pre>
		
		<pre class="file" id="file131" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_markdown

import (
        "fmt"
)

import (
        "github.com/microcosm-cc/bluemonday"
        "github.com/russross/blackfriday/v2"
)

func Render(src []byte) ([]byte, error) <span class="cov8" title="1">{
        if len(src) == 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("Render(): render empty src")
        }</span>
        <span class="cov8" title="1">dst := render(src)
        return dst, nil</span>
}

func render(src []byte) []byte <span class="cov8" title="1">{
        unsafe := blackfriday.Run(src)
        html := bluemonday.UGCPolicy().SanitizeBytes(unsafe)
        return html
}</span>
</pre>
		
		<pre class="file" id="file132" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package mod_markdown

import (
        "fmt"
        "os"
)

import (
        "github.com/bfenetworks/bfe/bfe_basic/condition"
        "github.com/bfenetworks/bfe/bfe_util/json"
)

type markdownRuleFile struct {
        Cond string
}

type markdownRule struct {
        Cond *condition.Condition
}

type markdownRuleFiles []*markdownRuleFile
type markdownRules []*markdownRule

type productRulesFile map[string]*markdownRuleFiles
type productRules map[string]*markdownRules

type productRuleConfFile struct {
        Version string
        Config  *productRulesFile
}

type productRuleConf struct {
        Version string
        Config  productRules
}

func ruleConvert(ruleFile *markdownRuleFile) (*markdownRule, error) <span class="cov8" title="1">{
        if ruleFile == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("ruleConvert(): nil ruleFile")
        }</span>
        <span class="cov8" title="1">rule := new(markdownRule)
        cond, err := condition.Build(ruleFile.Cond)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">rule.Cond = &amp;cond
        return rule, nil</span>
}

func rulesConvert(ruleFiles *markdownRuleFiles) (*markdownRules, error) <span class="cov8" title="1">{
        if ruleFiles == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("rulesConvert():nil markdownRuleFiles")
        }</span>
        <span class="cov8" title="1">rules := new(markdownRules)
        *rules = make([]*markdownRule, 0)
        for _, ruleFile := range *ruleFiles </span><span class="cov8" title="1">{
                rule, err := ruleConvert(ruleFile)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">*rules = append(*rules, rule)</span>
        }
        <span class="cov8" title="1">return rules, nil</span>
}

func mdRuleCheck(rule *markdownRuleFile) error <span class="cov8" title="1">{
        if rule == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("empty rule")
        }</span>
        <span class="cov8" title="1">if rule.Cond == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("empty rule cond")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func rulesCheck(mdRuleFiles *markdownRuleFiles) error <span class="cov8" title="1">{
        if mdRuleFiles == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("empty rules")
        }</span>
        <span class="cov8" title="1">for index, rule := range *mdRuleFiles </span><span class="cov8" title="1">{
                err := mdRuleCheck(rule)
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("Invalid markdown rule, index[%d], err[%s]", index, err)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func productRulesFileCheck(cfg *productRulesFile) error <span class="cov8" title="1">{
        if cfg == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("nil product rules file")
        }</span>
        <span class="cov8" title="1">for product, productRules := range *cfg </span><span class="cov8" title="1">{
                if productRules == nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("no product rules for product[%s]", product)
                }</span>

                <span class="cov8" title="1">err := rulesCheck(productRules)
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("check product[%s] rules err[%v]", product, err)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func productRuleFileCheck(cfg productRuleConfFile) error <span class="cov8" title="1">{
        if cfg.Version == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("no version")
        }</span>

        <span class="cov8" title="1">if cfg.Config == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("no Config")
        }</span>
        <span class="cov8" title="1">err := productRulesFileCheck(cfg.Config)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("Config err[%v]", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func ProductRuleConfLoad(fileName string) (productRuleConf, error) <span class="cov8" title="1">{
        var confFile productRuleConfFile
        var conf productRuleConf

        file, err := os.Open(fileName)
        if err != nil </span><span class="cov8" title="1">{
                return conf, err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        err = json.NewDecoder(file).Decode(&amp;confFile)
        if err != nil </span><span class="cov0" title="0">{
                return conf, err
        }</span>
        <span class="cov8" title="1">err = productRuleFileCheck(confFile)
        if err != nil </span><span class="cov8" title="1">{
                return conf, err
        }</span>

        <span class="cov8" title="1">conf.Version = confFile.Version
        conf.Config = make(productRules)

        for product, productConfFile := range *confFile.Config </span><span class="cov8" title="1">{
                productRules, err := rulesConvert(productConfFile)
                if err != nil </span><span class="cov0" title="0">{
                        return conf, err
                }</span>
                <span class="cov8" title="1">conf.Config[product] = productRules</span>
        }
        <span class="cov8" title="1">return conf, nil</span>
}
</pre>
		
		<pre class="file" id="file133" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package mod_markdown

import (
        "sync"
)

type MarkdownRuleTable struct {
        version string

        productRules productRules
        lock         sync.RWMutex
}

func NewMarkdownRuleTable() *MarkdownRuleTable <span class="cov8" title="1">{
        t := new(MarkdownRuleTable)
        t.productRules = make(productRules)
        return t
}</span>

func (t *MarkdownRuleTable) Update(conf productRuleConf) <span class="cov8" title="1">{
        t.lock.Lock()
        t.version = conf.Version
        t.productRules = conf.Config
        t.lock.Unlock()
}</span>

func (t *MarkdownRuleTable) Search(product string) (*markdownRules, bool) <span class="cov8" title="1">{
        t.lock.RLock()
        productRules := t.productRules
        t.lock.RUnlock()

        rules, ok := productRules[product]
        return rules, ok
}</span>
</pre>
		
		<pre class="file" id="file134" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// package mod mark_down, deal with the markdown`s response

package mod_markdown

import (
        "bytes"
        "fmt"
        "io/ioutil"
        "net/url"
        "strconv"
        "strings"
)

import (
        "github.com/baidu/go-lib/log"
        "github.com/baidu/go-lib/web-monitor/metrics"
        "github.com/baidu/go-lib/web-monitor/web_monitor"
)

import (
        "github.com/bfenetworks/bfe/bfe_basic"
        "github.com/bfenetworks/bfe/bfe_http"
        "github.com/bfenetworks/bfe/bfe_module"
)

const (
        ModMarkdown         = "mod_markdown"
        MaxBodyBytes        = 32 * 1024
        MarkdownContentType = "text/markdown"
        ConvertContentType  = "text/html; charset=UTF-8"
)

var openDebug = false

type ModuleMarkdownState struct {
        ReqTotal           *metrics.Counter
        ReqMarkDownRuleHit *metrics.Counter
        RspRenderSuccess   *metrics.Counter
        RspRenderFailure   *metrics.Counter
        RspRenderIgnore    *metrics.Counter
        // detail err reason
        ErrCountReadFail   *metrics.Counter
        ErrCountRenderFail *metrics.Counter
}

type ModuleMarkdown struct {
        name      string              //module name
        conf      *ConfModMarkdown    //module conf
        ruleTable *MarkdownRuleTable  // module rule table
        state     ModuleMarkdownState // module state
        metrics   metrics.Metrics     //module metrics
}

func NewModuleMarkdown() *ModuleMarkdown <span class="cov8" title="1">{
        m := new(ModuleMarkdown)
        m.name = ModMarkdown
        m.metrics.Init(&amp;m.state, ModMarkdown, 0)
        m.ruleTable = NewMarkdownRuleTable()
        return m
}</span>

func (m *ModuleMarkdown) Name() string <span class="cov8" title="1">{
        return m.name
}</span>

func (m *ModuleMarkdown) loadProductRuleConf(query url.Values) error <span class="cov8" title="1">{
        path := query.Get("path")
        if path == "" </span><span class="cov8" title="1">{
                path = m.conf.Basic.ProductRulePath
        }</span>

        <span class="cov8" title="1">conf, err := ProductRuleConfLoad(path)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("err in ProductRuleConfLoad(%s): %s", path, err)
        }</span>

        <span class="cov8" title="1">m.ruleTable.Update(conf)
        return nil</span>
}

func (m *ModuleMarkdown) checkResponse(res *bfe_http.Response) error <span class="cov8" title="1">{
        contentType := res.Header.Get("Content-Type")
        if !strings.Contains(contentType, MarkdownContentType) </span><span class="cov8" title="1">{
                return fmt.Errorf("ModuleMarkdown.checkResponse(): content type don`t contain %s ", MarkdownContentType)
        }</span>
        <span class="cov8" title="1">if len(res.TransferEncoding) &gt; 0 &amp;&amp; res.TransferEncoding[0] == "chunked" </span><span class="cov8" title="1">{
                return fmt.Errorf("ModuleMarkdown.checkResponse(): can not process chunked body")
        }</span>
        <span class="cov8" title="1">if res.ContentLength &lt;= 0 || res.ContentLength &gt; MaxBodyBytes </span><span class="cov8" title="1">{
                return fmt.Errorf("ModuleMarkdown.checkResponse(): content len:%d", res.ContentLength)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (m *ModuleMarkdown) renderMarkDownHandler(req *bfe_basic.Request, res *bfe_http.Response) int <span class="cov8" title="1">{
        rules, ok := m.ruleTable.Search(req.Route.Product)
        if !ok </span><span class="cov8" title="1">{
                return bfe_module.BfeHandlerGoOn
        }</span>
        <span class="cov8" title="1">m.state.ReqTotal.Inc(1)

        for _, rule := range *rules </span><span class="cov8" title="1">{
                if !(*rule.Cond).Match(req) </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">m.state.ReqMarkDownRuleHit.Inc(1)

                err := m.checkResponse(res)
                if err != nil </span><span class="cov0" title="0">{
                        m.state.RspRenderFailure.Inc(1)
                        if openDebug </span><span class="cov0" title="0">{
                                log.Logger.Debug("err in ModuleMarkdown.render.checkResponse(): %s", err)
                        }</span>
                        <span class="cov0" title="0">return bfe_module.BfeHandlerGoOn</span>
                }
                <span class="cov8" title="1">err = m.renderMarkDown(res)
                if err != nil </span><span class="cov0" title="0">{
                        if openDebug </span><span class="cov0" title="0">{
                                log.Logger.Debug("err in ModuleMarkdown.renderMarkDown(): %s", err)
                        }</span>

                        <span class="cov0" title="0">res.Body.Close()
                        *res = *bfe_basic.CreateInternalSrvErrResp(req)

                        m.state.RspRenderFailure.Inc(1)
                        return bfe_module.BfeHandlerGoOn</span>
                }

                <span class="cov8" title="1">m.state.RspRenderSuccess.Inc(1)
                return bfe_module.BfeHandlerGoOn</span>
        }
        <span class="cov0" title="0">return bfe_module.BfeHandlerGoOn</span>
}

func (m *ModuleMarkdown) renderMarkDown(res *bfe_http.Response) error <span class="cov8" title="1">{
        src, err := ioutil.ReadAll(res.Body)
        if err != nil </span><span class="cov0" title="0">{
                m.state.ErrCountReadFail.Inc(1)
                return err
        }</span>

        <span class="cov8" title="1">dst, err := Render(src)
        if err != nil </span><span class="cov0" title="0">{
                m.state.ErrCountRenderFail.Inc(1)
                return err
        }</span>
        <span class="cov8" title="1">res.Body.Close()
        res.Body = ioutil.NopCloser(bytes.NewReader(dst))

        res.ContentLength = int64(len(dst))
        res.Header.Set("Content-Length", strconv.FormatInt(res.ContentLength, 10))
        res.Header.Set("Content-Type", ConvertContentType)
        return nil</span>
}

func (m *ModuleMarkdown) getState(params map[string][]string) ([]byte, error) <span class="cov0" title="0">{
        s := m.metrics.GetAll()
        return s.Format(params)
}</span>

func (m *ModuleMarkdown) getStateDiff(params map[string][]string) ([]byte, error) <span class="cov0" title="0">{
        s := m.metrics.GetDiff()
        return s.Format(params)
}</span>

func (m *ModuleMarkdown) monitorHandlers() map[string]interface{} <span class="cov8" title="1">{
        handlers := map[string]interface{}{
                m.name:           m.getState,
                m.name + ".diff": m.getStateDiff,
        }
        return handlers
}</span>

func (m *ModuleMarkdown) reloadHandlers() map[string]interface{} <span class="cov8" title="1">{
        handlers := map[string]interface{}{
                m.name: m.loadProductRuleConf,
        }
        return handlers
}</span>

func (m *ModuleMarkdown) Init(cbs *bfe_module.BfeCallbacks, whs *web_monitor.WebHandlers, cr string) error <span class="cov8" title="1">{
        var err error

        confPath := bfe_module.ModConfPath(cr, m.Name())
        if m.conf, err = ConfLoad(confPath, cr); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("%s: conf load err %v", m.name, err)
        }</span>
        <span class="cov8" title="1">openDebug = m.conf.Log.OpenDebug

        if err = m.loadProductRuleConf(nil); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("%s: loadProductRuleConf() err %v", m.Name(), err)
        }</span>

        <span class="cov8" title="1">err = cbs.AddFilter(bfe_module.HandleReadResponse, m.renderMarkDownHandler)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("%s.Init(): AddFilter(m.renderMarkDownHandler): %v", m.name, err)
        }</span>

        <span class="cov8" title="1">err = web_monitor.RegisterHandlers(whs, web_monitor.WebHandleMonitor, m.monitorHandlers())
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("%s.Init(): RegisterHandlers(m.monitorHandlers): %v", m.Name(), err)
        }</span>

        <span class="cov8" title="1">err = web_monitor.RegisterHandlers(whs, web_monitor.WebHandleReload, m.reloadHandlers())
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init(): RegisterHandlers(m.reloadHandlerr): %v", m.Name(), err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file135" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_prison

import (
        "bytes"
        "crypto/md5"
        "errors"
        "net/url"
        "regexp"
        "strings"
        "sync/atomic"
        "time"
)

import (
        "github.com/bfenetworks/bfe/bfe_basic"
)

type AccessSign [16]byte

type AccessSigner struct {
        AccessSignConf                // basic conf for signature
        UrlReg         *regexp.Regexp // url regular expression
}

func (s *AccessSigner) Sign(label string, req *bfe_basic.Request) (AccessSign, error) <span class="cov0" title="0">{
        // prepare raw data for signature
        data, err := s.prepareData(label, req)
        if err != nil </span><span class="cov0" title="0">{
                return AccessSign{}, err
        }</span>

        // calculate signature
        <span class="cov0" title="0">return AccessSign(md5.Sum(data)), nil</span>
}

func (s *AccessSigner) prepareData(label string, req *bfe_basic.Request) ([]byte, error) <span class="cov0" title="0">{
        var buf bytes.Buffer

        // label
        buildKeyValue(&amp;buf, "label", label)
        // client ip
        if s.UseClientIP </span><span class="cov0" title="0">{
                if req.ClientAddr == nil </span><span class="cov0" title="0">{
                        return nil, errors.New("request without client ip")

                }</span>
                <span class="cov0" title="0">buildKeyValue(&amp;buf, "clientIP", req.ClientAddr.IP.String())</span>
        }
        // request url
        <span class="cov0" title="0">if s.UseUrl </span><span class="cov0" title="0">{
                buildKeyValue(&amp;buf, "url", req.HttpRequest.RequestURI)
        }</span>
        // request host
        <span class="cov0" title="0">if s.UseHost </span><span class="cov0" title="0">{
                buildKeyValue(&amp;buf, "host", req.HttpRequest.Host)
        }</span>
        // request path
        <span class="cov0" title="0">if s.UsePath </span><span class="cov0" title="0">{
                buildKeyValue(&amp;buf, "path", req.HttpRequest.URL.Path)
        }</span>
        // substring of url
        <span class="cov0" title="0">if len(s.UrlRegexp) &gt; 0 </span><span class="cov0" title="0">{
                subStrs := s.UrlReg.FindStringSubmatch(req.HttpRequest.RequestURI)
                if len(subStrs) == 0 </span><span class="cov0" title="0">{
                        return nil, errors.New("not matched url")
                }</span>
                <span class="cov0" title="0">buildKeyValue(&amp;buf, "urlpattern", strings.Join(subStrs[1:], ","))</span>
        }
        // request header
        <span class="cov0" title="0">if len(s.Header) != 0 </span><span class="cov0" title="0">{
                reqHeader := req.HttpRequest.Header
                for _, k := range s.Header </span><span class="cov0" title="0">{
                        v := reqHeader.Get(k)
                        if len(v) == 0 </span><span class="cov0" title="0">{
                                return nil, errors.New("request without Header")
                        }</span>
                        <span class="cov0" title="0">buildKeyValue(&amp;buf, k, v)</span>
                }
        }
        // request cookie
        <span class="cov0" title="0">if len(s.Cookie) != 0 </span><span class="cov0" title="0">{
                cookie := req.CachedCookie()
                for _, k := range s.Cookie </span><span class="cov0" title="0">{
                        v, ok := cookie.Get(k)
                        if !ok </span><span class="cov0" title="0">{
                                return nil, errors.New("request without Cookie")
                        }</span>
                        <span class="cov0" title="0">buildKeyValue(&amp;buf, k, v.Value)</span>
                }
        }
        // request query
        <span class="cov0" title="0">if len(s.Query) != 0 </span><span class="cov0" title="0">{
                query := req.CachedQuery()
                for _, k := range s.Query </span><span class="cov0" title="0">{
                        if ok := buildQueryValues(&amp;buf, query, k); !ok </span><span class="cov0" title="0">{
                                return nil, errors.New("request without Query")
                        }</span>
                }
        }
        // all request headers
        <span class="cov0" title="0">if s.UseHeaders </span><span class="cov0" title="0">{
                keys := req.HttpRequest.HeaderKeys
                for _, key := range keys </span><span class="cov0" title="0">{ // headers by order
                        val := req.HttpRequest.Header.Get(key)
                        if key == "Host" </span><span class="cov0" title="0">{
                                val = req.HttpRequest.Host
                        }</span>
                        <span class="cov0" title="0">buildKeyValue(&amp;buf, key, val)</span>
                }
        }

        <span class="cov0" title="0">return buf.Bytes(), nil</span>
}

func buildKeyValue(dst *bytes.Buffer, key string, val string) <span class="cov0" title="0">{
        dst.WriteString("&amp;")
        dst.WriteString(key)
        dst.WriteString("=")
        dst.WriteString(val)
}</span>

// buildQueryValues builds value from equivalent queries (separate by |, eg q1|q2)
func buildQueryValues(dst *bytes.Buffer, query url.Values, keys string) bool <span class="cov0" title="0">{
        // Note: output format &amp;q1|q2=v1v2 (instead of &amp;q1=v1&amp;q2=v2)
        existQuery := false
        dst.WriteString("&amp;")
        dst.WriteString(keys)
        dst.WriteString("=")
        keyList := strings.Split(keys, "|")
        for _, key := range keyList </span><span class="cov0" title="0">{
                if val := query.Get(key); len(val) &gt; 0 </span><span class="cov0" title="0">{
                        dst.WriteString(val)
                        existQuery = true
                }</span>
        }
        <span class="cov0" title="0">return existQuery</span>
}

type AccessCounter struct {
        count     int32 // value of stat counter
        startTime int64 // timestamp when start count
}

func NewAccessCounter() *AccessCounter <span class="cov8" title="1">{
        c := new(AccessCounter)
        c.count = 0
        c.startTime = time.Now().UnixNano()
        return c
}</span>

func (c *AccessCounter) IncAndCheck(checkPeriodNs int64, threshold int32) (bool, int64) <span class="cov8" title="1">{
        // check timestamp first
        now := time.Now().UnixNano()
        stime := atomic.LoadInt64(&amp;c.startTime)
        if stime+checkPeriodNs &lt; now </span><span class="cov0" title="0">{ // reset count
                c.reset()
        }</span>

        // increase counter
        <span class="cov8" title="1">count := atomic.AddInt32(&amp;c.count, 1)

        // check threshold
        stime = atomic.LoadInt64(&amp;c.startTime)
        return count &gt; threshold, stime + checkPeriodNs - now</span>
}

func (f *AccessCounter) reset() <span class="cov0" title="0">{
        atomic.StoreInt32(&amp;f.count, 0)
        now := time.Now().UnixNano()
        atomic.StoreInt64(&amp;f.startTime, now)
}</span>
</pre>
		
		<pre class="file" id="file136" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_prison

import (
        "github.com/baidu/go-lib/log"
        gcfg "gopkg.in/gcfg.v1"
)

import (
        "github.com/bfenetworks/bfe/bfe_util"
)

type ConfModPrison struct {
        Basic struct {
                ProductRulePath string // path for product rule
        }

        Log struct {
                OpenDebug bool // whether open debug
        }
}

// ConfLoad load config from file
func ConfLoad(filePath string, confRoot string) (*ConfModPrison, error) <span class="cov0" title="0">{
        var cfg ConfModPrison
        var err error

        // read config from file
        err = gcfg.ReadFileInto(&amp;cfg, filePath)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;cfg, err
        }</span>

        // check conf of mod_prison
        <span class="cov0" title="0">err = ConfModPrisonCheck(&amp;cfg, confRoot)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;cfg, err
        }</span>

        <span class="cov0" title="0">return &amp;cfg, nil</span>
}

// ConfModPrisonCheck check conf of mod_prison
func ConfModPrisonCheck(cfg *ConfModPrison, confRoot string) error <span class="cov0" title="0">{
        if cfg.Basic.ProductRulePath == "" </span><span class="cov0" title="0">{
                log.Logger.Warn("ModPrison.ProductRulePath not set, use default value")
                cfg.Basic.ProductRulePath = "mod_prison/prison.data"
        }</span>

        <span class="cov0" title="0">cfg.Basic.ProductRulePath = bfe_util.ConfPathProc(cfg.Basic.ProductRulePath, confRoot)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file137" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_prison

import (
        "fmt"
        "regexp"
)

import (
        "github.com/bfenetworks/bfe/bfe_basic/action"
        "github.com/bfenetworks/bfe/bfe_basic/condition"
        "github.com/bfenetworks/bfe/bfe_util"
)

type AccessSignConf struct {
        UseSocketIP  bool     // if true, add socketip to input of signature
        UseClientIP  bool     // if true, add clientip to input of signature
        UseConnectID bool     // if true, add connect id to input of signature
        UseUrl       bool     // if true, add url to input of signature
        UseHost      bool     // if true, add host to input of signature
        UsePath      bool     // if true, add path to input of signature
        UseHeaders   bool     // if true, use all request headers
        UrlRegexp    string   // url regmatch str
        Query        []string // query key list
        Header       []string // header key list
        Cookie       []string // cookie key list
}

type PrisonRuleConf struct {
        Cond           *string         // condition for prison rule
        Action         *action.Action  // action for prison rule
        AccessSignConf *AccessSignConf // sign conf for prison rule
        Name           *string         // rule name
        CheckPeriod    *int64          // check period in seconds
        StayPeriod     *int64          // stayPeriod in seconds
        Threshold      *int32          // threshold
        AccessDictSize *int            // size of access dict
        PrisonDictSize *int            // size of prison dict
}

type PrisonRuleConfList []*PrisonRuleConf

type ProductRuleConf struct {
        Version *string                         // version of the config
        Config  *map[string]*PrisonRuleConfList // product name =&gt; list of prison rules
}

// PrisonRuleCheck check prisonRule
func PrisonRuleCheck(conf *PrisonRuleConf) error <span class="cov8" title="1">{
        // check nil filed
        if err := bfe_util.CheckNilField(*conf, false); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // check action
        <span class="cov8" title="1">if _, ok := allowActions[conf.Action.Cmd]; !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("mod_prison action: [%s] not allowed", conf.Action.Cmd)
        }</span>

        // check condition
        <span class="cov8" title="1">if _, err := condition.Build(*conf.Cond); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cond.Build(): [%s][%s]", *conf.Cond, err.Error())
        }</span>

        // check AccessSignConf
        <span class="cov8" title="1">if len(conf.AccessSignConf.UrlRegexp) != 0 </span><span class="cov0" title="0">{
                urlRegexp, err := regexp.Compile(conf.AccessSignConf.UrlRegexp)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("regexp.Compile: %s:%s", conf.AccessSignConf.UrlRegexp, err.Error())
                }</span>

                // check subExprNum
                <span class="cov0" title="0">subExpNum := urlRegexp.NumSubexp()
                if subExpNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("regExpr[%s] without subexpression", conf.AccessSignConf.UrlRegexp)
                }</span>
        }

        // check CheckPeriod
        <span class="cov8" title="1">if *conf.CheckPeriod &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("checkPeriod should &gt; 0")
        }</span>

        // check Threshold
        <span class="cov8" title="1">if *conf.Threshold &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("threshold should &gt;= 0")
        }</span>

        // if num of requests is over conf.Threshold in check period,
        // the time duration of stay period should be :
        //    conf.StayPeriod + conf.CheckPeriod - SecondsElapsedInCheckPeriod
        <span class="cov8" title="1">if *conf.StayPeriod &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("stayPeriod should &gt;= 0")
        }</span>

        <span class="cov8" title="1">if *conf.AccessDictSize &lt;= 0 || *conf.PrisonDictSize &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("accessDictSize/prisonDictSize should &gt; 0")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// PrisonRuleListCheck check prisonRuleList
func PrisonRuleListCheck(conf *PrisonRuleConfList) error <span class="cov8" title="1">{
        // create a rule map
        ruleMap := make(map[string]bool)
        for index, rule := range *conf </span><span class="cov8" title="1">{
                if err := PrisonRuleCheck(rule); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("prisonRule:%d, %s", index, err.Error())
                }</span>
                <span class="cov8" title="1">if _, ok := ruleMap[*rule.Name]; ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("duplicated rule name[%s]", *rule.Name)
                }</span>
                <span class="cov8" title="1">ruleMap[*rule.Name] = true</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// ProductRulesCheck check ProductRules
func ProductRulesCheck(conf map[string]*PrisonRuleConfList) error <span class="cov8" title="1">{
        for product, ruleList := range conf </span><span class="cov8" title="1">{
                if ruleList == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("no prisonRuleList for product:%s", product)
                }</span>
                <span class="cov8" title="1">if err := PrisonRuleListCheck(ruleList); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("ProductRules:%s, %s", product, err.Error())
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func productRuleConfCheck(conf *ProductRuleConf) error <span class="cov8" title="1">{
        // check nil filed
        if err := bfe_util.CheckNilField(*conf, false); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // check productRules
        <span class="cov8" title="1">if err := ProductRulesCheck(*(conf.Config)); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("check config: %s", err.Error())
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func productRuleConfLoad(fileName string) (ProductRuleConf, error) <span class="cov8" title="1">{
        var config ProductRuleConf

        // load json file
        if err := bfe_util.LoadJsonFile(fileName, &amp;config); err != nil </span><span class="cov0" title="0">{
                return config, fmt.Errorf("LoadJsonFile() err: %s", err.Error())
        }</span>

        // check config
        <span class="cov8" title="1">if err := productRuleConfCheck(&amp;config); err != nil </span><span class="cov0" title="0">{
                return config, err
        }</span>

        <span class="cov8" title="1">return config, nil</span>
}
</pre>
		
		<pre class="file" id="file138" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_prison

import (
        "errors"
        "fmt"
        "net/url"
        "path/filepath"
        "time"
)

import (
        "github.com/baidu/go-lib/log"
        "github.com/baidu/go-lib/web-monitor/metrics"
        "github.com/baidu/go-lib/web-monitor/web_monitor"
)

import (
        "github.com/bfenetworks/bfe/bfe_basic"
        "github.com/bfenetworks/bfe/bfe_basic/action"
        "github.com/bfenetworks/bfe/bfe_http"
        "github.com/bfenetworks/bfe/bfe_module"
)

var (
        openDebug = false
)

const (
        ModPrison        = "mod_prison"
        ReqCtxPrisonInfo = "mod_prison.prison_info"
)

var (
        ErrPrison = errors.New("PRISON") // deny by mod_prison
)

type ModulePrisonState struct {
        AllChecked *metrics.Counter // count of checked requests
        AllPrison  *metrics.Counter // count of blocked requests
}

type PrisonInfo struct {
        PrisonType string    // type of prison, mod_prison
        PrisonName string    // name of prison rule
        FreeTime   time.Time // free time
        IsExpired  bool      // is expired
        Action     string    // action
}

type ModulePrison struct {
        name            string            // name of module
        state           ModulePrisonState // module state
        metrics         metrics.Metrics
        productConfPath string            // path for prodct rule
        productTable    *productRuleTable // product rule table
}

func NewModulePrison() *ModulePrison <span class="cov0" title="0">{
        m := new(ModulePrison)
        m.name = ModPrison
        m.metrics.Init(&amp;m.state, ModPrison, 0)
        m.productTable = newProductRuleTable()
        return m
}</span>

func (m *ModulePrison) Name() string <span class="cov0" title="0">{
        return m.name
}</span>

func (m *ModulePrison) prisonHandler(req *bfe_basic.Request) (
        int, *bfe_http.Response) <span class="cov0" title="0">{
        // process global prison rules
        product := bfe_basic.GlobalProduct
        ret, res := m.processProductRules(req, product)
        if ret != bfe_module.BfeHandlerGoOn </span><span class="cov0" title="0">{
                return ret, res
        }</span>

        // process product prison rules
        <span class="cov0" title="0">product = req.Route.Product
        ret, res = m.processProductRules(req, product)
        return ret, res</span>
}

func (m *ModulePrison) processProductRules(req *bfe_basic.Request, product string) (int, *bfe_http.Response) <span class="cov0" title="0">{
        rules, ok := m.productTable.getRules(product)
        if !ok </span><span class="cov0" title="0">{
                if openDebug </span><span class="cov0" title="0">{
                        log.Logger.Debug("product[%s] without prison rules, pass", product)
                }</span>
                <span class="cov0" title="0">return bfe_module.BfeHandlerGoOn, nil</span>
        }

        <span class="cov0" title="0">return m.processRules(req, rules)</span>
}

func (m *ModulePrison) processRules(req *bfe_basic.Request, rules *prisonRules) (int, *bfe_http.Response) <span class="cov0" title="0">{
        for _, rule := range rules.ruleList </span><span class="cov0" title="0">{
                if !rule.cond.Match(req) </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">m.state.AllChecked.Inc(1)
                if !rule.recordAndCheck(req) </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">m.state.AllPrison.Inc(1)
                switch rule.action.Cmd </span>{
                case action.ActionClose:<span class="cov0" title="0">
                        req.ErrCode = ErrPrison
                        return bfe_module.BfeHandlerClose, nil</span>
                case action.ActionFinish:<span class="cov0" title="0">
                        req.ErrCode = ErrPrison
                        return bfe_module.BfeHandlerFinish, nil</span>
                default:<span class="cov0" title="0">
                        rule.action.Do(req)</span>
                }
        }

        <span class="cov0" title="0">return bfe_module.BfeHandlerGoOn, nil</span>
}

func (m *ModulePrison) getState(params map[string][]string) ([]byte, error) <span class="cov0" title="0">{
        s := m.metrics.GetAll()
        return s.Format(params)
}</span>

func (m *ModulePrison) getStateDiff(params map[string][]string) ([]byte, error) <span class="cov0" title="0">{
        s := m.metrics.GetDiff()
        return s.Format(params)
}</span>

func (m *ModulePrison) loadProductRuleTable(query url.Values) (string, error) <span class="cov0" title="0">{
        // get reload file path
        path := query.Get("path")
        if path == "" </span><span class="cov0" title="0">{
                path = m.productConfPath // use default
        }</span>

        // load and update rules
        <span class="cov0" title="0">productConf, err := productRuleConfLoad(path)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("%s: load product rule err %s", m.name, err.Error())
        }</span>
        <span class="cov0" title="0">if err = m.productTable.load(productConf); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("%s: load prison err %s", m.name, err.Error())
        }</span>

        <span class="cov0" title="0">version := *productConf.Version
        _, fileName := filepath.Split(path)
        return fmt.Sprintf("%s=%s", fileName, version), nil</span>
}

func (m *ModulePrison) monitorHandlers() map[string]interface{} <span class="cov0" title="0">{
        handlers := map[string]interface{}{
                m.name:           m.getState,
                m.name + ".diff": m.getStateDiff,
        }
        return handlers
}</span>

func (m *ModulePrison) Init(cbs *bfe_module.BfeCallbacks, whs *web_monitor.WebHandlers,
        cr string) error <span class="cov0" title="0">{
        // load module config
        confPath := bfe_module.ModConfPath(cr, m.name)
        conf, err := ConfLoad(confPath, cr)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init():load conf err %s", m.name, err.Error())
        }</span>
        <span class="cov0" title="0">m.productConfPath = conf.Basic.ProductRulePath
        openDebug = conf.Log.OpenDebug

        // load product rule table
        if _, err := m.loadProductRuleTable(nil); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init():loadProductRuleTable(): %s", m.name, err.Error())
        }</span>

        // register handler for prison
        <span class="cov0" title="0">err = cbs.AddFilter(bfe_module.HandleFoundProduct, m.prisonHandler)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init():AddFilter(m.prisonHandler): %s", m.name, err.Error())
        }</span>

        // register web handler for monitor
        <span class="cov0" title="0">err = web_monitor.RegisterHandlers(whs, web_monitor.WebHandleMonitor, m.monitorHandlers())
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init():RegisterHandlers(m.monitorHandlers): %s", m.name, err.Error())
        }</span>

        // register web handler for reload
        <span class="cov0" title="0">err = whs.RegisterHandler(web_monitor.WebHandleReload, m.name, m.loadProductRuleTable)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init():RegisterHandlers(m.reloadHandlers): %s", m.name, err.Error())
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file139" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_prison

import (
        "sync"
)

type productRuleTable struct {
        ruleTable map[string]*prisonRules // productName =&gt; prison rules
        lock      sync.RWMutex
}

func newProductRuleTable() *productRuleTable <span class="cov0" title="0">{
        return &amp;productRuleTable{
                ruleTable: make(map[string]*prisonRules),
        }
}</span>

func (p *productRuleTable) getRules(product string) (*prisonRules, bool) <span class="cov0" title="0">{
        p.lock.RLock()
        rules, ok := p.ruleTable[product]
        p.lock.RUnlock()

        return rules, ok
}</span>

func (p *productRuleTable) setTable(ruleTable map[string]*prisonRules) <span class="cov0" title="0">{
        p.lock.Lock()
        p.ruleTable = ruleTable
        p.lock.Unlock()
}</span>

func (p *productRuleTable) getTable() map[string]*prisonRules <span class="cov0" title="0">{
        p.lock.RLock()
        ruleTable := p.ruleTable
        p.lock.RUnlock()

        return ruleTable
}</span>

func (p *productRuleTable) newRuleTable(config ProductRuleConf) (map[string]*prisonRules, error) <span class="cov0" title="0">{
        oldRuleTable := p.getTable()

        ruleTable := make(map[string]*prisonRules)
        for product, ruleConfList := range *config.Config </span><span class="cov0" title="0">{
                // create new Prison Rule
                rules, err := newPrisonRules(*ruleConfList)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // init accessDict and prisonDict
                <span class="cov0" title="0">oldRules, ok := oldRuleTable[product]
                if !ok </span><span class="cov0" title="0">{
                        rules.initDict(nil)
                }</span> else<span class="cov0" title="0"> {
                        rules.initDict(oldRules)
                }</span>

                <span class="cov0" title="0">ruleTable[product] = rules</span>
        }

        <span class="cov0" title="0">return ruleTable, nil</span>
}

func (p *productRuleTable) load(config ProductRuleConf) error <span class="cov0" title="0">{
        ruleTable, err := p.newRuleTable(config)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">p.setTable(ruleTable)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file140" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_prison

import (
        "fmt"
        "regexp"
        "time"
)

import (
        "github.com/baidu/go-lib/log"
        "github.com/baidu/go-lib/lru_cache"
)

import (
        "github.com/bfenetworks/bfe/bfe_basic"
        "github.com/bfenetworks/bfe/bfe_basic/action"
        "github.com/bfenetworks/bfe/bfe_basic/condition"
)

type prisonRule struct {
        name           string              // rule name
        cond           condition.Condition // condition parsed
        condStr        string              // condition string
        action         action.Action       // action
        accessSigner   AccessSigner        // access signer
        checkPeriodNs  int64               // check period in nanoSeconds
        stayPeriodNs   int64               // stay period in nanoSeconds
        threshold      int32               // threshold period
        accessDict     *lru_cache.LRUCache // dict store access info
        prisonDict     *lru_cache.LRUCache // dict store prison info
        accessDictSize int                 // access dict size
        prisonDictSize int                 // prison dict size
}

func newPrisonRule(ruleConf PrisonRuleConf) (*prisonRule, error) <span class="cov8" title="1">{
        // build condition
        cond, err := condition.Build(*ruleConf.Cond)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("build condition err: condStr[%s], err[%s]", *ruleConf.Cond, err)
        }</span>

        <span class="cov8" title="1">regExp, _ := regexp.Compile(ruleConf.AccessSignConf.UrlRegexp)

        // create new rule
        rule := new(prisonRule)
        rule.cond = cond
        rule.condStr = *ruleConf.Cond
        rule.action = *ruleConf.Action
        rule.name = *ruleConf.Name
        rule.accessSigner = AccessSigner{
                AccessSignConf: *ruleConf.AccessSignConf,
                UrlReg:         regExp,
        }
        rule.checkPeriodNs = *ruleConf.CheckPeriod * 1e9
        rule.stayPeriodNs = *ruleConf.StayPeriod * 1e9
        rule.threshold = *ruleConf.Threshold
        rule.accessDictSize = *ruleConf.AccessDictSize
        rule.prisonDictSize = *ruleConf.PrisonDictSize

        return rule, nil</span>
}

func (r *prisonRule) initDict(oldRule *prisonRule) <span class="cov8" title="1">{
        if oldRule == nil </span><span class="cov8" title="1">{
                // if oldRule is nil, create new dict
                r.accessDict = lru_cache.NewLRUCache(r.accessDictSize)
                r.prisonDict = lru_cache.NewLRUCache(r.prisonDictSize)
        }</span> else<span class="cov8" title="1"> {
                // use old dict instead
                r.accessDict = oldRule.accessDict
                r.prisonDict = oldRule.prisonDict

                // resize dict
                r.accessDict.EnlargeCapacity(r.accessDictSize)
                r.prisonDict.EnlargeCapacity(r.prisonDictSize)
        }</span>
}

func (r *prisonRule) recordAndCheck(req *bfe_basic.Request) bool <span class="cov0" title="0">{
        if openDebug </span><span class="cov0" title="0">{
                log.Logger.Debug("begin process rule %s", r.name)
        }</span>

        // get sign
        <span class="cov0" title="0">sign, err := r.accessSigner.Sign(r.condStr, req)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // check whether the access should be denied directyly
        <span class="cov0" title="0">if deny := r.shouldDeny(sign, req); deny </span><span class="cov0" title="0">{
                return deny
        }</span>

        // record and check
        <span class="cov0" title="0">r.recordAccess(sign)
        return r.shouldDeny(sign, req)</span>
}

func (r *prisonRule) recordAccess(sign AccessSign) <span class="cov8" title="1">{
        var f *AccessCounter

        // check access dict
        value, ok := r.accessDict.Get(sign)
        if !ok </span><span class="cov8" title="1">{
                f = NewAccessCounter()
                r.accessDict.Add(sign, f)
        }</span> else<span class="cov8" title="1"> {
                f = value.(*AccessCounter)
        }</span>

        // check threshod
        <span class="cov8" title="1">if block, restTimeNs := f.IncAndCheck(r.checkPeriodNs, r.threshold); block </span><span class="cov8" title="1">{
                // should block the access, update prisonDict and accessDict
                freeTimeNs := r.stayPeriodNs + restTimeNs + time.Now().UnixNano()
                r.prisonDict.Add(sign, freeTimeNs)
                r.accessDict.Del(sign)
        }</span>
}

func (r *prisonRule) shouldDeny(sign AccessSign, req *bfe_basic.Request) bool <span class="cov8" title="1">{
        // find prison record for this sign
        freeTimeNs, ok := r.prisonDict.Get(sign)
        if !ok </span><span class="cov8" title="1">{
                return false
        }</span>

        // check prison time
        <span class="cov8" title="1">if time.Now().UnixNano() &lt; freeTimeNs.(int64) </span><span class="cov8" title="1">{
                prisonInfo := &amp;PrisonInfo{
                        PrisonType: ModPrison,
                        PrisonName: r.name,
                        FreeTime:   time.Unix(0, freeTimeNs.(int64)),
                        IsExpired:  false,
                        Action:     r.action.Cmd,
                }
                req.SetContext(ReqCtxPrisonInfo, prisonInfo)
                return true
        }</span>

        // remove prison record if expired
        <span class="cov8" title="1">r.prisonDict.Del(sign)

        // set prisoninfo
        prisonInfo := &amp;PrisonInfo{
                PrisonType: ModPrison,
                PrisonName: r.name,
                FreeTime:   time.Unix(0, freeTimeNs.(int64)),
                IsExpired:  true,
                Action:     r.action.Cmd,
        }
        req.SetContext(ReqCtxPrisonInfo, prisonInfo)

        return false</span>
}
</pre>
		
		<pre class="file" id="file141" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_prison

type prisonRules struct {
        ruleList []prisonRule           // prison rule list for one product
        ruleMap  map[string]*prisonRule // name =&gt; prison rule
}

func newPrisonRules(ruleConfList PrisonRuleConfList) (*prisonRules, error) <span class="cov0" title="0">{
        // make new rule list
        ruleList, err := newPrisonRuleList(ruleConfList)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // build rule map
        <span class="cov0" title="0">ruleMap := buildPrisonRuleMap(ruleList)

        return &amp;prisonRules{
                ruleList: ruleList,
                ruleMap:  ruleMap,
        }, nil</span>
}

func newPrisonRuleList(ruleConfList PrisonRuleConfList) ([]prisonRule, error) <span class="cov0" title="0">{
        var ruleList []prisonRule
        for _, ruleConf := range ruleConfList </span><span class="cov0" title="0">{
                rule, err := newPrisonRule(*ruleConf)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">ruleList = append(ruleList, *rule)</span>
        }

        <span class="cov0" title="0">return ruleList, nil</span>
}

func buildPrisonRuleMap(ruleList []prisonRule) map[string]*prisonRule <span class="cov0" title="0">{
        ruleMap := make(map[string]*prisonRule, len(ruleList))
        for i := range ruleList </span><span class="cov0" title="0">{
                name := ruleList[i].name
                ruleMap[name] = &amp;ruleList[i]
        }</span>

        <span class="cov0" title="0">return ruleMap</span>
}

func (r *prisonRules) initDict(oldRules *prisonRules) <span class="cov0" title="0">{
        oldRuleMap := make(map[string]*prisonRule)
        if oldRules != nil </span><span class="cov0" title="0">{
                oldRuleMap = oldRules.ruleMap
        }</span>

        // compare rules
        <span class="cov0" title="0">ruleAdd, ruleMod, _ := compareRules(r.ruleMap, oldRuleMap)

        // add new rule
        for _, name := range ruleAdd </span><span class="cov0" title="0">{
                rule := r.ruleMap[name]
                rule.initDict(nil)
        }</span>

        // use old dict
        <span class="cov0" title="0">for _, name := range ruleMod </span><span class="cov0" title="0">{
                rule := r.ruleMap[name]
                rule.initDict(oldRuleMap[name])
        }</span>
}

func compareRules(newRuleMap, oldRuleMap map[string]*prisonRule) ([]string, []string, []string) <span class="cov0" title="0">{
        var ruleAdd, ruleMod, ruleDel []string

        for name := range newRuleMap </span><span class="cov0" title="0">{
                if _, ok := oldRuleMap[name]; !ok </span><span class="cov0" title="0">{
                        ruleAdd = append(ruleAdd, name)
                }</span> else<span class="cov0" title="0"> {
                        ruleMod = append(ruleMod, name)
                }</span>
        }

        <span class="cov0" title="0">for name := range oldRuleMap </span><span class="cov0" title="0">{
                if _, ok := newRuleMap[name]; !ok </span><span class="cov0" title="0">{
                        ruleDel = append(ruleDel, name)
                }</span>
        }

        <span class="cov0" title="0">return ruleAdd, ruleMod, ruleDel</span>
}
</pre>
		
		<pre class="file" id="file142" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_redirect

import (
        "errors"
        "fmt"
        "strings"
)

import (
        "github.com/bfenetworks/bfe/bfe_basic"
)

type ActionFile struct {
        Cmd    *string  // command of action
        Params []string // params of action
}

type Action struct {
        Cmd    string   // command of action
        Params []string // params of action
}

type ActionFileList []ActionFile

var EXCLUSIVE_ACTIONS = map[string]interface{}{
        "SCHEME_SET":     nil,
        "URL_SET":        nil,
        "URL_FROM_QUERY": nil,
        "URL_PREFIX_ADD": nil,
}

func ActionFileCheck(conf ActionFile) error <span class="cov8" title="1">{
        var paramsLenCheck int

        // check command
        if conf.Cmd == nil </span><span class="cov0" title="0">{
                return errors.New("no Cmd")
        }</span>

        // validate command, and get how many params should exist for each command
        <span class="cov8" title="1">switch *conf.Cmd </span>{
        // commands for url
        case "URL_SET", "URL_FROM_QUERY", "URL_PREFIX_ADD", "SCHEME_SET":<span class="cov8" title="1">
                paramsLenCheck = 1</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("invalid cmd:%s", *conf.Cmd)</span>
        }

        // check params
        <span class="cov8" title="1">if conf.Params == nil </span><span class="cov0" title="0">{
                return errors.New("no Params")
        }</span>

        <span class="cov8" title="1">if paramsLenCheck != -1 </span><span class="cov8" title="1">{
                paramsLen := len(conf.Params)
                if paramsLenCheck != paramsLen </span><span class="cov0" title="0">{
                        return fmt.Errorf("num of params:[ok:%d, now:%d]", paramsLenCheck, paramsLen)
                }</span>
        }

        // currently only http|https scheme supported.
        <span class="cov8" title="1">if *conf.Cmd == "SCHEME_SET" </span><span class="cov0" title="0">{
                scheme := strings.ToLower(conf.Params[0])
                if scheme != "http" &amp;&amp; scheme != "https" </span><span class="cov0" title="0">{
                        return fmt.Errorf("scheme %s invalid, only http|https supported now", conf.Params[0])
                }</span>
                <span class="cov0" title="0">conf.Params[0] = scheme</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func ActionFileListCheck(conf *ActionFileList) error <span class="cov8" title="1">{
        if len(*conf) &gt; 1 </span><span class="cov0" title="0">{
                return fmt.Errorf("ActionFileList: currently only support exclusive action!")
        }</span>

        <span class="cov8" title="1">for index, action := range *conf </span><span class="cov8" title="1">{
                err := ActionFileCheck(action)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("ActionFileList:%d, %s", index, err.Error())
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func actionConvert(actionFile ActionFile) Action <span class="cov8" title="1">{
        action := Action{}
        action.Cmd = *actionFile.Cmd
        action.Params = actionFile.Params
        return action
}</span>

func actionsConvert(actionFiles ActionFileList) []Action <span class="cov8" title="1">{
        actions := make([]Action, 0, len(actionFiles))

        for _, actionFile := range actionFiles </span><span class="cov8" title="1">{
                action := actionConvert(actionFile)
                actions = append(actions, action)
        }</span>

        <span class="cov8" title="1">return actions</span>
}

// do exclusive action to request
func redirectExclusiveActionDo(req *bfe_basic.Request, action Action) <span class="cov8" title="1">{
        switch action.Cmd </span>{
        case "SCHEME_SET":<span class="cov0" title="0">
                ReqSchemeSet(req, action.Params[0])</span>
        // for url
        case "URL_SET":<span class="cov8" title="1">
                ReqUrlSet(req, action.Params[0])</span>
        case "URL_FROM_QUERY":<span class="cov0" title="0">
                ReqUrlFromQuery(req, action.Params[0])</span>
        case "URL_PREFIX_ADD":<span class="cov0" title="0">
                ReqUrlPrefixAdd(req, action.Params[0])</span>
        }
}

// check if exclusive action
func checkExclusiveAction(actions []Action) bool <span class="cov8" title="1">{
        if len(actions) != 1 </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">action := actions[0]
        _, ok := EXCLUSIVE_ACTIONS[action.Cmd]
        return ok</span>
}

// do actions to request
func redirectActionsDo(req *bfe_basic.Request, actions []Action) <span class="cov8" title="1">{
        // for exclusive action
        if checkExclusiveAction(actions) </span><span class="cov8" title="1">{
                redirectExclusiveActionDo(req, actions[0])
                return
        }</span>
}
</pre>
		
		<pre class="file" id="file143" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_redirect

import (
        "github.com/bfenetworks/bfe/bfe_basic"
)

// ReqUrlSet sets redirect url
func ReqUrlSet(req *bfe_basic.Request, url string) <span class="cov8" title="1">{
        req.Redirect.Url = url
}</span>

// ReqUrlFromQuery sets redirect url to value of given field in query
// e.g., url "http://service?url=(.*)" =&gt; "$1",
func ReqUrlFromQuery(req *bfe_basic.Request, key string) <span class="cov8" title="1">{
        if req.Query == nil </span><span class="cov8" title="1">{
                req.Query = req.HttpRequest.URL.Query()
        }</span>

        <span class="cov8" title="1">req.Redirect.Url = req.Query.Get(key)</span>
}

// ReqUrlPrefixAdd specify redirect url by adding prefix to original uri(path+query)
// e.g., url  "/(.*)" =&gt; "link$1",
func ReqUrlPrefixAdd(req *bfe_basic.Request, prefix string) <span class="cov8" title="1">{
        rawUrl := req.HttpRequest.URL
        uri := rawUrl.RequestURI()
        req.Redirect.Url = prefix + uri
}</span>

// ReqSchemeSet specify redirect url to absolute one with scheme user defined
// e.g., url  scheme://host/path, usually scheme is https
func ReqSchemeSet(req *bfe_basic.Request, scheme string) <span class="cov8" title="1">{
        rawUrl := req.HttpRequest.URL
        uri := rawUrl.RequestURI()

        host := rawUrl.Host
        if host == "" </span><span class="cov0" title="0">{
                host = req.HttpRequest.Host
        }</span>

        <span class="cov8" title="1">req.Redirect.Url = scheme + "://" + host + uri</span>
}
</pre>
		
		<pre class="file" id="file144" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_redirect

import (
        "github.com/baidu/go-lib/log"
        gcfg "gopkg.in/gcfg.v1"
)

import (
        "github.com/bfenetworks/bfe/bfe_util"
)

type ConfModRedirect struct {
        Basic struct {
                DataPath string // path of config data (redirect)
        }

        Log struct {
                OpenDebug bool
        }
}

// ConfLoad loads config from config file
func ConfLoad(filePath string, confRoot string) (*ConfModRedirect, error) <span class="cov8" title="1">{
        var cfg ConfModRedirect
        var err error

        // read config from file
        err = gcfg.ReadFileInto(&amp;cfg, filePath)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;cfg, err
        }</span>

        // check conf of mod_redirect
        <span class="cov8" title="1">err = cfg.Check(confRoot)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;cfg, err
        }</span>

        <span class="cov8" title="1">return &amp;cfg, nil</span>
}

func (cfg *ConfModRedirect) Check(confRoot string) error <span class="cov8" title="1">{
        return ConfModRedirectCheck(cfg, confRoot)
}</span>

func ConfModRedirectCheck(cfg *ConfModRedirect, confRoot string) error <span class="cov8" title="1">{
        if cfg.Basic.DataPath == "" </span><span class="cov8" title="1">{
                log.Logger.Warn("ModRedirect.DataPath not set, use default value")
                cfg.Basic.DataPath = "mod_redirect/redirect.data"
        }</span>

        <span class="cov8" title="1">cfg.Basic.DataPath = bfe_util.ConfPathProc(cfg.Basic.DataPath, confRoot)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file145" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_redirect

import (
        "fmt"
        "net/url"
        "path/filepath"
)

import (
        "github.com/baidu/go-lib/log"
        "github.com/baidu/go-lib/web-monitor/web_monitor"
)

import (
        "github.com/bfenetworks/bfe/bfe_basic"
        "github.com/bfenetworks/bfe/bfe_http"
        "github.com/bfenetworks/bfe/bfe_module"
)

var (
        openDebug = false
)

type ModuleRedirect struct {
        name       string         // name of module
        configPath string         // path of config file
        ruleTable  *RedirectTable // table of redirect rules
}

func NewModuleRedirect() *ModuleRedirect <span class="cov8" title="1">{
        m := new(ModuleRedirect)
        m.name = "mod_redirect"
        m.ruleTable = NewRedirectTable()
        return m
}</span>

func (m *ModuleRedirect) Name() string <span class="cov0" title="0">{
        return m.name
}</span>

func (m *ModuleRedirect) loadConfData(query url.Values) (string, error) <span class="cov8" title="1">{
        // get file path
        path := query.Get("path")
        if path == "" </span><span class="cov8" title="1">{
                // use default
                path = m.configPath
        }</span>

        // load from config file
        <span class="cov8" title="1">conf, err := redirectConfLoad(path)

        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("err in redirectConfLoad(%s):%s", path, err.Error())
        }</span>

        // update to rule table
        <span class="cov8" title="1">m.ruleTable.Update(conf)

        _, fileName := filepath.Split(path)
        return fmt.Sprintf("%s=%s", fileName, conf.Version), nil</span>
}

func redirectCodeSet(req *bfe_basic.Request, code int) <span class="cov8" title="1">{
        req.Redirect.Code = code
}</span>

// PrepareReqRedirect do redirect to http request, with given redirect rules.
func PrepareReqRedirect(req *bfe_basic.Request, rules *RuleList) bool <span class="cov8" title="1">{
        for _, rule := range *rules </span><span class="cov8" title="1">{
                // rule condition is satisfied ?
                if rule.Cond.Match(req) </span><span class="cov8" title="1">{
                        // do actions of the rule
                        redirectActionsDo(req, rule.Actions)
                        redirectCodeSet(req, rule.Status)

                        // finish redirect rules process
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// redirectHandler is a handler for doing redirect.
func (m *ModuleRedirect) redirectHandler(request *bfe_basic.Request) (int, *bfe_http.Response) <span class="cov8" title="1">{
        // find redirect rules for given request
        rules, ok := m.ruleTable.Search(request.Route.Product)

        if ok </span><span class="cov8" title="1">{
                if openDebug </span><span class="cov0" title="0">{
                        log.Logger.Debug("%s:before:host=%s, path=%s, query=%s, rules=%v",
                                m.name,
                                request.HttpRequest.Host, request.HttpRequest.URL.Path,
                                request.HttpRequest.URL.RawQuery, rules)
                }</span>

                // redirect rules process
                <span class="cov8" title="1">needRedirect := PrepareReqRedirect(request, rules)

                if openDebug </span><span class="cov0" title="0">{
                        if needRedirect </span><span class="cov0" title="0">{
                                log.Logger.Debug("%s:after:redirectUrl=%s, redirectCode=%d",
                                        m.name, request.Redirect.Url, request.Redirect.Code)
                        }</span> else<span class="cov0" title="0"> {
                                log.Logger.Debug("%s:after:not need redirect", m.name)
                        }</span>
                }

                <span class="cov8" title="1">if needRedirect </span><span class="cov8" title="1">{
                        return bfe_module.BfeHandlerRedirect, nil
                }</span>
        }
        <span class="cov8" title="1">return bfe_module.BfeHandlerGoOn, nil</span>
}

func (m *ModuleRedirect) Init(cbs *bfe_module.BfeCallbacks, whs *web_monitor.WebHandlers,
        cr string) error <span class="cov8" title="1">{
        var err error
        var conf *ConfModRedirect

        confPath := bfe_module.ModConfPath(cr, m.name)
        if conf, err = ConfLoad(confPath, cr); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: cond load err %s", m.name, err.Error())
        }</span>

        <span class="cov8" title="1">return m.init(conf, cbs, whs)</span>
}

func (m *ModuleRedirect) init(cfg *ConfModRedirect, cbs *bfe_module.BfeCallbacks,
        whs *web_monitor.WebHandlers) error <span class="cov8" title="1">{
        openDebug = cfg.Log.OpenDebug

        m.configPath = cfg.Basic.DataPath

        // load from config file to rule table
        if _, err := m.loadConfData(nil); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("err in loadConfData(): %s", err.Error())
        }</span>

        // register handler
        <span class="cov8" title="1">err := cbs.AddFilter(bfe_module.HandleFoundProduct, m.redirectHandler)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init(): AddFilter(m.redirectHandler): %s", m.name, err.Error())
        }</span>

        // register web handler for reload
        <span class="cov8" title="1">err = whs.RegisterHandler(web_monitor.WebHandleReload, m.name, m.loadConfData)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init(): RegisterHandler(m.loadConfData): %s", m.name, err.Error())
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file146" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_redirect

import (
        "errors"
        "fmt"
        "os"
)

import (
        "github.com/bfenetworks/bfe/bfe_basic/condition"
        "github.com/bfenetworks/bfe/bfe_util/json"
)

type RedirectRuleFile struct {
        Cond    *string         // condition for redirect
        Actions *ActionFileList // list of actions
        Status  *int            // redirect code
}

type RedirectRule struct {
        Cond    condition.Condition // condition for redirect
        Actions []Action            // list of actions
        Status  int                 // redirect code
}

type RuleFileList []RedirectRuleFile
type RuleList []RedirectRule

type ProductRulesFile map[string]*RuleFileList // product =&gt; list of redirect rules
type ProductRules map[string]*RuleList         // product =&gt; list of redirect rules

type RedirectConfFile struct {
        Version *string // version of the config
        Config  *ProductRulesFile
}

type redirectConf struct {
        Version string       // version of the config
        Config  ProductRules // product rules for redirect
}

func redirectRuleCheck(conf RedirectRuleFile) error <span class="cov8" title="1">{
        var err error

        // check Cond
        if conf.Cond == nil </span><span class="cov8" title="1">{
                return errors.New("no Cond")
        }</span>

        // check Actions
        <span class="cov8" title="1">if conf.Actions == nil || len(*conf.Actions) == 0 </span><span class="cov0" title="0">{
                return errors.New("no Actions")
        }</span>

        <span class="cov8" title="1">err = ActionFileListCheck(conf.Actions)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Actions:%s", err.Error())
        }</span>

        // check redirect code
        <span class="cov8" title="1">if conf.Status == nil || *conf.Status == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("Status: redirect code not provided")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func RuleListCheck(conf *RuleFileList) error <span class="cov8" title="1">{
        for index, rule := range *conf </span><span class="cov8" title="1">{
                err := redirectRuleCheck(rule)
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("redirectRule:%d, %s", index, err.Error())
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func ProductRulesCheck(conf *ProductRulesFile) error <span class="cov8" title="1">{
        for product, ruleList := range *conf </span><span class="cov8" title="1">{
                if ruleList == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("no RuleList for product:%s", product)
                }</span>

                <span class="cov8" title="1">err := RuleListCheck(ruleList)
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("ProductRules:%s, %s", product, err.Error())
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func RedirectConfCheck(conf RedirectConfFile) error <span class="cov8" title="1">{
        var err error

        // check Version
        if conf.Version == nil </span><span class="cov0" title="0">{
                return errors.New("no Version")
        }</span>

        // check Config
        <span class="cov8" title="1">if conf.Config == nil </span><span class="cov0" title="0">{
                return errors.New("no Config")
        }</span>

        <span class="cov8" title="1">err = ProductRulesCheck(conf.Config)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("Config:%s", err.Error())
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func ruleConvert(ruleFile RedirectRuleFile) (RedirectRule, error) <span class="cov8" title="1">{
        rule := RedirectRule{}

        cond, err := condition.Build(*ruleFile.Cond)
        if err != nil </span><span class="cov0" title="0">{
                return rule, err
        }</span>
        <span class="cov8" title="1">rule.Cond = cond

        rule.Actions = actionsConvert(*ruleFile.Actions)
        rule.Status = *ruleFile.Status
        return rule, nil</span>
}

func ruleListConvert(ruleFileList *RuleFileList) (*RuleList, error) <span class="cov8" title="1">{
        ruleList := new(RuleList)
        *ruleList = make([]RedirectRule, 0)

        for _, ruleFile := range *ruleFileList </span><span class="cov8" title="1">{
                rule, err := ruleConvert(ruleFile)
                if err != nil </span><span class="cov0" title="0">{
                        return ruleList, err
                }</span>
                <span class="cov8" title="1">*ruleList = append(*ruleList, rule)</span>
        }

        <span class="cov8" title="1">return ruleList, nil</span>
}

// redirectConfLoad loads config of redirect from file.
func redirectConfLoad(filename string) (redirectConf, error) <span class="cov8" title="1">{
        var conf redirectConf
        var err error

        /* open the file    */
        file, err1 := os.Open(filename)

        if err1 != nil </span><span class="cov0" title="0">{
                return conf, err1
        }</span>

        /* decode the file  */
        <span class="cov8" title="1">decoder := json.NewDecoder(file)

        var config RedirectConfFile
        err = decoder.Decode(&amp;config)
        file.Close()

        if err != nil </span><span class="cov0" title="0">{
                return conf, err
        }</span>

        // check config
        <span class="cov8" title="1">err = RedirectConfCheck(config)
        if err != nil </span><span class="cov8" title="1">{
                return conf, err
        }</span>

        /* convert config   */
        <span class="cov8" title="1">conf.Version = *config.Version
        conf.Config = make(ProductRules)

        for product, ruleFileList := range *config.Config </span><span class="cov8" title="1">{
                ruleList, err := ruleListConvert(ruleFileList)
                if err != nil </span><span class="cov0" title="0">{
                        return conf, err
                }</span>
                <span class="cov8" title="1">conf.Config[product] = ruleList</span>
        }

        <span class="cov8" title="1">return conf, nil</span>
}
</pre>
		
		<pre class="file" id="file147" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_redirect

import (
        "sync"
)

type RedirectTable struct {
        lock         sync.RWMutex
        version      string
        productRules ProductRules
}

func NewRedirectTable() *RedirectTable <span class="cov8" title="1">{
        t := new(RedirectTable)
        t.productRules = make(ProductRules)
        return t
}</span>

func (t *RedirectTable) Update(conf redirectConf) <span class="cov8" title="1">{
        t.lock.Lock()

        t.version = conf.Version
        t.productRules = conf.Config

        t.lock.Unlock()
}</span>

func (t *RedirectTable) Search(product string) (*RuleList, bool) <span class="cov8" title="1">{
        t.lock.RLock()
        productRules := t.productRules
        t.lock.RUnlock()

        rules, ok := productRules[product]
        return rules, ok
}</span>
</pre>
		
		<pre class="file" id="file148" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_rewrite

import (
        "github.com/bfenetworks/bfe/bfe_basic"
        "github.com/bfenetworks/bfe/bfe_basic/action"
)

var allowActions = map[string]interface{}{
        // host actions
        action.ActionHostSetFromPathPrefix: nil, // set host from path prefix
        action.ActionHostSet:               nil, //set host
        action.ActionHostSuffixReplace:     nil, // replace host suffix

        // path actions
        action.ActionPathSet:        nil, // set path
        action.ActionPathPrefixAdd:  nil, // add path prefix
        action.ActionPathPrefixTrim: nil, // trim path prefix

        // query actions
        action.ActionQueryAdd:          nil, // add query
        action.ActionQueryDel:          nil, // del query
        action.ActionQueryRename:       nil, // rename query
        action.ActionQueryDelAllExcept: nil, // del query except given query key
}

func reWriteActionsDo(req *bfe_basic.Request, actions []action.Action) <span class="cov0" title="0">{
        for _, action := range actions </span><span class="cov0" title="0">{
                action.Do(req)
        }</span>
}
</pre>
		
		<pre class="file" id="file149" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_rewrite

import (
        "github.com/baidu/go-lib/log"
        gcfg "gopkg.in/gcfg.v1"
)

import (
        "github.com/bfenetworks/bfe/bfe_util"
)

type ConfModReWrite struct {
        Basic struct {
                DataPath string // path of config data (rewrite)
        }

        Log struct {
                OpenDebug bool
        }
}

// ConfLoad loads config from config file
func ConfLoad(filePath string, confRoot string) (*ConfModReWrite, error) <span class="cov8" title="1">{
        var err error
        var cfg ConfModReWrite

        // read config from file
        err = gcfg.ReadFileInto(&amp;cfg, filePath)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;cfg, err
        }</span>

        // check conf of mod_rewrite
        <span class="cov8" title="1">err = cfg.Check(confRoot)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;cfg, err
        }</span>

        <span class="cov8" title="1">return &amp;cfg, nil</span>
}

func (cfg *ConfModReWrite) Check(confRoot string) error <span class="cov8" title="1">{
        return ConfModReWriteCheck(cfg, confRoot)
}</span>

func ConfModReWriteCheck(cfg *ConfModReWrite, confRoot string) error <span class="cov8" title="1">{
        if cfg.Basic.DataPath == "" </span><span class="cov8" title="1">{
                log.Logger.Warn("ModReWrite.DataPath not set, use default value")
                cfg.Basic.DataPath = "mod_rewrite/rewrite.data"
        }</span>

        <span class="cov8" title="1">cfg.Basic.DataPath = bfe_util.ConfPathProc(cfg.Basic.DataPath, confRoot)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file150" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// module for marking rewrite

package mod_rewrite

import (
        "fmt"
        "net/url"
)

import (
        "github.com/baidu/go-lib/log"
        "github.com/baidu/go-lib/web-monitor/web_monitor"
)

import (
        "github.com/bfenetworks/bfe/bfe_basic"
        "github.com/bfenetworks/bfe/bfe_http"
        "github.com/bfenetworks/bfe/bfe_module"
)

var (
        openDebug = false
)

type ModuleReWrite struct {
        name string // name of module

        configPath string        // path of config file
        ruleTable  *ReWriteTable // table of rewrite rules
}

func NewModuleReWrite() *ModuleReWrite <span class="cov0" title="0">{
        m := new(ModuleReWrite)
        m.name = "mod_rewrite"
        m.ruleTable = NewReWriteTable()

        return m
}</span>

func (m *ModuleReWrite) Name() string <span class="cov0" title="0">{
        return m.name
}</span>

func (m *ModuleReWrite) loadConfData(query url.Values) error <span class="cov0" title="0">{
        // get file path
        path := query.Get("path")
        if path == "" </span><span class="cov0" title="0">{
                // use default
                path = m.configPath
        }</span>

        // load from config file
        <span class="cov0" title="0">conf, err := ReWriteConfLoad(path)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("err in ReWriteConfLoad(%s):%s", path, err.Error())
        }</span>

        // update to rule table
        <span class="cov0" title="0">m.ruleTable.Update(conf)

        return nil</span>
}

// ReqReWrite do rewrite to http request, with given rewrite rules.
func ReqReWrite(req *bfe_basic.Request, rules *RuleList) <span class="cov0" title="0">{
        for _, rule := range *rules </span><span class="cov0" title="0">{
                // rule condition is satisfied ?
                if rule.Cond.Match(req) </span><span class="cov0" title="0">{
                        // do actions of the rule
                        reWriteActionsDo(req, rule.Actions)

                        // flag of last is true?
                        if rule.Last </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
        }
}

// rewriteHandler is a handler for doing rewrite.
func (m *ModuleReWrite) rewriteHandler(request *bfe_basic.Request) (int, *bfe_http.Response) <span class="cov0" title="0">{
        // find rewrite rules for given request
        rules, ok := m.ruleTable.Search(request.Route.Product)

        if ok </span><span class="cov0" title="0">{
                if openDebug </span><span class="cov0" title="0">{
                        log.Logger.Debug("%s:before:host=%s, path=%s, query=%s, rules=%v", m.name,
                                request.HttpRequest.Host, request.HttpRequest.URL.Path,
                                request.HttpRequest.URL.RawQuery, rules)
                }</span>

                // do rewrite to request, according to rules
                <span class="cov0" title="0">ReqReWrite(request, rules)

                if openDebug </span><span class="cov0" title="0">{
                        log.Logger.Debug("%s:after:host=%s, path=%s, query=%s", m.name,
                                request.HttpRequest.Host, request.HttpRequest.URL.Path,
                                request.HttpRequest.URL.RawQuery)
                }</span>
        }

        <span class="cov0" title="0">return bfe_module.BfeHandlerGoOn, nil</span>
}

func (m *ModuleReWrite) Init(cbs *bfe_module.BfeCallbacks, whs *web_monitor.WebHandlers,
        cr string) error <span class="cov0" title="0">{
        var err error
        var conf *ConfModReWrite

        confPath := bfe_module.ModConfPath(cr, m.name)
        if conf, err = ConfLoad(confPath, cr); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: conf load err %s", m.name, err.Error())
        }</span>

        <span class="cov0" title="0">return m.init(conf, cbs, whs)</span>
}

func (m *ModuleReWrite) init(cfg *ConfModReWrite, cbs *bfe_module.BfeCallbacks,
        whs *web_monitor.WebHandlers) error <span class="cov0" title="0">{
        openDebug = cfg.Log.OpenDebug

        m.configPath = cfg.Basic.DataPath

        // load from config file to rule table
        if err := m.loadConfData(nil); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("err in loadConfData(): %s", err.Error())
        }</span>

        // register handler
        <span class="cov0" title="0">err := cbs.AddFilter(bfe_module.HandleAfterLocation, m.rewriteHandler)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init(): AddFilter(m.rewriteHandler): %s", m.name, err.Error())
        }</span>

        // register web handler for reload
        <span class="cov0" title="0">err = whs.RegisterHandler(web_monitor.WebHandleReload, m.name, m.loadConfData)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init(): RegisterHandler(m.loadConfData): %s", m.name, err.Error())
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file151" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_rewrite

import (
        "errors"
        "fmt"
        "os"
)

import (
        "github.com/bfenetworks/bfe/bfe_basic/action"
        "github.com/bfenetworks/bfe/bfe_basic/condition"
        "github.com/bfenetworks/bfe/bfe_util/json"
)

type ReWriteRuleFile struct {
        Cond    *string         // condition for rewrite
        Actions []action.Action // list of actions
        Last    *bool           // if true, not to check the next rule in the list if
        // the condition is satisfied
}

type ReWriteRule struct {
        Cond    condition.Condition // condition for rewrite
        Actions []action.Action     // list of actions
        Last    bool                // if true, not to check the next rule in the list if
        // the condition is satisfied
}

type RuleFileList []ReWriteRuleFile
type RuleList []ReWriteRule

type ProductRulesFile map[string]*RuleFileList // product =&gt; list of rewrite rules
type ProductRules map[string]*RuleList         // product =&gt; list of rewrite rules

type ReWriteConfFile struct {
        Version *string // version of the config
        Config  *ProductRulesFile
}

type ReWriteConf struct {
        Version string       // version of the config
        Config  ProductRules // product rules for rewrite
}

func ReWriteRuleCheck(conf ReWriteRuleFile) error <span class="cov8" title="1">{
        // check Cond
        if conf.Cond == nil </span><span class="cov8" title="1">{
                return errors.New("no Cond")
        }</span>

        // check Actions
        <span class="cov8" title="1">if conf.Actions == nil </span><span class="cov0" title="0">{
                return errors.New("no Actions")
        }</span>

        // check Action
        <span class="cov8" title="1">for _, ac := range conf.Actions </span><span class="cov8" title="1">{
                if ac.Cmd == "" </span><span class="cov0" title="0">{
                        return errors.New("no Cmd")
                }</span>
                <span class="cov8" title="1">_, ok := allowActions[ac.Cmd]
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("not allowed Cmd: %s", ac.Cmd)
                }</span>
        }

        // check Last
        <span class="cov8" title="1">if conf.Last == nil </span><span class="cov0" title="0">{
                return errors.New("no Last")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func RuleListCheck(conf *RuleFileList) error <span class="cov8" title="1">{
        for index, rule := range *conf </span><span class="cov8" title="1">{
                err := ReWriteRuleCheck(rule)
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("ReWriteRule:%d, %s", index, err.Error())
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func ProductRulesCheck(conf *ProductRulesFile) error <span class="cov8" title="1">{
        for product, ruleList := range *conf </span><span class="cov8" title="1">{
                if ruleList == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("no RuleList for product:%s", product)
                }</span>

                <span class="cov8" title="1">err := RuleListCheck(ruleList)
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("ProductRules:%s, %s", product, err.Error())
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func ReWriteConfCheck(conf ReWriteConfFile) error <span class="cov8" title="1">{
        var err error

        // check Version
        if conf.Version == nil </span><span class="cov0" title="0">{
                return errors.New("no Version")
        }</span>

        // check Config
        <span class="cov8" title="1">if conf.Config == nil </span><span class="cov0" title="0">{
                return errors.New("no Config")
        }</span>

        <span class="cov8" title="1">err = ProductRulesCheck(conf.Config)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("Config:%s", err.Error())
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func ruleConvert(ruleFile ReWriteRuleFile) (ReWriteRule, error) <span class="cov8" title="1">{
        rule := ReWriteRule{}

        if ruleFile.Cond == nil </span><span class="cov0" title="0">{
                return rule, fmt.Errorf("cond not set")
        }</span>
        <span class="cov8" title="1">cond, err := condition.Build(*ruleFile.Cond)
        if err != nil </span><span class="cov0" title="0">{
                return rule, err
        }</span>
        <span class="cov8" title="1">rule.Cond = cond

        rule.Actions = ruleFile.Actions
        rule.Last = *ruleFile.Last
        return rule, nil</span>
}

func ruleListConvert(ruleFileList *RuleFileList) (*RuleList, error) <span class="cov8" title="1">{
        ruleList := new(RuleList)
        *ruleList = make([]ReWriteRule, 0)

        for _, ruleFile := range *ruleFileList </span><span class="cov8" title="1">{
                rule, err := ruleConvert(ruleFile)
                if err != nil </span><span class="cov0" title="0">{
                        return ruleList, err
                }</span>
                <span class="cov8" title="1">*ruleList = append(*ruleList, rule)</span>
        }

        <span class="cov8" title="1">return ruleList, nil</span>
}

// ReWriteConfLoad loads config of rewrite from file.
func ReWriteConfLoad(filename string) (ReWriteConf, error) <span class="cov8" title="1">{
        var conf ReWriteConf
        var err error

        /* open the file    */
        file, err1 := os.Open(filename)

        if err1 != nil </span><span class="cov0" title="0">{
                return conf, err1
        }</span>

        /* decode the file  */
        <span class="cov8" title="1">decoder := json.NewDecoder(file)

        var config ReWriteConfFile
        err = decoder.Decode(&amp;config)
        file.Close()

        if err != nil </span><span class="cov0" title="0">{
                return conf, err
        }</span>

        // check config
        <span class="cov8" title="1">err = ReWriteConfCheck(config)
        if err != nil </span><span class="cov8" title="1">{
                return conf, err
        }</span>

        /* convert config   */
        <span class="cov8" title="1">conf.Version = *config.Version
        conf.Config = make(ProductRules)

        for product, ruleFileList := range *config.Config </span><span class="cov8" title="1">{
                ruleList, err := ruleListConvert(ruleFileList)
                if err != nil </span><span class="cov0" title="0">{
                        return conf, err
                }</span>
                <span class="cov8" title="1">conf.Config[product] = ruleList</span>
        }

        <span class="cov8" title="1">return conf, nil</span>
}
</pre>
		
		<pre class="file" id="file152" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_rewrite

import (
        "sync"
)

type ReWriteTable struct {
        lock         sync.RWMutex
        version      string
        productRules ProductRules
}

func NewReWriteTable() *ReWriteTable <span class="cov8" title="1">{
        t := new(ReWriteTable)
        t.productRules = make(ProductRules)
        return t
}</span>

func (t *ReWriteTable) Update(conf ReWriteConf) <span class="cov8" title="1">{
        t.lock.Lock()

        t.version = conf.Version
        t.productRules = conf.Config

        t.lock.Unlock()
}</span>

func (t *ReWriteTable) Search(product string) (*RuleList, bool) <span class="cov8" title="1">{
        t.lock.RLock()
        productRules := t.productRules
        t.lock.RUnlock()

        //  find rules for given product
        rules, ok := productRules[product]
        return rules, ok
}</span>
</pre>
		
		<pre class="file" id="file153" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_secure_link

import (
        "bytes"
        "crypto/md5"
        "encoding/base64"
        "fmt"
        "strconv"
        "strings"
        "time"
)

import (
        "github.com/bfenetworks/bfe/bfe_basic"
)

var (
        ErrReqWithoutExpiresKey   = fmt.Errorf("bad req: without expires key")
        ErrReqInvalidExpiresValue = fmt.Errorf("bad req: invalid expires val")
        ErrReqWithoutChecksumKey  = fmt.Errorf("bad req: without checksum key")
        ErrReqInvalidChecksum     = fmt.Errorf("bad req: invalid checksum key")
        ErrReqExpired             = fmt.Errorf("req overdue")
)

type CheckerConfig struct {
        ChecksumKey     string
        ExpiresKey      string
        ExpressionNodes []ExpressionNodeFile
}

type NodeConfig struct {
        ChecksumKey string
        ExpiresKey  string
        Expr        string
}

type Checker struct {
        Config     *CheckerConfig
        expression *Expression
}

// NewChecker gen
func NewChecker(cc *CheckerConfig) (*Checker, error) <span class="cov8" title="1">{
        exper, err := NewExpression(cc)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;Checker{
                Config:     cc,
                expression: exper,
        }, nil</span>
}

// Check validate request
func (cs *Checker) Check(request *bfe_basic.Request) error <span class="cov8" title="1">{
        if ek := cs.Config.ExpiresKey; ek != "" </span><span class="cov8" title="1">{
                expired := request.CachedQuery().Get(ek)
                if expired == "" </span><span class="cov0" title="0">{
                        return ErrReqWithoutExpiresKey
                }</span>

                <span class="cov8" title="1">expiredUnix, err := strconv.Atoi(expired)
                if err != nil </span><span class="cov0" title="0">{
                        return ErrReqInvalidExpiresValue
                }</span>

                <span class="cov8" title="1">if time.Now().Unix() &gt; int64(expiredUnix) </span><span class="cov8" title="1">{
                        return ErrReqExpired
                }</span>
        }

        <span class="cov8" title="1">origin := request.CachedQuery().Get(cs.Config.ChecksumKey)
        if origin == "" </span><span class="cov8" title="1">{
                return ErrReqWithoutChecksumKey
        }</span>

        <span class="cov8" title="1">raw := cs.expression.Value(request)
        want := cs.encode(raw)
        if want == origin </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">return ErrReqInvalidChecksum</span>
}

// encode do encode, the shell cmd has the same result:
// echo -n '2147483647/s/link127.0.0.1 secret' | openssl md5 -binary | openssl base64 | tr +/ -_ | tr -d =
func (cs *Checker) encode(origin string) string <span class="cov8" title="1">{
        tmpB := md5.Sum([]byte(origin))
        tmp := base64.StdEncoding.EncodeToString(tmpB[:])
        tmp = strings.ReplaceAll(tmp, "+", "-")
        tmp = strings.ReplaceAll(tmp, "/", "_")
        tmp = strings.ReplaceAll(tmp, "=", "")
        return tmp
}</span>

type Expression struct {
        nodes []ExpressionNode
}

type ExpressionNode interface {
        Value(req *bfe_basic.Request) string
}

type queryNode struct {
        key string
}

func (n queryNode) Value(req *bfe_basic.Request) string <span class="cov8" title="1">{
        return req.CachedQuery().Get(n.key)
}</span>

type headerNode struct {
        key string
}

func (n headerNode) Value(req *bfe_basic.Request) string <span class="cov0" title="0">{
        return req.HttpRequest.Header.Get(n.key)
}</span>

type labelNode struct {
        val string
}

func (n labelNode) Value(req *bfe_basic.Request) string <span class="cov8" title="1">{
        return n.val
}</span>

type hostNode struct{}

func (hn hostNode) Value(req *bfe_basic.Request) string <span class="cov0" title="0">{
        return req.HttpRequest.Host
}</span>

type uriNode struct{}

func (n uriNode) Value(req *bfe_basic.Request) string <span class="cov8" title="1">{
        return req.HttpRequest.RequestURI
}</span>

type remoteAddrNode struct{}

func (n remoteAddrNode) Value(req *bfe_basic.Request) string <span class="cov8" title="1">{
        return req.HttpRequest.RemoteAddr
}</span>

func NewNode(enf ExpressionNodeFile) (ExpressionNode, error) <span class="cov8" title="1">{
        switch strings.ToLower(enf.Type) </span>{
        case "label":<span class="cov8" title="1">
                return labelNode{
                        val: enf.Param,
                }, nil</span>
        case "query":<span class="cov8" title="1">
                return queryNode{
                        key: enf.Param,
                }, nil</span>
        case "header":<span class="cov0" title="0">
                return headerNode{
                        key: enf.Param,
                }, nil</span>
        case "host":<span class="cov0" title="0">
                return hostNode{}, nil</span>
        case "uri":<span class="cov8" title="1">
                return uriNode{}, nil</span>
        case "remote_addr":<span class="cov8" title="1">
                return remoteAddrNode{}, nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("bad node type: %v", enf.Type)</span>
        }
}

func NewExpression(cc *CheckerConfig) (*Expression, error) <span class="cov8" title="1">{
        nodes := []ExpressionNode{}

        for _, enf := range cc.ExpressionNodes </span><span class="cov8" title="1">{
                en, err := NewNode(enf)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">nodes = append(nodes, en)</span>
        }

        <span class="cov8" title="1">return &amp;Expression{
                nodes: nodes,
        }, nil</span>
}

func (exp *Expression) Value(req *bfe_basic.Request) string <span class="cov8" title="1">{
        buff := &amp;bytes.Buffer{}

        for _, n := range exp.nodes </span><span class="cov8" title="1">{
                buff.WriteString(n.Value(req))
        }</span>

        <span class="cov8" title="1">return buff.String()</span>
}
</pre>
		
		<pre class="file" id="file154" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_secure_link

import (
        "github.com/baidu/go-lib/log"
        gcfg "gopkg.in/gcfg.v1"
)

import (
        "github.com/bfenetworks/bfe/bfe_util"
)

type ConfModSecureLink struct {
        Basic struct {
                DataPath string // path of config data (mod_secure_link)
        }

        Log struct {
                OpenDebug bool
        }
}

func ConfLoad(filePath string, confRoot string) (*ConfModSecureLink, error) <span class="cov8" title="1">{
        cfg := &amp;ConfModSecureLink{}
        err := gcfg.ReadFileInto(cfg, filePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if cfg.Basic.DataPath == "" </span><span class="cov0" title="0">{
                log.Logger.Warn("ModSecureLink.DataPath not set, use default value")
                cfg.Basic.DataPath = "mod_secure_link/secure_link.data"
        }</span>
        <span class="cov8" title="1">cfg.Basic.DataPath = bfe_util.ConfPathProc(cfg.Basic.DataPath, confRoot)

        return cfg, nil</span>
}
</pre>
		
		<pre class="file" id="file155" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_secure_link

import (
        "fmt"
        "os"
)

import (
        "github.com/bfenetworks/bfe/bfe_basic"
        "github.com/bfenetworks/bfe/bfe_basic/condition"
        "github.com/bfenetworks/bfe/bfe_util/json"
)

// RuleFile define how to validate secure link
type RuleFile struct {
        Cond *string

        ChecksumKey     *string
        ExpiresKey      *string
        ExpressionNodes []ExpressionNodeFile
}

type Rule struct {
        Cond condition.Condition // condition for header

        ChecksumKey string
        ExpiresKey  string

        Expression *Expression

        Checker *Checker
}

type ExpressionNodeFile struct {
        Type  string
        Param string
}

func (rule *Rule) Check(req *bfe_basic.Request) error <span class="cov0" title="0">{
        return rule.Checker.Check(req)
}</span>

type ProductRulesFile map[string][]*RuleFile
type ProductRules map[string][]*Rule

type DataFile struct {
        Version *string // version of the config
        Config  ProductRulesFile
}

type Data struct {
        Version string       // version of the config
        Config  ProductRules // product rules for header
}

// DataLoad loads config of header from file.
func DataLoad(filename string) (*Data, error) <span class="cov8" title="1">{
        file, err := os.Open(filename)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        decoder := json.NewDecoder(file)
        cf := &amp;DataFile{}
        err = decoder.Decode(cf)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return NewData(cf)</span>
}

func NewData(cf *DataFile) (*Data, error) <span class="cov8" title="1">{
        if cf.Version == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("bad Version node")
        }</span>

        <span class="cov8" title="1">if cf.Config == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("bad Config node")
        }</span>

        <span class="cov8" title="1">conf := &amp;Data{
                Version: *cf.Version,
                Config:  make(map[string][]*Rule, len(cf.Config)),
        }

        for product, ruleFiles := range cf.Config </span><span class="cov8" title="1">{
                rules := make([]*Rule, len(ruleFiles))
                for i, ruleFile := range ruleFiles </span><span class="cov8" title="1">{
                        if ruleFile == nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("bad Config[%d] node", i)
                        }</span>

                        <span class="cov8" title="1">rule, err := NewRule(ruleFile)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("bad Config[%d] node: %v", i, err)
                        }</span>
                        <span class="cov8" title="1">rules[i] = rule</span>
                }
                <span class="cov8" title="1">conf.Config[product] = rules</span>
        }

        <span class="cov8" title="1">return conf, nil</span>
}

// NewRule get Rule by RuleFile
func NewRule(rf *RuleFile) (*Rule, error) <span class="cov8" title="1">{
        if rf.Cond == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("bad Cond node")
        }</span>
        <span class="cov8" title="1">cond, err := condition.Build(*rf.Cond)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">rule := &amp;Rule{
                Cond:        cond,
                ChecksumKey: "md5",
        }

        if val := rf.ChecksumKey; val != nil </span><span class="cov8" title="1">{
                rule.ChecksumKey = *val
                if rule.ChecksumKey == "" </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("bad ChecksumKey node: empty string")
                }</span>
        }
        <span class="cov8" title="1">if val := rf.ExpiresKey; val != nil </span><span class="cov8" title="1">{
                rule.ExpiresKey = *val
        }</span>

        <span class="cov8" title="1">if rf.ExpressionNodes == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("bad SecureLink node")
        }</span>
        <span class="cov8" title="1">rule.Checker, err = NewChecker(&amp;CheckerConfig{
                ExpressionNodes: rf.ExpressionNodes,
                ChecksumKey:     rule.ChecksumKey,
                ExpiresKey:      rule.ExpiresKey,
        })

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("bad SecureLink node, err: %v", err)
        }</span>

        <span class="cov8" title="1">return rule, nil</span>
}
</pre>
		
		<pre class="file" id="file156" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_secure_link

import (
        "fmt"
        "net/url"
)

import (
        "github.com/baidu/go-lib/web-monitor/metrics"
        "github.com/baidu/go-lib/web-monitor/web_monitor"
)

import (
        "github.com/bfenetworks/bfe/bfe_basic"
        "github.com/bfenetworks/bfe/bfe_http"
        "github.com/bfenetworks/bfe/bfe_module"
)

var (
        openDebug = false
)

type ModuleSecureLinkState struct {
        ReqTotal  *metrics.Counter // all request in
        ReqAccept *metrics.Counter // request accept

        ReqWithoutExpiresKey   *metrics.Counter
        ReqInvalidExpiresValue *metrics.Counter
        ReqWithoutChecksumKey  *metrics.Counter
        ReqInvalidChecksum     *metrics.Counter
        ReqExpired             *metrics.Counter
}

// ModuleSecureLink mean secure link module
type ModuleSecureLink struct {
        name       string // name of module
        configPath string // path of config file
        state      ModuleSecureLinkState
        metrics    metrics.Metrics
        ruleTable  *SecureLinkTable // table of header rules
}

// NewModuleSecureLink create module
func NewModuleSecureLink() *ModuleSecureLink <span class="cov8" title="1">{
        m := &amp;ModuleSecureLink{
                name:      "mod_secure_link",
                ruleTable: NewSecureLinkTable(),
        }
        m.metrics.Init(&amp;m.state, m.name, 0)
        return m
}</span>

// Name return module name
func (m *ModuleSecureLink) Name() string <span class="cov0" title="0">{
        return m.name
}</span>

// Init init mode, will be invoked by framework
func (m *ModuleSecureLink) Init(cbs *bfe_module.BfeCallbacks, whs *web_monitor.WebHandlers, cr string) error <span class="cov0" title="0">{
        confPath := bfe_module.ModConfPath(cr, m.name)
        cfg, err := ConfLoad(confPath, cr)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: conf load err %s", m.name, err.Error())
        }</span>

        <span class="cov0" title="0">openDebug = cfg.Log.OpenDebug

        m.configPath = cfg.Basic.DataPath
        // load from config file to rule table
        if err := m.loadConfData(nil); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("err in loadConfData(): %s", err.Error())
        }</span>

        // register handler
        <span class="cov0" title="0">err = cbs.AddFilter(bfe_module.HandleAfterLocation, m.validateHandler)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init(): AddFilter(m.headerHandler): %s", m.name, err.Error())
        }</span>

        // register web handler for reload
        <span class="cov0" title="0">err = whs.RegisterHandler(web_monitor.WebHandleReload, m.name, m.loadConfData)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init(): RegisterHandler(m.loadConfData): %s", m.name, err.Error())
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (m *ModuleSecureLink) validateHandler(request *bfe_basic.Request) (int, *bfe_http.Response) <span class="cov8" title="1">{
        rules, ok := m.ruleTable.Search(request.Route.Product)
        if !ok </span><span class="cov0" title="0">{
                return bfe_module.BfeHandlerGoOn, nil
        }</span>

        <span class="cov8" title="1">for _, rule := range rules </span><span class="cov8" title="1">{
                if !rule.Cond.Match(request) </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">m.state.ReqTotal.Inc(1)
                err := rule.Checker.Check(request)
                if err == nil </span><span class="cov8" title="1">{
                        m.state.ReqAccept.Inc(1)
                        return bfe_module.BfeHandlerGoOn, nil
                }</span>

                <span class="cov8" title="1">switch err </span>{
                case ErrReqWithoutExpiresKey:<span class="cov0" title="0">
                        m.state.ReqWithoutExpiresKey.Inc(1)</span>
                case ErrReqInvalidExpiresValue:<span class="cov0" title="0">
                        m.state.ReqInvalidExpiresValue.Inc(1)</span>
                case ErrReqWithoutChecksumKey:<span class="cov8" title="1">
                        m.state.ReqWithoutChecksumKey.Inc(1)</span>
                case ErrReqInvalidChecksum:<span class="cov8" title="1">
                        m.state.ReqInvalidChecksum.Inc(1)</span>
                case ErrReqExpired:<span class="cov8" title="1">
                        m.state.ReqExpired.Inc(1)</span>
                }
                <span class="cov8" title="1">return bfe_module.BfeHandlerResponse, &amp;bfe_http.Response{
                        StatusCode: 403,
                }</span>
        }

        <span class="cov0" title="0">return bfe_module.BfeHandlerGoOn, nil</span>
}

func (m *ModuleSecureLink) loadConfData(query url.Values) error <span class="cov8" title="1">{
        // get file path
        path := query.Get("path")
        if path == "" </span><span class="cov0" title="0">{
                // use default
                path = m.configPath
        }</span>

        // load from config file
        <span class="cov8" title="1">conf, err := DataLoad(path)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("err in SecureLinkConfLoad(%s): %s", path, err.Error())
        }</span>

        // update to rule table
        <span class="cov8" title="1">m.ruleTable.Update(conf)

        return nil</span>
}
</pre>
		
		<pre class="file" id="file157" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_secure_link

import (
        "sync"
)

type SecureLinkTable struct {
        lock         sync.RWMutex
        version      string
        productRules ProductRules
}

func NewSecureLinkTable() *SecureLinkTable <span class="cov8" title="1">{
        return &amp;SecureLinkTable{}
}</span>

func (t *SecureLinkTable) Update(conf *Data) <span class="cov8" title="1">{
        t.lock.Lock()

        t.version = conf.Version
        t.productRules = conf.Config

        t.lock.Unlock()
}</span>

func (t *SecureLinkTable) Search(product string) ([]*Rule, bool) <span class="cov8" title="1">{
        t.lock.RLock()
        productRules := t.productRules
        t.lock.RUnlock()

        rules, ok := productRules[product]
        return rules, ok
}</span>
</pre>
		
		<pre class="file" id="file158" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_static

import (
        "fmt"
        "os"
        "path"
)

const (
        ActionBrowse = "BROWSE"
)

type ActionFile struct {
        Cmd    *string
        Params []string
}

type Action struct {
        Cmd    string
        Params []string
}

func ActionFileCheck(conf *ActionFile) error <span class="cov8" title="1">{
        if conf.Cmd == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("no Cmd")
        }</span>

        <span class="cov8" title="1">switch *conf.Cmd </span>{
        case ActionBrowse:<span class="cov8" title="1">
                if len(conf.Params) != 2 </span><span class="cov0" title="0">{
                        return fmt.Errorf("Params num of %s should be 2", ActionBrowse)
                }</span>

                <span class="cov8" title="1">if _, err := os.Stat(conf.Params[0]); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("Directory[%s] error: %v", conf.Params[0], err)
                }</span>
                <span class="cov8" title="1">if len(conf.Params[1]) != 0 </span><span class="cov8" title="1">{
                        defaultFilePath := path.Join(conf.Params[0], conf.Params[1])
                        if _, err := os.Stat(defaultFilePath); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("Default File[%s] error: %v", defaultFilePath, err)
                        }</span>
                }
        default:<span class="cov8" title="1">
                return fmt.Errorf("invalid cmd: %s", *conf.Cmd)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func actionConvert(actionFile ActionFile) Action <span class="cov8" title="1">{
        action := Action{}
        action.Cmd = *actionFile.Cmd
        action.Params = actionFile.Params
        return action
}</span>
</pre>
		
		<pre class="file" id="file159" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_static

import (
        "github.com/baidu/go-lib/log"
        gcfg "gopkg.in/gcfg.v1"
)

import (
        "github.com/bfenetworks/bfe/bfe_util"
)

type ConfModStatic struct {
        Basic struct {
                DataPath       string
                MimeTypePath   string
                EnableCompress bool
        }

        Log struct {
                OpenDebug bool
        }
}

func ConfLoad(filePath string, confRoot string) (*ConfModStatic, error) <span class="cov8" title="1">{
        var err error
        var cfg ConfModStatic

        err = gcfg.ReadFileInto(&amp;cfg, filePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">err = cfg.Check(confRoot)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;cfg, nil</span>
}

func (cfg *ConfModStatic) Check(confRoot string) error <span class="cov8" title="1">{
        if cfg.Basic.DataPath == "" </span><span class="cov0" title="0">{
                log.Logger.Warn("ModStatic.DataPath not set, use default value")
                cfg.Basic.DataPath = "mod_static/static_rule.data"
        }</span>
        <span class="cov8" title="1">if cfg.Basic.MimeTypePath == "" </span><span class="cov0" title="0">{
                log.Logger.Warn("ModStatic.MimeTypePath not set, use default value")
                cfg.Basic.MimeTypePath = "mod_static/mime_type.data"
        }</span>

        <span class="cov8" title="1">cfg.Basic.DataPath = bfe_util.ConfPathProc(cfg.Basic.DataPath, confRoot)
        cfg.Basic.MimeTypePath = bfe_util.ConfPathProc(cfg.Basic.MimeTypePath, confRoot)

        return nil</span>
}
</pre>
		
		<pre class="file" id="file160" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_static

import (
        "fmt"
        "os"
        "strings"
)

import (
        "github.com/bfenetworks/bfe/bfe_util/json"
)

type MimeType map[string]string

type MimeTypeConf struct {
        Version string
        Config  MimeType
}

func MimeTypeConfCheck(mimeTypeConf MimeTypeConf) error <span class="cov8" title="1">{
        if len(mimeTypeConf.Version) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("no Version")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func MimeTypeConfConvert(mimeTypeConf *MimeTypeConf) <span class="cov8" title="1">{
        mimeType := make(MimeType)
        for k, v := range mimeTypeConf.Config </span><span class="cov8" title="1">{
                mimeType[strings.ToLower(k)] = v
        }</span>

        <span class="cov8" title="1">mimeTypeConf.Config = mimeType</span>
}

func MimeTypeConfLoad(filename string) (MimeTypeConf, error) <span class="cov8" title="1">{
        var mimeTypeConf MimeTypeConf

        file, err := os.Open(filename)
        if err != nil </span><span class="cov0" title="0">{
                return mimeTypeConf, err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        decoder := json.NewDecoder(file)
        err = decoder.Decode(&amp;mimeTypeConf)
        if err != nil </span><span class="cov0" title="0">{
                return mimeTypeConf, err
        }</span>

        <span class="cov8" title="1">err = MimeTypeConfCheck(mimeTypeConf)
        if err != nil </span><span class="cov0" title="0">{
                return mimeTypeConf, err
        }</span>

        <span class="cov8" title="1">MimeTypeConfConvert(&amp;mimeTypeConf)

        return mimeTypeConf, err</span>
}
</pre>
		
		<pre class="file" id="file161" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_static

import (
        "sync"
)

type MimeTypeTable struct {
        lock     sync.RWMutex
        version  string
        mimeType MimeType
}

func NewMimeTypeTable() *MimeTypeTable <span class="cov8" title="1">{
        t := new(MimeTypeTable)
        t.mimeType = make(MimeType)
        return t
}</span>

func (t *MimeTypeTable) Update(conf MimeTypeConf) <span class="cov8" title="1">{
        t.lock.Lock()
        t.version = conf.Version
        t.mimeType = conf.Config
        t.lock.Unlock()
}</span>

func (t *MimeTypeTable) Search(key string) (string, bool) <span class="cov8" title="1">{
        t.lock.RLock()
        mimeType := t.mimeType
        t.lock.RUnlock()

        value, ok := mimeType[key]
        return value, ok
}</span>
</pre>
		
		<pre class="file" id="file162" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_static

import (
        "fmt"
        "mime"
        "net/url"
        "os"
        "strings"
        "time"
)

import (
        "github.com/baidu/go-lib/web-monitor/metrics"
        "github.com/baidu/go-lib/web-monitor/web_monitor"
)

import (
        "github.com/bfenetworks/bfe/bfe_basic"
        "github.com/bfenetworks/bfe/bfe_http"
        "github.com/bfenetworks/bfe/bfe_module"
)

const (
        ModStatic = "mod_static"
)

var (
        openDebug     = false
        unixEpochTime = time.Unix(0, 0)
)

type ModuleStaticState struct {
        FileBrowseSize             *metrics.Counter
        FileBrowseCount            *metrics.Counter
        FileBrowseNotExist         *metrics.Counter
        FileBrowseContentTypeError *metrics.Counter
        FileBrowseFallbackDefault  *metrics.Counter
        FileCurrentOpened          *metrics.Gauge
}

type ModuleStatic struct {
        name          string
        state         ModuleStaticState
        metrics       metrics.Metrics
        conf          *ConfModStatic
        ruleTable     *StaticRuleTable
        mimeTypeTable *MimeTypeTable
}

func NewModuleStatic() *ModuleStatic <span class="cov8" title="1">{
        m := new(ModuleStatic)
        m.name = ModStatic
        m.metrics.Init(&amp;m.state, ModStatic, 0)
        m.ruleTable = NewStaticRuleTable()
        m.mimeTypeTable = NewMimeTypeTable()
        return m
}</span>

func (m *ModuleStatic) Name() string <span class="cov0" title="0">{
        return m.name
}</span>

func (m *ModuleStatic) loadConfData(query url.Values) error <span class="cov8" title="1">{
        path := query.Get("path")
        if path == "" </span><span class="cov8" title="1">{
                path = m.conf.Basic.DataPath
        }</span>

        <span class="cov8" title="1">conf, err := StaticConfLoad(path)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error in StaticConfLoad(%s): %v", path, err)
        }</span>

        <span class="cov8" title="1">m.ruleTable.Update(conf)
        return nil</span>
}

func (m *ModuleStatic) loadMimeType(query url.Values) error <span class="cov8" title="1">{
        var err error
        path := query.Get("path")
        if path == "" </span><span class="cov8" title="1">{
                path = m.conf.Basic.MimeTypePath
        }</span>

        <span class="cov8" title="1">conf, err := MimeTypeConfLoad(path)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error in MimeTypeConfLoad(%s): %v", path, err)
        }</span>
        <span class="cov8" title="1">m.mimeTypeTable.Update(conf)

        return nil</span>
}

func (m *ModuleStatic) getState(params map[string][]string) ([]byte, error) <span class="cov0" title="0">{
        s := m.metrics.GetAll()
        return s.Format(params)
}</span>

func (m *ModuleStatic) getStateDiff(params map[string][]string) ([]byte, error) <span class="cov0" title="0">{
        s := m.metrics.GetDiff()
        return s.Format(params)
}</span>

func (m *ModuleStatic) monitorHandlers() map[string]interface{} <span class="cov8" title="1">{
        handlers := map[string]interface{}{
                m.name:           m.getState,
                m.name + ".diff": m.getStateDiff,
        }
        return handlers
}</span>

func (m *ModuleStatic) reloadHandlers() map[string]interface{} <span class="cov8" title="1">{
        handlers := map[string]interface{}{
                m.name:                              m.loadConfData,
                fmt.Sprintf("%s.mime_type", m.name): m.loadMimeType,
        }
        return handlers
}</span>

func errorStatusCode(err error) int <span class="cov8" title="1">{
        if os.IsNotExist(err) </span><span class="cov8" title="1">{
                return bfe_http.StatusNotFound
        }</span>
        <span class="cov8" title="1">if os.IsPermission(err) </span><span class="cov0" title="0">{
                return bfe_http.StatusForbidden
        }</span>

        <span class="cov8" title="1">return bfe_http.StatusInternalServerError</span>
}

func (m *ModuleStatic) openStaticFile(req *bfe_http.Request, root string,
        defaultFile string) (*staticFile, error) <span class="cov8" title="1">{
        filename := req.URL.Path

        // check accept encoding
        encodingList := make([]string, 0)
        if m.conf.Basic.EnableCompress </span><span class="cov8" title="1">{
                encodingList = CheckAcceptEncoding(req)
        }</span>

        // try specified file
        <span class="cov8" title="1">file, err := newStaticFile(root, filename, encodingList, m)
        if os.IsNotExist(err) </span><span class="cov8" title="1">{
                m.state.FileBrowseNotExist.Inc(1)
        }</span>

        // try default file
        <span class="cov8" title="1">if os.IsNotExist(err) || err == errUnexpectedDir </span><span class="cov8" title="1">{
                if len(defaultFile) != 0 </span><span class="cov8" title="1">{
                        file, err = newStaticFile(root, defaultFile, encodingList, m)
                        m.state.FileBrowseFallbackDefault.Inc(1)
                }</span>
        }

        <span class="cov8" title="1">return file, err</span>
}

func (m *ModuleStatic) processContentType(resp *bfe_http.Response, file *staticFile) <span class="cov8" title="1">{
        // get and check mime type
        ctype, ok := m.mimeTypeTable.Search(strings.ToLower(file.extension))
        if !ok </span><span class="cov8" title="1">{
                ctype = mime.TypeByExtension(file.extension)
        }</span>
        <span class="cov8" title="1">if ctype == "" </span><span class="cov8" title="1">{
                m.state.FileBrowseContentTypeError.Inc(1)
                return
        }</span>

        // set Content-Type header
        <span class="cov8" title="1">resp.Header.Set("Content-Type", ctype)</span>
}

func (m *ModuleStatic) processContentEncoding(resp *bfe_http.Response, file *staticFile) <span class="cov8" title="1">{
        switch file.encoding </span>{
        case EncodeGzip, EncodeBrotil:<span class="cov8" title="1">
                resp.Header.Set("Content-Encoding", file.encoding)</span>
        default:<span class="cov8" title="1">
                return</span>
        }
}

func (m *ModuleStatic) processContentLength(resp *bfe_http.Response, file *staticFile) <span class="cov8" title="1">{
        resp.Header.Set("Content-Length", fmt.Sprintf("%d", file.Size()))
}</span>

func (m *ModuleStatic) processLastModified(resp *bfe_http.Response, file *staticFile) <span class="cov8" title="1">{
        // get and check mod time
        t := file.ModTime()
        if t.IsZero() || t.Equal(unixEpochTime) </span><span class="cov0" title="0">{
                return
        }</span>

        // set Last-Modified header
        <span class="cov8" title="1">resp.Header.Set("Last-Modified", t.UTC().Format(bfe_http.TimeFormat))</span>
}

func (m *ModuleStatic) createRespFromStaticFile(req *bfe_basic.Request,
        rule *StaticRule) *bfe_http.Response <span class="cov8" title="1">{
        resp := bfe_basic.CreateInternalResp(req, bfe_http.StatusOK)
        root := rule.Action.Params[0]
        defaultFile := rule.Action.Params[1]

        // check request method
        httpRequest := req.HttpRequest
        if httpRequest.Method != "GET" &amp;&amp; httpRequest.Method != "HEAD" </span><span class="cov8" title="1">{
                resp.StatusCode = bfe_http.StatusMethodNotAllowed
                return resp
        }</span>

        // open static file
        <span class="cov8" title="1">file, err := m.openStaticFile(httpRequest, root, defaultFile)
        if err != nil </span><span class="cov8" title="1">{
                resp.StatusCode = errorStatusCode(err)
                return resp
        }</span>
        <span class="cov8" title="1">m.state.FileBrowseSize.Inc(uint(file.Size()))

        // prepare response
        m.processContentType(resp, file)
        m.processContentEncoding(resp, file)
        m.processContentLength(resp, file)
        m.processLastModified(resp, file)

        if httpRequest.Method != "HEAD" </span><span class="cov8" title="1">{
                resp.Body = file
        }</span> else<span class="cov8" title="1"> {
                file.Close()
        }</span>

        <span class="cov8" title="1">return resp</span>
}

func (m *ModuleStatic) staticFileHandler(req *bfe_basic.Request) (int, *bfe_http.Response) <span class="cov8" title="1">{
        rules, ok := m.ruleTable.Search(req.Route.Product)
        if !ok </span><span class="cov0" title="0">{
                return bfe_module.BfeHandlerGoOn, nil
        }</span>

        <span class="cov8" title="1">for _, rule := range *rules </span><span class="cov8" title="1">{
                if !rule.Cond.Match(req) </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">switch rule.Action.Cmd </span>{
                case ActionBrowse:<span class="cov8" title="1">
                        m.state.FileBrowseCount.Inc(1)
                        return bfe_module.BfeHandlerResponse, m.createRespFromStaticFile(req, &amp;rule)</span>
                default:<span class="cov0" title="0"> // never come here
                        return bfe_module.BfeHandlerGoOn, nil</span>
                }
        }

        <span class="cov8" title="1">return bfe_module.BfeHandlerGoOn, nil</span>
}

func (m *ModuleStatic) Init(cbs *bfe_module.BfeCallbacks, whs *web_monitor.WebHandlers,
        cr string) error <span class="cov8" title="1">{
        var err error
        var cfg *ConfModStatic

        confPath := bfe_module.ModConfPath(cr, m.name)
        if cfg, err = ConfLoad(confPath, cr); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: conf load err: %v", m.name, err)
        }</span>
        <span class="cov8" title="1">openDebug = cfg.Log.OpenDebug
        m.conf = cfg

        if err = m.loadConfData(nil); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("err in loadConfData(): %v", err)
        }</span>

        <span class="cov8" title="1">if err = m.loadMimeType(nil); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("err in loadMimeType(): %v", err)
        }</span>

        <span class="cov8" title="1">err = cbs.AddFilter(bfe_module.HandleFoundProduct, m.staticFileHandler)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init(): AddFilter(m.staticFileHandler): %v", m.name, err)
        }</span>

        <span class="cov8" title="1">err = web_monitor.RegisterHandlers(whs, web_monitor.WebHandleMonitor, m.monitorHandlers())
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init():RegisterHandlers(m.monitorHandlers): %v", m.name, err)
        }</span>

        <span class="cov8" title="1">err = web_monitor.RegisterHandlers(whs, web_monitor.WebHandleReload, m.reloadHandlers())
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init(): RegisterHandlers(): %v", m.name, err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file163" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_static

import (
        "errors"
        "net/http"
        "os"
        "path/filepath"
)

import (
        "github.com/bfenetworks/bfe/bfe_http"
)

const (
        EncodeGzip   = "gzip"
        EncodeBrotil = "br"
)

const (
        FileExtensionGzip   = "gz"
        FileExtensionBrotil = "br"
)

var (
        errUnexpectedDir = errors.New("file type should not be dir")
)

func ConvertEncodeToExt(encoding string) string <span class="cov8" title="1">{
        switch encoding </span>{
        case EncodeGzip:<span class="cov8" title="1">
                return FileExtensionGzip</span>
        case EncodeBrotil:<span class="cov0" title="0">
                return FileExtensionBrotil</span>
        default:<span class="cov0" title="0">
                return encoding</span>
        }
}

func CheckAcceptEncoding(req *bfe_http.Request) []string <span class="cov8" title="1">{
        encodingList := make([]string, 0)
        acceptEncoding := req.Header.GetDirect("Accept-Encoding")
        if bfe_http.HasToken(acceptEncoding, EncodeGzip) </span><span class="cov8" title="1">{
                encodingList = append(encodingList, EncodeGzip)
        }</span>
        <span class="cov8" title="1">if bfe_http.HasToken(acceptEncoding, EncodeBrotil) </span><span class="cov0" title="0">{
                encodingList = append(encodingList, EncodeBrotil)
        }</span>

        <span class="cov8" title="1">return encodingList</span>
}

type staticFile struct {
        http.File
        os.FileInfo
        extension string
        encoding  string
        m         *ModuleStatic
}

func newStaticFile(root string, filename string, encodingList []string, m *ModuleStatic) (*staticFile, error) <span class="cov8" title="1">{
        var err error
        s := new(staticFile)
        s.m = m
        s.extension = filepath.Ext(filename)

        for _, encoding := range encodingList </span><span class="cov8" title="1">{
                ext := ConvertEncodeToExt(encoding)
                if _, err := os.Stat(filepath.Join(root, filename+"."+ext)); err == nil </span><span class="cov8" title="1">{
                        filename = filename + "." + ext
                        s.encoding = encoding
                        break</span>
                }
        }

        <span class="cov8" title="1">s.File, err = http.Dir(root).Open(filename)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">s.FileInfo, err = s.File.Stat()
        if err != nil </span><span class="cov0" title="0">{
                s.File.Close()
                return nil, err
        }</span>

        <span class="cov8" title="1">if s.FileInfo.IsDir() </span><span class="cov8" title="1">{
                s.File.Close()
                return nil, errUnexpectedDir
        }</span>

        <span class="cov8" title="1">m.state.FileCurrentOpened.Inc(1)
        return s, nil</span>
}

func (s *staticFile) Close() error <span class="cov8" title="1">{
        err := s.File.Close()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">state := s.m.state
        state.FileCurrentOpened.Dec(1)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file164" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_static

import (
        "fmt"
        "os"
)

import (
        "github.com/bfenetworks/bfe/bfe_basic/condition"
        "github.com/bfenetworks/bfe/bfe_util/json"
)

type StaticRuleFile struct {
        Cond   string
        Action *ActionFile
}

type StaticRule struct {
        Cond   condition.Condition
        Action Action
}

type RuleFileList []StaticRuleFile
type RuleList []StaticRule

type ProductRulesFile map[string]*RuleFileList
type ProductRules map[string]*RuleList

type StaticConfFile struct {
        Version *string
        Config  *ProductRulesFile
}

type StaticConf struct {
        Version string
        Config  ProductRules
}

func StaticRuleCheck(conf StaticRuleFile) error <span class="cov8" title="1">{
        if len(conf.Cond) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("no Cond")
        }</span>

        <span class="cov8" title="1">if conf.Action == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("no Action")
        }</span>

        <span class="cov8" title="1">if err := ActionFileCheck(conf.Action); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("Action: %v", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func RuleListCheck(conf *RuleFileList) error <span class="cov8" title="1">{
        for index, rule := range *conf </span><span class="cov8" title="1">{
                err := StaticRuleCheck(rule)
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("StaticRule: %d, %v", index, err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func ProductRulesCheck(conf *ProductRulesFile) error <span class="cov8" title="1">{
        for product, ruleList := range *conf </span><span class="cov8" title="1">{
                if ruleList == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("no RuleList for product: %s", product)
                }</span>

                <span class="cov8" title="1">err := RuleListCheck(ruleList)
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("invalid product rules:%s, %v", product, err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func StaticConfCheck(conf StaticConfFile) error <span class="cov8" title="1">{
        var err error

        if conf.Version == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("no Version")
        }</span>

        <span class="cov8" title="1">if conf.Config == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("no Config")
        }</span>

        <span class="cov8" title="1">err = ProductRulesCheck(conf.Config)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("Config: %v", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func ruleConvert(ruleFile StaticRuleFile) (StaticRule, error) <span class="cov8" title="1">{
        rule := StaticRule{}

        cond, err := condition.Build(ruleFile.Cond)
        if err != nil </span><span class="cov0" title="0">{
                return rule, err
        }</span>

        <span class="cov8" title="1">rule.Cond = cond
        rule.Action = actionConvert(*ruleFile.Action)

        return rule, nil</span>
}

func ruleListConvert(ruleFileList *RuleFileList) (*RuleList, error) <span class="cov8" title="1">{
        ruleList := new(RuleList)
        *ruleList = make([]StaticRule, 0)

        for _, ruleFile := range *ruleFileList </span><span class="cov8" title="1">{
                rule, err := ruleConvert(ruleFile)
                if err != nil </span><span class="cov0" title="0">{
                        return ruleList, err
                }</span>
                <span class="cov8" title="1">*ruleList = append(*ruleList, rule)</span>
        }

        <span class="cov8" title="1">return ruleList, nil</span>
}

func StaticConfLoad(filename string) (StaticConf, error) <span class="cov8" title="1">{
        var conf StaticConf

        file, err := os.Open(filename)
        if err != nil </span><span class="cov0" title="0">{
                return conf, err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        decoder := json.NewDecoder(file)

        var config StaticConfFile
        err = decoder.Decode(&amp;config)
        if err != nil </span><span class="cov0" title="0">{
                return conf, err
        }</span>

        <span class="cov8" title="1">err = StaticConfCheck(config)
        if err != nil </span><span class="cov8" title="1">{
                return conf, err
        }</span>

        <span class="cov8" title="1">conf.Version = *config.Version
        conf.Config = make(ProductRules)

        for product, ruleFileList := range *config.Config </span><span class="cov8" title="1">{
                ruleList, err := ruleListConvert(ruleFileList)
                if err != nil </span><span class="cov0" title="0">{
                        return conf, err
                }</span>
                <span class="cov8" title="1">conf.Config[product] = ruleList</span>
        }

        <span class="cov8" title="1">return conf, nil</span>
}
</pre>
		
		<pre class="file" id="file165" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_static

import (
        "sync"
)

type StaticRuleTable struct {
        lock         sync.RWMutex
        version      string
        productRules ProductRules
}

func NewStaticRuleTable() *StaticRuleTable <span class="cov8" title="1">{
        t := new(StaticRuleTable)
        t.productRules = make(ProductRules)
        return t
}</span>

func (t *StaticRuleTable) Update(conf StaticConf) <span class="cov8" title="1">{
        t.lock.Lock()
        t.version = conf.Version
        t.productRules = conf.Config
        t.lock.Unlock()
}</span>

func (t *StaticRuleTable) Search(product string) (*RuleList, bool) <span class="cov8" title="1">{
        t.lock.RLock()
        productRules := t.productRules
        t.lock.RUnlock()

        rules, ok := productRules[product]
        return rules, ok
}</span>
</pre>
		
		<pre class="file" id="file166" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_tag

import (
        "gopkg.in/gcfg.v1"
)

import (
        "github.com/baidu/go-lib/log"
)

import (
        "github.com/bfenetworks/bfe/bfe_util"
)

const (
        defaultDataPath = "mod_tag/tag_rule.data"
)

type ConfModTag struct {
        Basic struct {
                DataPath string // path of rule data
        }

        Log struct {
                OpenDebug bool
        }
}

func ConfLoad(filePath string, confRoot string) (*ConfModTag, error) <span class="cov8" title="1">{
        var err error
        var cfg ConfModTag

        err = gcfg.ReadFileInto(&amp;cfg, filePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">err = cfg.Check(confRoot)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;cfg, nil</span>
}

func (cfg *ConfModTag) Check(confRoot string) error <span class="cov8" title="1">{
        if len(cfg.Basic.DataPath) == 0 </span><span class="cov8" title="1">{
                cfg.Basic.DataPath = defaultDataPath
                log.Logger.Warn("ModTag.DataPath not set, use default value: %s", defaultDataPath)
        }</span>

        <span class="cov8" title="1">cfg.Basic.DataPath = bfe_util.ConfPathProc(cfg.Basic.DataPath, confRoot)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file167" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_tag

import (
        "fmt"
        "net/url"
        "path/filepath"
)

import (
        "github.com/baidu/go-lib/log"
        "github.com/baidu/go-lib/web-monitor/web_monitor"
)

import (
        "github.com/bfenetworks/bfe/bfe_basic"
        "github.com/bfenetworks/bfe/bfe_http"
        "github.com/bfenetworks/bfe/bfe_module"
)

const (
        ModTag = "mod_tag"
)

var (
        openDebug = false
)

type ModuleTag struct {
        name      string
        conf      *ConfModTag
        ruleTable *TagRuleTable
}

func NewModuleTag() *ModuleTag <span class="cov8" title="1">{
        m := new(ModuleTag)
        m.name = ModTag
        m.ruleTable = NewTagRuleTable()
        return m
}</span>

func (m *ModuleTag) Name() string <span class="cov0" title="0">{
        return m.name
}</span>

func (m *ModuleTag) loadRuleData(query url.Values) (string, error) <span class="cov8" title="1">{
        // get file path
        path := query.Get("path")
        if path == "" </span><span class="cov8" title="1">{
                // use default
                path = m.conf.Basic.DataPath
        }</span>

        // load from config file
        <span class="cov8" title="1">conf, err := TagRuleFileLoad(path)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("%s: TagRuleFileLoad(%s) error: %v", m.name, path, err)
        }</span>

        // update to rule table
        <span class="cov8" title="1">m.ruleTable.Update(conf)

        _, fileName := filepath.Split(path)
        return fmt.Sprintf("%s=%s", fileName, conf.Version), nil</span>
}

func (m *ModuleTag) tagHandler(request *bfe_basic.Request) (int, *bfe_http.Response) <span class="cov8" title="1">{
        rules, ok := m.ruleTable.Search(request.Route.Product)
        if !ok </span><span class="cov0" title="0">{
                return bfe_module.BfeHandlerGoOn, nil
        }</span>

        <span class="cov8" title="1">for _, rule := range rules </span><span class="cov8" title="1">{
                if rule.Cond.Match(request) </span><span class="cov8" title="1">{
                        if openDebug </span><span class="cov0" title="0">{
                                log.Logger.Info("%s add tag: %s:%s", request.Route.Product, rule.Param.TagName, rule.Param.TagValue)
                        }</span>
                        <span class="cov8" title="1">request.AddTags(rule.Param.TagName, []string{rule.Param.TagValue})
                        if rule.Last </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
        }

        <span class="cov8" title="1">return bfe_module.BfeHandlerGoOn, nil</span>
}

func (m *ModuleTag) reloadHandlers() map[string]interface{} <span class="cov8" title="1">{
        handlers := map[string]interface{}{
                m.name: m.loadRuleData,
        }
        return handlers
}</span>

func (m *ModuleTag) init(conf *ConfModTag, cbs *bfe_module.BfeCallbacks, whs *web_monitor.WebHandlers) error <span class="cov8" title="1">{
        var err error

        _, err = m.loadRuleData(nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">err = cbs.AddFilter(bfe_module.HandleFoundProduct, m.tagHandler)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init(): AddFilter(m.tagHandler): %v", m.name, err)
        }</span>

        <span class="cov8" title="1">err = web_monitor.RegisterHandlers(whs, web_monitor.WebHandleReload, m.reloadHandlers())
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init():RegisterHandlers(m.reloadHandlers): %v", m.name, err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (m *ModuleTag) Init(cbs *bfe_module.BfeCallbacks, whs *web_monitor.WebHandlers, cr string) error <span class="cov8" title="1">{
        var err error
        var conf *ConfModTag

        confPath := bfe_module.ModConfPath(cr, m.name)
        if conf, err = ConfLoad(confPath, cr); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: conf load err %s", m.name, err.Error())
        }</span>

        <span class="cov8" title="1">m.conf = conf
        openDebug = conf.Log.OpenDebug
        return m.init(conf, cbs, whs)</span>
}
</pre>
		
		<pre class="file" id="file168" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_tag

import (
        "fmt"
        "os"
)

import (
        "github.com/bfenetworks/bfe/bfe_basic/condition"
        "github.com/bfenetworks/bfe/bfe_util/json"
)

type TagRuleFile struct {
        Version string             // version
        Config  ProductRuleRawList // product -&gt; raw rule list
}

type TagRuleConf struct {
        Version string          // version
        Config  ProductRuleList // product -&gt; rule list
}

type TagRuleRaw struct {
        Cond  string   // condition
        Param TagParam // tag param
        Last  bool     // if true, not to check the next rule in the list if the condition is satisfied
}

type ProductRuleRawList map[string]RuleRawList // product =&gt; raw rule list
type RuleRawList []TagRuleRaw

func TagRuleCheck(tagRuleFile *TagRuleFile) error <span class="cov8" title="1">{
        if tagRuleFile == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("tagRuleFile is nil")
        }</span>

        <span class="cov8" title="1">if len(tagRuleFile.Version) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("no Version")
        }</span>

        <span class="cov8" title="1">if tagRuleFile.Config == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("no Config")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func ruleConvert(rawRule TagRuleRaw) (*TagRule, error) <span class="cov8" title="1">{
        cond, err := condition.Build(rawRule.Cond)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if len(rawRule.Param.TagName) == 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("TagName may be empty")
        }</span>

        <span class="cov8" title="1">if len(rawRule.Param.TagValue) == 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("TagValue may be empty")
        }</span>

        <span class="cov8" title="1">var rule TagRule
        rule.Cond = cond
        rule.Param = rawRule.Param
        rule.Last = rawRule.Last

        return &amp;rule, nil</span>
}

func ruleListConvert(rawRuleList RuleRawList) (TagRuleList, error) <span class="cov8" title="1">{
        ruleList := TagRuleList{}
        for i, rawRule := range rawRuleList </span><span class="cov8" title="1">{
                rule, err := ruleConvert(rawRule)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("rule [%d] error: %v", i, err)
                }</span>

                <span class="cov8" title="1">ruleList = append(ruleList, *rule)</span>
        }

        <span class="cov8" title="1">return ruleList, nil</span>
}

func TagRuleFileLoad(filename string) (*TagRuleConf, error) <span class="cov8" title="1">{
        var tagRuleFile TagRuleFile
        var tagRuleConf TagRuleConf

        file, err := os.Open(filename)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        decoder := json.NewDecoder(file)

        err = decoder.Decode(&amp;tagRuleFile)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">err = TagRuleCheck(&amp;tagRuleFile)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">tagRuleConf.Version = tagRuleFile.Version
        tagRuleConf.Config = make(ProductRuleList)

        for product, ruleFileList := range tagRuleFile.Config </span><span class="cov8" title="1">{
                ruleList, err := ruleListConvert(ruleFileList)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("product[%s] rule error: %v", product, err)
                }</span>
                <span class="cov8" title="1">tagRuleConf.Config[product] = ruleList</span>
        }

        <span class="cov8" title="1">return &amp;tagRuleConf, nil</span>
}
</pre>
		
		<pre class="file" id="file169" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_tag

import (
        "sync"
)

import (
        "github.com/bfenetworks/bfe/bfe_basic/condition"
)

type TagRuleTable struct {
        lock        sync.RWMutex
        version     string
        productRule ProductRuleList // product =&gt; rule list
}

type TagRule struct {
        Cond  condition.Condition
        Param TagParam
        Last  bool // if true, not to check the next rule in the list if the condition is satisfied
}

type TagParam struct {
        TagName  string `json:"TagName"`
        TagValue string `json:"TagValue"`
}

type ProductRuleList map[string]TagRuleList // product =&gt; list of tag rule list
type TagRuleList []TagRule

func NewTagRuleTable() *TagRuleTable <span class="cov8" title="1">{
        t := new(TagRuleTable)
        t.productRule = make(ProductRuleList)
        return t
}</span>

func (t *TagRuleTable) Update(ruleConf *TagRuleConf) <span class="cov8" title="1">{
        t.lock.Lock()
        t.version = ruleConf.Version
        t.productRule = ruleConf.Config
        t.lock.Unlock()
}</span>

func (t *TagRuleTable) Search(product string) (TagRuleList, bool) <span class="cov8" title="1">{
        t.lock.RLock()
        ruleList, ok := t.productRule[product]
        t.lock.RUnlock()

        return ruleList, ok
}</span>
</pre>
		
		<pre class="file" id="file170" style="display: none">// Copyright (c) 2021 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_tcp_keepalive

import (
        "github.com/baidu/go-lib/log"
        "github.com/bfenetworks/bfe/bfe_util"
        gcfg "gopkg.in/gcfg.v1"
)

type ConfModTcpKeepAlive struct {
        Basic struct {
                DataPath string // path of product keepalive rule data
        }

        Log struct {
                OpenDebug bool // whether open debug
        }
}

func ConfLoad(filePath string, confRoot string) (*ConfModTcpKeepAlive, error) <span class="cov8" title="1">{
        var cfg ConfModTcpKeepAlive
        var err error

        err = gcfg.ReadFileInto(&amp;cfg, filePath)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;cfg, err
        }</span>

        // check conf of mod_tcp_keepalive
        <span class="cov8" title="1">err = cfg.Check(confRoot)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;cfg, err
        }</span>

        <span class="cov8" title="1">return &amp;cfg, nil</span>
}

func (cfg *ConfModTcpKeepAlive) Check(confRoot string) error <span class="cov8" title="1">{
        return ConfModTcpKeepAliveCheck(cfg, confRoot)
}</span>

func ConfModTcpKeepAliveCheck(cfg *ConfModTcpKeepAlive, confRoot string) error <span class="cov8" title="1">{
        if cfg.Basic.DataPath == "" </span><span class="cov8" title="1">{
                log.Logger.Warn("ModTcpKeepAlive.DataPath not set, use default value")
                cfg.Basic.DataPath = "mod_tcp_keepalive/tcp_keepalive.data"
        }</span>
        <span class="cov8" title="1">cfg.Basic.DataPath = bfe_util.ConfPathProc(cfg.Basic.DataPath, confRoot)

        return nil</span>
}
</pre>
		
		<pre class="file" id="file171" style="display: none">// Copyright (c) 2021 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_tcp_keepalive

import (
        "errors"
        "fmt"
        "net"
        "os"
)

import (
        "github.com/bfenetworks/bfe/bfe_util/json"
)

type ProductRuleConf struct {
        Version string
        Config  map[string]ProductRulesFile
}

type ProductRulesFile []ProductRuleFile
type ProductRuleFile struct {
        VipConf        []string
        KeepAliveParam KeepAliveParam
}

type ProductRuleData struct {
        Version string
        Config  ProductRules
}

type KeepAliveParam struct {
        Disable   bool // close the TCP-KeepAlive heartbeat message sending strategy
        KeepIdle  int  // period to send heartbeat message since there is no data transport in tcp connection
        KeepIntvl int  // period to send heartbeat message again when last message is not applied
        KeepCnt   int  // count to resend heartbeat message when last message is not applied
}
type KeepAliveRules map[string]KeepAliveParam
type ProductRules map[string]KeepAliveRules

func ConvertConf(c ProductRuleConf) (ProductRuleData, error) <span class="cov8" title="1">{
        data := ProductRuleData{}
        data.Version = c.Version
        data.Config = ProductRules{}

        for product, rules := range c.Config </span><span class="cov8" title="1">{
                data.Config[product] = KeepAliveRules{}
                for _, rule := range rules </span><span class="cov8" title="1">{
                        for _, val := range rule.VipConf </span><span class="cov8" title="1">{
                                ip, err := formatIP(val)
                                if err != nil </span><span class="cov8" title="1">{
                                        return data, err
                                }</span>
                                <span class="cov8" title="1">if _, ok := data.Config[product][ip]; ok </span><span class="cov0" title="0">{
                                        return data, fmt.Errorf("duplicated ip[%s] in product[%s]", val, product)
                                }</span>
                                <span class="cov8" title="1">data.Config[product][ip] = rule.KeepAliveParam</span>
                        }
                }
        }

        <span class="cov8" title="1">return data, nil</span>
}

func RulesCheck(conf KeepAliveRules) error <span class="cov8" title="1">{
        for ip, val := range conf </span><span class="cov8" title="1">{
                if net.ParseIP(ip) == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid ip: %s", ip)
                }</span>

                <span class="cov8" title="1">if val.KeepIdle &lt; 0 || val.KeepIntvl &lt; 0 || val.KeepCnt &lt; 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid keepalive param: %+v", val)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func ProductRulesCheck(conf ProductRules) error <span class="cov8" title="1">{
        for product, rules := range conf </span><span class="cov8" title="1">{
                if product == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("no product name")
                }</span>
                <span class="cov8" title="1">if rules == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("no rules for product: %s", product)
                }</span>

                <span class="cov8" title="1">err := RulesCheck(rules)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("ProductRules:%s, %s", product, err.Error())
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func ProductRuleDataCheck(conf ProductRuleData) error <span class="cov8" title="1">{
        var err error

        // check Version
        if conf.Version == "" </span><span class="cov0" title="0">{
                return errors.New("no Version")
        }</span>

        // check Config
        <span class="cov8" title="1">if conf.Config == nil </span><span class="cov0" title="0">{
                return errors.New("no Config")
        }</span>

        <span class="cov8" title="1">err = ProductRulesCheck(conf.Config)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Config: %s", err.Error())
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func formatIP(s string) (string, error) <span class="cov8" title="1">{
        ip := net.ParseIP(s)
        if ip == nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("formatIP: net.ParseIP() error, ip: %s", s)
        }</span>

        <span class="cov8" title="1">ret := ip.String()
        if ret == "&lt;nil&gt;" </span><span class="cov0" title="0">{
                return "", fmt.Errorf("formatIP: ip.String() error, ip: %s", s)
        }</span>

        <span class="cov8" title="1">return ret, nil</span>
}

func KeepAliveDataLoad(filename string) (ProductRuleData, error) <span class="cov8" title="1">{
        var err error
        var conf ProductRuleConf
        var data ProductRuleData

        // open the file
        file, err := os.Open(filename)
        if err != nil </span><span class="cov0" title="0">{
                return data, err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        // decode the file
        decoder := json.NewDecoder(file)
        err = decoder.Decode(&amp;conf)
        if err != nil </span><span class="cov8" title="1">{
                return data, err
        }</span>

        // convert to ProductRuleData
        <span class="cov8" title="1">data, err = ConvertConf(conf)
        if err != nil </span><span class="cov8" title="1">{
                return data, err
        }</span>

        // check data
        <span class="cov8" title="1">err = ProductRuleDataCheck(data)
        if err != nil </span><span class="cov0" title="0">{
                return data, err
        }</span>

        <span class="cov8" title="1">return data, nil</span>
}
</pre>
		
		<pre class="file" id="file172" style="display: none">// Copyright (c) 2021 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_tcp_keepalive

import (
        "os"
        "syscall"
)

// from netinet/tcp.h (OS X 10.9.4)
const (
        _TCP_KEEPINTVL = 0x101 /* interval between keepalives */
        _TCP_KEEPCNT   = 0x102 /* number of keepalives before close */
)

func setIdle(fd int, secs int) error <span class="cov8" title="1">{
        return os.NewSyscallError("setsockopt", syscall.SetsockoptInt(fd, syscall.IPPROTO_TCP, syscall.TCP_KEEPALIVE, secs))
}</span>

func setCount(fd int, n int) error <span class="cov0" title="0">{
        return os.NewSyscallError("setsockopt", syscall.SetsockoptInt(fd, syscall.IPPROTO_TCP, _TCP_KEEPCNT, n))
}</span>

func setInterval(fd int, secs int) error <span class="cov8" title="1">{
        return os.NewSyscallError("setsockopt", syscall.SetsockoptInt(fd, syscall.IPPROTO_TCP, _TCP_KEEPINTVL, secs))
}</span>

func setNonblock(fd int) error <span class="cov8" title="1">{
        return os.NewSyscallError("setsockopt", syscall.SetNonblock(fd, true))
}</span>
</pre>
		
		<pre class="file" id="file173" style="display: none">// Copyright (c) 2021 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_tcp_keepalive

import (
        "sync"
)

type KeepAliveTable struct {
        lock         sync.RWMutex
        version      string
        productRules ProductRules
}

func NewKeepAliveTable() *KeepAliveTable <span class="cov8" title="1">{
        t := new(KeepAliveTable)
        t.productRules = make(ProductRules)

        return t
}</span>

func (t *KeepAliveTable) Update(data ProductRuleData) <span class="cov8" title="1">{
        t.lock.Lock()
        t.version = data.Version
        t.productRules = data.Config
        t.lock.Unlock()
}</span>

func (t *KeepAliveTable) Search(product string) (KeepAliveRules, bool) <span class="cov8" title="1">{
        t.lock.RLock()
        productRules := t.productRules
        t.lock.RUnlock()

        rules, ok := productRules[product]
        return rules, ok
}</span>
</pre>
		
		<pre class="file" id="file174" style="display: none">// Copyright (c) 2021 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_tcp_keepalive

import (
        "fmt"
        "net"
        "net/url"
        "os"
        "reflect"

        "github.com/baidu/go-lib/log"
        "github.com/baidu/go-lib/web-monitor/metrics"
        "github.com/baidu/go-lib/web-monitor/web_monitor"
        "github.com/bfenetworks/bfe/bfe_basic"
        "github.com/bfenetworks/bfe/bfe_module"
        "github.com/bfenetworks/bfe/bfe_util"
)

const (
        ModTcpKeepAlive = "mod_tcp_keepalive"
)

var (
        openDebug = false
)

type ModuleTcpKeepAliveState struct {
        ConnToSet                 *metrics.Counter // connection hit rule, to set or disable keeplaive
        ConnSetKeepIdle           *metrics.Counter // connection set keepalive idle
        ConnSetKeepIdleError      *metrics.Counter // connection set keepalive idle error
        ConnSetKeepIntvl          *metrics.Counter // connection set keepalive interval
        ConnSetKeepIntvlError     *metrics.Counter // connection set keepalive interval error
        ConnSetKeepCnt            *metrics.Counter // connection set keepalive retry count
        ConnSetKeepCntError       *metrics.Counter // connection set keepalive retry count error
        ConnDisableKeepAlive      *metrics.Counter // connection disable keepalive message
        ConnDisableKeepAliveError *metrics.Counter // connection disable keepalive error
        ConnConvertToTcpConnError *metrics.Counter // connection convert to TCPConn error
}

type ModuleTcpKeepAlive struct {
        name string // name of module

        state   ModuleTcpKeepAliveState // module state
        metrics metrics.Metrics         // module metrics

        dataPath  string          // path of module data file
        ruleTable *KeepAliveTable // table of keepalive rules
}

func NewModuleTcpKeepAlive() *ModuleTcpKeepAlive <span class="cov8" title="1">{
        m := new(ModuleTcpKeepAlive)
        m.name = ModTcpKeepAlive
        m.metrics.Init(&amp;m.state, ModTcpKeepAlive, 0)
        m.ruleTable = NewKeepAliveTable()

        return m
}</span>

func (m *ModuleTcpKeepAlive) Name() string <span class="cov0" title="0">{
        return m.name
}</span>

func (m *ModuleTcpKeepAlive) Init(cbs *bfe_module.BfeCallbacks, whs *web_monitor.WebHandlers, cr string) error <span class="cov8" title="1">{
        var conf *ConfModTcpKeepAlive
        var err error

        // load module config
        confPath := bfe_module.ModConfPath(cr, m.name)
        if conf, err = ConfLoad(confPath, cr); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: conf load err %s", m.name, err.Error())
        }</span>

        <span class="cov8" title="1">m.dataPath = conf.Basic.DataPath
        openDebug = conf.Log.OpenDebug

        // load conf data
        if err = m.loadConfData(nil); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: loadConfData() err %s", m.name, err.Error())
        }</span>

        // register handler
        <span class="cov8" title="1">err = cbs.AddFilter(bfe_module.HandleAccept, m.HandleAccept)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init(): AddFilter(m.HandleAccept): %s", m.name, err.Error())
        }</span>

        // register web handler for monitor
        <span class="cov8" title="1">err = web_monitor.RegisterHandlers(whs, web_monitor.WebHandleMonitor, m.monitorHandlers())
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init(): RegisterHandlers(m.monitorHandlers): %s", m.name, err.Error())
        }</span>

        // register web handler for reload
        <span class="cov8" title="1">err = web_monitor.RegisterHandlers(whs, web_monitor.WebHandleReload, m.reloadHandlers())
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init(): RegisterHandlers(m.reloadHandlers): %s", m.name, err.Error())
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (m *ModuleTcpKeepAlive) loadConfData(query url.Values) error <span class="cov8" title="1">{
        path := query.Get("path")
        if path == "" </span><span class="cov8" title="1">{
                // use default
                path = m.dataPath
        }</span>

        // load file
        <span class="cov8" title="1">data, err := KeepAliveDataLoad(path)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("err in KeepAliveDataLoad(%s): %s", path, err.Error())
        }</span>

        <span class="cov8" title="1">m.ruleTable.Update(data)

        return nil</span>
}

func (m *ModuleTcpKeepAlive) disableKeepAlive(tcpConn *net.TCPConn) error <span class="cov0" title="0">{
        err := tcpConn.SetKeepAlive(false)
        if err != nil </span><span class="cov0" title="0">{
                m.state.ConnDisableKeepAliveError.Inc(1)
                return fmt.Errorf("SetKeepAlive(false) failed: %v", err)
        }</span>

        <span class="cov0" title="0">m.state.ConnDisableKeepAlive.Inc(1)
        return nil</span>
}

func (m *ModuleTcpKeepAlive) setKeepAliveParam(conn *net.TCPConn, p KeepAliveParam) error <span class="cov8" title="1">{
        var err error
        var f *os.File

        if f, err = conn.File(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("get conn.File() error: %v", err)
        }</span>
        <span class="cov8" title="1">defer f.Close()
        fd := int(f.Fd())

        if p.KeepIdle &gt; 0 </span><span class="cov8" title="1">{
                err = setIdle(fd, p.KeepIdle)
                if err != nil </span><span class="cov0" title="0">{
                        m.state.ConnSetKeepIdleError.Inc(1)
                        return fmt.Errorf("set tcp keepIdle error: %v", err)
                }</span>
                <span class="cov8" title="1">m.state.ConnSetKeepIdle.Inc(1)</span>
        }

        <span class="cov8" title="1">if p.KeepIntvl &gt; 0 </span><span class="cov8" title="1">{
                err = setInterval(fd, p.KeepIntvl)
                if err != nil </span><span class="cov0" title="0">{
                        m.state.ConnSetKeepIntvlError.Inc(1)
                        return fmt.Errorf("set tcp keepIntvl error: %v", err)
                }</span>
                <span class="cov8" title="1">m.state.ConnSetKeepIntvl.Inc(1)</span>
        }

        <span class="cov8" title="1">if p.KeepCnt &gt; 0 </span><span class="cov0" title="0">{
                err = setCount(fd, p.KeepCnt)
                if err != nil </span><span class="cov0" title="0">{
                        m.state.ConnSetKeepCntError.Inc(1)
                        return fmt.Errorf("set tcp KeepCnt error: %v", err)
                }</span>
                <span class="cov0" title="0">m.state.ConnSetKeepCnt.Inc(1)</span>
        }

        <span class="cov8" title="1">err = setNonblock(fd)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("setNonblock error: %v", err)
        }</span>

        <span class="cov8" title="1">return err</span>
}

func (m *ModuleTcpKeepAlive) handleTcpKeepAlive(conn *net.TCPConn, p KeepAliveParam) error <span class="cov8" title="1">{
        if p.Disable </span><span class="cov0" title="0">{
                return m.disableKeepAlive(conn)
        }</span>

        <span class="cov8" title="1">return m.setKeepAliveParam(conn, p)</span>
}

func (m *ModuleTcpKeepAlive) getTcpConn(conn net.Conn) (*net.TCPConn, error) <span class="cov8" title="1">{
        if c, ok := conn.(bfe_util.ConnFetcher); ok </span><span class="cov0" title="0">{
                conn = c.GetNetConn()
                return m.getTcpConn(conn)
        }</span>

        <span class="cov8" title="1">tcpConn, ok := conn.(*net.TCPConn)
        if !ok </span><span class="cov0" title="0">{
                m.state.ConnConvertToTcpConnError.Inc(1)
                if openDebug </span><span class="cov0" title="0">{
                        log.Logger.Debug("conn type[%s] connvert to TCPConn failed", reflect.TypeOf(conn))
                }</span>

                <span class="cov0" title="0">return nil, fmt.Errorf("conn connvert to TCPConn failed")</span>
        }

        <span class="cov8" title="1">return tcpConn, nil</span>
}

func (m *ModuleTcpKeepAlive) HandleAccept(session *bfe_basic.Session) int <span class="cov8" title="1">{
        vip := session.Vip.String()
        if openDebug </span><span class="cov8" title="1">{
                log.Logger.Debug("mod[%s] get connection, remote: %v, vip: %s", m.name, session.RemoteAddr, vip)
        }</span>

        <span class="cov8" title="1">rules, ok := m.ruleTable.Search(session.Product)
        if !ok </span><span class="cov0" title="0">{
                if openDebug </span><span class="cov0" title="0">{
                        log.Logger.Debug("mod[%s] product[%s] not found, just pass", m.name, session.Product)
                }</span>
                <span class="cov0" title="0">return bfe_module.BfeHandlerGoOn</span>
        }

        <span class="cov8" title="1">if param, ok := rules[vip]; ok </span><span class="cov8" title="1">{
                m.state.ConnToSet.Inc(1)
                conn, err := m.getTcpConn(session.Connection)
                if err != nil </span><span class="cov0" title="0">{
                        log.Logger.Error("mod[%s] vip[%s] getTcpConn error: %v", err)
                        return bfe_module.BfeHandlerGoOn
                }</span>

                <span class="cov8" title="1">err = m.handleTcpKeepAlive(conn, param)
                if err != nil </span><span class="cov0" title="0">{
                        log.Logger.Error("mod[%s] vip[%s] remote[%v] handleTcpKeepAlive error: %v", m.name, vip, session.RemoteAddr, err)
                }</span>

                <span class="cov8" title="1">if openDebug </span><span class="cov8" title="1">{
                        log.Logger.Debug("mod[%s] vip[%s] product[%s] found, set keepalive success, param[%+v]", m.name, vip, session.Product, param)
                }</span>

                <span class="cov8" title="1">return bfe_module.BfeHandlerGoOn</span>
        }

        <span class="cov0" title="0">return bfe_module.BfeHandlerGoOn</span>
}

func (m *ModuleTcpKeepAlive) getState(params map[string][]string) ([]byte, error) <span class="cov8" title="1">{
        s := m.metrics.GetAll()
        return s.Format(params)
}</span>

func (m *ModuleTcpKeepAlive) getStateDiff(params map[string][]string) ([]byte, error) <span class="cov0" title="0">{
        s := m.metrics.GetDiff()
        return s.Format(params)
}</span>

func (m *ModuleTcpKeepAlive) monitorHandlers() map[string]interface{} <span class="cov8" title="1">{
        handlers := map[string]interface{}{
                m.name:           m.getState,
                m.name + ".diff": m.getStateDiff,
        }

        return handlers
}</span>

func (m *ModuleTcpKeepAlive) reloadHandlers() map[string]interface{} <span class="cov8" title="1">{
        handlers := map[string]interface{}{
                m.name: m.loadConfData,
        }

        return handlers
}</span>
</pre>
		
		<pre class="file" id="file175" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_trace

import (
        "fmt"
)

import (
        "github.com/baidu/go-lib/log"
        "gopkg.in/gcfg.v1"
)

import (
        "github.com/bfenetworks/bfe/bfe_modules/mod_trace/trace"
        "github.com/bfenetworks/bfe/bfe_modules/mod_trace/trace/elastic"
        "github.com/bfenetworks/bfe/bfe_modules/mod_trace/trace/jaeger"
        "github.com/bfenetworks/bfe/bfe_modules/mod_trace/trace/zipkin"
        "github.com/bfenetworks/bfe/bfe_util"
)

const (
        defaultDataPath = "mod_trace/trace_rule.data"
)

var (
        supportedTraceAgent = map[string]bool{
                zipkin.Name:  true,
                jaeger.Name:  true,
                elastic.Name: true,
        }
)

type ConfModTrace struct {
        Basic struct {
                DataPath    string // The path of rule data
                ServiceName string // The name of this service
                TraceAgent  string // The type of trace agent: zipkin, jaeger or elastic
        }

        Log struct {
                OpenDebug bool
        }

        Zipkin  zipkin.Config  // Settings for zipkin, only useful when TraceAgent is zipkin
        Jaeger  jaeger.Config  // Settings for jaeger, only useful when TraceAgent is jaeger
        Elastic elastic.Config // Settings for elastic, only useful when TraceAgent is elastic
}

func ConfLoad(filePath string, confRoot string) (*ConfModTrace, error) <span class="cov8" title="1">{
        var err error
        var cfg ConfModTrace

        err = gcfg.ReadFileInto(&amp;cfg, filePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">err = cfg.Check(confRoot)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;cfg, nil</span>
}

func (cfg *ConfModTrace) Check(confRoot string) error <span class="cov8" title="1">{
        if len(cfg.Basic.DataPath) == 0 </span><span class="cov0" title="0">{
                cfg.Basic.DataPath = defaultDataPath
                log.Logger.Warn("ModTrace.DataPath not set, use default value: %s", defaultDataPath)
        }</span>
        <span class="cov8" title="1">cfg.Basic.DataPath = bfe_util.ConfPathProc(cfg.Basic.DataPath, confRoot)

        if len(cfg.Basic.TraceAgent) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("ModTrace.TraceAgent not set")
        }</span>

        <span class="cov8" title="1">if _, ok := supportedTraceAgent[cfg.Basic.TraceAgent]; !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("ModTrace.TraceAgent %s is not supported", cfg.Basic.TraceAgent)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (cfg *ConfModTrace) GetTraceConfig() trace.TraceAgent <span class="cov8" title="1">{
        switch cfg.Basic.TraceAgent </span>{
        case jaeger.Name:<span class="cov8" title="1">
                return &amp;cfg.Jaeger</span>
        case zipkin.Name:<span class="cov0" title="0">
                return &amp;cfg.Zipkin</span>
        case elastic.Name:<span class="cov0" title="0">
                return &amp;cfg.Elastic</span>
        default:<span class="cov0" title="0">
                return &amp;cfg.Jaeger</span>
        }
}
</pre>
		
		<pre class="file" id="file176" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_trace

import (
        "fmt"
        "net/url"
        "path/filepath"
        "strings"
)

import (
        "github.com/baidu/go-lib/log"
        "github.com/baidu/go-lib/web-monitor/metrics"
        "github.com/baidu/go-lib/web-monitor/web_monitor"
        "github.com/opentracing/opentracing-go"
)

import (
        "github.com/bfenetworks/bfe/bfe_basic"
        "github.com/bfenetworks/bfe/bfe_http"
        "github.com/bfenetworks/bfe/bfe_module"
        "github.com/bfenetworks/bfe/bfe_modules/mod_trace/trace"
)

const (
        ModTrace = "mod_trace"
        CtxSpan  = "mod_trace.span"
)

var (
        openDebug = false
)

var (
        globalTrace *trace.Trace
)

type ModuleTrace struct {
        name      string
        conf      *ConfModTrace
        ruleTable *TraceRuleTable

        // metrics
        state   ModuleTraceState
        metrics metrics.Metrics
}

type ModuleTraceState struct {
        StartSpanCount  *metrics.Counter
        FinishSpanCount *metrics.Counter
}

func NewModuleTrace() *ModuleTrace <span class="cov8" title="1">{
        m := new(ModuleTrace)
        m.name = ModTrace
        m.metrics.Init(&amp;m.state, ModTrace, 0)
        m.ruleTable = NewTraceRuleTable()
        return m
}</span>

func (m *ModuleTrace) Name() string <span class="cov0" title="0">{
        return m.name
}</span>

func (m *ModuleTrace) loadRuleData(query url.Values) (string, error) <span class="cov8" title="1">{
        // get file path
        path := query.Get("path")
        if path == "" </span><span class="cov8" title="1">{
                // use default
                path = m.conf.Basic.DataPath
        }</span>

        // load from config file
        <span class="cov8" title="1">conf, err := TraceRuleFileLoad(path)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("%s: TraceRuleFileLoad(%s) error: %v", m.name, path, err)
        }</span>

        // update to rule table
        <span class="cov8" title="1">m.ruleTable.Update(conf)

        _, fileName := filepath.Split(path)
        return fmt.Sprintf("%s=%s", fileName, conf.Version), nil</span>
}

func (m *ModuleTrace) startTrace(request *bfe_basic.Request) (int, *bfe_http.Response) <span class="cov8" title="1">{
        rules, ok := m.ruleTable.Search(request.Route.Product)
        if !ok </span><span class="cov0" title="0">{
                return bfe_module.BfeHandlerGoOn, nil
        }</span>

        <span class="cov8" title="1">for _, rule := range rules </span><span class="cov8" title="1">{
                if rule.Cond.Match(request) </span><span class="cov8" title="1">{
                        if !rule.Enable </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        // count start span
                        <span class="cov8" title="1">m.state.StartSpanCount.Inc(1)

                        // start span
                        span := StartSpan(request.HttpRequest)

                        // log request with span
                        trace.LogRequest(span, request.HttpRequest)

                        // inject request header
                        InjectRequestHeader(span, request.HttpRequest)

                        // set context, used by finishTrace
                        request.SetContext(CtxSpan, span)
                        if openDebug </span><span class="cov0" title="0">{
                                log.Logger.Info("%s%s start span", request.HttpRequest.Host, request.HttpRequest.URL.Path)
                        }</span>

                        // if hit one rule, no need to match next
                        <span class="cov8" title="1">break</span>
                }
        }

        <span class="cov8" title="1">return bfe_module.BfeHandlerGoOn, nil</span>
}

func (m *ModuleTrace) finishTrace(req *bfe_basic.Request, res *bfe_http.Response) int <span class="cov0" title="0">{
        value := req.GetContext(CtxSpan)
        if value == nil </span><span class="cov0" title="0">{
                return bfe_module.BfeHandlerGoOn
        }</span>

        <span class="cov0" title="0">span := value.(opentracing.Span)

        // set http code
        if req.HttpResponse != nil </span><span class="cov0" title="0">{
                trace.LogResponseCode(span, req.HttpResponse.StatusCode)
        }</span>

        // set error msg
        <span class="cov0" title="0">if len(req.ErrMsg) &gt; 0 </span><span class="cov0" title="0">{
                trace.SetErrorWithEvent(span, req.ErrMsg)
        }</span>

        // set backend info
        <span class="cov0" title="0">trace.LogBackend(span, req)

        // count finish span
        m.state.FinishSpanCount.Inc(1)

        // finish span
        span.Finish()

        if openDebug </span><span class="cov0" title="0">{
                log.Logger.Info("%s%s finish span, err msg:[%s]", req.HttpRequest.Host, req.HttpRequest.URL.Path, req.ErrMsg)
        }</span>

        <span class="cov0" title="0">return bfe_module.BfeHandlerGoOn</span>
}

func (m *ModuleTrace) getState(params map[string][]string) ([]byte, error) <span class="cov0" title="0">{
        s := m.metrics.GetAll()
        return s.Format(params)
}</span>

func (m *ModuleTrace) getStateDiff(params map[string][]string) ([]byte, error) <span class="cov0" title="0">{
        s := m.metrics.GetDiff()
        return s.Format(params)
}</span>

func (m *ModuleTrace) monitorHandlers() map[string]interface{} <span class="cov8" title="1">{
        handlers := map[string]interface{}{
                m.name:           m.getState,
                m.name + ".diff": m.getStateDiff,
        }
        return handlers
}</span>

func (m *ModuleTrace) reloadHandlers() map[string]interface{} <span class="cov8" title="1">{
        handlers := map[string]interface{}{
                m.name: m.loadRuleData,
        }
        return handlers
}</span>

func (m *ModuleTrace) init(conf *ConfModTrace, cbs *bfe_module.BfeCallbacks, whs *web_monitor.WebHandlers) error <span class="cov8" title="1">{
        var err error

        globalTrace, err = trace.NewTrace(conf.Basic.ServiceName, conf.GetTraceConfig())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">_, err = m.loadRuleData(nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">err = cbs.AddFilter(bfe_module.HandleFoundProduct, m.startTrace)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init(): AddFilter(m.startTrace): %v", m.name, err)
        }</span>

        <span class="cov8" title="1">err = cbs.AddFilter(bfe_module.HandleRequestFinish, m.finishTrace)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init(): AddFilter(m.finishTrace): %v", m.name, err)
        }</span>

        <span class="cov8" title="1">err = web_monitor.RegisterHandlers(whs, web_monitor.WebHandleMonitor, m.monitorHandlers())
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init():RegisterHandlers(m.reloadHandlers): %v", m.name, err)
        }</span>

        <span class="cov8" title="1">err = web_monitor.RegisterHandlers(whs, web_monitor.WebHandleReload, m.reloadHandlers())
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init():RegisterHandlers(m.reloadHandlers): %v", m.name, err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (m *ModuleTrace) Init(cbs *bfe_module.BfeCallbacks, whs *web_monitor.WebHandlers, cr string) error <span class="cov8" title="1">{
        var err error
        var conf *ConfModTrace

        confPath := bfe_module.ModConfPath(cr, m.name)
        if conf, err = ConfLoad(confPath, cr); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: conf load err %s", m.name, err.Error())
        }</span>

        <span class="cov8" title="1">m.conf = conf
        openDebug = conf.Log.OpenDebug
        return m.init(conf, cbs, whs)</span>
}

// InjectRequestHeaders used to inject opentracing headers into the request.
func InjectRequestHeader(span opentracing.Span, r *bfe_http.Request) <span class="cov8" title="1">{
        if globalTrace != nil &amp;&amp; span != nil &amp;&amp; r != nil </span><span class="cov8" title="1">{
                globalTrace.Inject(
                        span.Context(),
                        opentracing.HTTPHeaders,
                        opentracing.HTTPHeadersCarrier(r.Header))
        }</span>
}

// StartSpan starts a new span
func StartSpan(r *bfe_http.Request) opentracing.Span <span class="cov8" title="1">{
        var span opentracing.Span
        if globalTrace != nil &amp;&amp; r != nil </span><span class="cov8" title="1">{
                // set span name
                spName := spanName(r)

                // If headers contain trace data, create child span from parent; else, create root span
                spanCtx, err := globalTrace.Extract(opentracing.HTTPHeaders, opentracing.HTTPHeadersCarrier(r.Header))
                if err != nil </span><span class="cov8" title="1">{
                        span = globalTrace.StartSpan(spName)
                }</span> else<span class="cov0" title="0"> {
                        span = globalTrace.StartSpan(spName, opentracing.ChildOf(spanCtx))
                }</span>
        } else<span class="cov0" title="0"> {
                // if trace is nil or request is nil, create noop span
                span = opentracing.NoopTracer{}.StartSpan("")
        }</span>

        <span class="cov8" title="1">return span</span> // caller must defer span.Finish()
}

// spanName returns the rendered span name by request
func spanName(r *bfe_http.Request) string <span class="cov8" title="1">{
        host := strings.SplitN(r.Host, ":", 2)[0]
        return host + r.URL.Path
}</span>
</pre>
		
		<pre class="file" id="file177" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_trace

import (
        "fmt"
        "os"
)

import (
        "github.com/bfenetworks/bfe/bfe_basic/condition"
        "github.com/bfenetworks/bfe/bfe_util/json"
)

type TraceRuleFile struct {
        Version string             // version
        Config  ProductRuleRawList // product -&gt; raw rule list
}

type TraceRuleConf struct {
        Version string          // version
        Config  ProductRuleList // product -&gt; rule list
}

type TraceRuleRaw struct {
        Cond   string // condition
        Enable bool   // enable trace
}

type ProductRuleRawList map[string]RuleRawList // product =&gt; raw rule list
type RuleRawList []TraceRuleRaw

func TraceRuleCheck(traceRuleFile *TraceRuleFile) error <span class="cov8" title="1">{
        if traceRuleFile == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("traceRuleFile is nil")
        }</span>

        <span class="cov8" title="1">if len(traceRuleFile.Version) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("no Version")
        }</span>

        <span class="cov8" title="1">if traceRuleFile.Config == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("no Config")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func ruleConvert(rawRule TraceRuleRaw) (*TraceRule, error) <span class="cov8" title="1">{
        cond, err := condition.Build(rawRule.Cond)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var rule TraceRule
        rule.Cond = cond
        rule.Enable = rawRule.Enable

        return &amp;rule, nil</span>
}

func ruleListConvert(rawRuleList RuleRawList) (TraceRuleList, error) <span class="cov8" title="1">{
        ruleList := TraceRuleList{}
        for i, rawRule := range rawRuleList </span><span class="cov8" title="1">{
                rule, err := ruleConvert(rawRule)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("rule [%d] error: %v", i, err)
                }</span>

                <span class="cov8" title="1">ruleList = append(ruleList, *rule)</span>
        }

        <span class="cov8" title="1">return ruleList, nil</span>
}

func TraceRuleFileLoad(filename string) (*TraceRuleConf, error) <span class="cov8" title="1">{
        var traceRuleFile TraceRuleFile
        var traceRuleConf TraceRuleConf

        file, err := os.Open(filename)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        decoder := json.NewDecoder(file)

        err = decoder.Decode(&amp;traceRuleFile)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">err = TraceRuleCheck(&amp;traceRuleFile)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">traceRuleConf.Version = traceRuleFile.Version
        traceRuleConf.Config = make(ProductRuleList)

        for product, ruleFileList := range traceRuleFile.Config </span><span class="cov8" title="1">{
                ruleList, err := ruleListConvert(ruleFileList)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("product[%s] rule error: %v", product, err)
                }</span>
                <span class="cov8" title="1">traceRuleConf.Config[product] = ruleList</span>
        }

        <span class="cov8" title="1">return &amp;traceRuleConf, nil</span>
}
</pre>
		
		<pre class="file" id="file178" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_trace

import (
        "sync"
)

import (
        "github.com/bfenetworks/bfe/bfe_basic/condition"
)

type TraceRuleTable struct {
        lock        sync.RWMutex
        version     string
        productRule ProductRuleList // product =&gt; rule list
}

type TraceRule struct {
        Cond   condition.Condition
        Enable bool
}

type ProductRuleList map[string]TraceRuleList // product =&gt; list of trace rule list
type TraceRuleList []TraceRule

func NewTraceRuleTable() *TraceRuleTable <span class="cov8" title="1">{
        t := new(TraceRuleTable)
        t.productRule = make(ProductRuleList)
        return t
}</span>

func (t *TraceRuleTable) Update(ruleConf *TraceRuleConf) <span class="cov8" title="1">{
        t.lock.Lock()
        t.version = ruleConf.Version
        t.productRule = ruleConf.Config
        t.lock.Unlock()
}</span>

func (t *TraceRuleTable) Search(product string) (TraceRuleList, bool) <span class="cov8" title="1">{
        t.lock.RLock()
        ruleList, ok := t.productRule[product]
        t.lock.RUnlock()

        return ruleList, ok
}</span>
</pre>
		
		<pre class="file" id="file179" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_trust_clientip

import (
        "github.com/baidu/go-lib/log"
        gcfg "gopkg.in/gcfg.v1"
)

import (
        "github.com/bfenetworks/bfe/bfe_util"
)

type ConfModTrustClientIP struct {
        Basic struct {
                DataPath string // path of config data (trust-ip)
        }

        Log struct {
                OpenDebug bool
        }
}

// ConfLoad loads config from config file.
func ConfLoad(filePath string, confRoot string) (*ConfModTrustClientIP, error) <span class="cov8" title="1">{
        var cfg ConfModTrustClientIP
        var err error

        // read config from file
        err = gcfg.ReadFileInto(&amp;cfg, filePath)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;cfg, err
        }</span>

        // check conf of mod_trust_clientip
        <span class="cov8" title="1">err = cfg.Check(confRoot)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;cfg, err
        }</span>

        <span class="cov8" title="1">return &amp;cfg, nil</span>
}

func (cfg *ConfModTrustClientIP) Check(confRoot string) error <span class="cov8" title="1">{
        return ConfModTrustClientIPCheck(cfg, confRoot)
}</span>

func ConfModTrustClientIPCheck(cfg *ConfModTrustClientIP, confRoot string) error <span class="cov8" title="1">{
        if cfg.Basic.DataPath == "" </span><span class="cov8" title="1">{
                log.Logger.Warn("ModTrustClientIP.DataPath not set, use default value")
                cfg.Basic.DataPath = "mod_trust_clientip/trust_client_ip.data"
        }</span>

        <span class="cov8" title="1">cfg.Basic.DataPath = bfe_util.ConfPathProc(cfg.Basic.DataPath, confRoot)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file180" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// module for marking trust-client-ip in session

package mod_trust_clientip

import (
        "bytes"
        "fmt"
        "net/url"
)

import (
        "github.com/baidu/go-lib/log"
        "github.com/baidu/go-lib/web-monitor/metrics"
        "github.com/baidu/go-lib/web-monitor/web_monitor"
)

import (
        "github.com/bfenetworks/bfe/bfe_basic"
        "github.com/bfenetworks/bfe/bfe_module"
        "github.com/bfenetworks/bfe/bfe_util/ipdict"
)

const (
        ModTrustClientIP = "mod_trust_clientip"
)

var (
        openDebug = false
)

type ModuleTrustClientIPState struct {
        ConnTotal                *metrics.Counter // all connnetion checked
        ConnTrustClientip        *metrics.Counter // connection from trust addr
        ConnAddrInternal         *metrics.Counter // connection from internal
        ConnAddrInternalNotTrust *metrics.Counter // connection from internal and not trust
}

type ModuleTrustClientIP struct {
        name       string                   // name of module
        configPath string                   // path of config file
        state      ModuleTrustClientIPState // module state
        metrics    metrics.Metrics          // diff counter of module state
        trustTable *ipdict.IPTable          // table for storing trust-ip
}

func NewModuleTrustClientIP() *ModuleTrustClientIP <span class="cov8" title="1">{
        m := new(ModuleTrustClientIP)
        m.name = ModTrustClientIP
        m.metrics.Init(&amp;m.state, ModTrustClientIP, 0)

        return m
}</span>

func (m *ModuleTrustClientIP) Name() string <span class="cov0" title="0">{
        return m.name
}</span>

func ipItemsMake(conf TrustIPConf) (*ipdict.IPItems, error) <span class="cov8" title="1">{
        // calculate singleIPNum and pairIPNum
        singleIPNum, pairIPNum := 0, 0
        for _, addrScopeList := range conf.Config </span><span class="cov8" title="1">{
                for _, AddrScope := range *addrScopeList </span><span class="cov8" title="1">{
                        // Insert start &amp; end ip into ipItems
                        ret := bytes.Compare(AddrScope.Begin, AddrScope.End)
                        if ret == 0 </span><span class="cov8" title="1">{
                                // startip == endip
                                singleIPNum += 1
                        }</span> else<span class="cov8" title="1"> {
                                // startip != endip
                                pairIPNum += 1
                        }</span>
                }
        }

        // create ipItems
        <span class="cov8" title="1">ipItems, err := ipdict.NewIPItems(singleIPNum, pairIPNum)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // insert
        <span class="cov8" title="1">for src, addrScopeList := range conf.Config </span><span class="cov8" title="1">{
                for index, AddrScope := range *addrScopeList </span><span class="cov8" title="1">{
                        // Insert start &amp; end ip into ipItems
                        ret := bytes.Compare(AddrScope.Begin, AddrScope.End)
                        if ret == 0 </span><span class="cov8" title="1">{
                                // startip == endip
                                err = ipItems.InsertSingle(AddrScope.Begin)
                        }</span> else<span class="cov8" title="1"> {
                                // startip != endip
                                err = ipItems.InsertPair(AddrScope.Begin, AddrScope.End)
                        }</span>

                        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                                return nil, fmt.Errorf("ipItemsMake():[%s, %d], err:[%s]", src, index, err.Error())
                        }</span>
                }
        }

        // Load succ, sort dict
        <span class="cov8" title="1">ipItems.Sort()
        ipItems.Version = conf.Version

        return ipItems, nil</span>
}

func (m *ModuleTrustClientIP) loadConfData(query url.Values) error <span class="cov8" title="1">{
        // get file path
        path := query.Get("path")
        if path == "" </span><span class="cov8" title="1">{
                // use default
                path = m.configPath
        }</span>

        // load from config file
        <span class="cov8" title="1">conf, err := TrustIPConfLoad(path)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("err in TrustIPConfLoad(%s):%s", path, err.Error())
        }</span>

        <span class="cov8" title="1">items, err := ipItemsMake(conf)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("err in ipItemsMake():%s", err.Error())
        }</span>

        // update to trust-table
        <span class="cov8" title="1">m.trustTable.Update(items)

        return nil</span>
}

func (m *ModuleTrustClientIP) acceptHandler(session *bfe_basic.Session) int <span class="cov8" title="1">{
        m.state.ConnTotal.Inc(1)

        trusted := m.trustTable.Search(session.RemoteAddr.IP)
        if trusted </span><span class="cov8" title="1">{
                m.state.ConnTrustClientip.Inc(1)
        }</span>
        <span class="cov8" title="1">session.SetTrustSource(trusted)

        // state for internal remote ip
        if session.RemoteAddr.IP.IsPrivate() </span><span class="cov0" title="0">{
                m.state.ConnAddrInternal.Inc(1)
                if !trusted </span><span class="cov0" title="0">{
                        m.state.ConnAddrInternalNotTrust.Inc(1)
                }</span>
        }

        <span class="cov8" title="1">if openDebug </span><span class="cov0" title="0">{
                log.Logger.Debug("mod_trust_clientip:src ip = %s, trusted = %t",
                        session.RemoteAddr.IP, session.TrustSource())
        }</span>

        <span class="cov8" title="1">return bfe_module.BfeHandlerGoOn</span>
}

func (m *ModuleTrustClientIP) getState(params map[string][]string) ([]byte, error) <span class="cov0" title="0">{
        s := m.metrics.GetAll()
        return s.Format(params)
}</span>

func (m *ModuleTrustClientIP) getStateDiff(params map[string][]string) ([]byte, error) <span class="cov0" title="0">{
        s := m.metrics.GetDiff()
        return s.Format(params)
}</span>

func (m *ModuleTrustClientIP) monitorHandlers() map[string]interface{} <span class="cov0" title="0">{
        handlers := map[string]interface{}{
                m.name:           m.getState,
                m.name + ".diff": m.getStateDiff,
        }
        return handlers
}</span>

func (m *ModuleTrustClientIP) Init(cbs *bfe_module.BfeCallbacks, whs *web_monitor.WebHandlers,
        cr string) error <span class="cov0" title="0">{
        var err error
        var conf *ConfModTrustClientIP

        confPath := bfe_module.ModConfPath(cr, m.name)
        if conf, err = ConfLoad(confPath, cr); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: conf load err %s", m.name, err.Error())
        }</span>

        <span class="cov0" title="0">return m.init(conf, cbs, whs)</span>
}

func (m *ModuleTrustClientIP) init(cfg *ConfModTrustClientIP, cbs *bfe_module.BfeCallbacks,
        whs *web_monitor.WebHandlers) error <span class="cov0" title="0">{
        m.configPath = cfg.Basic.DataPath

        // set debug switch
        openDebug = cfg.Log.OpenDebug

        // initialize trust-table
        m.trustTable = ipdict.NewIPTable()

        // load from config file to trust-table
        if err := m.loadConfData(nil); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("err in loadConfData(): %s", err.Error())
        }</span>

        // register handler
        // for accept
        <span class="cov0" title="0">err := cbs.AddFilter(bfe_module.HandleAccept, m.acceptHandler)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init(): AddFilter(m.acceptHandler): %s", m.name, err.Error())
        }</span>

        // register web handler for monitor
        <span class="cov0" title="0">err = web_monitor.RegisterHandlers(whs, web_monitor.WebHandleMonitor, m.monitorHandlers())
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init():RegisterHandlers(m.monitorHandlers): %s", m.name, err.Error())
        }</span>

        // register web handler for reload
        <span class="cov0" title="0">err = whs.RegisterHandler(web_monitor.WebHandleReload, m.name, m.loadConfData)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init(): RegisterHandler(m.loadConfData): %s", m.name, err.Error())
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file181" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_trust_clientip

import (
        "errors"
        "fmt"
        "net"
        "os"
)

import (
        "github.com/bfenetworks/bfe/bfe_util/json"
)

type AddrScopeFile struct {
        Begin *string // start, e.g,. 119.75.215.0
        End   *string // end, e.g., 119.75.215.255
}

type AddrScope struct {
        Begin net.IP // start
        End   net.IP // end
}

type AddrScopeFileList []AddrScopeFile
type AddrScopeList []AddrScope

type SrcScopeMapFile map[string]*AddrScopeFileList // source =&gt; list of addr scope
type SrcScopeMap map[string]*AddrScopeList         // source =&gt; list of addr scope

type TrustIPConfFile struct {
        Version *string // version of the config
        Config  *SrcScopeMapFile
}

type TrustIPConf struct {
        Version string // version of the config
        Config  SrcScopeMap
}

func AddrScopeListCheck(conf *AddrScopeFileList) error <span class="cov8" title="1">{
        for index, scope := range *conf </span><span class="cov8" title="1">{
                // the check for ip address format will be done in convert function
                if scope.Begin == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("%d:no start", index)
                }</span>

                <span class="cov8" title="1">if scope.End == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("%d:no end", index)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func TrustIPConfCheck(conf *TrustIPConfFile) error <span class="cov8" title="1">{
        if conf.Version == nil </span><span class="cov0" title="0">{
                return errors.New("no Version")
        }</span>

        <span class="cov8" title="1">if conf.Config == nil </span><span class="cov0" title="0">{
                return errors.New("no Config")
        }</span>

        // check config for each source
        <span class="cov8" title="1">for src, scopeList := range *conf.Config </span><span class="cov8" title="1">{
                if scopeList == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("no conf for src:%s", src)
                }</span>

                <span class="cov8" title="1">if err := AddrScopeListCheck(scopeList); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("src %s:%s", src, err.Error())
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// TrustIPConfLoad loads config of trust-ip from file
func TrustIPConfLoad(filename string) (TrustIPConf, error) <span class="cov8" title="1">{
        var conf TrustIPConf

        // open the file
        file, err1 := os.Open(filename)

        if err1 != nil </span><span class="cov0" title="0">{
                return conf, err1
        }</span>

        // decode the file
        <span class="cov8" title="1">decoder := json.NewDecoder(file)

        config := TrustIPConfFile{}
        err2 := decoder.Decode(&amp;config)
        file.Close()

        if err2 != nil </span><span class="cov0" title="0">{
                return conf, err2
        }</span>

        // check config
        <span class="cov8" title="1">err3 := TrustIPConfCheck(&amp;config)
        if err3 != nil </span><span class="cov0" title="0">{
                return conf, err3
        }</span>

        /* convert config   */
        <span class="cov8" title="1">conf.Version = *config.Version
        conf.Config = make(SrcScopeMap)

        for src, scopeListFile := range *config.Config </span><span class="cov8" title="1">{
                scopeList := new(AddrScopeList)
                *scopeList = make([]AddrScope, 0)

                for index, scopeFile := range *scopeListFile </span><span class="cov8" title="1">{
                        var startAddr, endAddr net.IP

                        if startAddr = net.ParseIP(*scopeFile.Begin); startAddr == nil </span><span class="cov0" title="0">{
                                return conf, fmt.Errorf("%d:illegal begin:%s", index, *scopeFile.Begin)
                        }</span>

                        <span class="cov8" title="1">if endAddr = net.ParseIP(*scopeFile.End); endAddr == nil </span><span class="cov8" title="1">{
                                return conf, fmt.Errorf("%d:illegal end:%s", index, *scopeFile.End)
                        }</span>

                        <span class="cov8" title="1">scope := AddrScope{}
                        scope.Begin = startAddr
                        scope.End = endAddr

                        *scopeList = append(*scopeList, scope)</span>
                }

                <span class="cov8" title="1">conf.Config[src] = scopeList</span>
        }

        <span class="cov8" title="1">return conf, nil</span>
}
</pre>
		
		<pre class="file" id="file182" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_userid

import (
        "github.com/baidu/go-lib/log"
        gcfg "gopkg.in/gcfg.v1"
)

import (
        "github.com/bfenetworks/bfe/bfe_util"
)

type ConfModUserID struct {
        Basic struct {
                DataPath string // path of config data
        }

        Log struct {
                OpenDebug bool
        }
}

func ConfLoad(filePath, confRoot string) (*ConfModUserID, error) <span class="cov8" title="1">{
        cfg := &amp;ConfModUserID{}

        // read config from file
        err := gcfg.ReadFileInto(cfg, filePath)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if cfg.Basic.DataPath == "" </span><span class="cov8" title="1">{
                log.Logger.Warn("ModUserID.DataPath not set, use default value")
                cfg.Basic.DataPath = "mod_userid/userid_rule.data"
        }</span>

        <span class="cov8" title="1">cfg.Basic.DataPath = bfe_util.ConfPathProc(cfg.Basic.DataPath, confRoot)

        return cfg, nil</span>
}
</pre>
		
		<pre class="file" id="file183" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package mod_userid generate user identity to trace one user in different request
// this mod will auto set user id for request if user id not exited in cookie to cookie
package mod_userid

import (
        "encoding/hex"
        "fmt"
        "math/rand"
        "net/url"
        "path/filepath"
        "sync"
        "time"
)

import (
        "github.com/baidu/go-lib/web-monitor/web_monitor"
)

import (
        "github.com/bfenetworks/bfe/bfe_basic"
        "github.com/bfenetworks/bfe/bfe_http"
        "github.com/bfenetworks/bfe/bfe_module"
)

var openDebug = false

const (
        ModName   = "mod_userid"
        UidCtxKey = "mod_userid.uid_cookie"
)

type ModuleUserID struct {
        name         string
        confFile     string
        config       *Config
        configLocker sync.RWMutex
}

func NewModuleUserID() *ModuleUserID <span class="cov8" title="1">{
        return &amp;ModuleUserID{
                name: ModName,
        }
}</span>

func (m *ModuleUserID) Name() string <span class="cov8" title="1">{
        return m.name
}</span>

func (m *ModuleUserID) Init(cbs *bfe_module.BfeCallbacks, whs *web_monitor.WebHandlers,
        cr string) error <span class="cov8" title="1">{
        // load config
        cfg, err := ConfLoad(bfe_module.ModConfPath(cr, m.name), cr)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: conf load err %v", m.name, err)
        }</span>

        <span class="cov8" title="1">openDebug = cfg.Log.OpenDebug
        m.confFile = cfg.Basic.DataPath
        if _, err := m.loadConfData(nil); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: conf load err %v", m.name, err)
        }</span>

        // register handlers
        <span class="cov8" title="1">if err := whs.RegisterHandler(web_monitor.WebHandleReload, m.name, m.loadConfData); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init(): RegisterHandler(m.loadConfData): %s", m.name, err.Error())
        }</span>

        <span class="cov8" title="1">if err := cbs.AddFilter(bfe_module.HandleFoundProduct, m.reqSetUid); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init(): AddFilter(m.reqSetUid): %s", m.name, err.Error())
        }</span>

        <span class="cov8" title="1">if err := cbs.AddFilter(bfe_module.HandleReadResponse, m.rspSetUid); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init(): AddFilter(m.rspSetUid): %s", m.name, err.Error())
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (m *ModuleUserID) loadConfData(query url.Values) (string, error) <span class="cov8" title="1">{
        path := m.confFile
        if q := query.Get("path"); q != "" </span><span class="cov8" title="1">{
                path = q
        }</span>

        <span class="cov8" title="1">config, err := NewConfigFromFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">m.setConfig(config)

        _, fileName := filepath.Split(path)
        return fmt.Sprintf("%s=%s", fileName, config.Version), nil</span>
}

func (m *ModuleUserID) setConfig(config *Config) <span class="cov8" title="1">{
        m.configLocker.Lock()
        m.config = config
        m.configLocker.Unlock()
}</span>

func (m *ModuleUserID) getConfig() *Config <span class="cov8" title="1">{
        m.configLocker.RLock()
        config := m.config
        m.configLocker.RUnlock()

        return config
}</span>

func (m *ModuleUserID) reqSetUid(request *bfe_basic.Request) (int, *bfe_http.Response) <span class="cov8" title="1">{
        conf := m.getConfig()
        if conf == nil </span><span class="cov0" title="0">{
                return bfe_module.BfeHandlerGoOn, nil
        }</span>

        <span class="cov8" title="1">productRules := conf.FindProductRules(request.Route.Product)
        if len(productRules) == 0 </span><span class="cov8" title="1">{
                productRules = conf.FindProductRules(bfe_basic.GlobalProduct)
        }</span>
        <span class="cov8" title="1">for _, rule := range productRules </span><span class="cov0" title="0">{
                if !rule.Cond.Match(request) </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">params := rule.Params
                if _, ok := request.Cookie(params.Name); ok </span><span class="cov0" title="0">{
                        return bfe_module.BfeHandlerGoOn, nil
                }</span>

                <span class="cov0" title="0">cookie := &amp;bfe_http.Cookie{
                        Name:    params.Name,
                        Value:   genUid(),
                        Path:    params.Path,
                        Domain:  params.Domain,
                        Expires: time.Now().Add(params.MaxAge),
                        MaxAge:  int(params.MaxAge.Seconds()),
                }
                request.CookieMap[cookie.Name] = cookie
                request.HttpRequest.AddCookie(cookie)
                request.SetContext(UidCtxKey, cookie)
                break</span>
        }

        <span class="cov8" title="1">return bfe_module.BfeHandlerGoOn, nil</span>
}

func genUid() string <span class="cov0" title="0">{
        id := fmt.Sprintf("%d_%d", time.Now().UnixNano(), rand.Intn(1&lt;&lt;31-1))
        return hex.EncodeToString([]byte(id))
}</span>

func (m *ModuleUserID) rspSetUid(request *bfe_basic.Request, res *bfe_http.Response) int <span class="cov8" title="1">{
        data := request.GetContext(UidCtxKey)
        if data == nil </span><span class="cov8" title="1">{
                return bfe_module.BfeHandlerGoOn
        }</span>

        <span class="cov8" title="1">uidCookie, ok := data.(*bfe_http.Cookie)
        if !ok </span><span class="cov0" title="0">{
                return bfe_module.BfeHandlerGoOn
        }</span>

        <span class="cov8" title="1">res.Header.Add("Set-Cookie", uidCookie.String())
        return bfe_module.BfeHandlerGoOn</span>
}
</pre>
		
		<pre class="file" id="file184" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mod_userid

import (
        "fmt"
        "os"
        "time"
)

import (
        "github.com/bfenetworks/bfe/bfe_basic/condition"
        "github.com/bfenetworks/bfe/bfe_util/json"
)

// ConfigData the config for this module
type ConfigData struct {
        Version string
        Config  map[string][]ProductRuleData
}

// ProductRuleData config for one product line
type ProductRuleData struct {
        Cond   string
        Params *struct {
                Name   string
                Domain string
                Path   string
                MaxAge int
        }
}

func (cd *ConfigData) toConfig() (*Config, error) <span class="cov8" title="1">{
        config := &amp;Config{
                Version:  cd.Version,
                Products: map[string][]ProductRule{},
        }

        for name, rules := range cd.Config </span><span class="cov8" title="1">{
                if len(rules) == 0 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("mod_user: product %s is nil", name)
                }</span>

                <span class="cov8" title="1">for _, rule := range rules </span><span class="cov8" title="1">{
                        cond, err := condition.Build(rule.Cond)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov8" title="1">if rule.Params == nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("mod_user: product %s' Params is nil", name)
                        }</span>

                        <span class="cov8" title="1">config.Products[name] = append(config.Products[name], ProductRule{
                                Cond: cond,
                                Params: ProductRuleParams{
                                        Name:   rule.Params.Name,
                                        Domain: rule.Params.Domain,
                                        Path:   rule.Params.Path,
                                        MaxAge: time.Duration(rule.Params.MaxAge) * time.Second,
                                },
                        })</span>
                }
        }

        <span class="cov8" title="1">return config, nil</span>

}

// ProductRuleParams config params
type ProductRuleParams struct {
        Name   string
        Domain string
        Path   string
        MaxAge time.Duration
}

// Config config
type Config struct {
        Version  string
        Products map[string][]ProductRule
}

// ProductRule  productRule
type ProductRule struct {
        Params ProductRuleParams
        Cond   condition.Condition
}

// NewConfigFromFile new one config
func NewConfigFromFile(fileName string) (*Config, error) <span class="cov8" title="1">{
        file, err := os.Open(fileName)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        cd := &amp;ConfigData{}
        if err := json.NewDecoder(file).Decode(cd); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return cd.toConfig()</span>
}

// FindProductRules find by name。no locker because of nobody will write it
func (c *Config) FindProductRules(productName string) []ProductRule <span class="cov8" title="1">{
        return c.Products[productName]
}</span>
</pre>
		
		<pre class="file" id="file185" style="display: none">// Copyright (c) 2020 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package mod_waf

import (
        "github.com/baidu/go-lib/log"
        "gopkg.in/gcfg.v1"
)

import (
        "github.com/bfenetworks/bfe/bfe_util"
        "github.com/bfenetworks/bfe/bfe_util/access_log"
)

const (
        DefaultRulePath = "mod_waf/waf_rule.data" // default product rule path
)

type ConfModWaf struct {
        Basic struct {
                ProductRulePath string // path of waf rule data
        }
        Log access_log.LogConfig
}

func (cfg *ConfModWaf) Check(confRoot string) error <span class="cov8" title="1">{
        if cfg.Basic.ProductRulePath == "" </span><span class="cov8" title="1">{
                log.Logger.Warn("ConfModWaf.ProductRulePath not set, use default value")
                cfg.Basic.ProductRulePath = DefaultRulePath
        }</span>

        <span class="cov8" title="1">cfg.Basic.ProductRulePath = bfe_util.ConfPathProc(cfg.Basic.ProductRulePath, confRoot)

        return cfg.Log.Check(confRoot)</span>
}

func ConfLoad(filePath string, confRoot string) (*ConfModWaf, error) <span class="cov8" title="1">{
        var cfg ConfModWaf
        err := gcfg.ReadFileInto(&amp;cfg, filePath)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">err = cfg.Check(confRoot)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;cfg, nil</span>
}
</pre>
		
		<pre class="file" id="file186" style="display: none">// Copyright (c) 2020 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package mod_waf

import (
        "errors"
        "fmt"
        "net/url"
)

import (
        "github.com/baidu/go-lib/log"
        "github.com/baidu/go-lib/web-monitor/metrics"
        "github.com/baidu/go-lib/web-monitor/web_monitor"
)

import (
        "github.com/bfenetworks/bfe/bfe_basic"
        "github.com/bfenetworks/bfe/bfe_http"
        "github.com/bfenetworks/bfe/bfe_module"
)

const (
        ModWaf = "mod_waf" // mod waf
)

var (
        ErrWaf = errors.New("WAF") // deny by Waf
)

type ModuleWafState struct {
        CheckedReq *metrics.Counter // record how many requests check waf rule

        HitBlockedReq  *metrics.Counter // record how many requests check waf rule
        HitCheckedRule *metrics.Counter // hit checked rule

        BlockedRuleError *metrics.Counter //err times of check blocked rule
        CheckedRuleError *metrics.Counter // err times of check checked rule
}

type ModuleWaf struct {
        name      string          // mod name
        conf      *ConfModWaf     // mod waf config
        handler   *wafHandler     // mod waf handler
        state     ModuleWafState  // state of waf
        ruleTable *WarRuleTable   // rule table of waf
        metrics   metrics.Metrics // metric info of waf
}

func NewModuleWaf() *ModuleWaf <span class="cov8" title="1">{
        m := new(ModuleWaf)
        m.name = ModWaf
        m.handler = NewWafHandler()
        m.metrics.Init(&amp;m.state, m.name, 0)
        m.ruleTable = NewWarRuleTable()
        return m
}</span>

func (m *ModuleWaf) Name() string <span class="cov8" title="1">{
        return m.name
}</span>

func (m *ModuleWaf) loadProductRuleConf(query url.Values) error <span class="cov8" title="1">{
        // get file path
        path := query.Get("path")
        if path == "" </span><span class="cov8" title="1">{
                // use default
                path = m.conf.Basic.ProductRulePath
        }</span>

        // load from config file
        <span class="cov8" title="1">conf, err := ProductWafRuleConfLoad(path)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: loadProductRuleConf(%s) error: %v", m.name, path, err)
        }</span>

        // update to rule table
        <span class="cov8" title="1">m.ruleTable.Update(&amp;conf)
        return nil</span>
}

func (m *ModuleWaf) getState(params map[string][]string) ([]byte, error) <span class="cov0" title="0">{
        s := m.metrics.GetAll()
        return s.Format(params)
}</span>

func (m *ModuleWaf) getStateDiff(params map[string][]string) ([]byte, error) <span class="cov0" title="0">{
        s := m.metrics.GetDiff()
        return s.Format(params)
}</span>

func (m *ModuleWaf) monitorHandlers() map[string]interface{} <span class="cov8" title="1">{
        handlers := map[string]interface{}{
                m.name:           m.getState,
                m.name + ".diff": m.getStateDiff,
        }
        return handlers
}</span>

func (m *ModuleWaf) reloadHandlers() map[string]interface{} <span class="cov8" title="1">{
        handlers := map[string]interface{}{
                m.name: m.loadProductRuleConf,
        }
        return handlers
}</span>

func (m *ModuleWaf) handleWaf(req *bfe_basic.Request) (int, *bfe_http.Response) <span class="cov8" title="1">{
        rules, ok := m.ruleTable.Search(req.Route.Product)
        if !ok </span><span class="cov0" title="0">{
                return bfe_module.BfeHandlerGoOn, nil
        }</span>
        <span class="cov8" title="1">for _, rule := range *rules </span><span class="cov8" title="1">{
                if !rule.Cond.Match(req) </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">m.state.CheckedReq.Inc(1)
                for _, blockRule := range rule.BlockRules </span><span class="cov8" title="1">{
                        blocked, err := m.handler.HandleBlockJob(blockRule, req)
                        if err != nil </span><span class="cov0" title="0">{
                                m.state.BlockedRuleError.Inc(1)
                                log.Logger.Debug("ModuleWaf.handleWaf() block job err=%v, rule=%s", err, blockRule)
                                continue</span>
                        }
                        <span class="cov8" title="1">if blocked </span><span class="cov8" title="1">{
                                req.ErrCode = ErrWaf
                                m.state.HitBlockedReq.Inc(1)
                                return bfe_module.BfeHandlerFinish, nil
                        }</span>
                }
                <span class="cov8" title="1">for _, checkRule := range rule.CheckRules </span><span class="cov8" title="1">{
                        hit, err := m.handler.HandleCheckJob(checkRule, req)
                        if err != nil </span><span class="cov0" title="0">{
                                m.state.CheckedRuleError.Inc(1)
                                log.Logger.Debug("ModuleWaf.handleWaf() checkjob err=%v, rule=%s", err, checkRule)
                                continue</span>
                        }
                        <span class="cov8" title="1">if hit </span><span class="cov8" title="1">{
                                m.state.HitCheckedRule.Inc(1)
                        }</span>
                }
                <span class="cov8" title="1">break</span>
        }
        <span class="cov8" title="1">return bfe_module.BfeHandlerGoOn, nil</span>
}

func (m *ModuleWaf) Init(cbs *bfe_module.BfeCallbacks, whs *web_monitor.WebHandlers, cr string) error <span class="cov8" title="1">{
        var err error

        confPath := bfe_module.ModConfPath(cr, m.Name())
        if m.conf, err = ConfLoad(confPath, cr); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: conf load err %v", m.name, err)
        }</span>

        <span class="cov8" title="1">if err = m.loadProductRuleConf(nil); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: loadProductRuleConf() err %v", m.Name(), err)
        }</span>

        <span class="cov8" title="1">if err = m.handler.Init(m.conf); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: handler.Init() err %v", m.Name(), err)
        }</span>

        <span class="cov8" title="1">err = cbs.AddFilter(bfe_module.HandleFoundProduct, m.handleWaf)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init(): AddFilter(m.handleWaf): %v", m.name, err)
        }</span>

        <span class="cov8" title="1">err = web_monitor.RegisterHandlers(whs, web_monitor.WebHandleMonitor, m.monitorHandlers())
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init(): RegisterHandlers(m.monitorHandlers): %v", m.Name(), err)
        }</span>

        <span class="cov8" title="1">err = web_monitor.RegisterHandlers(whs, web_monitor.WebHandleReload, m.reloadHandlers())
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init(): RegisterHandlers(m.reloadHandlerr): %v", m.Name(), err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file187" style="display: none">// Copyright (c) 2020 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package mod_waf

import (
        "fmt"
)

import (
        "github.com/baidu/go-lib/log"
)

import (
        "github.com/bfenetworks/bfe/bfe_basic"
        "github.com/bfenetworks/bfe/bfe_modules/mod_waf/waf_rule"
)

type wafHandler struct {
        wafLogger *wafLogger // waf detail log in the waf logger

        wafTable *waf_rule.WafRuleTable // waf table, which do the check stuff
}

func NewWafHandler() *wafHandler <span class="cov8" title="1">{
        wh := new(wafHandler)
        return wh
}</span>

func (wh *wafHandler) Init(conf *ConfModWaf) error <span class="cov8" title="1">{
        wh.wafLogger = NewWafLogger()
        err := wh.wafLogger.Init(conf)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">wh.wafTable = waf_rule.NewWafRuleTable()
        wh.wafTable.Init()
        return err</span>
}

func (wh *wafHandler) HandleBlockJob(rule string, req *bfe_basic.Request) (bool, error) <span class="cov8" title="1">{
        if !waf_rule.IsValidRule(rule) </span><span class="cov0" title="0">{
                return false, fmt.Errorf("HandleBlockJob() err=unknown rule: %s", rule)
        }</span>
        <span class="cov8" title="1">job := NewWafJob(req, rule, BlockType)
        return wh.doJob(job)</span>
}

func (wh *wafHandler) HandleCheckJob(rule string, req *bfe_basic.Request) (bool, error) <span class="cov8" title="1">{
        if !waf_rule.IsValidRule(rule) </span><span class="cov0" title="0">{
                return false, fmt.Errorf("HandleCheckJob() err=unknown rule: %s", rule)
        }</span>
        <span class="cov8" title="1">job := NewWafJob(req, rule, CheckType)
        return wh.doJob(job)</span>
}

func (wh *wafHandler) doJob(job *wafJob) (bool, error) <span class="cov8" title="1">{
        wafRule, ok := wh.wafTable.GetRule(job.Rule)
        if !ok </span><span class="cov0" title="0">{
                return true, fmt.Errorf("wafHandler.doJob(), err=invalid rule %s", job.Rule)
        }</span>
        <span class="cov8" title="1">log.Logger.Debug("wafHandler.doJob() %v rule=%s", job.RuleRequest, job.Rule)
        hit := wafRule.Check(job.RuleRequest)
        job.SetHit(hit)
        wh.wafLogger.DumpLog(job)
        return hit, nil</span>
}
</pre>
		
		<pre class="file" id="file188" style="display: none">// Copyright (c) 2020 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package mod_waf

import (
        "github.com/bfenetworks/bfe/bfe_basic"
        "github.com/bfenetworks/bfe/bfe_modules/mod_waf/waf_rule"
        "github.com/bfenetworks/bfe/bfe_util/json"
)

const (
        CheckType = "Check" // check job is async job, which just check and log, but never block
        BlockType = "Block" // block job is sync job, which check, log and maybe block
)

type wafJob struct {
        Rule        string                    // rule name of this job
        Type        string                    // type of this job
        Hit         bool                      // is job hit rule
        RuleRequest *waf_rule.RuleRequestInfo // waf check request info
}

func NewWafJob(req *bfe_basic.Request, rule string, jtype string) *wafJob <span class="cov8" title="1">{
        wj := new(wafJob)
        wj.Rule = rule
        wj.Type = jtype
        wj.RuleRequest = waf_rule.NewRuleRequestInfo(req)
        return wj
}</span>

func (j *wafJob) SetHit(hit bool) <span class="cov8" title="1">{ j.Hit = hit }</span>

func (j *wafJob) String() string <span class="cov8" title="1">{
        bytes, _ := json.Marshal(*j)
        return string(bytes)
}</span>
</pre>
		
		<pre class="file" id="file189" style="display: none">// Copyright (c) 2020 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package mod_waf

import (
        "fmt"
)

import (
        "github.com/baidu/go-lib/log/log4go"
)

import (
        "github.com/bfenetworks/bfe/bfe_util/access_log"
)

type wafLogger struct {
        log log4go.Logger // wrapper log info
}

func NewWafLogger() *wafLogger <span class="cov8" title="1">{
        return new(wafLogger)
}</span>

func (wf *wafLogger) Init(conf *ConfModWaf) error <span class="cov8" title="1">{
        var err error
        // WAF LOG Demo:[2020/08/25 13:40:58 CST] [INFO] [69613] {"Rule":"RuleBashCmd","Type":"Block","Hit":true ...
        logFormatter := "[%D %T] [%L] [%P] %M"
        wf.log, err = access_log.LoggerInitWithFormat(conf.Log, logFormatter)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("WafLogger.Init(): create logger error:%v", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (wl *wafLogger) DumpLog(v interface{}) <span class="cov8" title="1">{
        wl.log.Info("%s", v)
}</span>
</pre>
		
		<pre class="file" id="file190" style="display: none">// Copyright (c) 2020 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/*
This rule is used to detect exploitation of "Shellshock" GNU Bash RCE vulnerability.
ModSecurity rule see: https://github.com/coreruleset/coreruleset/blob/v3.4/dev/rules/REQUEST-932-APPLICATION-ATTACK-RCE.conf

# [ Shellshock vulnerability (CVE-2014-6271 and CVE-2014-7169) ]
# Detect exploitation of "Shellshock" GNU Bash RCE vulnerability.
#
# Based on ModSecurity rules created by Red Hat.
#
SecRule REQUEST_HEADERS|REQUEST_LINE "@rx ^\(\s*\)\s+{" \
    "id:932170,\
    phase:2,\
    block,\
    capture,\
    t:none,t:urlDecode,\
    msg:'Remote Command Execution: Shellshock (CVE-2014-6271)',\
    logdata:'Matched Data: %{TX.0} found within %{MATCHED_VAR_NAME}: %{MATCHED_VAR}',\
    tag:'application-multi',\
    tag:'language-shell',\
    tag:'platform-unix',\
    tag:'attack-rce',\
    tag:'paranoia-level/1',\
    tag:'OWASP_CRS',\
    tag:'capec/1000/152/248/88',\
    tag:'PCI/6.5.2',\
    ctl:auditLogParts=+E,\
    ver:'OWASP_CRS/3.3.0',\
    severity:'CRITICAL',\
    setvar:'tx.rce_score=+%{tx.critical_anomaly_score}',\
    setvar:'tx.anomaly_score_pl1=+%{tx.critical_anomaly_score}'"

SecRule ARGS_NAMES|ARGS|FILES_NAMES "@rx ^\(\s*\)\s+{" \
    "id:932171,\
    phase:2,\
    block,\
    capture,\
    t:none,t:urlDecode,t:urlDecodeUni,\
    msg:'Remote Command Execution: Shellshock (CVE-2014-6271)',\
    logdata:'Matched Data: %{TX.0} found within %{MATCHED_VAR_NAME}: %{MATCHED_VAR}',\
    tag:'application-multi',\
    tag:'language-shell',\
    tag:'platform-unix',\
    tag:'attack-rce',\
    tag:'paranoia-level/1',\
    tag:'OWASP_CRS',\
    tag:'capec/1000/152/248/88',\
    tag:'PCI/6.5.2',\
    ctl:auditLogParts=+E,\
    ver:'OWASP_CRS/3.3.0',\
    severity:'CRITICAL',\
    setvar:'tx.rce_score=+%{tx.critical_anomaly_score}',\
    setvar:'tx.anomaly_score_pl1=+%{tx.critical_anomaly_score}'"
*/

package waf_rule

import "strings"

type RuleBashCmdExe struct {
}

func NewRuleBashCmdExe() *RuleBashCmdExe <span class="cov8" title="1">{
        rule := new(RuleBashCmdExe)
        return rule
}</span>

func (rule *RuleBashCmdExe) Init() error <span class="cov8" title="1">{
        return nil
}</span>

func (rule *RuleBashCmdExe) Check(req *RuleRequestInfo) bool <span class="cov0" title="0">{
        return ruleBashCmdExeCheck(req)
}</span>

func (rule *RuleBashCmdExe) CheckString(pStr *string) bool <span class="cov0" title="0">{
        return checkHeaderValue(*pStr)
}</span>

// checkSemicolon check if first non-space/tab char is ";"
func checkSemicolon(value string) bool <span class="cov8" title="1">{
        length := len(value)

        for i := 0; i &lt; length; i++ </span><span class="cov8" title="1">{
                if value[i] == ' ' || value[i] == '\t' </span><span class="cov8" title="1">{
                        continue</span>
                } else<span class="cov8" title="1"> if value[i] != ';' </span><span class="cov8" title="1">{
                        return false
                }</span> else<span class="cov8" title="1"> {
                        return true
                }</span>
        }

        <span class="cov8" title="1">return false</span>
}

// checkHeaderValueContent check if header value content matches the specific rules
func checkHeaderValueContent(value string) bool <span class="cov8" title="1">{
        index := strings.Index(value, "}")
        if index != -1 </span><span class="cov8" title="1">{
                if checkSemicolon(value[index+1:]) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        <span class="cov8" title="1">return false</span>
}

// checkSpecificChar check if value started with the specific char
func checkSpecificChar(value string, c string) (int, bool) <span class="cov8" title="1">{
        length := len(value)

        for i := 0; i &lt; length; i++ </span><span class="cov8" title="1">{
                if value[i] == ' ' || value[i] == '\t' </span><span class="cov8" title="1">{
                        continue</span>
                } else<span class="cov8" title="1"> if value[i] != c[0] </span><span class="cov8" title="1">{
                        return -1, false
                }</span> else<span class="cov8" title="1"> {
                        return i, true
                }</span>
        }

        <span class="cov8" title="1">return -1, false</span>
}

// checkHeaderValuePrefix check if header value matches "^\s+\(\s+\)\s+{"
func checkHeaderValuePrefix(value string) (int, bool) <span class="cov8" title="1">{
        var index, gIndex int
        var hit bool

        index, hit = checkSpecificChar(value[gIndex:], "(")
        if !hit </span><span class="cov8" title="1">{
                return -1, false
        }</span>

        <span class="cov8" title="1">gIndex += index + 1
        index, hit = checkSpecificChar(value[gIndex:], ")")
        if !hit </span><span class="cov8" title="1">{
                return -1, false
        }</span>

        <span class="cov8" title="1">gIndex += index + 1
        index, hit = checkSpecificChar(value[gIndex:], "{")
        if !hit </span><span class="cov8" title="1">{
                return -1, false
        }</span>

        <span class="cov8" title="1">gIndex += index
        return gIndex, true</span>
}

// checkHeaderValue check header value
func checkHeaderValue(value string) bool <span class="cov8" title="1">{
        index, hit := checkHeaderValuePrefix(value)
        if hit </span><span class="cov8" title="1">{
                if checkHeaderValueContent(value[index+1:]) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        <span class="cov8" title="1">return false</span>
}

func ruleBashCmdExeCheck(req *RuleRequestInfo) bool <span class="cov0" title="0">{
        for _, values := range req.Headers </span><span class="cov0" title="0">{
                for _, value := range values </span><span class="cov0" title="0">{
                        if checkHeaderValue(value) </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
        }

        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file191" style="display: none">// Copyright (c) 2020 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package waf_rule

import (
        "net/url"
)
import (
        "github.com/bfenetworks/bfe/bfe_basic"
)

type RuleRequestInfo struct {
        Method  string // "GET", "POST", "PUT", "DELETE"
        Version string // "HTTP_1_0", "HTTP_1_1"

        Headers map[string][]string //Header

        Uri        string   // uri
        UriUnquote string   // unquoted uri
        UriParsed  *url.URL // parsed uri

        QueryValues url.Values // parsed query string values
}

func NewRuleRequestInfo(req *bfe_basic.Request) *RuleRequestInfo <span class="cov0" title="0">{
        wj := new(RuleRequestInfo)
        wj.Method = req.HttpRequest.Method
        wj.Uri = req.HttpRequest.RequestURI
        wj.Headers = req.HttpRequest.Header

        wj.UriUnquote, _ = url.QueryUnescape(wj.Uri)
        wj.UriParsed, _ = url.Parse(wj.Uri)
        wj.QueryValues = wj.UriParsed.Query()
        return wj
}</span>
</pre>
		
		<pre class="file" id="file192" style="display: none">// Copyright (c) 2020 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package waf_rule

const (
        RuleBashCmd = "RuleBashCmd" // bash cmd
)

var implementedRule = map[string]WafRule{
        RuleBashCmd: NewRuleBashCmdExe(),
}

func IsValidRule(rule string) bool <span class="cov8" title="1">{
        _, ok := implementedRule[rule]
        return ok
}</span>

type WafRule interface {
        Init() error
        Check(req *RuleRequestInfo) bool
}

type WafRuleTable struct {
        rules map[string]WafRule // name to WafRule
}

func NewWafRuleTable() *WafRuleTable <span class="cov8" title="1">{
        wafRules := new(WafRuleTable)

        wafRules.rules = make(map[string]WafRule)
        return wafRules
}</span>

func (wr *WafRuleTable) Init() <span class="cov8" title="1">{
        for k, v := range implementedRule </span><span class="cov8" title="1">{
                wr.rules[k] = v
        }</span>
        <span class="cov8" title="1">for _, v := range wr.rules </span><span class="cov8" title="1">{
                v.Init()
        }</span>
}

func (wr *WafRuleTable) GetRule(ruleName string) (WafRule, bool) <span class="cov8" title="1">{
        rule, ok := wr.rules[ruleName]
        return rule, ok
}</span>
</pre>
		
		<pre class="file" id="file193" style="display: none">// Copyright (c) 2020 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package mod_waf

import (
        "fmt"
        "os"
)

import (
        "github.com/bfenetworks/bfe/bfe_basic/condition"
        "github.com/bfenetworks/bfe/bfe_modules/mod_waf/waf_rule"
        "github.com/bfenetworks/bfe/bfe_util/json"
)

type wafRule struct {
        Cond       condition.Condition
        BlockRules []string
        CheckRules []string
}

type ruleList []*wafRule

type productWafRule map[string]*ruleList

type productWafRuleConfig struct {
        Version string
        Config  productWafRule
}

type wafRuleFile struct {
        Cond       string
        BlockRules []string
        CheckRules []string
}

type ruleListFile []*wafRuleFile

type productWafRuleFile map[string]*ruleListFile

type productWafRuleConfigFile struct {
        Version *string
        Config  *productWafRuleFile
}

func wafRuleConvert(ruleFile *wafRuleFile) (*wafRule, error) <span class="cov8" title="1">{
        if ruleFile == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("wafRuleConvert(), err= empty ruleFile")
        }</span>
        <span class="cov8" title="1">var rule wafRule
        var err error
        rule.Cond, err = condition.Build(ruleFile.Cond)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">rule.BlockRules = make([]string, len(ruleFile.BlockRules))
        rule.CheckRules = make([]string, len(ruleFile.CheckRules))

        copy(rule.BlockRules, ruleFile.BlockRules)
        copy(rule.CheckRules, ruleFile.CheckRules)
        return &amp;rule, nil</span>
}

func productWafRuleConvert(prf *productWafRuleFile) (productWafRule, error) <span class="cov8" title="1">{
        wr := make(productWafRule)
        if prf == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ruleConvert(), err= empty productWafRuleFile")
        }</span>

        <span class="cov8" title="1">for product, fruleList := range *prf </span><span class="cov8" title="1">{
                rlist := make(ruleList, 0)
                for _, frule := range *fruleList </span><span class="cov8" title="1">{
                        rule, err := wafRuleConvert(frule)
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, fmt.Errorf("ruleConvert(), err=%s", err)
                        }</span>
                        <span class="cov8" title="1">rlist = append(rlist, rule)</span>
                }
                <span class="cov8" title="1">wr[product] = &amp;rlist</span>
        }
        <span class="cov8" title="1">return wr, nil</span>
}

func wafRuleFileCheck(conf *wafRuleFile) error <span class="cov8" title="1">{
        if conf == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("wafRuleFileCheck(), err=nil config")
        }</span>
        <span class="cov8" title="1">if len(conf.Cond) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("wafRuleFileCheck(), err=empty cond")
        }</span>
        <span class="cov8" title="1">if len(conf.BlockRules) == 0 &amp;&amp; len(conf.CheckRules) == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("wafRuleFileCheck(), err=block rules and check rule both empty")
        }</span>
        <span class="cov8" title="1">if len(conf.BlockRules) != 0 </span><span class="cov8" title="1">{
                for _, rule := range conf.BlockRules </span><span class="cov8" title="1">{
                        if !waf_rule.IsValidRule(rule) </span><span class="cov8" title="1">{
                                return fmt.Errorf("wafRuleFileCheck(), err:= unknow rule %s", rule)
                        }</span>
                }
        }
        <span class="cov8" title="1">if len(conf.CheckRules) != 0 </span><span class="cov8" title="1">{
                for _, rule := range conf.CheckRules </span><span class="cov8" title="1">{
                        if !waf_rule.IsValidRule(rule) </span><span class="cov8" title="1">{
                                return fmt.Errorf("wafRuleFileCheck(), err:= unknow rule %s", rule)
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

func ruleListFileCheck(conf *ruleListFile) error <span class="cov8" title="1">{
        if conf == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ruleListFileCheck(), err=nil config")
        }</span>
        <span class="cov8" title="1">for index, rule := range *conf </span><span class="cov8" title="1">{
                if err := wafRuleFileCheck(rule); err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("ruleListFileCheck(), err=%d, %s", index, err)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func productWafRuleFileCheck(conf *productWafRuleFile) error <span class="cov8" title="1">{
        if conf == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("productWafRuleFileCheck(), err=nil config")
        }</span>
        <span class="cov8" title="1">for product, ruleList := range *conf </span><span class="cov8" title="1">{
                if ruleList == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("productWafRuleFileCheck(), err=product[%s] has empty rulelist", product)
                }</span>
                <span class="cov8" title="1">err := ruleListFileCheck(ruleList)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func productWafRuleConfFileCheck(conf *productWafRuleConfigFile) error <span class="cov8" title="1">{
        if conf == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("productWafRuleConfFileCheck(), err=nil config")
        }</span>

        <span class="cov8" title="1">if conf.Version == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("productWafRuleConfFileCheck(), err=no version")
        }</span>
        <span class="cov8" title="1">if conf.Config == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("productWafRuleConfFileCheck(), err=no Config")
        }</span>

        <span class="cov8" title="1">return productWafRuleFileCheck(conf.Config)</span>
}

func ProductWafRuleConfLoad(fileName string) (productWafRuleConfig, error) <span class="cov8" title="1">{
        var conf productWafRuleConfig
        var fileConf productWafRuleConfigFile

        f, err := os.Open(fileName)
        if err != nil </span><span class="cov8" title="1">{
                return conf, fmt.Errorf("ProductWafRuleConfLoad(), err=%s", err)
        }</span>
        <span class="cov8" title="1">defer f.Close()
        err = json.NewDecoder(f).Decode(&amp;fileConf)
        if err != nil </span><span class="cov8" title="1">{
                return conf, fmt.Errorf("ProductWafRuleConfLoad(), err=%s", err)
        }</span>
        <span class="cov8" title="1">err = productWafRuleConfFileCheck(&amp;fileConf)
        if err != nil </span><span class="cov8" title="1">{
                return conf, fmt.Errorf("ProductWafRuleConfLoad(), err=%s", err)
        }</span>
        <span class="cov8" title="1">pwr, err := productWafRuleConvert(fileConf.Config)
        if err != nil </span><span class="cov8" title="1">{
                return conf, fmt.Errorf("ProductWafRuleConfLoad(), err=%s", err)
        }</span>
        <span class="cov8" title="1">conf.Version = *fileConf.Version
        conf.Config = pwr
        return conf, nil</span>
}
</pre>
		
		<pre class="file" id="file194" style="display: none">// Copyright (c) 2020 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package mod_waf

import "sync"

type WarRuleTable struct {
        lock        sync.RWMutex   // lock for following fields
        version     string         // version
        productRule productWafRule // rule
}

func NewWarRuleTable() *WarRuleTable <span class="cov8" title="1">{
        t := new(WarRuleTable)
        t.productRule = make(productWafRule)
        return t
}</span>

func (t *WarRuleTable) Update(ruleConf *productWafRuleConfig) <span class="cov8" title="1">{
        t.lock.Lock()
        t.version = ruleConf.Version
        t.productRule = ruleConf.Config
        t.lock.Unlock()
}</span>

func (t *WarRuleTable) Search(product string) (*ruleList, bool) <span class="cov8" title="1">{
        t.lock.RLock()
        ruleList, ok := t.productRule[product]
        t.lock.RUnlock()

        return ruleList, ok
}</span>
</pre>
		
		<pre class="file" id="file195" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Copyright 2010 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package textproto

// MIMEHeader represents a MIME-style header mapping
// keys to sets of values.
type MIMEHeader map[string][]string

// MIMEKeys represents keys of header in original order
type MIMEKeys []string

// Add adds the key, value pair to the header.
// It appends to any existing values associated with key.
func (h MIMEHeader) Add(key, value string) <span class="cov0" title="0">{
        key = CanonicalMIMEHeaderKey(key)
        h[key] = append(h[key], value)
}</span>

// Set sets the header entries associated with key to
// the single element value.  It replaces any existing
// values associated with key.
func (h MIMEHeader) Set(key, value string) <span class="cov0" title="0">{
        h[CanonicalMIMEHeaderKey(key)] = []string{value}
}</span>

// Get gets the first value associated with the given key.
// If there are no values associated with the key, Get returns "".
// Get is a convenience method.  For more complex queries,
// access the map directly.
func (h MIMEHeader) Get(key string) string <span class="cov8" title="1">{
        if h == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">v := h[CanonicalMIMEHeaderKey(key)]
        if len(v) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">return v[0]</span>
}

// Values returns all values associated with the given key.
// It is case-insensitive; CanonicalMIMEHeaderKey is
// used to canonicalize the provided key. To use non-canonical
// keys, access the map directly.
// The returned slice is not a copy.
func (h MIMEHeader) Values(key string) []string <span class="cov8" title="1">{
        if h == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return h[CanonicalMIMEHeaderKey(key)]</span>
}

// Del deletes the values associated with key.
func (h MIMEHeader) Del(key string) <span class="cov0" title="0">{
        delete(h, CanonicalMIMEHeaderKey(key))
}</span>
</pre>
		
		<pre class="file" id="file196" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Copyright 2010 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package textproto

import (
        "sync"
)

// A Pipeline manages a pipelined in-order request/response sequence.
//
// To use a Pipeline p to manage multiple clients on a connection,
// each client should run:
//
//        id := p.Next()        // take a number
//
//        p.StartRequest(id)        // wait for turn to send request
//        «send request»
//        p.EndRequest(id)        // notify Pipeline that request is sent
//
//        p.StartResponse(id)        // wait for turn to read response
//        «read response»
//        p.EndResponse(id)        // notify Pipeline that response is read
//
// A pipelined server can use the same calls to ensure that
// responses computed in parallel are written in the correct order.
type Pipeline struct {
        mu       sync.Mutex
        id       uint
        request  sequencer
        response sequencer
}

// Next returns the next id for a request/response pair.
func (p *Pipeline) Next() uint <span class="cov0" title="0">{
        p.mu.Lock()
        id := p.id
        p.id++
        p.mu.Unlock()
        return id
}</span>

// StartRequest blocks until it is time to send (or, if this is a server, receive)
// the request with the given id.
func (p *Pipeline) StartRequest(id uint) <span class="cov0" title="0">{
        p.request.Start(id)
}</span>

// EndRequest notifies p that the request with the given id has been sent
// (or, if this is a server, received).
func (p *Pipeline) EndRequest(id uint) <span class="cov0" title="0">{
        p.request.End(id)
}</span>

// StartResponse blocks until it is time to receive (or, if this is a server, send)
// the request with the given id.
func (p *Pipeline) StartResponse(id uint) <span class="cov0" title="0">{
        p.response.Start(id)
}</span>

// EndResponse notifies p that the response with the given id has been received
// (or, if this is a server, sent).
func (p *Pipeline) EndResponse(id uint) <span class="cov0" title="0">{
        p.response.End(id)
}</span>

// A sequencer schedules a sequence of numbered events that must
// happen in order, one after the other.  The event numbering must start
// at 0 and increment without skipping.  The event number wraps around
// safely as long as there are not 2^32 simultaneous events pending.
type sequencer struct {
        mu   sync.Mutex
        id   uint
        wait map[uint]chan struct{}
}

// Start waits until it is time for the event numbered id to begin.
// That is, except for the first event, it waits until End(id-1) has
// been called.
func (s *sequencer) Start(id uint) <span class="cov0" title="0">{
        s.mu.Lock()
        if s.id == id </span><span class="cov0" title="0">{
                s.mu.Unlock()
                return
        }</span>
        <span class="cov0" title="0">c := make(chan struct{})
        if s.wait == nil </span><span class="cov0" title="0">{
                s.wait = make(map[uint]chan struct{})
        }</span>
        <span class="cov0" title="0">s.wait[id] = c
        s.mu.Unlock()
        &lt;-c</span>
}

// End notifies the sequencer that the event numbered id has completed,
// allowing it to schedule the event numbered id+1.  It is a run-time error
// to call End with an id that is not the number of the active event.
func (s *sequencer) End(id uint) <span class="cov0" title="0">{
        s.mu.Lock()
        if s.id != id </span><span class="cov0" title="0">{
                s.mu.Unlock()
                panic("out of sync")</span>
        }
        <span class="cov0" title="0">id++
        s.id = id
        if s.wait == nil </span><span class="cov0" title="0">{
                s.wait = make(map[uint]chan struct{})
        }</span>
        <span class="cov0" title="0">c, ok := s.wait[id]
        if ok </span><span class="cov0" title="0">{
                delete(s.wait, id)
        }</span>
        <span class="cov0" title="0">s.mu.Unlock()
        if ok </span><span class="cov0" title="0">{
                close(c)
        }</span>
}
</pre>
		
		<pre class="file" id="file197" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Copyright 2010 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package textproto

import (
        "bytes"
        "io"
        "io/ioutil"
        "strconv"
        "strings"
        "sync"
)

import (
        "github.com/bfenetworks/bfe/bfe_bufio"
)

// A Reader implements convenience methods for reading requests
// or responses from a text protocol network connection.
type Reader struct {
        R   *bfe_bufio.Reader
        dot *dotReader
        buf []byte // a re-usable buffer for readContinuedLineSlice
}

// NewReader returns a new Reader reading from r.
//
// To avoid denial of service attacks, the provided bufio.Reader
// should be reading from an io.LimitReader or similar Reader to bound
// the size of responses.
func NewReader(r *bfe_bufio.Reader) *Reader <span class="cov8" title="1">{
        commonHeaderOnce.Do(initCommonHeader)
        return &amp;Reader{R: r}
}</span>

// ReadLine reads a single line from r,
// eliding the final \n or \r\n from the returned string.
func (r *Reader) ReadLine() (string, error) <span class="cov8" title="1">{
        line, err := r.readLineSlice()
        return string(line), err
}</span>

// ReadLineBytes is like ReadLine but returns a []byte instead of a string.
func (r *Reader) ReadLineBytes() ([]byte, error) <span class="cov0" title="0">{
        line, err := r.readLineSlice()
        if line != nil </span><span class="cov0" title="0">{
                buf := make([]byte, len(line))
                copy(buf, line)
                line = buf
        }</span>
        <span class="cov0" title="0">return line, err</span>
}

func (r *Reader) readLineSlice() ([]byte, error) <span class="cov8" title="1">{
        r.closeDot()
        var line []byte
        for </span><span class="cov8" title="1">{
                l, more, err := r.R.ReadLine()
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                // Avoid the copy if the first call produced a full line.
                <span class="cov8" title="1">if line == nil &amp;&amp; !more </span><span class="cov8" title="1">{
                        return l, nil
                }</span>
                <span class="cov8" title="1">line = append(line, l...)
                if !more </span><span class="cov8" title="1">{
                        break</span>
                }
        }
        <span class="cov8" title="1">return line, nil</span>
}

// ReadContinuedLine reads a possibly continued line from r,
// eliding the final trailing ASCII white space.
// Lines after the first are considered continuations if they
// begin with a space or tab character.  In the returned data,
// continuation lines are separated from the previous line
// only by a single space: the newline and leading white space
// are removed.
//
// For example, consider this input:
//
//        Line 1
//          continued...
//        Line 2
//
// The first call to ReadContinuedLine will return "Line 1 continued..."
// and the second will return "Line 2".
//
// A line consisting of only white space is never continued.
//
func (r *Reader) ReadContinuedLine() (string, error) <span class="cov8" title="1">{
        line, err := r.readContinuedLineSlice()
        return string(line), err
}</span>

// trim returns s with leading and trailing spaces and tabs removed.
// It does not assume Unicode or UTF-8.
func trim(s []byte) []byte <span class="cov8" title="1">{
        i := 0
        for i &lt; len(s) &amp;&amp; (s[i] == ' ' || s[i] == '\t') </span><span class="cov0" title="0">{
                i++
        }</span>
        <span class="cov8" title="1">n := len(s)
        for n &gt; i &amp;&amp; (s[n-1] == ' ' || s[n-1] == '\t') </span><span class="cov8" title="1">{
                n--
        }</span>
        <span class="cov8" title="1">return s[i:n]</span>
}

// ReadContinuedLineBytes is like ReadContinuedLine but
// returns a []byte instead of a string.
func (r *Reader) ReadContinuedLineBytes() ([]byte, error) <span class="cov0" title="0">{
        line, err := r.readContinuedLineSlice()
        if line != nil </span><span class="cov0" title="0">{
                buf := make([]byte, len(line))
                copy(buf, line)
                line = buf
        }</span>
        <span class="cov0" title="0">return line, err</span>
}

func (r *Reader) readContinuedLineSlice() ([]byte, error) <span class="cov8" title="1">{
        // Read the first line.
        line, err := r.readLineSlice()
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if len(line) == 0 </span><span class="cov8" title="1">{ // blank line - no continuation
                return line, nil
        }</span>

        // Optimistically assume that we have started to buffer the next line
        // and it starts with an ASCII letter (the next header key), or a blank
        // line, so we can avoid copying that buffered data around in memory
        // and skipping over non-existent whitespace.
        <span class="cov8" title="1">if r.R.Buffered() &gt; 1 </span><span class="cov8" title="1">{
                peek, _ := r.R.Peek(2)
                if len(peek) &gt; 0 &amp;&amp; (isASCIILetter(peek[0]) || peek[0] == '\n') ||
                        len(peek) == 2 &amp;&amp; peek[0] == '\r' &amp;&amp; peek[1] == '\n' </span><span class="cov8" title="1">{
                        return trim(line), nil
                }</span>
        }

        // ReadByte or the next readLineSlice will flush the read buffer;
        // copy the slice into buf.
        <span class="cov8" title="1">r.buf = append(r.buf[:0], trim(line)...)

        // Read continuation lines.
        for r.skipSpace() &gt; 0 </span><span class="cov8" title="1">{
                line, err := r.readLineSlice()
                if err != nil </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov8" title="1">r.buf = append(r.buf, ' ')
                r.buf = append(r.buf, trim(line)...)</span>
        }
        <span class="cov8" title="1">return r.buf, nil</span>
}

// skipSpace skips R over all spaces and returns the number of bytes skipped.
func (r *Reader) skipSpace() int <span class="cov8" title="1">{
        n := 0
        for </span><span class="cov8" title="1">{
                c, err := r.R.ReadByte()
                if err != nil </span><span class="cov8" title="1">{
                        // Bufio will keep err until next read.
                        break</span>
                }
                <span class="cov8" title="1">if c != ' ' &amp;&amp; c != '\t' </span><span class="cov8" title="1">{
                        r.R.UnreadByte()
                        break</span>
                }
                <span class="cov8" title="1">n++</span>
        }
        <span class="cov8" title="1">return n</span>
}

func (r *Reader) readCodeLine(expectCode int) (code int, continued bool, message string, err error) <span class="cov8" title="1">{
        line, err := r.ReadLine()
        if err != nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">return parseCodeLine(line, expectCode)</span>
}

func parseCodeLine(line string, expectCode int) (code int, continued bool, message string, err error) <span class="cov8" title="1">{
        if len(line) &lt; 4 || line[3] != ' ' &amp;&amp; line[3] != '-' </span><span class="cov8" title="1">{
                err = ProtocolError("short response: " + line)
                return
        }</span>
        <span class="cov8" title="1">continued = line[3] == '-'
        code, err = strconv.Atoi(line[0:3])
        if err != nil || code &lt; 100 </span><span class="cov0" title="0">{
                err = ProtocolError("invalid response code: " + line)
                return
        }</span>
        <span class="cov8" title="1">message = line[4:]
        if 1 &lt;= expectCode &amp;&amp; expectCode &lt; 10 &amp;&amp; code/100 != expectCode ||
                10 &lt;= expectCode &amp;&amp; expectCode &lt; 100 &amp;&amp; code/10 != expectCode ||
                100 &lt;= expectCode &amp;&amp; expectCode &lt; 1000 &amp;&amp; code != expectCode </span><span class="cov8" title="1">{
                err = &amp;Error{code, message}
        }</span>
        <span class="cov8" title="1">return</span>
}

// ReadCodeLine reads a response code line of the form
//        code message
// where code is a three-digit status code and the message
// extends to the rest of the line.  An example of such a line is:
//        220 plan9.bell-labs.com ESMTP
//
// If the prefix of the status does not match the digits in expectCode,
// ReadCodeLine returns with err set to &amp;Error{code, message}.
// For example, if expectCode is 31, an error will be returned if
// the status is not in the range [310,319].
//
// If the response is multi-line, ReadCodeLine returns an error.
//
// An expectCode &lt;= 0 disables the check of the status code.
//
func (r *Reader) ReadCodeLine(expectCode int) (code int, message string, err error) <span class="cov8" title="1">{
        code, continued, message, err := r.readCodeLine(expectCode)
        if err == nil &amp;&amp; continued </span><span class="cov0" title="0">{
                err = ProtocolError("unexpected multi-line response: " + message)
        }</span>
        <span class="cov8" title="1">return</span>
}

// ReadResponse reads a multi-line response of the form:
//
//        code-message line 1
//        code-message line 2
//        ...
//        code message line n
//
// where code is a three-digit status code. The first line starts with the
// code and a hyphen. The response is terminated by a line that starts
// with the same code followed by a space. Each line in message is
// separated by a newline (\n).
//
// See page 36 of RFC 959 (http://www.ietf.org/rfc/rfc959.txt) for
// details.
//
// If the prefix of the status does not match the digits in expectCode,
// ReadResponse returns with err set to &amp;Error{code, message}.
// For example, if expectCode is 31, an error will be returned if
// the status is not in the range [310,319].
//
// An expectCode &lt;= 0 disables the check of the status code.
//
func (r *Reader) ReadResponse(expectCode int) (code int, message string, err error) <span class="cov8" title="1">{
        code, continued, message, err := r.readCodeLine(expectCode)
        for err == nil &amp;&amp; continued </span><span class="cov8" title="1">{
                line, err := r.ReadLine()
                if err != nil </span><span class="cov0" title="0">{
                        return 0, "", err
                }</span>

                <span class="cov8" title="1">var code2 int
                var moreMessage string
                code2, continued, moreMessage, err = parseCodeLine(line, expectCode)
                if err != nil || code2 != code </span><span class="cov8" title="1">{
                        message += "\n" + strings.TrimRight(line, "\r\n")
                        continued = true
                        continue</span>
                }
                <span class="cov8" title="1">message += "\n" + moreMessage</span>
        }
        <span class="cov8" title="1">return</span>
}

// DotReader returns a new Reader that satisfies Reads using the
// decoded text of a dot-encoded block read from r.
// The returned Reader is only valid until the next call
// to a method on r.
//
// Dot encoding is a common framing used for data blocks
// in text protocols such as SMTP.  The data consists of a sequence
// of lines, each of which ends in "\r\n".  The sequence itself
// ends at a line containing just a dot: ".\r\n".  Lines beginning
// with a dot are escaped with an additional dot to avoid
// looking like the end of the sequence.
//
// The decoded form returned by the Reader's Read method
// rewrites the "\r\n" line endings into the simpler "\n",
// removes leading dot escapes if present, and stops with error io.EOF
// after consuming (and discarding) the end-of-sequence line.
func (r *Reader) DotReader() io.Reader <span class="cov8" title="1">{
        r.closeDot()
        r.dot = &amp;dotReader{r: r}
        return r.dot
}</span>

type dotReader struct {
        r     *Reader
        state int
}

// Read satisfies reads by decoding dot-encoded data read from d.r.
func (d *dotReader) Read(b []byte) (n int, err error) <span class="cov8" title="1">{
        // Run data through a simple state machine to
        // elide leading dots, rewrite trailing \r\n into \n,
        // and detect ending .\r\n line.
        const (
                stateBeginLine = iota // beginning of line; initial state; must be zero
                stateDot              // read . at beginning of line
                stateDotCR            // read .\r at beginning of line
                stateCR               // read \r (possibly at end of line)
                stateData             // reading data in middle of line
                stateEOF              // reached .\r\n end marker line
        )
        br := d.r.R
        for n &lt; len(b) &amp;&amp; d.state != stateEOF </span><span class="cov8" title="1">{
                var c byte
                c, err = br.ReadByte()
                if err != nil </span><span class="cov8" title="1">{
                        if err == io.EOF </span><span class="cov8" title="1">{
                                err = io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">break</span>
                }
                <span class="cov8" title="1">switch d.state </span>{
                case stateBeginLine:<span class="cov8" title="1">
                        if c == '.' </span><span class="cov8" title="1">{
                                d.state = stateDot
                                continue</span>
                        }
                        <span class="cov8" title="1">if c == '\r' </span><span class="cov8" title="1">{
                                d.state = stateCR
                                continue</span>
                        }
                        <span class="cov8" title="1">d.state = stateData</span>

                case stateDot:<span class="cov8" title="1">
                        if c == '\r' </span><span class="cov8" title="1">{
                                d.state = stateDotCR
                                continue</span>
                        }
                        <span class="cov8" title="1">if c == '\n' </span><span class="cov0" title="0">{
                                d.state = stateEOF
                                continue</span>
                        }
                        <span class="cov8" title="1">d.state = stateData</span>

                case stateDotCR:<span class="cov8" title="1">
                        if c == '\n' </span><span class="cov8" title="1">{
                                d.state = stateEOF
                                continue</span>
                        }
                        // Not part of .\r\n.
                        // Consume leading dot and emit saved \r.
                        <span class="cov0" title="0">br.UnreadByte()
                        c = '\r'
                        d.state = stateData</span>

                case stateCR:<span class="cov8" title="1">
                        if c == '\n' </span><span class="cov8" title="1">{
                                d.state = stateBeginLine
                                break</span>
                        }
                        // Not part of \r\n.  Emit saved \r
                        <span class="cov0" title="0">br.UnreadByte()
                        c = '\r'
                        d.state = stateData</span>

                case stateData:<span class="cov8" title="1">
                        if c == '\r' </span><span class="cov8" title="1">{
                                d.state = stateCR
                                continue</span>
                        }
                        <span class="cov8" title="1">if c == '\n' </span><span class="cov8" title="1">{
                                d.state = stateBeginLine
                        }</span>
                }
                <span class="cov8" title="1">b[n] = c
                n++</span>
        }
        <span class="cov8" title="1">if err == nil &amp;&amp; d.state == stateEOF </span><span class="cov8" title="1">{
                err = io.EOF
        }</span>
        <span class="cov8" title="1">if err != nil &amp;&amp; d.r.dot == d </span><span class="cov8" title="1">{
                d.r.dot = nil
        }</span>
        <span class="cov8" title="1">return</span>
}

// closeDot drains the current DotReader if any,
// making sure that it reads until the ending dot line.
func (r *Reader) closeDot() <span class="cov8" title="1">{
        if r.dot == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov0" title="0">buf := make([]byte, 128)
        for r.dot != nil </span><span class="cov0" title="0">{
                // When Read reaches EOF or an error,
                // it will set r.dot == nil.
                r.dot.Read(buf)
        }</span>
}

// ReadDotBytes reads a dot-encoding and returns the decoded data.
//
// See the documentation for the DotReader method for details about dot-encoding.
func (r *Reader) ReadDotBytes() ([]byte, error) <span class="cov8" title="1">{
        return ioutil.ReadAll(r.DotReader())
}</span>

// ReadDotLines reads a dot-encoding and returns a slice
// containing the decoded lines, with the final \r\n or \n elided from each.
//
// See the documentation for the DotReader method for details about dot-encoding.
func (r *Reader) ReadDotLines() ([]string, error) <span class="cov8" title="1">{
        // We could use ReadDotBytes and then Split it,
        // but reading a line at a time avoids needing a
        // large contiguous block of memory and is simpler.
        var v []string
        var err error
        for </span><span class="cov8" title="1">{
                var line string
                line, err = r.ReadLine()
                if err != nil </span><span class="cov8" title="1">{
                        if err == io.EOF </span><span class="cov8" title="1">{
                                err = io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">break</span>
                }

                // Dot by itself marks end; otherwise cut one dot.
                <span class="cov8" title="1">if len(line) &gt; 0 &amp;&amp; line[0] == '.' </span><span class="cov8" title="1">{
                        if len(line) == 1 </span><span class="cov8" title="1">{
                                break</span>
                        }
                        <span class="cov8" title="1">line = line[1:]</span>
                }
                <span class="cov8" title="1">v = append(v, line)</span>
        }
        <span class="cov8" title="1">return v, err</span>
}

// ReadMIMEHeader reads a MIME-style header from r.
// The header is a sequence of possibly continued Key: Value lines
// ending in a blank line.
// The returned map m maps CanonicalMIMEHeaderKey(key) to a
// sequence of values in the same order encountered in the input.
//
// For example, consider this input:
//
//        My-Key: Value 1
//        Long-Key: Even
//               Longer Value
//        My-Key: Value 2
//
// Given that input, ReadMIMEHeader returns the map:
//
//        map[string][]string{
//                "My-Key": {"Value 1", "Value 2"},
//                "Long-Key": {"Even Longer Value"},
//        }
//
func (r *Reader) ReadMIMEHeader() (MIMEHeader, error) <span class="cov8" title="1">{
        header, _, err := r.ReadMIMEHeaderAndKeys()
        return header, err
}</span>

func (r *Reader) ReadMIMEHeaderAndKeys() (MIMEHeader, MIMEKeys, error) <span class="cov8" title="1">{
        // Avoid lots of small slice allocations later by allocating one
        // large one ahead of time which we'll cut up into smaller
        // slices. If this isn't big enough later, we allocate small ones.
        var strs []string
        hint := r.upcomingHeaderNewlines()
        if hint &gt; 0 </span><span class="cov8" title="1">{
                // Note: Avoid additional allocations caused by header
                // modification from application layer
                hint += 10
                strs = make([]string, hint)
        }</span>

        <span class="cov8" title="1">m := make(MIMEHeader, hint)
        mkeys := make(MIMEKeys, 0, hint)
        for </span><span class="cov8" title="1">{
                kv, err := r.readContinuedLineSlice()
                if len(kv) == 0 </span><span class="cov8" title="1">{
                        return m, mkeys, err
                }</span>

                // Key ends at first colon.
                <span class="cov8" title="1">i := bytes.IndexByte(kv, ':')
                if i &lt; 0 </span><span class="cov0" title="0">{
                        return m, mkeys, ProtocolError("malformed MIME header line: " + string(kv))
                }</span>
                <span class="cov8" title="1">key := canonicalMIMEHeaderKey(kv[:i])

                // As per RFC 7230 field-name is a token, tokens consist of one or more chars.
                // We could return a ProtocolError here, but better to be liberal in what we
                // accept, so if we get an empty key, skip it.
                if key == "" </span><span class="cov8" title="1">{
                        continue</span>
                }

                // Skip initial spaces in value.
                <span class="cov8" title="1">i++ // skip colon
                for i &lt; len(kv) &amp;&amp; (kv[i] == ' ' || kv[i] == '\t') </span><span class="cov8" title="1">{
                        i++
                }</span>
                <span class="cov8" title="1">value := string(kv[i:])

                vv := m[key]
                if vv == nil &amp;&amp; len(strs) &gt; 0 </span><span class="cov8" title="1">{
                        // More than likely this will be a single-element key.
                        // Most headers aren't multi-valued.
                        // Set the capacity on strs[0] to 1, so any future append
                        // won't extend the slice into the other strings.
                        vv, strs = strs[:1:1], strs[1:]
                        vv[0] = value
                        m[key] = vv
                }</span> else<span class="cov8" title="1"> {
                        m[key] = append(vv, value)
                }</span>

                // append key in original order
                <span class="cov8" title="1">mkeys = append(mkeys, key)

                if err != nil </span><span class="cov0" title="0">{
                        return m, mkeys, err
                }</span>
        }
}

// upcomingHeaderNewlines returns an approximation of the number of newlines
// that will be in this header. If it gets confused, it returns 0.
func (r *Reader) upcomingHeaderNewlines() (n int) <span class="cov8" title="1">{
        // Try to determine the 'hint' size.
        r.R.Peek(1) // force a buffer load if empty
        s := r.R.Buffered()
        if s == 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">peek, _ := r.R.Peek(s)
        for len(peek) &gt; 0 </span><span class="cov8" title="1">{
                i := bytes.IndexByte(peek, '\n')
                if i &lt; 3 </span><span class="cov8" title="1">{
                        // Not present (-1) or found within the next few bytes,
                        // implying we're at the end ("\r\n\r\n" or "\n\n")
                        return
                }</span>
                <span class="cov8" title="1">n++
                peek = peek[i+1:]</span>
        }
        <span class="cov0" title="0">return</span>
}

// CanonicalMIMEHeaderKey returns the canonical format of the
// MIME header key s.  The canonicalization converts the first
// letter and any letter following a hyphen to upper case;
// the rest are converted to lowercase.  For example, the
// canonical key for "accept-encoding" is "Accept-Encoding".
// MIME header keys are assumed to be ASCII only.
func CanonicalMIMEHeaderKey(s string) string <span class="cov8" title="1">{
        commonHeaderOnce.Do(initCommonHeader)

        // Quick check for canonical encoding.
        upper := true
        for i := 0; i &lt; len(s); i++ </span><span class="cov8" title="1">{
                c := s[i]
                if !validHeaderFieldByte(c) </span><span class="cov8" title="1">{
                        return s
                }</span>
                <span class="cov8" title="1">if upper &amp;&amp; 'a' &lt;= c &amp;&amp; c &lt;= 'z' </span><span class="cov8" title="1">{
                        return canonicalMIMEHeaderKey([]byte(s))
                }</span>
                <span class="cov8" title="1">if !upper &amp;&amp; 'A' &lt;= c &amp;&amp; c &lt;= 'Z' </span><span class="cov8" title="1">{
                        return canonicalMIMEHeaderKey([]byte(s))
                }</span>
                <span class="cov8" title="1">upper = c == '-'</span>
        }
        <span class="cov8" title="1">return s</span>
}

func canonicalMIMEHeaderKey(a []byte) string <span class="cov8" title="1">{
        return canonicalMIMEHeaderKeyOriginal(a)
}</span>

const toLower = 'a' - 'A'

// validHeaderFieldByte reports whether b is a valid byte in a header
// field name. RFC 7230 says:
//   header-field   = field-name ":" OWS field-value OWS
//   field-name     = token
//   tchar = "!" / "#" / "$" / "%" / "&amp;" / "'" / "*" / "+" / "-" / "." /
//           "^" / "_" / "`" / "|" / "~" / DIGIT / ALPHA
//   token = 1*tchar
func validHeaderFieldByte(b byte) bool <span class="cov8" title="1">{
        return int(b) &lt; len(isTokenTable) &amp;&amp; isTokenTable[b]
}</span>

// canonicalMIMEHeaderKey is like CanonicalMIMEHeaderKey but is
// allowed to mutate the provided byte slice before returning the
// string.
func canonicalMIMEHeaderKeyOriginal(a []byte) string <span class="cov8" title="1">{
        // Look for it in commonHeaders , so that we can avoid an
        // allocation by sharing the strings among all users
        // of textproto. If we don't find it, a has been canonicalized
        // so just return string(a).
        // See if a looks like a header key. If not, return it unchanged.
        for _, c := range a </span><span class="cov8" title="1">{
                if validHeaderFieldByte(c) </span><span class="cov8" title="1">{
                        continue</span>
                }
                // Don't canonicalize.
                <span class="cov8" title="1">return string(a)</span>
        }

        <span class="cov8" title="1">upper := true
        for i, c := range a </span><span class="cov8" title="1">{
                // Canonicalize: first letter upper case
                // and upper case after each dash.
                // (Host, User-Agent, If-Modified-Since).
                // MIME headers are ASCII only, so no Unicode issues.
                if upper &amp;&amp; 'a' &lt;= c &amp;&amp; c &lt;= 'z' </span><span class="cov8" title="1">{
                        c -= toLower
                }</span> else<span class="cov8" title="1"> if !upper &amp;&amp; 'A' &lt;= c &amp;&amp; c &lt;= 'Z' </span><span class="cov8" title="1">{
                        c += toLower
                }</span>
                <span class="cov8" title="1">a[i] = c
                upper = c == '-'</span> // for next time

        }
        <span class="cov8" title="1">if v := commonHeader[string(a)]; v != "" </span><span class="cov8" title="1">{
                return v
        }</span>
        <span class="cov8" title="1">return string(a)</span>
}

// commonHeader interns common header strings.
var commonHeader map[string]string

var commonHeaderOnce sync.Once

func initCommonHeader() <span class="cov8" title="1">{
        commonHeader = make(map[string]string)
        for _, v := range []string{
                "Accept",
                "Accept-Charset",
                "Accept-Encoding",
                "Accept-Language",
                "Accept-Ranges",
                "Cache-Control",
                "Cc",
                "Connection",
                "Content-Id",
                "Content-Language",
                "Content-Length",
                "Content-Transfer-Encoding",
                "Content-Type",
                "Cookie",
                "Date",
                "Dkim-Signature",
                "Etag",
                "Expires",
                "From",
                "Host",
                "If-Modified-Since",
                "If-None-Match",
                "In-Reply-To",
                "Last-Modified",
                "Location",
                "Message-Id",
                "Mime-Version",
                "Pragma",
                "Received",
                "Return-Path",
                "Server",
                "Set-Cookie",
                "Subject",
                "To",
                "User-Agent",
                "Via",
                "X-Forwarded-For",
                "X-Imforwards",
                "X-Powered-By",
        } </span><span class="cov8" title="1">{
                commonHeader[v] = v
        }</span>
}

// isTokenTable is a copy of net/http/lex.go's isTokenTable.
// See https://httpwg.github.io/specs/rfc7230.html#rule.token.separators
var isTokenTable = [127]bool{
        '!':  true,
        '#':  true,
        '$':  true,
        '%':  true,
        '&amp;':  true,
        '\'': true,
        '*':  true,
        '+':  true,
        '-':  true,
        '.':  true,
        '0':  true,
        '1':  true,
        '2':  true,
        '3':  true,
        '4':  true,
        '5':  true,
        '6':  true,
        '7':  true,
        '8':  true,
        '9':  true,
        'A':  true,
        'B':  true,
        'C':  true,
        'D':  true,
        'E':  true,
        'F':  true,
        'G':  true,
        'H':  true,
        'I':  true,
        'J':  true,
        'K':  true,
        'L':  true,
        'M':  true,
        'N':  true,
        'O':  true,
        'P':  true,
        'Q':  true,
        'R':  true,
        'S':  true,
        'T':  true,
        'U':  true,
        'W':  true,
        'V':  true,
        'X':  true,
        'Y':  true,
        'Z':  true,
        '^':  true,
        '_':  true,
        '`':  true,
        'a':  true,
        'b':  true,
        'c':  true,
        'd':  true,
        'e':  true,
        'f':  true,
        'g':  true,
        'h':  true,
        'i':  true,
        'j':  true,
        'k':  true,
        'l':  true,
        'm':  true,
        'n':  true,
        'o':  true,
        'p':  true,
        'q':  true,
        'r':  true,
        's':  true,
        't':  true,
        'u':  true,
        'v':  true,
        'w':  true,
        'x':  true,
        'y':  true,
        'z':  true,
        '|':  true,
        '~':  true,
}
</pre>
		
		<pre class="file" id="file198" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Copyright 2010 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Package textproto implements generic support for text-based request/response
// protocols in the style of HTTP, NNTP, and SMTP.
//
// The package provides:
//
// Error, which represents a numeric error response from
// a server.
//
// Pipeline, to manage pipelined requests and responses
// in a client.
//
// Reader, to read numeric response code lines,
// key: value headers, lines wrapped with leading spaces
// on continuation lines, and whole text blocks ending
// with a dot on a line by itself.
//
// Writer, to write dot-encoded text blocks.
//
// Conn, a convenient packaging of Reader, Writer, and Pipeline for use
// with a single network connection.
//
package textproto

import (
        "fmt"
        "io"
        "net"
)

import (
        "github.com/bfenetworks/bfe/bfe_bufio"
)

// An Error represents a numeric error response from a server.
type Error struct {
        Code int
        Msg  string
}

func (e *Error) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("%03d %s", e.Code, e.Msg)
}</span>

// A ProtocolError describes a protocol violation such
// as an invalid response or a hung-up connection.
type ProtocolError string

func (p ProtocolError) Error() string <span class="cov0" title="0">{
        return string(p)
}</span>

// A Conn represents a textual network protocol connection.
// It consists of a Reader and Writer to manage I/O
// and a Pipeline to sequence concurrent requests on the connection.
// These embedded types carry methods with them;
// see the documentation of those types for details.
type Conn struct {
        Reader
        Writer
        Pipeline
        conn io.ReadWriteCloser
}

// NewConn returns a new Conn using conn for I/O.
func NewConn(conn io.ReadWriteCloser) *Conn <span class="cov0" title="0">{
        return &amp;Conn{
                Reader: Reader{R: bfe_bufio.NewReader(conn)},
                Writer: Writer{W: bfe_bufio.NewWriter(conn)},
                conn:   conn,
        }
}</span>

// Close closes the connection.
func (c *Conn) Close() error <span class="cov0" title="0">{
        return c.conn.Close()
}</span>

// Dial connects to the given address on the given network using net.Dial
// and then returns a new Conn for the connection.
func Dial(network, addr string) (*Conn, error) <span class="cov0" title="0">{
        c, err := net.Dial(network, addr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return NewConn(c), nil</span>
}

// Cmd is a convenience method that sends a command after
// waiting its turn in the pipeline.  The command text is the
// result of formatting format with args and appending \r\n.
// Cmd returns the id of the command, for use with StartResponse and EndResponse.
//
// For example, a client might run a HELP command that returns a dot-body
// by using:
//
//        id, err := c.Cmd("HELP")
//        if err != nil {
//                return nil, err
//        }
//
//        c.StartResponse(id)
//        defer c.EndResponse(id)
//
//        if _, _, err = c.ReadCodeLine(110); err != nil {
//                return nil, err
//        }
//        text, err := c.ReadDotBytes()
//        if err != nil {
//                return nil, err
//        }
//        return c.ReadCodeLine(250)
//
func (c *Conn) Cmd(format string, args ...interface{}) (id uint, err error) <span class="cov0" title="0">{
        id = c.Next()
        c.StartRequest(id)
        err = c.PrintfLine(format, args...)
        c.EndRequest(id)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">return id, nil</span>
}

// TrimString returns s without leading and trailing ASCII space.
func TrimString(s string) string <span class="cov0" title="0">{
        for len(s) &gt; 0 &amp;&amp; isASCIISpace(s[0]) </span><span class="cov0" title="0">{
                s = s[1:]
        }</span>
        <span class="cov0" title="0">for len(s) &gt; 0 &amp;&amp; isASCIISpace(s[len(s)-1]) </span><span class="cov0" title="0">{
                s = s[:len(s)-1]
        }</span>
        <span class="cov0" title="0">return s</span>
}

// TrimBytes returns b without leading and trailing ASCII space.
func TrimBytes(b []byte) []byte <span class="cov0" title="0">{
        for len(b) &gt; 0 &amp;&amp; isASCIISpace(b[0]) </span><span class="cov0" title="0">{
                b = b[1:]
        }</span>
        <span class="cov0" title="0">for len(b) &gt; 0 &amp;&amp; isASCIISpace(b[len(b)-1]) </span><span class="cov0" title="0">{
                b = b[:len(b)-1]
        }</span>
        <span class="cov0" title="0">return b</span>
}

func isASCIISpace(b byte) bool <span class="cov0" title="0">{
        return b == ' ' || b == '\t' || b == '\n' || b == '\r'
}</span>

func isASCIILetter(b byte) bool <span class="cov8" title="1">{
        b |= 0x20 // make lower case
        return 'a' &lt;= b &amp;&amp; b &lt;= 'z'
}</span>
</pre>
		
		<pre class="file" id="file199" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Copyright 2010 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package textproto

import (
        "fmt"
        "io"
)

import (
        "github.com/bfenetworks/bfe/bfe_bufio"
)

// A Writer implements convenience methods for writing
// requests or responses to a text protocol network connection.
type Writer struct {
        W   *bfe_bufio.Writer
        dot *dotWriter
}

// NewWriter returns a new Writer writing to w.
func NewWriter(w *bfe_bufio.Writer) *Writer <span class="cov8" title="1">{
        return &amp;Writer{W: w}
}</span>

var crnl = []byte{'\r', '\n'}
var dotcrnl = []byte{'.', '\r', '\n'}

// PrintfLine writes the formatted output followed by \r\n.
func (w *Writer) PrintfLine(format string, args ...interface{}) error <span class="cov8" title="1">{
        w.closeDot()
        fmt.Fprintf(w.W, format, args...)
        w.W.Write(crnl)
        return w.W.Flush()
}</span>

// DotWriter returns a writer that can be used to write a dot-encoding to w.
// It takes care of inserting leading dots when necessary,
// translating line-ending \n into \r\n, and adding the final .\r\n line
// when the DotWriter is closed.  The caller should close the
// DotWriter before the next call to a method on w.
//
// See the documentation for Reader's DotReader method for details about dot-encoding.
func (w *Writer) DotWriter() io.WriteCloser <span class="cov8" title="1">{
        w.closeDot()
        w.dot = &amp;dotWriter{w: w}
        return w.dot
}</span>

func (w *Writer) closeDot() <span class="cov8" title="1">{
        if w.dot != nil </span><span class="cov0" title="0">{
                w.dot.Close() // sets w.dot = nil
        }</span>
}

type dotWriter struct {
        w     *Writer
        state int
}

const (
        wstateBegin     = iota // initial state; must be zero
        wstateBeginLine        // beginning of line
        wstateCR               // wrote \r (possibly at end of line)
        wstateData             // writing data in middle of line
)

func (d *dotWriter) Write(b []byte) (n int, err error) <span class="cov8" title="1">{
        bw := d.w.W
        for n &lt; len(b) </span><span class="cov8" title="1">{
                c := b[n]
                switch d.state </span>{
                case wstateBegin, wstateBeginLine:<span class="cov8" title="1">
                        d.state = wstateData
                        if c == '.' </span><span class="cov8" title="1">{
                                // escape leading dot
                                bw.WriteByte('.')
                        }</span>
                        <span class="cov8" title="1">fallthrough</span>

                case wstateData:<span class="cov8" title="1">
                        if c == '\r' </span><span class="cov0" title="0">{
                                d.state = wstateCR
                        }</span>
                        <span class="cov8" title="1">if c == '\n' </span><span class="cov8" title="1">{
                                bw.WriteByte('\r')
                                d.state = wstateBeginLine
                        }</span>

                case wstateCR:<span class="cov0" title="0">
                        d.state = wstateData
                        if c == '\n' </span><span class="cov0" title="0">{
                                d.state = wstateBeginLine
                        }</span>
                }
                <span class="cov8" title="1">if err = bw.WriteByte(c); err != nil </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov8" title="1">n++</span>
        }
        <span class="cov8" title="1">return</span>
}

func (d *dotWriter) Close() error <span class="cov8" title="1">{
        if d.w.dot == d </span><span class="cov8" title="1">{
                d.w.dot = nil
        }</span>
        <span class="cov8" title="1">bw := d.w.W
        switch d.state </span>{
        default:<span class="cov8" title="1">
                bw.WriteByte('\r')
                fallthrough</span>
        case wstateCR:<span class="cov8" title="1">
                bw.WriteByte('\n')
                fallthrough</span>
        case wstateBeginLine:<span class="cov8" title="1">
                bw.Write(dotcrnl)</span>
        }
        <span class="cov8" title="1">return bw.Flush()</span>
}
</pre>
		
		<pre class="file" id="file200" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Copyright (c) pires.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package bfe_proxy

// AddressFamilyAndProtocol represents address family and transport protocol.
type AddressFamilyAndProtocol byte

const (
        UNSPEC       = '\x00'
        TCPv4        = '\x11'
        UDPv4        = '\x12'
        TCPv6        = '\x21'
        UDPv6        = '\x22'
        UnixStream   = '\x31'
        UnixDatagram = '\x32'
)

var supportedTransportProtocol = map[AddressFamilyAndProtocol]bool{
        TCPv4:        true,
        UDPv4:        true,
        TCPv6:        true,
        UDPv6:        true,
        UnixStream:   true,
        UnixDatagram: true,
}

// IsIPv4 returns true if the address family is IPv4 (AF_INET4), false otherwise.
func (ap AddressFamilyAndProtocol) IsIPv4() bool <span class="cov8" title="1">{
        return 0x10 == ap&amp;0xF0
}</span>

// IsIPv6 returns true if the address family is IPv6 (AF_INET6), false otherwise.
func (ap AddressFamilyAndProtocol) IsIPv6() bool <span class="cov8" title="1">{
        return 0x20 == ap&amp;0xF0
}</span>

// IsUnix returns true if the address family is UNIX (AF_UNIX), false otherwise.
func (ap AddressFamilyAndProtocol) IsUnix() bool <span class="cov8" title="1">{
        return 0x30 == ap&amp;0xF0
}</span>

// IsStream returns true if the transport protocol is TCP or STREAM (SOCK_STREAM), false otherwise.
func (ap AddressFamilyAndProtocol) IsStream() bool <span class="cov8" title="1">{
        return 0x01 == ap&amp;0x0F
}</span>

// IsDatagram returns true if the transport protocol is UDP or DGRAM (SOCK_DGRAM), false otherwise.
func (ap AddressFamilyAndProtocol) IsDatagram() bool <span class="cov8" title="1">{
        return 0x02 == ap&amp;0x0F
}</span>

// IsUnspec returns true if the transport protocol or address family is unspecified, false otherwise.
func (ap AddressFamilyAndProtocol) IsUnspec() bool <span class="cov8" title="1">{
        return (0x00 == ap&amp;0xF0) || (0x00 == ap&amp;0x0F)
}</span>

func (ap AddressFamilyAndProtocol) toByte() byte <span class="cov8" title="1">{
        if ap.IsIPv4() &amp;&amp; ap.IsStream() </span><span class="cov8" title="1">{
                return TCPv4
        }</span> else<span class="cov8" title="1"> if ap.IsIPv4() &amp;&amp; ap.IsDatagram() </span><span class="cov8" title="1">{
                return UDPv4
        }</span> else<span class="cov8" title="1"> if ap.IsIPv6() &amp;&amp; ap.IsStream() </span><span class="cov8" title="1">{
                return TCPv6
        }</span> else<span class="cov8" title="1"> if ap.IsIPv6() &amp;&amp; ap.IsDatagram() </span><span class="cov8" title="1">{
                return UDPv6
        }</span> else<span class="cov8" title="1"> if ap.IsUnix() &amp;&amp; ap.IsStream() </span><span class="cov8" title="1">{
                return UnixStream
        }</span> else<span class="cov8" title="1"> if ap.IsUnix() &amp;&amp; ap.IsDatagram() </span><span class="cov8" title="1">{
                return UnixDatagram
        }</span>

        <span class="cov8" title="1">return UNSPEC</span>
}

func (ap AddressFamilyAndProtocol) String() string <span class="cov8" title="1">{
        if ap.IsIPv4() &amp;&amp; ap.IsStream() </span><span class="cov8" title="1">{
                return "tcp4"
        }</span> else<span class="cov8" title="1"> if ap.IsIPv4() &amp;&amp; ap.IsDatagram() </span><span class="cov8" title="1">{
                return "udp4"
        }</span> else<span class="cov8" title="1"> if ap.IsIPv6() &amp;&amp; ap.IsStream() </span><span class="cov8" title="1">{
                return "tcp6"
        }</span> else<span class="cov8" title="1"> if ap.IsIPv6() &amp;&amp; ap.IsDatagram() </span><span class="cov8" title="1">{
                return "udp6"
        }</span> else<span class="cov8" title="1"> if ap.IsUnix() &amp;&amp; ap.IsStream() </span><span class="cov8" title="1">{
                return "unix"
        }</span> else<span class="cov8" title="1"> if ap.IsUnix() &amp;&amp; ap.IsDatagram() </span><span class="cov8" title="1">{
                return "unixgram"
        }</span>
        <span class="cov8" title="1">return "unspec"</span>
}
</pre>
		
		<pre class="file" id="file201" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Copyright (c) pires.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package bfe_proxy

import (
        "github.com/baidu/go-lib/web-monitor/metrics"
)

// ProxyState is State for Proxy
type ProxyState struct {
        ProxyErrReadHeader      *metrics.Counter // connection with io err while read header
        ProxyErrNoProxyProtocol *metrics.Counter // connection with signature unmatched
        ProxyMatchedV1Signature *metrics.Counter // connection with signature v1 matched
        ProxyMatchedV2Signature *metrics.Counter // connection with signature v1 matched
        ProxyErrInvalidHeader   *metrics.Counter // connection with invalid header
        ProxyNormalV1Header     *metrics.Counter // connection with normal v1 header
        ProxyNormalV2Header     *metrics.Counter // connection with normal v2 header
}

var state ProxyState

func GetProxyState() *ProxyState <span class="cov0" title="0">{
        return &amp;state
}</span>
</pre>
		
		<pre class="file" id="file202" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package bfe_proxy

import (
        "fmt"
        "io"
        "net"
        "sync"
        "time"
)

import (
        "github.com/baidu/go-lib/log"
)

import (
        bufio "github.com/bfenetworks/bfe/bfe_bufio"
)

const (
        // defaultProxyHeaderTimeout is the read timeout of PROXY header.
        // This can be overridden by setting ProxyHeaderTimeout.
        defaultProxyHeaderTimeout = 30 * time.Second

        // defaultProxyHeaderBytes is the maximum permitted size of the PROXY headers
        //
        // Maximum length of header in PROXY v1
        //   See: Proxy Protocol 2.1. Human-readable header format (Version 1)
        //   "So a 108-byte buffer is always enough to store all the line and a trailing zero."
        //
        // Maximum length of header in PROXY V2
        //   See: Proxy Protocol 2.2. Binary header format (version 2)
        //   "The sender must ensure that all the protocol header is sent at once. This block
        //   is always smaller than an MSS, so there is no reason for it to be segmented at
        //   the beginning of the connection."
        defaultMaxProxyHeaderBytes int64 = 2048

        // noLimit is an effective infinite upper bound for io.LimitedReader
        noLimit int64 = (1 &lt;&lt; 63) - 1
)

// Conn is used to wrap an underlying connection which
// may be speaking the Proxy Protocol. If it is, the RemoteAddr() will
// return the address of the client instead of the proxy address.
type Conn struct {
        conn          net.Conn // underlying TCP connection
        lmtReader     *io.LimitedReader
        bufReader     *bufio.Reader
        headerTimeout time.Duration // timeout for reading proxy header
        headerLimit   int64         // maximum bytes of proxy header accepted
        headerErr     error         // error when parsing proxy header
        dstAddr       *net.TCPAddr  // real dst address (i.e. virtual address)
        srcAddr       *net.TCPAddr  // real src address (i.e. real client address)
        once          sync.Once
}

// NewConn is used to wrap a net.Conn that may be speaking
// the proxy protocol
func NewConn(conn net.Conn, headerTimeout time.Duration, maxProxyHeaderBytes int64) *Conn <span class="cov8" title="1">{
        if headerTimeout &lt;= 0 </span><span class="cov8" title="1">{
                headerTimeout = defaultProxyHeaderTimeout
        }</span>
        <span class="cov8" title="1">if maxProxyHeaderBytes &lt;= 0 </span><span class="cov8" title="1">{
                maxProxyHeaderBytes = defaultMaxProxyHeaderBytes
        }</span>

        <span class="cov8" title="1">pConn := new(Conn)
        pConn.headerTimeout = headerTimeout
        pConn.headerLimit = maxProxyHeaderBytes
        pConn.conn = conn
        pConn.lmtReader = io.LimitReader(conn, pConn.headerLimit).(*io.LimitedReader)
        pConn.bufReader = bufio.NewReader(pConn.lmtReader)
        return pConn</span>
}

// Read reads data from the connection.
// It check for the proxy protocol header when doing
// the initial read. If there is an error parsing the header,
// it is returned and the socket is closed.
func (p *Conn) Read(b []byte) (int, error) <span class="cov8" title="1">{
        p.checkProxyHeaderOnce()
        if p.headerErr != nil </span><span class="cov8" title="1">{
                return 0, p.headerErr
        }</span>
        <span class="cov8" title="1">return p.bufReader.Read(b)</span>
}

// Write writes data to the connection.
func (p *Conn) Write(b []byte) (int, error) <span class="cov8" title="1">{
        return p.conn.Write(b)
}</span>

// Close closes the connection.
func (p *Conn) Close() error <span class="cov8" title="1">{
        return p.conn.Close()
}</span>

// LocalAddr returns the local network address.
func (p *Conn) LocalAddr() net.Addr <span class="cov8" title="1">{
        return p.conn.LocalAddr()
}</span>

// RemoteAddr returns the address of the client if the proxy
// protocol is being used, otherwise just returns the address of
// the socket peer. If there is an error parsing the header, the
// address of the client is not returned, and the socket is closed.
func (p *Conn) RemoteAddr() net.Addr <span class="cov8" title="1">{
        p.checkProxyHeaderOnce()
        if p.srcAddr != nil </span><span class="cov8" title="1">{
                return p.srcAddr
        }</span>
        <span class="cov8" title="1">return p.conn.RemoteAddr()</span>
}

// VirtualAddr returns the virtual address
func (p *Conn) VirtualAddr() net.Addr <span class="cov8" title="1">{
        p.checkProxyHeaderOnce()
        if p.dstAddr != nil </span><span class="cov8" title="1">{
                return p.dstAddr
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// BalancerAddr returns the address of balancer
func (p *Conn) BalancerAddr() net.Addr <span class="cov8" title="1">{
        p.checkProxyHeaderOnce()
        if p.dstAddr != nil </span><span class="cov8" title="1">{
                return p.conn.RemoteAddr()
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// GetNetConn returns the underlying connection
func (p *Conn) GetNetConn() net.Conn <span class="cov0" title="0">{
        return p.conn
}</span>

// SetDeadline implements the Conn.SetDeadline method
func (p *Conn) SetDeadline(t time.Time) error <span class="cov0" title="0">{
        return p.conn.SetDeadline(t)
}</span>

// SetReadDeadline implements the Conn.SetReadDeadline method
func (p *Conn) SetReadDeadline(t time.Time) error <span class="cov8" title="1">{
        return p.conn.SetReadDeadline(t)
}</span>

// SetWriteDeadline implements the Conn.SetWriteDeadline method
func (p *Conn) SetWriteDeadline(t time.Time) error <span class="cov8" title="1">{
        return p.conn.SetWriteDeadline(t)
}</span>

func (p *Conn) checkProxyHeaderOnce() <span class="cov8" title="1">{
        p.once.Do(func() </span><span class="cov8" title="1">{
                if err := p.checkProxyHeader(); err != nil </span><span class="cov8" title="1">{
                        log.Logger.Error("bfe_proxy: Failed to read proxy header: %v", err)
                }</span>
        })
}

func (p *Conn) checkProxyHeader() error <span class="cov8" title="1">{
        // set read timeout for proxy header
        p.conn.SetReadDeadline(time.Now().Add(p.headerTimeout))

        // reset timeout and read limit for conn
        defer func() </span><span class="cov8" title="1">{
                p.conn.SetReadDeadline(time.Time{})
                p.lmtReader.N = noLimit
        }</span>()

        // read and parse proxy header
        <span class="cov8" title="1">hdr, err := Read(p.bufReader)
        if err == ErrNoProxyProtocol </span><span class="cov8" title="1">{ // ignore ErrNoProxyProtocol
                return nil
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                p.Close()
                p.headerErr = err
                return err
        }</span>

        // initial real src/dst address
        <span class="cov8" title="1">srcAddr := net.JoinHostPort(hdr.SourceAddress.String(), fmt.Sprintf("%d", hdr.SourcePort))
        p.srcAddr, err = net.ResolveTCPAddr(hdr.TransportProtocol.String(), srcAddr)
        if err != nil </span><span class="cov8" title="1">{ /* never go here */
                p.Close()
                return err
        }</span>

        <span class="cov8" title="1">dstAddr := net.JoinHostPort(hdr.DestinationAddress.String(), fmt.Sprintf("%d", hdr.DestinationPort))
        p.dstAddr, err = net.ResolveTCPAddr(hdr.TransportProtocol.String(), dstAddr)
        if err != nil </span><span class="cov0" title="0">{ /* never go here */
                p.Close()
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file203" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Copyright (c) pires.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package bfe_proxy implements Proxy Protocol (v1 and v2) parser and writer, as per specification:
// http://www.haproxy.org/download/1.8/doc/proxy-protocol.txt
package bfe_proxy

import (
        "bytes"
        "errors"
        "io"
        "net"
        "time"
)

import (
        bufio "github.com/bfenetworks/bfe/bfe_bufio"
)

// Protocol signature
var (
        SIGV1 = []byte{'\x50', '\x52', '\x4F', '\x58', '\x59'}
        SIGV2 = []byte{'\x0D', '\x0A', '\x0D', '\x0A', '\x00', '\x0D', '\x0A', '\x51', '\x55', '\x49', '\x54', '\x0A'}
)

var (
        ErrCantReadProtocolVersionAndCommand    = errors.New("Can't read proxy protocol version and command")
        ErrCantReadAddressFamilyAndProtocol     = errors.New("Can't read address family or protocol")
        ErrCantReadLength                       = errors.New("Can't read length")
        ErrCantResolveSourceUnixAddress         = errors.New("Can't resolve source Unix address")
        ErrCantResolveDestinationUnixAddress    = errors.New("Can't resolve destination Unix address")
        ErrNoProxyProtocol                      = errors.New("Proxy protocol signature not present")
        ErrUnknownProxyProtocolVersion          = errors.New("Unknown proxy protocol version")
        ErrUnsupportedProtocolVersionAndCommand = errors.New("Unsupported proxy protocol version and command")
        ErrUnsupportedAddressFamilyAndProtocol  = errors.New("Unsupported address family and protocol")
        ErrInvalidLength                        = errors.New("Invalid length")
        ErrLengthExceeded                       = errors.New("Length Exceeded")
        ErrInvalidAddress                       = errors.New("Invalid address")
        ErrInvalidPortNumber                    = errors.New("Invalid port number")
)

// Header is the placeholder for proxy protocol header.
type Header struct {
        Version            byte
        Command            ProtocolVersionAndCommand
        TransportProtocol  AddressFamilyAndProtocol
        SourceAddress      net.IP
        DestinationAddress net.IP
        SourcePort         uint16
        DestinationPort    uint16
}

// EqualTo returns true if headers are equivalent, false otherwise.
func (header *Header) EqualTo(q *Header) bool <span class="cov8" title="1">{
        if header == nil || q == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if header.Command.IsLocal() </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">return header.TransportProtocol == q.TransportProtocol &amp;&amp;
                header.SourceAddress.String() == q.SourceAddress.String() &amp;&amp;
                header.DestinationAddress.String() == q.DestinationAddress.String() &amp;&amp;
                header.SourcePort == q.SourcePort &amp;&amp;
                header.DestinationPort == q.DestinationPort</span>
}

// WriteTo renders a proxy protocol header in a format to write over the wire.
func (header *Header) WriteTo(w io.Writer) (int64, error) <span class="cov8" title="1">{
        switch header.Version </span>{
        case 1:<span class="cov8" title="1">
                return header.writeVersion1(w)</span>
        case 2:<span class="cov8" title="1">
                return header.writeVersion2(w)</span>
        default:<span class="cov0" title="0">
                return 0, ErrUnknownProxyProtocolVersion</span>
        }
}

// Read identifies the proxy protocol version and reads the remaining of
// the header, accordingly.
//
// If proxy protocol header signature is not present, the reader buffer remains untouched
// and is safe for reading outside of this code.
//
// If proxy protocol header signature is present but an error is raised while processing
// the remaining header, assume the reader buffer to be in a corrupt state.
// Also, this operation will block until enough bytes are available for peeking.
func Read(reader *bufio.Reader) (*Header, error) <span class="cov8" title="1">{
        // In order to improve speed for small non-PROXYed packets,
        // take a peek at the first byte alone.
        b1, err := reader.Peek(1)
        if err != nil </span><span class="cov8" title="1">{
                state.ProxyErrReadHeader.Inc(1)
                return nil, err
        }</span>
        <span class="cov8" title="1">if !bytes.Equal(b1[:1], SIGV1[:1]) &amp;&amp; !bytes.Equal(b1[:1], SIGV2[:1]) </span><span class="cov8" title="1">{
                state.ProxyErrNoProxyProtocol.Inc(1)
                return nil, ErrNoProxyProtocol
        }</span>

        // Peek and check signature of PROXY v1
        <span class="cov8" title="1">signature, err := reader.Peek(5)
        if err != nil </span><span class="cov8" title="1">{
                state.ProxyErrReadHeader.Inc(1)
                return nil, err
        }</span>
        <span class="cov8" title="1">if bytes.Equal(signature[:5], SIGV1) </span><span class="cov8" title="1">{
                state.ProxyMatchedV1Signature.Inc(1)
                return parseVersion1(reader)
        }</span>

        // Peek and check signature of PROXY v2
        <span class="cov8" title="1">signature, err = reader.Peek(12)
        if err != nil </span><span class="cov8" title="1">{
                state.ProxyErrReadHeader.Inc(1)
                return nil, err
        }</span>
        <span class="cov8" title="1">if bytes.Equal(signature[:12], SIGV2) </span><span class="cov8" title="1">{
                state.ProxyMatchedV2Signature.Inc(1)
                return parseVersion2(reader)
        }</span>

        <span class="cov0" title="0">state.ProxyErrNoProxyProtocol.Inc(1)
        return nil, ErrNoProxyProtocol</span>
}

// ReadTimeout acts as Read but takes a timeout. If that timeout is reached, it's assumed
// there's no proxy protocol header.
func ReadTimeout(reader *bufio.Reader, timeout time.Duration) (*Header, error) <span class="cov8" title="1">{
        type header struct {
                h *Header
                e error
        }
        read := make(chan *header, 1)

        go func() </span><span class="cov8" title="1">{
                h := &amp;header{}
                h.h, h.e = Read(reader)
                read &lt;- h
        }</span>()

        <span class="cov8" title="1">timer := time.NewTimer(timeout)
        select </span>{
        case result := &lt;-read:<span class="cov0" title="0">
                timer.Stop()
                return result.h, result.e</span>
        case &lt;-timer.C:<span class="cov8" title="1">
                return nil, ErrNoProxyProtocol</span>
        }
}
</pre>
		
		<pre class="file" id="file204" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Copyright (c) pires.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package bfe_proxy

import (
        "bytes"
        "io"
        "net"
        "strconv"
        "strings"
)

import (
        bufio "github.com/bfenetworks/bfe/bfe_bufio"
)

const (
        CRLF      = "\r\n"
        SEPARATOR = " "
)

func initVersion1() *Header <span class="cov8" title="1">{
        header := new(Header)
        header.Version = 1
        // Command doesn't exist in v1
        header.Command = PROXY
        return header
}</span>

func parseVersion1(reader *bufio.Reader) (*Header, error) <span class="cov8" title="1">{
        // Make sure we have a v1 header
        line, err := reader.ReadString('\n')
        if err != nil </span><span class="cov8" title="1">{
                state.ProxyErrReadHeader.Inc(1)
                return nil, err
        }</span>
        <span class="cov8" title="1">if !strings.HasSuffix(line, CRLF) </span><span class="cov0" title="0">{
                state.ProxyErrInvalidHeader.Inc(1)
                return nil, ErrCantReadProtocolVersionAndCommand
        }</span>
        <span class="cov8" title="1">tokens := strings.Split(line[:len(line)-2], SEPARATOR)
        if len(tokens) &lt; 6 </span><span class="cov8" title="1">{
                state.ProxyErrInvalidHeader.Inc(1)
                return nil, ErrCantReadProtocolVersionAndCommand
        }</span>

        <span class="cov8" title="1">header := initVersion1()

        // Read address family and protocol
        switch tokens[1] </span>{
        case "TCP4":<span class="cov8" title="1">
                header.TransportProtocol = TCPv4</span>
        case "TCP6":<span class="cov8" title="1">
                header.TransportProtocol = TCPv6</span>
        default:<span class="cov8" title="1">
                header.TransportProtocol = UNSPEC</span>
        }

        // Read addresses and ports
        <span class="cov8" title="1">header.SourceAddress, err = parseV1IPAddress(header.TransportProtocol, tokens[2])
        if err != nil </span><span class="cov8" title="1">{
                state.ProxyErrInvalidHeader.Inc(1)
                return nil, err
        }</span>
        <span class="cov8" title="1">header.DestinationAddress, err = parseV1IPAddress(header.TransportProtocol, tokens[3])
        if err != nil </span><span class="cov0" title="0">{
                state.ProxyErrInvalidHeader.Inc(1)
                return nil, err
        }</span>
        <span class="cov8" title="1">header.SourcePort, err = parseV1PortNumber(tokens[4])
        if err != nil </span><span class="cov8" title="1">{
                state.ProxyErrInvalidHeader.Inc(1)
                return nil, err
        }</span>
        <span class="cov8" title="1">header.DestinationPort, err = parseV1PortNumber(tokens[5])
        if err != nil </span><span class="cov0" title="0">{
                state.ProxyErrInvalidHeader.Inc(1)
                return nil, err
        }</span>

        <span class="cov8" title="1">state.ProxyNormalV1Header.Inc(1)
        return header, nil</span>
}

func (header *Header) writeVersion1(w io.Writer) (int64, error) <span class="cov8" title="1">{
        // As of version 1, only "TCP4" ( \x54 \x43 \x50 \x34 ) for TCP over IPv4,
        // and "TCP6" ( \x54 \x43 \x50 \x36 ) for TCP over IPv6 are allowed.
        proto := "UNKNOWN"
        if header.TransportProtocol == TCPv4 </span><span class="cov8" title="1">{
                proto = "TCP4"
        }</span> else<span class="cov8" title="1"> if header.TransportProtocol == TCPv6 </span><span class="cov8" title="1">{
                proto = "TCP6"
        }</span>

        <span class="cov8" title="1">var buf bytes.Buffer
        buf.Write(SIGV1)
        buf.WriteString(SEPARATOR)
        buf.WriteString(proto)
        buf.WriteString(SEPARATOR)
        buf.WriteString(header.SourceAddress.String())
        buf.WriteString(SEPARATOR)
        buf.WriteString(header.DestinationAddress.String())
        buf.WriteString(SEPARATOR)
        buf.WriteString(strconv.Itoa(int(header.SourcePort)))
        buf.WriteString(SEPARATOR)
        buf.WriteString(strconv.Itoa(int(header.DestinationPort)))
        buf.WriteString(CRLF)

        return buf.WriteTo(w)</span>
}

func parseV1PortNumber(portStr string) (uint16, error) <span class="cov8" title="1">{
        var port uint16

        pval, err := strconv.Atoi(portStr)
        if err == nil </span><span class="cov8" title="1">{
                if pval &lt; 0 || pval &gt; 65535 </span><span class="cov8" title="1">{
                        err = ErrInvalidPortNumber
                }</span>
                <span class="cov8" title="1">port = uint16(pval)</span>
        }

        <span class="cov8" title="1">return port, err</span>
}

func parseV1IPAddress(protocol AddressFamilyAndProtocol, addrStr string) (addr net.IP, err error) <span class="cov8" title="1">{
        addr = net.ParseIP(addrStr)
        tryV4 := addr.To4()
        if (protocol == TCPv4 &amp;&amp; tryV4 == nil) || (protocol == TCPv6 &amp;&amp; tryV4 != nil) </span><span class="cov8" title="1">{
                err = ErrInvalidAddress
        }</span>
        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file205" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Copyright (c) pires.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package bfe_proxy

import (
        "bytes"
        "encoding/binary"
        "io"
)

import (
        bufio "github.com/bfenetworks/bfe/bfe_bufio"
)

var (
        lengthV4   = uint16(12)
        lengthV6   = uint16(36)
        lengthUnix = uint16(218)

        lengthV4Bytes = func() []byte <span class="cov8" title="1">{
                a := make([]byte, 2)
                binary.BigEndian.PutUint16(a, lengthV4)
                return a
        }</span>()
        lengthV6Bytes = func() []byte <span class="cov8" title="1">{
                a := make([]byte, 2)
                binary.BigEndian.PutUint16(a, lengthV6)
                return a
        }</span>()
        lengthUnixBytes = func() []byte <span class="cov8" title="1">{
                a := make([]byte, 2)
                binary.BigEndian.PutUint16(a, lengthUnix)
                return a
        }</span>()
)

type _ports struct {
        SrcPort uint16
        DstPort uint16
}

type _addr4 struct {
        Src     [4]byte
        Dst     [4]byte
        SrcPort uint16
        DstPort uint16
}

type _addr6 struct {
        Src [16]byte
        Dst [16]byte
        _ports
}

// parseVersion2 parses protocol header
//
// Note: binary header format:
// - Signature [1~12]
// - Version and Command [13]
// - Protocol and Address Family [14]
// - Address Length [15]
// - Additional TLVs [optional]
func parseVersion2(reader *bufio.Reader) (header *Header, err error) <span class="cov8" title="1">{
        // Skip first 12 bytes (signature)
        for i := 0; i &lt; 12; i++ </span><span class="cov8" title="1">{
                if _, err = reader.ReadByte(); err != nil </span><span class="cov0" title="0">{
                        state.ProxyErrReadHeader.Inc(1)
                        return nil, ErrCantReadProtocolVersionAndCommand
                }</span>
        }

        <span class="cov8" title="1">header = new(Header)
        header.Version = 2

        // Read the 13th byte, protocol version and command
        b13, err := reader.ReadByte()
        if err != nil </span><span class="cov8" title="1">{
                state.ProxyErrReadHeader.Inc(1)
                return nil, ErrCantReadProtocolVersionAndCommand
        }</span>
        <span class="cov8" title="1">header.Command = ProtocolVersionAndCommand(b13)
        if _, ok := supportedCommand[header.Command]; !ok </span><span class="cov8" title="1">{
                state.ProxyErrInvalidHeader.Inc(1)
                return nil, ErrUnsupportedProtocolVersionAndCommand
        }</span>
        // If command is LOCAL, header ends here
        <span class="cov8" title="1">if header.Command.IsLocal() </span><span class="cov8" title="1">{
                return header, nil
        }</span>

        // Read the 14th byte, address family and protocol
        <span class="cov8" title="1">b14, err := reader.ReadByte()
        if err != nil </span><span class="cov8" title="1">{
                state.ProxyErrReadHeader.Inc(1)
                return nil, ErrCantReadAddressFamilyAndProtocol
        }</span>
        <span class="cov8" title="1">header.TransportProtocol = AddressFamilyAndProtocol(b14)
        if _, ok := supportedTransportProtocol[header.TransportProtocol]; !ok </span><span class="cov8" title="1">{
                state.ProxyErrInvalidHeader.Inc(1)
                return nil, ErrUnsupportedAddressFamilyAndProtocol
        }</span>

        // Make sure there are bytes available as specified in length
        <span class="cov8" title="1">var length uint16
        if err := binary.Read(io.LimitReader(reader, 2), binary.BigEndian, &amp;length); err != nil </span><span class="cov8" title="1">{
                state.ProxyErrReadHeader.Inc(1)
                return nil, ErrCantReadLength
        }</span>

        <span class="cov8" title="1">if !header.validateLength(length) </span><span class="cov8" title="1">{
                state.ProxyErrInvalidHeader.Inc(1)
                return nil, ErrInvalidLength
        }</span>

        <span class="cov8" title="1">if _, err := reader.Peek(int(length)); err != nil </span><span class="cov8" title="1">{
                state.ProxyErrReadHeader.Inc(1)
                return nil, ErrInvalidLength
        }</span>

        // Length-limited reader for payload section
        <span class="cov8" title="1">payloadReader := io.LimitReader(reader, int64(length))

        // Read addresses and ports
        if header.TransportProtocol.IsIPv4() </span><span class="cov8" title="1">{
                var addr _addr4
                if err := binary.Read(payloadReader, binary.BigEndian, &amp;addr); err != nil </span><span class="cov0" title="0">{
                        state.ProxyErrReadHeader.Inc(1)
                        return nil, ErrInvalidAddress
                }</span>
                <span class="cov8" title="1">header.SourceAddress = addr.Src[:]
                header.DestinationAddress = addr.Dst[:]
                header.SourcePort = addr.SrcPort
                header.DestinationPort = addr.DstPort</span>
        } else<span class="cov8" title="1"> if header.TransportProtocol.IsIPv6() </span><span class="cov8" title="1">{
                var addr _addr6
                if err := binary.Read(payloadReader, binary.BigEndian, &amp;addr); err != nil </span><span class="cov0" title="0">{
                        state.ProxyErrReadHeader.Inc(1)
                        return nil, ErrInvalidAddress
                }</span>
                <span class="cov8" title="1">header.SourceAddress = addr.Src[:]
                header.DestinationAddress = addr.Dst[:]
                header.SourcePort = addr.SrcPort
                header.DestinationPort = addr.DstPort</span>
        }

        // TODO add encapsulated TLV support

        // Drain the remaining padding
        <span class="cov8" title="1">payloadReader.Read(make([]byte, length))

        state.ProxyNormalV2Header.Inc(1)
        return header, nil</span>
}

func (header *Header) writeVersion2(w io.Writer) (int64, error) <span class="cov8" title="1">{
        var buf bytes.Buffer
        buf.Write(SIGV2)
        buf.WriteByte(header.Command.toByte())
        if !header.Command.IsLocal() </span><span class="cov8" title="1">{
                buf.WriteByte(header.TransportProtocol.toByte())
                // TODO add encapsulated TLV length
                var addrSrc, addrDst []byte
                if header.TransportProtocol.IsIPv4() </span><span class="cov8" title="1">{
                        buf.Write(lengthV4Bytes)
                        addrSrc = header.SourceAddress.To4()
                        addrDst = header.DestinationAddress.To4()
                }</span> else<span class="cov8" title="1"> if header.TransportProtocol.IsIPv6() </span><span class="cov8" title="1">{
                        buf.Write(lengthV6Bytes)
                        addrSrc = header.SourceAddress.To16()
                        addrDst = header.DestinationAddress.To16()
                }</span> else<span class="cov0" title="0"> if header.TransportProtocol.IsUnix() </span><span class="cov0" title="0">{
                        buf.Write(lengthUnixBytes)
                        // TODO is below right?
                        addrSrc = []byte(header.SourceAddress.String())
                        addrDst = []byte(header.DestinationAddress.String())
                }</span>
                <span class="cov8" title="1">buf.Write(addrSrc)
                buf.Write(addrDst)

                portSrcBytes := func() []byte </span><span class="cov8" title="1">{
                        a := make([]byte, 2)
                        binary.BigEndian.PutUint16(a, header.SourcePort)
                        return a
                }</span>()
                <span class="cov8" title="1">buf.Write(portSrcBytes)

                portDstBytes := func() []byte </span><span class="cov8" title="1">{
                        a := make([]byte, 2)
                        binary.BigEndian.PutUint16(a, header.DestinationPort)
                        return a
                }</span>()
                <span class="cov8" title="1">buf.Write(portDstBytes)</span>

        }

        <span class="cov8" title="1">return buf.WriteTo(w)</span>
}

func (header *Header) validateLength(length uint16) bool <span class="cov8" title="1">{
        if header.TransportProtocol.IsIPv4() </span><span class="cov8" title="1">{
                return length &gt;= lengthV4
        }</span> else<span class="cov8" title="1"> if header.TransportProtocol.IsIPv6() </span><span class="cov8" title="1">{
                return length &gt;= lengthV6
        }</span> else<span class="cov0" title="0"> if header.TransportProtocol.IsUnix() </span><span class="cov0" title="0">{
                return length &gt;= lengthUnix
        }</span>
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file206" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Copyright (c) pires.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package bfe_proxy

// ProtocolVersionAndCommand represents proxy protocol version and command.
type ProtocolVersionAndCommand byte

const (
        LOCAL = '\x20'
        PROXY = '\x21'
)

var supportedCommand = map[ProtocolVersionAndCommand]bool{
        LOCAL: true,
        PROXY: true,
}

// IsLocal returns true if the protocol version is \x2 and command is LOCAL, false otherwise.
func (pvc ProtocolVersionAndCommand) IsLocal() bool <span class="cov8" title="1">{
        return 0x20 == pvc&amp;0xF0 &amp;&amp; 0x00 == pvc&amp;0x0F
}</span>

// IsProxy returns true if the protocol version is \x2 and command is PROXY, false otherwise.
func (pvc ProtocolVersionAndCommand) IsProxy() bool <span class="cov8" title="1">{
        return 0x20 == pvc&amp;0xF0 &amp;&amp; 0x01 == pvc&amp;0x0F
}</span>

// IsUnspec returns true if the protocol version or command is unspecified, false otherwise.
func (pvc ProtocolVersionAndCommand) IsUnspec() bool <span class="cov8" title="1">{
        return !(pvc.IsLocal() || pvc.IsProxy())
}</span>

func (pvc ProtocolVersionAndCommand) toByte() byte <span class="cov8" title="1">{
        if pvc.IsLocal() </span><span class="cov8" title="1">{
                return LOCAL
        }</span> else<span class="cov8" title="1"> if pvc.IsProxy() </span><span class="cov8" title="1">{
                return PROXY
        }</span>

        <span class="cov0" title="0">return LOCAL</span>
}
</pre>
		
		<pre class="file" id="file207" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// table for maintain backend cluster

package bfe_route

import "fmt"

import (
        "github.com/baidu/go-lib/log"
)

import (
        "github.com/bfenetworks/bfe/bfe_config/bfe_cluster_conf/cluster_conf"
        "github.com/bfenetworks/bfe/bfe_route/bfe_cluster"
)

// ClusterMap holds mappings from clusterName to cluster.
type ClusterMap map[string]*bfe_cluster.BfeCluster

type ClusterTable struct {
        clusterTable ClusterMap
        versions     ClusterVersion
}

type ClusterVersion struct {
        ClusterConfVer string // version of cluster-conf
}

func newClusterTable() *ClusterTable <span class="cov8" title="1">{
        ct := new(ClusterTable)
        return ct
}</span>

func (t *ClusterTable) Init(clusterConfFilename string) error <span class="cov8" title="1">{
        // init cluster basic
        t.clusterTable = make(ClusterMap)
        clusterConf, err := cluster_conf.ClusterConfLoad(clusterConfFilename)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">t.BasicInit(clusterConf)

        log.Logger.Info("init cluster table success")
        return nil</span>
}

func (t *ClusterTable) BasicInit(clusterConfs cluster_conf.BfeClusterConf) <span class="cov8" title="1">{
        t.clusterTable = make(ClusterMap)

        for clusterName, clusterConf := range *clusterConfs.Config </span><span class="cov8" title="1">{
                // create new cluster
                cluster := bfe_cluster.NewBfeCluster(clusterName)

                // initialize
                cluster.BasicInit(clusterConf)
                // add cluster to clusterTable
                t.clusterTable[clusterName] = cluster
        }</span>

        <span class="cov8" title="1">t.versions.ClusterConfVer = *clusterConfs.Version</span>
}

func (t *ClusterTable) Lookup(clusterName string) (*bfe_cluster.BfeCluster, error) <span class="cov8" title="1">{
        // lookup in cluster table
        cluster, ok := t.clusterTable[clusterName]
        if !ok </span><span class="cov8" title="1">{
                return cluster, fmt.Errorf("no cluster found for %s", clusterName)
        }</span>

        <span class="cov8" title="1">return cluster, nil</span>
}

func (t *ClusterTable) GetVersions() ClusterVersion <span class="cov0" title="0">{
        return t.versions
}</span>

func (t *ClusterTable) ClusterMap() ClusterMap <span class="cov0" title="0">{
        return t.clusterTable
}</span>
</pre>
		
		<pre class="file" id="file208" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// table for mapping hostname to cluster name

package bfe_route

import (
        "errors"
        "strings"
)

import (
        "github.com/bfenetworks/bfe/bfe_basic"
        "github.com/bfenetworks/bfe/bfe_config/bfe_route_conf/host_rule_conf"
        "github.com/bfenetworks/bfe/bfe_config/bfe_route_conf/route_rule_conf"
        "github.com/bfenetworks/bfe/bfe_config/bfe_route_conf/vip_rule_conf"
        "github.com/bfenetworks/bfe/bfe_route/trie"
        "github.com/bfenetworks/bfe/bfe_util/string_reverse"
)

var (
        ErrNoProduct     = errors.New("no product found")
        ErrNoProductRule = errors.New("no route rule found for product")
        ErrNoMatchRule   = errors.New("no rule match for this req")
)

// HostTable holds mappings from host to prduct and
// mappings from product to cluster rules.
type HostTable struct {
        versions Versions // record conf versions

        hostTable      host_rule_conf.Host2HostTag    // for get host-tag
        hostTagTable   host_rule_conf.HostTag2Product // for get product name by hostname
        vipTable       vip_rule_conf.Vip2Product      // for get product name by vip (backup)
        defaultProduct string                         // default product name

        hostTrie *trie.Trie

        productBasicRouteTable    route_rule_conf.ProductBasicRouteRule    // all product's basic route rules list
        productBasicRouteTree     route_rule_conf.ProductBasicRouteTree    // all product's basic route rules tree
        productAdvancedRouteTable route_rule_conf.ProductAdvancedRouteRule // all product's advanced route rules

}

type Versions struct {
        HostTag      string // version of host-tag
        Vip          string // version of vip rule
        ProductRoute string // version of product route rule
}

type Status struct {
        HostTableSize              int
        HostTagTableSize           int
        VipTableSize               int
        ProductRouteTableSize      int
        ProductBasicRouteTableSize int
}

type route struct {
        product string
        tag     string
}

func newHostTable() *HostTable <span class="cov0" title="0">{
        t := new(HostTable)
        return t
}</span>

// updateHostTable updates host-tag related table
func (t *HostTable) updateHostTable(conf host_rule_conf.HostConf) <span class="cov0" title="0">{
        t.versions.HostTag = conf.Version
        t.hostTable = conf.HostMap
        t.hostTagTable = conf.HostTagMap
        t.defaultProduct = conf.DefaultProduct
        t.hostTrie = buildHostRoute(conf)
}</span>

// updateVipTable updates vip table
func (t *HostTable) updateVipTable(conf vip_rule_conf.VipConf) <span class="cov0" title="0">{
        t.versions.Vip = conf.Version
        t.vipTable = conf.VipMap
}</span>

// updateRouteTable updates product Route Rule
func (t *HostTable) updateRouteTable(conf *route_rule_conf.RouteTableConf) <span class="cov0" title="0">{
        t.versions.ProductRoute = conf.Version
        t.productBasicRouteTree = conf.BasicRuleTree
        t.productBasicRouteTable = conf.BasicRuleMap
        t.productAdvancedRouteTable = conf.AdvancedRuleMap
}</span>

// Update updates host table
func (t *HostTable) Update(hostConf host_rule_conf.HostConf,
        vipConf vip_rule_conf.VipConf, routeConf *route_rule_conf.RouteTableConf) <span class="cov0" title="0">{

        t.updateHostTable(hostConf)
        t.updateVipTable(vipConf)
        t.updateRouteTable(routeConf)
}</span>

// LookupHostTagAndProduct find hosttag and product with given hostname.
func (t *HostTable) LookupHostTagAndProduct(req *bfe_basic.Request) error <span class="cov0" title="0">{
        hostName := req.HttpRequest.Host

        // lookup product by hostname
        hostRoute, err := t.findHostRoute(hostName)

        // if failed, try to lookup product by visited vip
        if err != nil </span><span class="cov0" title="0">{
                if vip := req.Session.Vip; vip != nil </span><span class="cov0" title="0">{
                        hostRoute, err = t.findVipRoute(vip.String())
                }</span>
        }

        // if failed, use default proudct
        <span class="cov0" title="0">if err != nil &amp;&amp; t.defaultProduct != "" </span><span class="cov0" title="0">{
                hostRoute, err = route{product: t.defaultProduct}, nil
        }</span>

        // set hostTag and product
        <span class="cov0" title="0">req.Route.HostTag = hostRoute.tag
        req.Route.Product = hostRoute.product
        req.Route.Error = err

        return err</span>
}

// LookupCluster find clusterName with given request.
func (t *HostTable) LookupCluster(req *bfe_basic.Request) error <span class="cov0" title="0">{
        var clusterName string

        // match basic route rules
        basicRules, ok := t.productBasicRouteTree[req.Route.Product]
        if ok </span><span class="cov0" title="0">{
                host := strings.SplitN(req.HttpRequest.Host, ":", 2)[0]

                path := ""
                if req.HttpRequest.URL != nil </span><span class="cov0" title="0">{
                        path = req.HttpRequest.URL.Path
                }</span>

                <span class="cov0" title="0">clusterName, found := basicRules.Get(host, path)
                if found &amp;&amp; clusterName != route_rule_conf.AdvancedMode </span><span class="cov0" title="0">{
                        // set clusterName
                        req.Route.ClusterName = clusterName
                        return nil
                }</span>
        }

        // match advanced route rules
        <span class="cov0" title="0">rules, ok := t.productAdvancedRouteTable[req.Route.Product]
        if !ok </span><span class="cov0" title="0">{
                req.Route.ClusterName = ""
                req.Route.Error = ErrNoProductRule
                return req.Route.Error
        }</span>

        // matching route rules
        <span class="cov0" title="0">for _, rule := range rules </span><span class="cov0" title="0">{
                if rule.Cond.Match(req) </span><span class="cov0" title="0">{
                        clusterName = rule.ClusterName
                        break</span>
                }
        }

        <span class="cov0" title="0">if clusterName == "" </span><span class="cov0" title="0">{
                req.Route.ClusterName = ""
                req.Route.Error = ErrNoMatchRule
                return req.Route.Error
        }</span>

        // set clusterName
        <span class="cov0" title="0">req.Route.ClusterName = clusterName

        return nil</span>
}

// Lookup find cluster name with given hostname.
func (t *HostTable) Lookup(req *bfe_basic.Request) bfe_basic.RequestRoute <span class="cov0" title="0">{
        route := bfe_basic.RequestRoute{}

        // 1. look up hostTag and product
        if err := t.LookupHostTagAndProduct(req); err != nil </span><span class="cov0" title="0">{
                route.Error = err
                return route
        }</span>

        // 2. set product and host tag
        <span class="cov0" title="0">route.Product = req.Route.Product
        route.HostTag = req.Route.HostTag

        // 3. lookup clusterName
        if err := t.LookupCluster(req); err != nil </span><span class="cov0" title="0">{
                route.Error = err
                return route
        }</span>

        // 4. set cluter name
        <span class="cov0" title="0">route.ClusterName = req.Route.ClusterName

        return route</span>
}

// LookupProductByVip find product name by vip.
func (t *HostTable) LookupProductByVip(vip string) (string, error) <span class="cov0" title="0">{
        hostRoute, err := t.findVipRoute(vip)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return hostRoute.product, nil</span>
}

// LookupProduct find product name with given hostname.
func (t *HostTable) LookupProduct(hostname string) (string, error) <span class="cov0" title="0">{
        hostRoute, err := t.findHostRoute(hostname)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return hostRoute.product, nil</span>
}

// GetVersions return versions of host table.
func (t *HostTable) GetVersions() Versions <span class="cov0" title="0">{
        return t.versions
}</span>

// GetStatus return status of host table.
func (t *HostTable) GetStatus() Status <span class="cov0" title="0">{
        var s Status
        s.ProductBasicRouteTableSize = len(t.productBasicRouteTable)
        s.ProductRouteTableSize = len(t.productAdvancedRouteTable)
        s.HostTableSize = len(t.hostTable)
        s.HostTagTableSize = len(t.hostTagTable)
        s.VipTableSize = len(t.vipTable)
        return s
}</span>

func (t *HostTable) findHostRoute(host string) (route, error) <span class="cov0" title="0">{
        if t.hostTrie == nil </span><span class="cov0" title="0">{
                return route{}, ErrNoProduct
        }</span>

        <span class="cov0" title="0">host = strings.ToLower(host)
        // get host-tag by hostname
        match, ok := t.hostTrie.Get(strings.Split(string_reverse.ReverseFqdnHost(hostnameStrip(host)), "."))
        if ok </span><span class="cov0" title="0">{
                // get route success, return
                return match.(route), nil
        }</span>

        <span class="cov0" title="0">return route{}, ErrNoProduct</span>
}

func (t *HostTable) findVipRoute(vip string) (route, error) <span class="cov0" title="0">{
        if len(t.vipTable) == 0 </span><span class="cov0" title="0">{
                return route{}, ErrNoProduct
        }</span>

        <span class="cov0" title="0">if product, ok := t.vipTable[vip]; ok </span><span class="cov0" title="0">{
                return route{product: product}, nil
        }</span>

        <span class="cov0" title="0">return route{}, ErrNoProduct</span>
}

// hostnameStrip remove ":port" in hostname.
func hostnameStrip(hostname string) string <span class="cov0" title="0">{
        return strings.Split(hostname, ":")[0]
}</span>

func buildHostRoute(conf host_rule_conf.HostConf) *trie.Trie <span class="cov0" title="0">{
        hostTrie := trie.NewTrie()

        for host, tag := range conf.HostMap </span><span class="cov0" title="0">{
                host = strings.ToLower(host)
                product := conf.HostTagMap[tag]
                hostTrie.Set(strings.Split(string_reverse.ReverseFqdnHost(host), "."), route{product: product, tag: tag})
        }</span>

        <span class="cov0" title="0">return hostTrie</span>
}
</pre>
		
		<pre class="file" id="file209" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// for route traffic to backend cluster

package bfe_route

import (
        "fmt"
)

import (
        "github.com/baidu/go-lib/log"
)

import (
        "github.com/bfenetworks/bfe/bfe_config/bfe_route_conf/host_rule_conf"
        "github.com/bfenetworks/bfe/bfe_config/bfe_route_conf/route_rule_conf"
        "github.com/bfenetworks/bfe/bfe_config/bfe_route_conf/vip_rule_conf"
        "github.com/bfenetworks/bfe/bfe_route/bfe_cluster"
)

type ServerDataConf struct {
        HostTable    *HostTable
        ClusterTable *ClusterTable
}

func newServerDataConf() *ServerDataConf <span class="cov0" title="0">{
        c := new(ServerDataConf)

        // initialize HostTable &amp; ClusterTable
        c.HostTable = newHostTable()
        c.ClusterTable = newClusterTable()

        return c
}</span>

// LoadServerDataConf loads ServerDataConf config.
func LoadServerDataConf(hostFile, vipFile, routeFile, clusterConfFile string) (*ServerDataConf, error) <span class="cov0" title="0">{
        s := newServerDataConf()

        // load host table
        if err := s.hostTableLoad(hostFile, vipFile, routeFile); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("hostTableLoad Error %s", err)
        }</span>

        // load cluster table
        <span class="cov0" title="0">if err := s.clusterTableLoad(clusterConfFile); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("clusterTableLoad Error %s", err)
        }</span>

        // check host, route, cluster_conf dependent relationship
        <span class="cov0" title="0">if err := s.check(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ServerDataConf.check Error %s", err)
        }</span>

        <span class="cov0" title="0">return s, nil</span>
}

// hostTableLoad loads all data for host table from file.
func (s *ServerDataConf) hostTableLoad(hostFile, vipFile, routeFile string) error <span class="cov0" title="0">{
        // load host rule from file
        hostConf, err := host_rule_conf.HostRuleConfLoad(hostFile)
        if err != nil </span><span class="cov0" title="0">{
                log.Logger.Error("hostTableLoad():err in HostRuleConfLoad():%s", err.Error())
                return err
        }</span>

        // load vip rule from file
        <span class="cov0" title="0">vipConf, err := vip_rule_conf.VipRuleConfLoad(vipFile)
        if err != nil </span><span class="cov0" title="0">{
                log.Logger.Error("vipTableLoad():err in VipRuleConfLoad():%s", err.Error())
                return err
        }</span>

        // load route conf from file
        <span class="cov0" title="0">routeConf, err := route_rule_conf.RouteConfLoad(routeFile)
        if err != nil </span><span class="cov0" title="0">{
                log.Logger.Error("hostTableLoad():err in RouteConfLoad():%s", err.Error())
                return err
        }</span>

        // update to host table
        <span class="cov0" title="0">s.HostTable.Update(hostConf, vipConf, routeConf)
        return nil</span>
}

func (s *ServerDataConf) clusterTableLoad(clusterConf string) error <span class="cov0" title="0">{
        err := s.ClusterTable.Init(clusterConf)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">log.Logger.Info("init cluster table success")
        return nil</span>
}

func (s *ServerDataConf) check() error <span class="cov0" title="0">{
        // check product consistency in host and route
        for product1 := range s.HostTable.productAdvancedRouteTable </span><span class="cov0" title="0">{
                find := false
                for _, product2 := range s.HostTable.hostTagTable </span><span class="cov0" title="0">{
                        if product1 == product2 </span><span class="cov0" title="0">{
                                find = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !find </span><span class="cov0" title="0">{
                        return fmt.Errorf("product[%s] in route should exist in host!", product1)
                }</span>
        }

        <span class="cov0" title="0">for product1 := range s.HostTable.productBasicRouteTree </span><span class="cov0" title="0">{
                find := false
                for _, product2 := range s.HostTable.hostTagTable </span><span class="cov0" title="0">{
                        if product1 == product2 </span><span class="cov0" title="0">{
                                find = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !find </span><span class="cov0" title="0">{
                        return fmt.Errorf("product[%s] in route should exist in host!", product1)
                }</span>
        }

        // check cluster_name of advanced rule in route and cluster_conf
        <span class="cov0" title="0">for _, routeRules := range s.HostTable.productAdvancedRouteTable </span><span class="cov0" title="0">{
                for _, routeRule := range routeRules </span><span class="cov0" title="0">{
                        if _, err := s.ClusterTable.Lookup(routeRule.ClusterName); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("cluster[%s] in advanced route should exist in cluster_conf",
                                        routeRule.ClusterName)
                        }</span>
                }
        }

        // check cluster_name of basic rule table in route and cluster_conf
        <span class="cov0" title="0">for _, routeRules := range s.HostTable.productBasicRouteTable </span><span class="cov0" title="0">{
                for _, routeRule := range routeRules </span><span class="cov0" title="0">{
                        if routeRule.ClusterName == route_rule_conf.AdvancedMode </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">if _, err := s.ClusterTable.Lookup(routeRule.ClusterName); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("cluster[%s] in basic route should exist in cluster_conf",
                                        routeRule.ClusterName)
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// HostTableLookup find cluster name with given hostname.
// implement interface ServerDataConfInterface.
func (s *ServerDataConf) HostTableLookup(hostname string) (string, error) <span class="cov0" title="0">{
        return s.HostTable.LookupProduct(hostname)
}</span>

// ClusterTableLookup find backend with given cluster-name and request.
// implement interface ServerDataConfInterface.
func (s *ServerDataConf) ClusterTableLookup(clusterName string) (*bfe_cluster.BfeCluster, error) <span class="cov0" title="0">{
        return s.ClusterTable.Lookup(clusterName)
}</span>
</pre>
		
		<pre class="file" id="file210" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package trie implements a simple trie data structure that maps "paths" (which
// are slices of strings) to arbitrary data values (type interface{}).
package trie

import "errors"

type trieChildren map[string]*Trie

type Trie struct {
        Entry      interface{}
        SplatEntry interface{} // to match xxx.xxx.*
        Children   trieChildren
}

// NewTrie makes a new empty Trie
func NewTrie() *Trie <span class="cov8" title="1">{
        return &amp;Trie{
                Children: make(trieChildren),
        }
}</span>

// Get retrieves an element from the Trie
//
// Takes a path (which can be empty, to denote the root element of the Trie),
// and returns the object if the path exists in the Trie, or nil and a status of
// false. Example:
//
//     if res, ok := trie.Get([]string{"foo", "bar"}), ok {
//       fmt.Println("Value at /foo/bar was", res)
//     }
func (t *Trie) Get(path []string) (entry interface{}, ok bool) <span class="cov8" title="1">{
        if len(path) == 0 </span><span class="cov8" title="1">{
                return t.getEntry()
        }</span>

        <span class="cov8" title="1">key := path[0]
        newPath := path[1:]

        res, ok := t.Children[key]
        if ok </span><span class="cov8" title="1">{
                entry, ok = res.Get(newPath)
        }</span>

        <span class="cov8" title="1">if entry == nil &amp;&amp; t.SplatEntry != nil </span><span class="cov8" title="1">{
                entry = t.SplatEntry
                ok = true
        }</span>

        <span class="cov8" title="1">return</span>
}

// Set creates an element in the Trie
//
// Takes a path (which can be empty, to denote the root element of the Trie),
// and an arbitrary value (interface{}) to use as the leaf data.
func (t *Trie) Set(path []string, value interface{}) error <span class="cov8" title="1">{
        if len(path) == 0 </span><span class="cov8" title="1">{
                t.setEntry(value)
                return nil
        }</span>

        <span class="cov8" title="1">if path[0] == "*" </span><span class="cov8" title="1">{
                if len(path) != 1 </span><span class="cov0" title="0">{
                        return errors.New("* should be last element")
                }</span>
                <span class="cov8" title="1">t.SplatEntry = value</span>
        }

        <span class="cov8" title="1">key := path[0]
        newPath := path[1:]

        res, ok := t.Children[key]
        if !ok </span><span class="cov8" title="1">{
                // Trie node that should hold entry doesn't already exist, so let's create it
                res = NewTrie()
                t.Children[key] = res
        }</span>

        <span class="cov8" title="1">return res.Set(newPath, value)</span>
}

func (t *Trie) setEntry(value interface{}) <span class="cov8" title="1">{
        t.Entry = value
}</span>

func (t *Trie) getEntry() (entry interface{}, ok bool) <span class="cov8" title="1">{
        return t.Entry, t.Entry != nil
}</span>
</pre>
		
		<pre class="file" id="file211" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// load config data for bfe

package bfe_server

import (
        "encoding/hex"
        "fmt"
        "net/url"
        "path/filepath"
        "strings"
)

import (
        "github.com/baidu/go-lib/log"
)

import (
        "github.com/bfenetworks/bfe/bfe_config/bfe_tls_conf/server_cert_conf"
        "github.com/bfenetworks/bfe/bfe_config/bfe_tls_conf/session_ticket_key_conf"
        "github.com/bfenetworks/bfe/bfe_config/bfe_tls_conf/tls_rule_conf"
        "github.com/bfenetworks/bfe/bfe_route"
        "github.com/bfenetworks/bfe/bfe_util/bns"
)

// InitDataLoad load data when bfe start.
func (srv *BfeServer) InitDataLoad() error <span class="cov0" title="0">{
        // load ServerDataConf
        serverConf, err := bfe_route.LoadServerDataConf(srv.Config.Server.HostRuleConf,
                srv.Config.Server.VipRuleConf, srv.Config.Server.RouteRuleConf,
                srv.Config.Server.ClusterConf)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("InitDataLoad():bfe_route.LoadServerDataConf Error %s", err)
        }</span>

        <span class="cov0" title="0">srv.ServerConf = serverConf
        srv.ReverseProxy.setTransports(srv.ServerConf.ClusterTable.ClusterMap())
        log.Logger.Info("init serverDataConf success")

        // load bal table
        if err := srv.balTable.Init(srv.Config.Server.GslbConf,
                srv.Config.Server.ClusterTableConf); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("InitDataLoad():balTableInit Error %s", err)
        }</span>

        // set gslb retry config, slow_start config
        <span class="cov0" title="0">if srv.ServerConf != nil </span><span class="cov0" title="0">{
                ct := srv.ServerConf.ClusterTable
                srv.balTable.SetGslbBasic(ct)
                srv.balTable.SetSlowStart(ct)
        }</span>
        <span class="cov0" title="0">log.Logger.Info("init bal table success")

        // load name conf
        if len(srv.Config.Server.NameConf) &gt; 0 </span><span class="cov0" title="0">{
                if err := srv.NameConfReload(nil); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("InitDataLoad():NameConfLoad Error %s", err)
                }</span>
                <span class="cov0" title="0">log.Logger.Info("init name conf success")</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func joinPath(path, suffix string) string <span class="cov0" title="0">{
        words := strings.Split(suffix, "/")
        if len(words) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">return filepath.Join(path, words[len(words)-1])</span>
}

// ServerDataConfReload reloads host/route/cluster conf
func (srv *BfeServer) ServerDataConfReload(query url.Values) error <span class="cov0" title="0">{
        hostFile := srv.Config.Server.HostRuleConf
        vipFile := srv.Config.Server.VipRuleConf
        routeFile := srv.Config.Server.RouteRuleConf
        clusterConfFile := srv.Config.Server.ClusterConf

        path := query.Get("path")
        if path != "" </span><span class="cov0" title="0">{
                hostFile = joinPath(path, hostFile)
                vipFile = joinPath(path, vipFile)
                routeFile = joinPath(path, routeFile)
                clusterConfFile = joinPath(path, clusterConfFile)
        }</span>

        <span class="cov0" title="0">return srv.serverDataConfReload(hostFile, vipFile, routeFile, clusterConfFile)</span>
}

func (srv *BfeServer) serverDataConfReload(hostFile, vipFile, routeFile, clusterConfFile string) error <span class="cov0" title="0">{
        newServerConf, err := bfe_route.LoadServerDataConf(hostFile, vipFile, routeFile, clusterConfFile)
        if err != nil </span><span class="cov0" title="0">{
                log.Logger.Error("ServerDataConfReload():bfe_route.LoadServerDataConf: %s", err)
                return err
        }</span>

        <span class="cov0" title="0">srv.confLock.Lock()
        srv.ServerConf = newServerConf
        srv.confLock.Unlock()

        srv.ReverseProxy.setTransports(srv.ServerConf.ClusterTable.ClusterMap())

        // set gslb basic
        srv.balTable.SetGslbBasic(newServerConf.ClusterTable)
        // set slow_start config
        srv.balTable.SetSlowStart(newServerConf.ClusterTable)

        return nil</span>
}

// GslbDataConfReload reloads gslb and cluster conf.
func (srv *BfeServer) GslbDataConfReload(query url.Values) error <span class="cov0" title="0">{
        gslbFile := srv.Config.Server.GslbConf
        clusterTableFile := srv.Config.Server.ClusterTableConf

        path := query.Get("path")
        if path != "" </span><span class="cov0" title="0">{
                gslbFile = joinPath(path, gslbFile)
                clusterTableFile = joinPath(path, clusterTableFile)
        }</span>

        <span class="cov0" title="0">return srv.gslbDataConfReload(gslbFile, clusterTableFile)</span>
}

func (srv *BfeServer) gslbDataConfReload(gslbFile, clusterTableFile string) error <span class="cov0" title="0">{
        // load gslb and cluster_table file
        gslbConf, backendConf, err := srv.balTable.BalTableConfLoad(gslbFile, clusterTableFile)
        if err != nil </span><span class="cov0" title="0">{
                log.Logger.Error("GslbDataConfReload():BalTable conf load err [%s]", err)
                return err
        }</span>

        <span class="cov0" title="0">if err := srv.balTable.BalTableReload(gslbConf, backendConf); err != nil </span><span class="cov0" title="0">{
                log.Logger.Error("GslbDataConfReload():BalTableReload err [%s]", err)
                return err
        }</span>

        // set gslb basic conf
        <span class="cov0" title="0">srv.confLock.Lock()
        serverConf := srv.ServerConf
        srv.confLock.Unlock()
        srv.balTable.SetGslbBasic(serverConf.ClusterTable)
        // set slow_start config
        srv.balTable.SetSlowStart(serverConf.ClusterTable)

        return nil</span>
}

// SessionTicketKeyReload reloads for session ticket key.
func (srv *BfeServer) SessionTicketKeyReload() error <span class="cov0" title="0">{
        log.Logger.Info("start session ticket key reload")
        sessionTicketConf := srv.Config.SessionTicket
        if sessionTicketConf.SessionTicketsDisabled </span><span class="cov0" title="0">{
                return nil
        }</span>

        // load session ticket key
        <span class="cov0" title="0">keyFile := sessionTicketConf.SessionTicketKeyFile
        keyConf, err := session_ticket_key_conf.SessionTicketKeyConfLoad(keyFile)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">key, err := hex.DecodeString(keyConf.SessionTicketKey)
        if err != nil </span><span class="cov0" title="0">{ // never go here
                return fmt.Errorf("wrong session ticket key %s (%s)", err, key)
        }</span>

        // update session ticket key
        <span class="cov0" title="0">srv.HttpsListener.UpdateSessionTicketKey(key)
        log.Logger.Debug("update session ticket key for %s", keyConf.SessionTicketKey)

        return nil</span>
}

func (srv *BfeServer) TLSConfReload(query url.Values) error <span class="cov0" title="0">{
        log.Logger.Info("start tls rules reload (params: %s)", query)

        // enable or disable specified protocols
        protosParam := strings.Split(query.Get("enable"), ",")
        for _, proto := range protosParam </span><span class="cov0" title="0">{
                srv.enableTLSNextProto(proto)
        }</span>

        // reload tls conf
        <span class="cov0" title="0">certConfFile := srv.Config.HttpsBasic.ServerCertConf
        tlsRuleFile := srv.Config.HttpsBasic.TlsRuleConf
        if path := query.Get("path"); path != "" </span><span class="cov0" title="0">{
                certConfFile = joinPath(path, certConfFile)
                tlsRuleFile = joinPath(path, tlsRuleFile)
        }</span>

        <span class="cov0" title="0">return srv.tlsConfLoad(certConfFile, tlsRuleFile)</span>
}

func (srv *BfeServer) tlsConfLoad(certConfFile string, tlsRuleFile string) error <span class="cov0" title="0">{
        // load certificate conf
        certConf, err := server_cert_conf.ServerCertConfLoad(certConfFile, srv.ConfRoot)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("in ServerCertConfLoad() :%s", err.Error())
        }</span>

        // parse certificate
        <span class="cov0" title="0">certMap, err := server_cert_conf.ServerCertParse(certConf)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("in ServerCertParse() :%s", err.Error())
        }</span>

        // load tls server rule
        <span class="cov0" title="0">tlsRule, err := tls_rule_conf.TlsRuleConfLoad(tlsRuleFile)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("in TlsRuleConfLoad() :%s", err.Error())
        }</span>

        // load client CA certificates
        <span class="cov0" title="0">clientCABaseDir := srv.Config.HttpsBasic.ClientCABaseDir
        clientCAMap, err := tls_rule_conf.ClientCALoad(tlsRule.Config, clientCABaseDir)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("in ClientCALoad() :%s", err.Error())
        }</span>

        // load client cert CRL
        <span class="cov0" title="0">clientCRLBaseDir := srv.Config.HttpsBasic.ClientCRLBaseDir
        clientCRLPoolMap, err := tls_rule_conf.ClientCRLLoad(clientCAMap, clientCRLBaseDir)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("in ClientCRLLoad(): %s", err.Error())
        }</span>

        // validate tls conf
        <span class="cov0" title="0">if err := tls_rule_conf.CheckTlsConf(certMap, tlsRule.Config); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("in CheckTlsConf() :%s", err.Error())
        }</span>

        // update certificates and tls rule data
        <span class="cov0" title="0">srv.MultiCert.Update(certMap, tlsRule.Config)
        srv.TLSServerRule.Update(tlsRule, clientCAMap, clientCRLPoolMap)
        log.Logger.Debug("update tls server rule success")

        return nil</span>
}

func (srv *BfeServer) enableTLSNextProto(proto string) <span class="cov0" title="0">{
        switch proto </span>{
        case "+spdy", "spdy":<span class="cov0" title="0">
                srv.TLSServerRule.EnableNextProto("spdy", true)
                log.Logger.Info("spdy protocol is enabled")</span>
        case "-spdy":<span class="cov0" title="0">
                srv.TLSServerRule.EnableNextProto("spdy", false)
                log.Logger.Info("spdy protocol is disabled")</span>
        case "+h2", "h2":<span class="cov0" title="0">
                srv.TLSServerRule.EnableNextProto("h2", true)
                log.Logger.Info("http2 protocol is enabled")</span>
        case "-h2":<span class="cov0" title="0">
                srv.TLSServerRule.EnableNextProto("h2", false)
                log.Logger.Info("http2 protocol is disabled")</span>
        }
}

// NameConfReload reloads name conf data.
func (srv *BfeServer) NameConfReload(query url.Values) error <span class="cov0" title="0">{
        nameConfFile := query.Get("path")
        if nameConfFile == "" </span><span class="cov0" title="0">{
                nameConfFile = srv.Config.Server.NameConf
        }</span>

        <span class="cov0" title="0">return bns.LoadLocalNameConf(nameConfFile)</span>
}
</pre>
		
		<pre class="file" id="file212" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// BfeListener is a wrapper of TCP listener which accept connections behind
// a load balancer (PROXY/NONE)
//
//  Note: The TLS listener is wired together like:
//  1. TCP listener
//  2. BFE listener (PROXY)
//  3. TLS listener

package bfe_server

import (
        "net"
        "time"
)

import (
        "github.com/bfenetworks/bfe/bfe_config/bfe_conf"
        "github.com/bfenetworks/bfe/bfe_proxy"
)

import (
        "github.com/baidu/go-lib/log"
)

// BfeListener is used to wrap an underlying TCP listener, which accept connections
// behind a layer4 load balancer (PROXY)
type BfeListener struct {
        // Listener is the underlying tcp listener
        Listener net.Listener

        // BalancerType is the type of Layer4 load balancer
        BalancerType string

        // ProxyHeaderTimeout Optionally specifies the timeout value to
        // receive the Proxy Protocol Header. Zero means no timeout.
        ProxyHeaderTimeout time.Duration

        // ProxyHeaderLimit Optionally specifies the maximum bytes to
        // receive the Proxy Protocol Header. Zero means default value.
        ProxyHeaderLimit int64
}

// NewBfeListener return bfe listener according to config
func NewBfeListener(listener net.Listener, config bfe_conf.BfeConfig) *BfeListener <span class="cov0" title="0">{
        l := new(BfeListener)
        l.Listener = listener
        l.BalancerType = config.Server.Layer4LoadBalancer
        l.ProxyHeaderTimeout = time.Duration(config.Server.ClientReadTimeout) * time.Second
        l.ProxyHeaderLimit = int64(config.Server.MaxProxyHeaderBytes)

        return l
}</span>

// Accept implements the Accept method in the Listener interface;
// it waits for the next call and returns a generic net.Conn.
func (l *BfeListener) Accept() (net.Conn, error) <span class="cov0" title="0">{
        conn, err := l.Listener.Accept()
        if err != nil </span><span class="cov0" title="0">{
                log.Logger.Debug("BfeListener: accept error %s", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">switch l.BalancerType </span>{
        case bfe_conf.BalancerProxy:<span class="cov0" title="0">
                conn = bfe_proxy.NewConn(conn, l.ProxyHeaderTimeout, l.ProxyHeaderLimit)
                log.Logger.Debug("BfeListener: accept connection via PROXY")</span>
        }

        <span class="cov0" title="0">return conn, nil</span>
}

// Close closes the underlying listener.
func (l *BfeListener) Close() error <span class="cov0" title="0">{
        return l.Listener.Close()
}</span>

// Addr returns the underlying listener's network address.
func (l *BfeListener) Addr() net.Addr <span class="cov0" title="0">{
        return l.Listener.Addr()
}</span>
</pre>
		
		<pre class="file" id="file213" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// the main structure of bfe-server

package bfe_server

import (
        "encoding/hex"
        "fmt"
        "net"
        "os"
        "sync"
        "syscall"
        "time"
)

import (
        "github.com/baidu/go-lib/log"
)

import (
        "github.com/bfenetworks/bfe/bfe_balance"
        "github.com/bfenetworks/bfe/bfe_config/bfe_cluster_conf/cluster_conf"
        "github.com/bfenetworks/bfe/bfe_config/bfe_conf"
        "github.com/bfenetworks/bfe/bfe_config/bfe_tls_conf/session_ticket_key_conf"
        "github.com/bfenetworks/bfe/bfe_config/bfe_tls_conf/tls_rule_conf"
        "github.com/bfenetworks/bfe/bfe_http"
        "github.com/bfenetworks/bfe/bfe_http2"
        "github.com/bfenetworks/bfe/bfe_module"
        "github.com/bfenetworks/bfe/bfe_route"
        "github.com/bfenetworks/bfe/bfe_spdy"
        "github.com/bfenetworks/bfe/bfe_stream"
        "github.com/bfenetworks/bfe/bfe_tls"
        "github.com/bfenetworks/bfe/bfe_util/signal_table"
        "github.com/bfenetworks/bfe/bfe_websocket"
)

type BfeServer struct {
        bfe_http.Server

        // service listeners
        listenerMap   map[string]net.Listener // all listeners
        HttpListener  net.Listener            // listener for http
        HttpsListener *HttpsListener          // listener for https

        connWaitGroup sync.WaitGroup // waits for server conns to finish

        // for http server
        ReverseProxy *ReverseProxy // reverse proxy

        // TLS session cache
        SessionCache *ServerSessionCache

        // TLS certificates
        MultiCert *MultiCertMap

        // TLS server rule
        TLSServerRule *TLSServerRuleMap

        // server config
        Config   bfe_conf.BfeConfig
        ConfRoot string

        // module and callback
        CallBacks *bfe_module.BfeCallbacks // call back functions
        Modules   *bfe_module.BfeModules   // bfe modules
        Plugins   *bfe_module.BfePlugins   // bfe plugins

        // web server for bfe monitor and reload
        Monitor *BfeMonitor

        // bufio cache
        BufioCache *BufioCache

        // signal table
        SignalTable *signal_table.SignalTable

        // server status
        serverStatus *ServerStatus

        confLock   sync.RWMutex              // mutex when reload data conf
        ServerConf *bfe_route.ServerDataConf // cluster_conf and host table conf
        balTable   *bfe_balance.BalTable     // for balance

        Version string // version of bfe server
}

// NewBfeServer create a new instance of BfeServer.
func NewBfeServer(cfg bfe_conf.BfeConfig, confRoot string,
        version string) *BfeServer <span class="cov0" title="0">{

        s := new(BfeServer)

        // bfe config
        s.Config = cfg
        s.ConfRoot = confRoot
        s.InitConfig()

        // initialize counters, proxyState
        s.serverStatus = NewServerStatus()

        // initialize bufioCache
        s.BufioCache = NewBufioCache()

        // create reverse proxy
        s.ReverseProxy = NewReverseProxy(s, s.serverStatus.ProxyState)

        // initialize callbacks
        s.CallBacks = bfe_module.NewBfeCallbacks()
        // create modules
        s.Modules = bfe_module.NewBfeModules()
        // create plugins
        s.Plugins = bfe_module.NewBfePlugins()

        // initialize balTable
        s.balTable = bfe_balance.NewBalTable(s.GetCheckConf)

        // set keep-alive
        s.SetKeepAlivesEnabled(cfg.Server.KeepAliveEnabled)

        s.CloseNotifyCh = make(chan bool)

        s.Version = version

        return s
}</span>

// InitConfig set some parameter based on config.
func (srv *BfeServer) InitConfig() <span class="cov0" title="0">{
        // set service port, according to config
        srv.Addr = fmt.Sprintf(":%d", srv.Config.Server.HttpPort)

        // set TlsHandshakeTimeout
        if srv.Config.Server.TlsHandshakeTimeout != 0 </span><span class="cov0" title="0">{
                srv.TlsHandshakeTimeout = time.Duration(srv.Config.Server.TlsHandshakeTimeout) * time.Second
        }</span>

        // set ReadTimeout
        <span class="cov0" title="0">if srv.Config.Server.ClientReadTimeout != 0 </span><span class="cov0" title="0">{
                srv.ReadTimeout = time.Duration(srv.Config.Server.ClientReadTimeout) * time.Second
        }</span>

        // set MaxHeaderBytes
        <span class="cov0" title="0">if srv.Config.Server.MaxHeaderBytes != 0 </span><span class="cov0" title="0">{
                srv.MaxHeaderBytes = srv.Config.Server.MaxHeaderBytes
        }</span> else<span class="cov0" title="0"> {
                srv.MaxHeaderBytes = bfe_http.DefaultMaxHeaderBytes
        }</span>

        // set GracefulShutdownTimeout
        <span class="cov0" title="0">srv.GracefulShutdownTimeout = time.Duration(srv.Config.Server.GracefulShutdownTimeout) * time.Second

        // set MaxHeaderUriBytes
        if srv.Config.Server.MaxHeaderUriBytes != 0 </span><span class="cov0" title="0">{
                srv.MaxHeaderUriBytes = srv.Config.Server.MaxHeaderUriBytes
        }</span> else<span class="cov0" title="0"> {
                srv.MaxHeaderUriBytes = bfe_http.DefaultMaxHeaderUriBytes
        }</span>
}

func (srv *BfeServer) InitHttp() (err error) <span class="cov0" title="0">{
        // disable cookie value sanitize
        bfe_http.SetDisableSanitize(true)

        // initialize http next proto handlers
        httpNextProto := make(map[string]func(*bfe_http.Server, bfe_http.ResponseWriter, *bfe_http.Request))
        httpNextProto[bfe_websocket.WebSocket] = bfe_websocket.NewProtoHandler(&amp;bfe_websocket.Server{
                BalanceHandler: srv.Balance})
        srv.HTTPNextProto = httpNextProto

        return nil
}</span>

func (srv *BfeServer) InitHttps() (err error) <span class="cov0" title="0">{
        // initialize tls config
        if err := srv.initTLSConfig(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // init tls next proto handlers
        <span class="cov0" title="0">srv.initTLSNextProtoHandler()

        return nil</span>
}

func (srv *BfeServer) initTLSConfig() (err error) <span class="cov0" title="0">{
        srv.TLSConfig = new(bfe_tls.Config)
        httpsConf := srv.Config.HttpsBasic

        // set max and min TLS version
        srv.TLSConfig.MaxVersion, srv.TLSConfig.MinVersion = bfe_conf.GetTlsVersion(&amp;httpsConf)

        // enable Sslv2 ClientHello for compatible with ancient TLS-capable clients
        srv.TLSConfig.EnableSslv2ClientHello = httpsConf.EnableSslv2ClientHello

        // initialize ciphersuites preference
        srv.TLSConfig.PreferServerCipherSuites = true
        cipherSuites, cipherSuitesPriority, err := bfe_conf.GetCipherSuites(httpsConf.CipherSuites)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("in ServerCertConfLoad() :%s", err.Error())
        }</span>
        <span class="cov0" title="0">srv.TLSConfig.CipherSuites = cipherSuites
        srv.TLSConfig.CipherSuitesPriority = cipherSuitesPriority

        // set Ssl3PoodleProofed true make server free of poodle attach
        srv.TLSConfig.Ssl3PoodleProofed = true

        // initialize elliptic curves preference
        srv.TLSConfig.CurvePreferences, err = bfe_conf.GetCurvePreferences(httpsConf.CurvePreferences)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("in ServerCertConfLoad() :%s", err.Error())
        }</span>

        // initialize session cache
        <span class="cov0" title="0">srv.initTLSSessionCache()

        // initialize session ticket
        if err = srv.initTLSSessionTicket(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // initialize tls rule
        <span class="cov0" title="0">if err = srv.initTLSRule(httpsConf); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (srv *BfeServer) initTLSSessionCache() <span class="cov0" title="0">{
        sessionCacheConf := srv.Config.SessionCache
        srv.TLSConfig.SessionCacheDisabled = sessionCacheConf.SessionCacheDisabled

        if !sessionCacheConf.SessionCacheDisabled </span><span class="cov0" title="0">{
                srv.SessionCache = NewServerSessionCache(sessionCacheConf, srv.serverStatus.ProxyState)
                srv.TLSConfig.ServerSessionCache = srv.SessionCache
        }</span>
}

func (srv *BfeServer) initTLSSessionTicket() error <span class="cov0" title="0">{
        sessionTicketConf := srv.Config.SessionTicket

        // initialize session ticket key
        if !sessionTicketConf.SessionTicketsDisabled </span><span class="cov0" title="0">{
                srv.TLSConfig.SessionTicketsDisabled = false
                keyFile := sessionTicketConf.SessionTicketKeyFile
                keyConf, err := session_ticket_key_conf.SessionTicketKeyConfLoad(keyFile)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">key, err := hex.DecodeString(keyConf.SessionTicketKey)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("wrong session ticket key %s (%s)", err, key)
                }</span>

                <span class="cov0" title="0">copy(srv.TLSConfig.SessionTicketKeyName[:], key[:16])
                copy(srv.TLSConfig.SessionTicketKey[:], key[16:])</span>
        } else<span class="cov0" title="0"> {
                srv.TLSConfig.SessionTicketsDisabled = true
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (srv *BfeServer) initTLSRule(httpsConf bfe_conf.ConfigHttpsBasic) error <span class="cov0" title="0">{
        srv.MultiCert = NewMultiCertMap(srv.serverStatus.ProxyState)
        srv.TLSServerRule = NewTLSServerRuleMap(srv.serverStatus.ProxyState)
        if err := srv.tlsConfLoad(httpsConf.ServerCertConf, httpsConf.TlsRuleConf); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">cert := srv.MultiCert.GetDefault()
        if cert == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("createTlsConfig get default Cert error")
        }</span>

        // Note: config.Certificates must be initialized, but we just use config.MultiCert
        // for server certificates
        <span class="cov0" title="0">srv.TLSConfig.Certificates = make([]bfe_tls.Certificate, 1)
        srv.TLSConfig.Certificates[0] = *cert
        srv.TLSConfig.MultiCert = srv.MultiCert
        srv.TLSConfig.ServerRule = srv.TLSServerRule
        return nil</span>
}

func (srv *BfeServer) initTLSNextProtoHandler() <span class="cov0" title="0">{
        // init next protocol handler
        tlsNextProto := make(map[string]func(*bfe_http.Server, *bfe_tls.Conn, bfe_http.Handler))
        tlsNextProto[tls_rule_conf.SPDY31] = bfe_spdy.NewProtoHandler(nil)
        tlsNextProto[tls_rule_conf.HTTP2] = bfe_http2.NewProtoHandler(nil)
        tlsNextProto[tls_rule_conf.STREAM] = bfe_stream.NewProtoHandler(&amp;bfe_stream.Server{
                BalanceHandler: srv.Balance})
        srv.TLSNextProto = tlsNextProto

        // init params for http2
        bfe_http2.DisableConnHeaderCheck()
        bfe_http2.SetServerRule(srv.TLSServerRule)
        bfe_http2.EnableLargeConnRecvWindow()

        // init params for stream
        bfe_stream.SetServerRule(srv.TLSServerRule)
}</span>

func (srv *BfeServer) InitModules() error <span class="cov0" title="0">{
        return srv.Modules.Init(srv.CallBacks, srv.Monitor.WebHandlers, srv.ConfRoot)
}</span>

func (srv *BfeServer) LoadPlugins(plugins []string) error <span class="cov0" title="0">{
        if len(plugins) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">for _, pluginPath := range plugins </span><span class="cov0" title="0">{
                if err := srv.Plugins.RegisterPlugin(pluginPath, srv.Version); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">log.Logger.Info("RegisterPlugin():pluginPath=%s", pluginPath)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (srv *BfeServer) InitPlugins() error <span class="cov0" title="0">{
        return srv.Plugins.Init(srv.CallBacks, srv.Monitor.WebHandlers, srv.ConfRoot)
}</span>

func (srv *BfeServer) InitSignalTable() <span class="cov0" title="0">{
        /* create signal table */
        srv.SignalTable = signal_table.NewSignalTable()

        /* register signal handlers */
        srv.SignalTable.Register(syscall.SIGQUIT, srv.ShutdownHandler)
        srv.SignalTable.Register(syscall.SIGTERM, signal_table.TermHandler)
        srv.SignalTable.Register(syscall.SIGHUP, signal_table.IgnoreHandler)
        srv.SignalTable.Register(syscall.SIGILL, signal_table.IgnoreHandler)
        srv.SignalTable.Register(syscall.SIGTRAP, signal_table.IgnoreHandler)
        srv.SignalTable.Register(syscall.SIGABRT, signal_table.IgnoreHandler)

        /* start signal handler routine */
        srv.SignalTable.StartSignalHandle()
}</span>

func (srv *BfeServer) InitWebMonitor(port int) error <span class="cov0" title="0">{
        var err error
        srv.Monitor, err = newBfeMonitor(srv, port)
        return err
}</span>

// ShutdownHandler is signal handler for QUIT
func (srv *BfeServer) ShutdownHandler(sig os.Signal) <span class="cov0" title="0">{
        shutdownTimeout := srv.Config.Server.GracefulShutdownTimeout
        log.Logger.Info("get signal %s, graceful shutdown in %ds", sig, shutdownTimeout)

        // notify that server is in graceful shutdown state
        close(srv.CloseNotifyCh)

        // close server listeners
        srv.closeListeners()

        // waits server conns to finish
        connFinCh := make(chan bool)
        go func() </span><span class="cov0" title="0">{
                srv.connWaitGroup.Wait()
                connFinCh &lt;- true
        }</span>()

        <span class="cov0" title="0">shutdownTimer := time.After(time.Duration(shutdownTimeout) * time.Second)

Loop:
        for </span><span class="cov0" title="0">{
                select </span>{
                // waits server conns to finish
                case &lt;-connFinCh:<span class="cov0" title="0">
                        log.Logger.Info("graceful shutdown success.")
                        break Loop</span>

                // wait for shutdown timeout
                case &lt;-shutdownTimer:<span class="cov0" title="0">
                        log.Logger.Info("graceful shutdown timeout.")
                        break Loop</span>
                }
        }

        // shutdown server
        <span class="cov0" title="0">log.Logger.Close()
        os.Exit(0)</span>
}

// CheckGracefulShutdown check whether the server is in graceful shutdown state.
func (srv *BfeServer) CheckGracefulShutdown() bool <span class="cov0" title="0">{
        select </span>{
        case &lt;-srv.CloseNotifyCh:<span class="cov0" title="0">
                return true</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

func (srv *BfeServer) GetServerConf() *bfe_route.ServerDataConf <span class="cov0" title="0">{
        srv.confLock.RLock()
        sf := srv.ServerConf
        srv.confLock.RUnlock()

        return sf
}</span>

// GetCheckConf implements CheckConfFetcher and return current
// health check configuration.
func (srv *BfeServer) GetCheckConf(clusterName string) *cluster_conf.BackendCheck <span class="cov0" title="0">{
        sf := srv.GetServerConf()
        cluster, err := sf.ClusterTable.Lookup(clusterName)
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return cluster.BackendCheckConf()</span>
}

func (srv *BfeServer) InitListeners(config bfe_conf.BfeConfig) error <span class="cov0" title="0">{
        listenerMap := make(map[string]net.Listener)
        lnConf := map[string]int{
                "HTTP":  config.Server.HttpPort,
                "HTTPS": config.Server.HttpsPort,
        }

        for proto, port := range lnConf </span><span class="cov0" title="0">{
                listener, err := net.Listen("tcp", fmt.Sprintf(":%d", port))
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // wrap underlying listener according to balancer type
                <span class="cov0" title="0">listener = NewBfeListener(listener, config)
                listenerMap[proto] = listener
                log.Logger.Info("InitListeners(): begin to listen [:%d]", port)</span>
        }

        <span class="cov0" title="0">srv.listenerMap = listenerMap
        srv.HttpListener = listenerMap["HTTP"]
        srv.HttpsListener = NewHttpsListener(srv.listenerMap["HTTPS"], srv.TLSConfig)

        return nil</span>
}

func (srv *BfeServer) closeListeners() <span class="cov0" title="0">{
        for _, ln := range srv.listenerMap </span><span class="cov0" title="0">{
                if err := ln.Close(); err != nil </span><span class="cov0" title="0">{
                        log.Logger.Error("closeListeners(): %s, %s", err, ln.Addr())
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file214" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// create bfe service and init

package bfe_server

import (
        "github.com/baidu/go-lib/log"
)

import (
        "github.com/bfenetworks/bfe/bfe_config/bfe_conf"
        "github.com/bfenetworks/bfe/bfe_modules"
)

func StartUp(cfg bfe_conf.BfeConfig, version string, confRoot string) error <span class="cov0" title="0">{
        var err error

        // set all available modules
        bfe_modules.SetModules()

        // create bfe server
        bfeServer := NewBfeServer(cfg, confRoot, version)

        // initial http
        if err = bfeServer.InitHttp(); err != nil </span><span class="cov0" title="0">{
                log.Logger.Error("StartUp(): InitHttp():%s", err.Error())
                return err
        }</span>

        // initial https
        <span class="cov0" title="0">if err = bfeServer.InitHttps(); err != nil </span><span class="cov0" title="0">{
                log.Logger.Error("StartUp(): InitHttps():%s", err.Error())
                return err
        }</span>

        // load data
        <span class="cov0" title="0">if err = bfeServer.InitDataLoad(); err != nil </span><span class="cov0" title="0">{
                log.Logger.Error("StartUp(): bfeServer.InitDataLoad():%s",
                        err.Error())
                return err
        }</span>
        <span class="cov0" title="0">log.Logger.Info("StartUp(): bfeServer.InitDataLoad() OK")

        // setup signal table
        bfeServer.InitSignalTable()
        log.Logger.Info("StartUp():bfeServer.InitSignalTable() OK")

        // init web monitor
        monitorPort := cfg.Server.MonitorPort
        if err = bfeServer.InitWebMonitor(monitorPort); err != nil </span><span class="cov0" title="0">{
                log.Logger.Error("StartUp(): InitWebMonitor():%s", err.Error())
                return err
        }</span>

        // register modules
        <span class="cov0" title="0">if err = bfeServer.RegisterModules(cfg.Server.Modules); err != nil </span><span class="cov0" title="0">{
                log.Logger.Error("StartUp(): RegisterModules():%s", err.Error())
                return err
        }</span>

        // initialize modules
        <span class="cov0" title="0">if err = bfeServer.InitModules(); err != nil </span><span class="cov0" title="0">{
                log.Logger.Error("StartUp(): bfeServer.InitModules():%s",
                        err.Error())
                return err
        }</span>
        <span class="cov0" title="0">log.Logger.Info("StartUp():bfeServer.InitModules() OK")

        // load plugins
        if err = bfeServer.LoadPlugins(cfg.Server.Plugins); err != nil </span><span class="cov0" title="0">{
                log.Logger.Error("StartUp():bfeServer.LoadPlugins():%s", err.Error())
                return err
        }</span>

        // initialize plugins
        <span class="cov0" title="0">if err = bfeServer.InitPlugins(); err != nil </span><span class="cov0" title="0">{
                log.Logger.Error("StartUp():bfeServer.InitPlugins():%s",
                        err.Error())
                return err
        }</span>
        <span class="cov0" title="0">log.Logger.Info("StartUp():bfeServer.InitPlugins() OK")

        // initialize listeners
        if err = bfeServer.InitListeners(cfg); err != nil </span><span class="cov0" title="0">{
                log.Logger.Error("StartUp(): InitListeners():%v", err)
                return err
        }</span>

        // start embedded web server if enabled
        <span class="cov0" title="0">if cfg.Server.MonitorEnabled </span><span class="cov0" title="0">{
                bfeServer.Monitor.Start()
        }</span>

        <span class="cov0" title="0">serveChan := make(chan error)

        // start goroutine to accept http connections
        for i := 0; i &lt; cfg.Server.AcceptNum; i++ </span><span class="cov0" title="0">{
                go func() </span><span class="cov0" title="0">{
                        httpErr := bfeServer.ServeHttp(bfeServer.HttpListener)
                        serveChan &lt;- httpErr
                }</span>()
        }

        // start goroutine to accept https connections
        <span class="cov0" title="0">for i := 0; i &lt; cfg.Server.AcceptNum; i++ </span><span class="cov0" title="0">{
                go func() </span><span class="cov0" title="0">{
                        httpsErr := bfeServer.ServeHttps(bfeServer.HttpsListener)
                        serveChan &lt;- httpsErr
                }</span>()
        }

        <span class="cov0" title="0">err = &lt;-serveChan
        return err</span>
}
</pre>
		
		<pre class="file" id="file215" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// HTTP server.  See RFC 2616.

package bfe_server

import (
        "io"
        "sync"
)

import (
        bufio "github.com/bfenetworks/bfe/bfe_bufio"
)

var (
        bufioReaderPool    sync.Pool
        bufioWriter256Pool sync.Pool
        bufioWriter512Pool sync.Pool
        bufioWriter1kPool  sync.Pool
        bufioWriter2kPool  sync.Pool
        bufioWriter4kPool  sync.Pool
)

func bufioWriterPool(size int) *sync.Pool <span class="cov0" title="0">{
        switch size </span>{
        case 1 &lt;&lt; 8:<span class="cov0" title="0">
                return &amp;bufioWriter256Pool</span>
        case 1 &lt;&lt; 9:<span class="cov0" title="0">
                return &amp;bufioWriter512Pool</span>
        case 1 &lt;&lt; 10:<span class="cov0" title="0">
                return &amp;bufioWriter1kPool</span>
        case 2 &lt;&lt; 10:<span class="cov0" title="0">
                return &amp;bufioWriter2kPool</span>
        case 4 &lt;&lt; 10:<span class="cov0" title="0">
                return &amp;bufioWriter4kPool</span>
        }
        <span class="cov0" title="0">return nil</span>
}

type BufioCache struct {
}

func NewBufioCache() *BufioCache <span class="cov0" title="0">{
        return new(BufioCache)
}</span>

func (*BufioCache) newBufioReader(r io.Reader) *bufio.Reader <span class="cov0" title="0">{
        if v := bufioReaderPool.Get(); v != nil </span><span class="cov0" title="0">{
                br := v.(*bufio.Reader)
                br.Reset(r)
                return br
        }</span>
        <span class="cov0" title="0">return bufio.NewReader(r)</span>
}

func (*BufioCache) putBufioReader(br *bufio.Reader) <span class="cov0" title="0">{
        br.Reset(nil)
        bufioReaderPool.Put(br)
}</span>

func (*BufioCache) newBufioWriterSize(w io.Writer, size int) *bufio.Writer <span class="cov0" title="0">{
        pool := bufioWriterPool(size)
        if pool != nil </span><span class="cov0" title="0">{
                if v := pool.Get(); v != nil </span><span class="cov0" title="0">{
                        bw := v.(*bufio.Writer)
                        bw.Reset(w)
                        return bw
                }</span>
        }
        <span class="cov0" title="0">return bufio.NewWriterSize(w, size)</span>
}

func (*BufioCache) putBufioWriter(bw *bufio.Writer) <span class="cov0" title="0">{
        bw.Reset(nil)
        if pool := bufioWriterPool(bw.Available()); pool != nil </span><span class="cov0" title="0">{
                pool.Put(bw)
        }</span>
}
</pre>
		
		<pre class="file" id="file216" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// HTTP server.  See RFC 2616.

package bfe_server

import (
        "fmt"
        "io"
        "io/ioutil"
        "strconv"
        "sync"
        "time"
)

import (
        "github.com/baidu/go-lib/log"
)

import (
        "github.com/bfenetworks/bfe/bfe_bufio"
        "github.com/bfenetworks/bfe/bfe_http"
)

// maxPostHandlerReadBytes is the max number of Request.Body bytes not
// consumed by a handler that the server will read from the client
// in order to keep a connection alive.  If there are more bytes than
// this then the server to be paranoid instead sends a "Connection:
// close" response.
//
// This number is approximately what a typical machine's TCP buffer
// size is anyway.  (if we have the bytes on the machine, we might as
// well read them)
const maxPostHandlerReadBytes = 256 &lt;&lt; 10

// extraHeader is the set of headers sometimes added by chunkWriter.writeHeader.
// This type is used to avoid extra allocations from cloning and/or populating
// the response Header map and all its 1-element slices.
type extraHeader struct {
        contentType      string
        connection       string
        transferEncoding string
        date             []byte // written if not nil
        contentLength    []byte // written if not nil
}

// Sorted the same as extraHeader.Write's loop.
var extraHeaderKeys = [][]byte{
        []byte("Content-Type"),
        []byte("Connection"),
        []byte("Transfer-Encoding"),
}

var (
        headerContentLength = []byte("Content-Length: ")
        headerDate          = []byte("Date: ")
)

// Write writes the headers described in h to w.
//
// This method has a value receiver, despite the somewhat large size
// of h, because it prevents an allocation. The escape analysis isn't
// smart enough to realize this function doesn't mutate h.
func (h extraHeader) Write(w *bfe_bufio.Writer) <span class="cov0" title="0">{
        if h.date != nil </span><span class="cov0" title="0">{
                w.Write(headerDate)
                w.Write(h.date)
                w.Write(crlf)
        }</span>
        <span class="cov0" title="0">if h.contentLength != nil </span><span class="cov0" title="0">{
                w.Write(headerContentLength)
                w.Write(h.contentLength)
                w.Write(crlf)
        }</span>
        <span class="cov0" title="0">for i, v := range []string{h.contentType, h.connection, h.transferEncoding} </span><span class="cov0" title="0">{
                if v != "" </span><span class="cov0" title="0">{
                        w.Write(extraHeaderKeys[i])
                        w.Write(colonSpace)
                        w.WriteString(v)
                        w.Write(crlf)
                }</span>
        }
}

// chunkWriter writes to a response's conn buffer, and is the writer
// wrapped by the response.bufw buffered writer.
//
// chunkWriter also is responsible for finalizing the Header, including
// conditionally setting the Content-Type and setting a Content-Length
// in cases where the handler's final output is smaller than the buffer
// size. It also conditionally adds chunk headers, when in chunking mode.
//
// See the comment above (*response).Write for the entire write flow.
type chunkWriter struct {
        res *response

        // header is either nil or a deep clone of res.handlerHeader
        // at the time of res.WriteHeader, if res.WriteHeader is
        // called and extra buffering is being done to calculate
        // Content-Type and/or Content-Length.
        header bfe_http.Header

        // wroteHeader tells whether the header's been written to "the
        // wire" (or rather: w.conn.buf). this is unlike
        // (*response).wroteHeader, which tells only whether it was
        // logically written.
        wroteHeader bool

        // set by the writeHeader method:
        chunking bool // using chunked transfer encoding for reply body

        // total bytes of body written
        length int

        // Signer calculates signature for current response
        Signer bfe_http.SignCalculator
}

var (
        crlf       = []byte("\r\n")
        colonSpace = []byte(": ")
)

func (cw *chunkWriter) Write(p []byte) (n int, err error) <span class="cov0" title="0">{
        if !cw.wroteHeader </span><span class="cov0" title="0">{
                cw.writeHeader(p)
        }</span>
        <span class="cov0" title="0">if cw.res.req.Method == "HEAD" </span><span class="cov0" title="0">{
                // Eat writes.
                return len(p), nil
        }</span>
        <span class="cov0" title="0">if cw.chunking </span><span class="cov0" title="0">{
                _, err = fmt.Fprintf(cw.res.conn.buf, "%x\r\n", len(p))
                if err != nil </span><span class="cov0" title="0">{
                        cw.res.conn.rwc.Close()
                        return
                }</span>
        }
        <span class="cov0" title="0">n, err = cw.res.conn.buf.Write(p)
        if cw.chunking &amp;&amp; err == nil </span><span class="cov0" title="0">{
                _, err = cw.res.conn.buf.Write(crlf)
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                cw.res.conn.rwc.Close()
        }</span>

        // update total bytes written
        <span class="cov0" title="0">cw.length += len(p)

        // force flush data
        cw.flush()

        return</span>
}

func (cw *chunkWriter) flush() <span class="cov0" title="0">{
        if !cw.wroteHeader </span><span class="cov0" title="0">{
                cw.writeHeader(nil)
        }</span>
        <span class="cov0" title="0">cw.res.conn.buf.Flush()</span>
}

func (cw *chunkWriter) close() <span class="cov0" title="0">{
        if !cw.wroteHeader </span><span class="cov0" title="0">{
                cw.writeHeader(nil)
        }</span>
        <span class="cov0" title="0">if cw.chunking </span><span class="cov0" title="0">{
                // zero EOF chunk, trailer key/value pairs (currently
                // unsupported in Go's server), followed by a blank
                // line.
                cw.res.conn.buf.WriteString("0\r\n\r\n")
        }</span>
}

// appendTime is a non-allocating version of []byte(t.UTC().Format(TimeFormat))
func appendTime(b []byte, t time.Time) []byte <span class="cov0" title="0">{
        const days = "SunMonTueWedThuFriSat"
        const months = "JanFebMarAprMayJunJulAugSepOctNovDec"

        t = t.UTC()
        yy, mm, dd := t.Date()
        hh, mn, ss := t.Clock()
        day := days[3*t.Weekday():]
        mon := months[3*(mm-1):]

        return append(b,
                day[0], day[1], day[2], ',', ' ',
                byte('0'+dd/10), byte('0'+dd%10), ' ',
                mon[0], mon[1], mon[2], ' ',
                byte('0'+yy/1000), byte('0'+(yy/100)%10), byte('0'+(yy/10)%10), byte('0'+yy%10), ' ',
                byte('0'+hh/10), byte('0'+hh%10), ':',
                byte('0'+mn/10), byte('0'+mn%10), ':',
                byte('0'+ss/10), byte('0'+ss%10), ' ',
                'G', 'M', 'T')
}</span>

// statusLines is a cache of Status-Line strings, keyed by code (for
// HTTP/1.1) or negative code (for HTTP/1.0). This is faster than a
// map keyed by struct of two fields. This map's max size is bounded
// by 2*len(statusText), two protocol types for each known official
// status code in the statusText map.
var (
        statusMu    sync.RWMutex
        statusLines = make(map[int]string)
)

// statusLine returns a response Status-Line (RFC 2616 Section 6.1)
// for the given request and response status code.
func statusLine(req *bfe_http.Request, code int) string <span class="cov0" title="0">{
        // Fast path:
        key := code
        proto11 := req.ProtoAtLeast(1, 1)
        if !proto11 </span><span class="cov0" title="0">{
                key = -key
        }</span>
        <span class="cov0" title="0">statusMu.RLock()
        line, ok := statusLines[key]
        statusMu.RUnlock()
        if ok </span><span class="cov0" title="0">{
                return line
        }</span>

        // Slow path:
        <span class="cov0" title="0">proto := "HTTP/1.0"
        if proto11 </span><span class="cov0" title="0">{
                proto = "HTTP/1.1"
        }</span>
        <span class="cov0" title="0">codestring := strconv.Itoa(code)
        text, ok := bfe_http.StatusText[code]
        if !ok </span><span class="cov0" title="0">{
                text = "status code " + codestring
        }</span>
        <span class="cov0" title="0">line = proto + " " + codestring + " " + text + "\r\n"
        if ok </span><span class="cov0" title="0">{
                statusMu.Lock()
                defer statusMu.Unlock()
                statusLines[key] = line
        }</span>
        <span class="cov0" title="0">return line</span>
}

// writeHeader finalizes the header sent to the client and writes it
// to cw.res.conn.buf.
//
// p is not written by writeHeader, but is the first chunk of the body
// that will be written.  It is sniffed for a Content-Type if none is
// set explicitly.  It's also used to set the Content-Length, if the
// total body size was small and the handler has already finished
// running.
func (cw *chunkWriter) writeHeader(p []byte) <span class="cov0" title="0">{
        if cw.wroteHeader </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">cw.wroteHeader = true

        w := cw.res
        isHEAD := w.req.Method == "HEAD"

        // header is written out to w.conn.buf below. Depending on the
        // state of the handler, we either own the map or not. If we
        // don't own it, the exclude map is created lazily for
        // WriteSubset to remove headers. The setHeader struct holds
        // headers we need to add.
        header := cw.header
        owned := header != nil
        if !owned </span><span class="cov0" title="0">{
                header = w.handlerHeader
        }</span>
        <span class="cov0" title="0">var excludeHeader map[string]bool
        delHeader := func(key string) </span><span class="cov0" title="0">{
                if owned </span><span class="cov0" title="0">{
                        header.Del(key)
                        return
                }</span>
                <span class="cov0" title="0">if _, ok := header[key]; !ok </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">if excludeHeader == nil </span><span class="cov0" title="0">{
                        excludeHeader = make(map[string]bool)
                }</span>
                <span class="cov0" title="0">excludeHeader[key] = true</span>
        }
        <span class="cov0" title="0">var setHeader extraHeader

        // If the handler is done but never sent a Content-Length
        // response header and this is our first (and last) write, set
        // it, even to zero. This helps HTTP/1.0 clients keep their
        // "keep-alive" connections alive.
        // Exceptions: 304 responses never get Content-Length, and if
        // it was a HEAD request, we don't know the difference between
        // 0 actual bytes and 0 bytes because the handler noticed it
        // was a HEAD request and chose not to write anything.  So for
        // HEAD, the handler should either write the Content-Length or
        // write non-zero bytes.  If it's actually 0 bytes and the
        // handler never looked at the Request.Method, we just don't
        // send a Content-Length header.
        if w.handlerDone &amp;&amp; w.status != bfe_http.StatusNotModified &amp;&amp; header.GetDirect("Content-Length") == "" &amp;&amp; (!isHEAD || len(p) &gt; 0) </span><span class="cov0" title="0">{
                w.contentLength = int64(len(p))
                setHeader.contentLength = strconv.AppendInt(cw.res.clenBuf[:0], int64(len(p)), 10)
        }</span>

        // If this was an HTTP/1.0 request with keep-alive and we sent a
        // Content-Length back, we can make this a keep-alive response ...
        <span class="cov0" title="0">if w.req.WantsHttp10KeepAlive() </span><span class="cov0" title="0">{
                sentLength := header.GetDirect("Content-Length") != ""
                if sentLength &amp;&amp; header.GetDirect("Connection") == "keep-alive" </span><span class="cov0" title="0">{
                        w.closeAfterReply = false
                }</span>
        }

        // Check for a explicit (and valid) Content-Length header.
        <span class="cov0" title="0">hasCL := w.contentLength != -1

        if w.req.WantsHttp10KeepAlive() &amp;&amp; (isHEAD || hasCL) </span><span class="cov0" title="0">{
                _, connectionHeaderSet := header["Connection"]
                if !connectionHeaderSet </span><span class="cov0" title="0">{
                        setHeader.connection = "keep-alive"
                }</span>
        } else<span class="cov0" title="0"> if !w.req.ProtoAtLeast(1, 1) || w.req.WantsClose() </span><span class="cov0" title="0">{
                w.closeAfterReply = true
        }</span>

        <span class="cov0" title="0">if header.GetDirect("Connection") == "close" </span><span class="cov0" title="0">{
                w.closeAfterReply = true
        }</span>

        <span class="cov0" title="0">if !w.conn.server.DoKeepAlives() </span><span class="cov0" title="0">{
                w.closeAfterReply = true
        }</span>

        <span class="cov0" title="0">if ecr, ok := w.req.Body.(*expectContinueReader); ok &amp;&amp; !ecr.sawEOF.isSet() </span><span class="cov0" title="0">{
                w.closeAfterReply = true
        }</span>

        // Per RFC 2616, we should consume the request body before
        // replying, if the handler hasn't already done so.  But we
        // don't want to do an unbounded amount of reading here for
        // DoS reasons, so we only try up to a threshold.
        <span class="cov0" title="0">if w.req.ContentLength != 0 &amp;&amp; !w.closeAfterReply </span><span class="cov0" title="0">{
                ecr, isExpecter := w.req.Body.(*expectContinueReader)
                if !isExpecter || ecr.WroteContinue() </span><span class="cov0" title="0">{
                        n, _ := io.CopyN(ioutil.Discard, w.req.Body, maxPostHandlerReadBytes+1)
                        if n &gt;= maxPostHandlerReadBytes </span><span class="cov0" title="0">{
                                w.requestTooLarge()
                                delHeader("Connection")
                                setHeader.connection = "close"
                        }</span> else<span class="cov0" title="0"> {
                                w.req.Body.Close()
                        }</span>
                }
        }

        <span class="cov0" title="0">code := w.status
        if code == bfe_http.StatusNotModified </span><span class="cov0" title="0">{
                // Must not have body.
                // RFC 2616 section 10.3.5: "the response MUST NOT include other entity-headers"
                for _, k := range []string{"Content-Type", "Content-Length", "Transfer-Encoding"} </span><span class="cov0" title="0">{
                        delHeader(k)
                }</span>
        } else<span class="cov0" title="0"> {
                // If no content type, apply sniffing algorithm to body.
                _, haveType := header["Content-Type"]
                if !haveType </span><span class="cov0" title="0">{
                        setHeader.contentType = bfe_http.DetectContentType(p)
                }</span>
        }

        <span class="cov0" title="0">if _, ok := header["Date"]; !ok </span><span class="cov0" title="0">{
                setHeader.date = appendTime(cw.res.dateBuf[:0], time.Now())
        }</span>

        <span class="cov0" title="0">te := header.GetDirect("Transfer-Encoding")
        hasTE := te != ""
        if hasCL &amp;&amp; hasTE &amp;&amp; te != "identity" </span><span class="cov0" title="0">{
                // TODO: return an error if WriteHeader gets a return parameter
                // For now just ignore the Content-Length.
                log.Logger.Warn("http: WriteHeader called with both Transfer-Encoding of %q and a Content-Length of %d",
                        te, w.contentLength)
                delHeader("Content-Length")
                hasCL = false
        }</span>

        <span class="cov0" title="0">if w.req.Method == "HEAD" || code == bfe_http.StatusNotModified </span>{<span class="cov0" title="0">
                // do nothing
        }</span> else<span class="cov0" title="0"> if code == bfe_http.StatusNoContent </span><span class="cov0" title="0">{
                delHeader("Transfer-Encoding")
        }</span> else<span class="cov0" title="0"> if hasCL </span><span class="cov0" title="0">{
                delHeader("Transfer-Encoding")
        }</span> else<span class="cov0" title="0"> if w.req.ProtoAtLeast(1, 1) </span><span class="cov0" title="0">{
                // HTTP/1.1 or greater: use chunked transfer encoding
                // to avoid closing the connection at EOF.
                // TODO: this blows away any custom or stacked Transfer-Encoding they
                // might have set.  Deal with that as need arises once we have a valid
                // use case.
                cw.chunking = true
                setHeader.transferEncoding = "chunked"
        }</span> else<span class="cov0" title="0"> {
                // HTTP version &lt; 1.1: cannot do chunked transfer
                // encoding and we don't know the Content-Length so
                // signal EOF by closing connection.
                w.closeAfterReply = true
                delHeader("Transfer-Encoding") // in case already set
        }</span>

        // Cannot use Content-Length with non-identity Transfer-Encoding.
        <span class="cov0" title="0">if cw.chunking </span><span class="cov0" title="0">{
                delHeader("Content-Length")
        }</span>
        <span class="cov0" title="0">if !w.req.ProtoAtLeast(1, 0) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">if w.closeAfterReply &amp;&amp; !bfe_http.HasToken(cw.header.GetDirect("Connection"), "close") </span><span class="cov0" title="0">{
                delHeader("Connection")
                if w.req.ProtoAtLeast(1, 1) </span><span class="cov0" title="0">{
                        setHeader.connection = "close"
                }</span>
        }

        <span class="cov0" title="0">prev := w.conn.buf.TotalWrite
        w.conn.buf.WriteString(statusLine(w.req, code))
        cw.header.WriteSubset(w.conn.buf, excludeHeader)
        setHeader.Write(w.conn.buf.Writer)

        w.conn.buf.Write(crlf)
        w.headerWritten = int64(w.conn.buf.TotalWrite - prev)</span>
}
</pre>
		
		<pre class="file" id="file217" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// HTTP server.  See RFC 2616.

package bfe_server

import (
        "errors"
        "io"
)

import (
        "github.com/bfenetworks/bfe/bfe_http"
)

// wrapper around io.ReaderCloser which on first read, sends an
// HTTP/1.1 100 Continue header
type expectContinueReader struct {
        resp       *response
        readCloser io.ReadCloser
        closed     atomicBool
        sawEOF     atomicBool
}

func (ecr *expectContinueReader) tryWriteContinue() <span class="cov0" title="0">{
        w := ecr.resp

        if !w.wroteContinue &amp;&amp; w.canWriteContinue.isSet() </span><span class="cov0" title="0">{
                w.wroteContinue = true
                w.writeContinueMu.Lock()
                if w.canWriteContinue.isSet() </span><span class="cov0" title="0">{
                        ecr.resp.conn.buf.WriteString("HTTP/1.1 100 Continue\r\n\r\n")
                        ecr.resp.conn.buf.Flush()
                        w.canWriteContinue.setFalse()
                }</span>
                <span class="cov0" title="0">w.writeContinueMu.Unlock()</span>
        }
}

func (ecr *expectContinueReader) Read(p []byte) (n int, err error) <span class="cov0" title="0">{
        if ecr.closed.isSet() </span><span class="cov0" title="0">{
                return 0, bfe_http.ErrBodyReadAfterClose
        }</span>

        <span class="cov0" title="0">ecr.tryWriteContinue()
        n, err = ecr.readCloser.Read(p)
        if err == io.EOF </span><span class="cov0" title="0">{
                ecr.sawEOF.setTrue()
        }</span>
        <span class="cov0" title="0">return</span>
}

func (ecr *expectContinueReader) Close() error <span class="cov0" title="0">{
        ecr.closed.setTrue()
        return ecr.readCloser.Close()
}</span>

var ErrExpectContinueReaderPeek = errors.New("http: expect continue reader peek failed")

// Peek add peek function which is used by access log module
func (ecr *expectContinueReader) Peek(n int) ([]byte, error) <span class="cov0" title="0">{
        if ecr.closed.isSet() </span><span class="cov0" title="0">{
                return nil, bfe_http.ErrBodyReadAfterClose
        }</span>

        // Ensure that "100-continue" has been written before peeking
        <span class="cov0" title="0">ecr.tryWriteContinue()
        if p, ok := ecr.readCloser.(bfe_http.Peeker); ok </span><span class="cov0" title="0">{
                n, err := p.Peek(n)
                if err == io.EOF </span><span class="cov0" title="0">{
                        ecr.sawEOF.setTrue()
                }</span>
                <span class="cov0" title="0">return n, err</span>
        }
        <span class="cov0" title="0">return nil, ErrExpectContinueReaderPeek</span>
}

// WroteContinue check whether expectContinueReader has sent 100-Continue response
func (ecr *expectContinueReader) WroteContinue() bool <span class="cov0" title="0">{
        return ecr.resp.wroteContinue
}</span>
</pre>
		
		<pre class="file" id="file218" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// find cluster name for incoming request

package bfe_server

import (
        "fmt"
        "net"
        "net/url"
        "time"
)

import (
        "github.com/bfenetworks/bfe/bfe_balance/backend"
        "github.com/bfenetworks/bfe/bfe_basic"
        "github.com/bfenetworks/bfe/bfe_http"
        "github.com/bfenetworks/bfe/bfe_route"
        "github.com/bfenetworks/bfe/bfe_tls"
        "github.com/bfenetworks/bfe/bfe_util"
)

// findProduct finds product name for given request.
func (srv *BfeServer) findProduct(req *bfe_basic.Request) error <span class="cov0" title="0">{
        req.Stat.FindProStart = time.Now()
        defer func() </span><span class="cov0" title="0">{
                req.Stat.FindProEnd = time.Now()
        }</span>()

        <span class="cov0" title="0">serverConf := req.SvrDataConf.(*bfe_route.ServerDataConf)

        // look up hostTag and product in host table
        return serverConf.HostTable.LookupHostTagAndProduct(req)</span>
}

// findCluster finds clusterName for given request.
func (srv *BfeServer) findCluster(req *bfe_basic.Request) error <span class="cov0" title="0">{
        req.Stat.LocateStart = time.Now()
        defer func() </span><span class="cov0" title="0">{
                req.Stat.LocateEnd = time.Now()
        }</span>()

        <span class="cov0" title="0">serverConf := req.SvrDataConf.(*bfe_route.ServerDataConf)

        // look up clusterName
        return serverConf.HostTable.LookupCluster(req)</span>
}

// FindLocation finds product and cluster for given request
func (srv *BfeServer) FindLocation(request *bfe_basic.Request) (string, error) <span class="cov0" title="0">{
        var clusterName string
        // find product
        if err := srv.findProduct(request); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // find cluster
        <span class="cov0" title="0">if err := srv.findCluster(request); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">clusterName = request.Route.ClusterName
        return clusterName, nil</span>
}

// FindProduct finds product for proxied conn (under tls proxy mode).
func (srv *BfeServer) FindProduct(conn net.Conn) string <span class="cov0" title="0">{
        sc := srv.GetServerConf()

        // get vip from connection
        vip := bfe_util.GetVip(conn)
        if vip == nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        // find product from vip
        <span class="cov0" title="0">product, err := sc.HostTable.LookupProductByVip(vip.String())
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">return product</span>
}

// Balance finds backend for proxied conn (under tls proxy mode).
func (srv *BfeServer) Balance(e interface{}) (*backend.BfeBackend, error) <span class="cov0" title="0">{
        serverDataConf := srv.GetServerConf()

        var conn net.Conn
        var req *bfe_http.Request
        switch v := e.(type) </span>{
        case net.Conn:<span class="cov0" title="0">
                conn = v
                req = &amp;bfe_http.Request{URL: new(url.URL)}</span>
        case *bfe_http.Request:<span class="cov0" title="0">
                req = v
                conn = req.State.Conn</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("invalid type for Balance:%T", v)</span>
        }

        // create pesudo request
        <span class="cov0" title="0">session := bfe_basic.NewSession(conn)
        vip, vport, err := bfe_util.GetVipPort(conn)
        if err == nil </span><span class="cov0" title="0">{
                session.Vip = vip
                session.Vport = vport
        }</span>

        <span class="cov0" title="0">if _, ok := conn.(*bfe_tls.Conn); ok </span><span class="cov0" title="0">{
                session.IsSecure = true
        }</span>

        <span class="cov0" title="0">reqStat := bfe_basic.NewRequestStat(time.Now())
        reqBasic := bfe_basic.NewRequest(req, conn, reqStat, session, serverDataConf)

        // find cluster
        clusterName, err := srv.FindLocation(reqBasic)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // find backend
        <span class="cov0" title="0">bal, err := srv.balTable.Lookup(clusterName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">backend, err := bal.Balance(reqBasic)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return backend, nil</span>
}
</pre>
		
		<pre class="file" id="file219" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// HTTP server.  See RFC 2616.

package bfe_server

import (
        "errors"
        "io"
        "net"
        "strings"
        "sync"
        "time"
)

import (
        "github.com/baidu/go-lib/gotrack"
        "github.com/baidu/go-lib/log"
)

import (
        "github.com/bfenetworks/bfe/bfe_basic"
        "github.com/bfenetworks/bfe/bfe_bufio"
        "github.com/bfenetworks/bfe/bfe_http"
        "github.com/bfenetworks/bfe/bfe_module"
        "github.com/bfenetworks/bfe/bfe_tls"
        "github.com/bfenetworks/bfe/bfe_util"
        "github.com/bfenetworks/bfe/bfe_websocket"
)

// This should be &gt;= 512 bytes for DetectContentType,
// but otherwise it's somewhat arbitrary.
const bufferBeforeChunkingSize = 512

// Actions to do with current connection.
const (
        // Reuse the connection (default aciton)
        keepAlive = iota
        // Close the connection after send response to client.
        closeAfterReply
        // Close the connection directly, do not send any data,
        // it usually means some attacks may happened.
        closeDirectly
)

var errTooLarge = errors.New("http: request too large")

// A switchReader can have its Reader changed at runtime.
// It's not safe for concurrent Reads and switches.
type switchReader struct {
        io.Reader
}

// A liveSwitchReader is a switchReader that's safe for concurrent
// reads and switches, if its mutex is held.
type liveSwitchReader struct {
        sync.Mutex
        r io.Reader
}

func (sr *liveSwitchReader) Read(p []byte) (n int, err error) <span class="cov0" title="0">{
        sr.Lock()
        r := sr.r
        sr.Unlock()
        return r.Read(p)
}</span>

// conn represents the server side of an HTTP/HTTPS connection.
type conn struct {
        // immutable:
        remoteAddr string             // network address of remote side
        server     *BfeServer         // the Server on which the connection arrived
        rwc        net.Conn           // i/o connection
        session    *bfe_basic.Session // for maintain connection information

        // for http/https:
        sr    liveSwitchReader      // where the LimitReader reads from; usually the rwc
        lr    *io.LimitedReader     // io.LimitReader(sr)
        buf   *bfe_bufio.ReadWriter // buffered(lr,rwc), reading from bufio-&gt;limitReader-&gt;sr-&gt;rwc
        reqSN uint32                //number of requests arrived on this connection

        mu           sync.Mutex // guards the following
        clientGone   bool       // if client has disconnected mid-request
        closeNotifyc chan bool  // made lazily
}

func (c *conn) closeNotify() &lt;-chan bool <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()
        if c.closeNotifyc == nil </span><span class="cov0" title="0">{
                c.closeNotifyc = make(chan bool, 1)

                pr, pw := io.Pipe()

                readSource := c.sr.r
                c.sr.Lock()
                c.sr.r = pr
                c.sr.Unlock()
                go func() </span><span class="cov0" title="0">{
                        _, err := io.Copy(pw, readSource)
                        if err == nil </span><span class="cov0" title="0">{
                                err = io.EOF
                        }</span>
                        <span class="cov0" title="0">pw.CloseWithError(err)
                        c.noteClientGone()</span>
                }()
        }
        <span class="cov0" title="0">return c.closeNotifyc</span>
}

func (c *conn) noteClientGone() <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()
        if c.closeNotifyc != nil &amp;&amp; !c.clientGone </span><span class="cov0" title="0">{
                c.closeNotifyc &lt;- true
        }</span>
        <span class="cov0" title="0">c.clientGone = true</span>
}

// noLimit is an effective infinite upper bound for io.LimitedReader
const noLimit int64 = (1 &lt;&lt; 63) - 1

// Create new connection from rwc.
func newConn(rwc net.Conn, srv *BfeServer) (c *conn, err error) <span class="cov0" title="0">{
        c = new(conn)
        c.remoteAddr = rwc.RemoteAddr().String()
        c.server = srv
        c.rwc = rwc
        c.sr = liveSwitchReader{r: c.rwc}
        c.lr = io.LimitReader(&amp;c.sr, noLimit).(*io.LimitedReader)
        br := srv.BufioCache.newBufioReader(c.lr)
        bw := srv.BufioCache.newBufioWriterSize(c.rwc, 4&lt;&lt;10)
        c.buf = bfe_bufio.NewReadWriter(br, bw)
        c.reqSN = 0

        c.session = bfe_basic.NewSession(rwc)
        vip, vport, err := bfe_util.GetVipPort(rwc)
        if err == nil </span><span class="cov0" title="0">{
                c.session.Vip = vip
                c.session.Vport = vport

                // get product if vip -&gt; product table is set
                sf := srv.GetServerConf()
                product, err := sf.HostTable.LookupProductByVip(vip.String())
                if err == nil </span><span class="cov0" title="0">{
                        c.session.Product = product
                }</span>

                <span class="cov0" title="0">log.Logger.Debug("newConn(): VIP: %v, Port: %v, Product: %v", c.session.Vip.String(), vport, product)</span>
        } else<span class="cov0" title="0"> {
                log.Logger.Debug("newConn(): GetVip: %s", err.Error())
        }</span>

        <span class="cov0" title="0">if sc, ok := rwc.(*bfe_tls.Conn); ok </span><span class="cov0" title="0">{
                c.session.IsSecure = true
                sc.SetConnParam(c.session)
        }</span>

        <span class="cov0" title="0">return c, nil</span>
}

// Read next request from connection.
func (c *conn) readRequest() (request *bfe_basic.Request, err error) <span class="cov0" title="0">{
        c.lr.N = int64(c.server.MaxHeaderBytes) + 4096 /* bufio slop */

        var req *bfe_http.Request

        // another request arrives
        c.reqSN += 1
        if req, err = bfe_http.ReadRequest(c.buf.Reader, c.server.MaxHeaderUriBytes); err != nil </span><span class="cov0" title="0">{
                if c.lr.N == 0 </span><span class="cov0" title="0">{
                        return nil, errTooLarge
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">c.lr.N = noLimit

        req.RemoteAddr = c.remoteAddr
        req.State.SerialNumber = c.reqSN
        req.State.Conn = c.rwc

        reqStat := bfe_basic.NewRequestStat(req.State.StartTime)
        reqStat.ReadReqEnd = time.Now()
        reqStat.HeaderLenIn = int(req.State.HeaderSize)

        sf := c.server.GetServerConf()

        return bfe_basic.NewRequest(req, c.rwc, reqStat, c.session, sf), nil</span>
}

func (c *conn) finalFlush() <span class="cov0" title="0">{
        if c.buf != nil </span><span class="cov0" title="0">{
                c.buf.Flush()

                // Steal the bufio.Writer (~4KB worth of memory) and its associated
                // writer for a future connection.
                c.server.BufioCache.putBufioWriter(c.buf.Writer)

                // Warn: it's not safe to reuse c.buf.Reader which is used by both conn
                // goroutine and transport.WriteLoop goroutine.
                // There is no guarantee that transport.WriteLoop has stopped to read from
                // c.buf.Reader when conn goroutine call finalFlush().

                c.buf = nil
        }</span>
}

// Close the connection.
func (c *conn) close() <span class="cov0" title="0">{
        c.finalFlush()
        c.rwc.Close()
}</span>

// rstAvoidanceDelay is the amount of time we sleep after closing the
// write side of a TCP connection before closing the entire socket.
// By sleeping, we increase the chances that the client sees our FIN
// and processes its final data before they process the subsequent RST
// from closing a connection with known unread data.
// This RST seems to occur mostly on BSD systems. (And Windows?)
// This timeout is somewhat arbitrary (~latency around the planet).
const rstAvoidanceDelay = 500 * time.Millisecond

// closeWrite flushes any outstanding data and sends a FIN packet (if
// client is connected via TCP), signalling that we're done.  We then
// pause for a bit, hoping the client processes it before `any
// subsequent RST.
//
// See http://golang.org/issue/3595
func (c *conn) closeWriteAndWait() <span class="cov0" title="0">{
        c.finalFlush()
        if cw, ok := c.rwc.(bfe_util.CloseWriter); ok </span><span class="cov0" title="0">{
                cw.CloseWrite()
        }</span>
        <span class="cov0" title="0">time.Sleep(rstAvoidanceDelay)</span>
}

// callback of finish connection
func (c *conn) finish() <span class="cov0" title="0">{
        srv := c.server

        // finish session
        c.session.Finish()

        // Callback for HandleFinish
        hl := srv.CallBacks.GetHandlerList(bfe_module.HandleFinish)
        if hl != nil </span><span class="cov0" title="0">{
                hl.FilterFinish(c.session)
        }</span>
}

func (c *conn) getMandatoryProtocol(tlsConn *bfe_tls.Conn) (string, bool) <span class="cov0" title="0">{
        tlsRule := c.server.TLSServerRule.Get(tlsConn)
        protoConf := tlsRule.NextProtos.(*NextProtosConf)
        return protoConf.Mandatory(tlsConn)
}</span>

// Serve a new connection.
func (c *conn) serve() <span class="cov0" title="0">{
        var hl *bfe_module.HandlerList
        var retVal int
        session := c.session
        c.server.connWaitGroup.Add(1)
        serverStatus := c.server.serverStatus
        proxyState := serverStatus.ProxyState

        defer func() </span><span class="cov0" title="0">{
                if err := recover(); err != nil </span><span class="cov0" title="0">{
                        log.Logger.Warn("panic: conn.serve(): %v, readTotal=%d,writeTotal=%d,reqNum=%d,%v\n%s",
                                c.remoteAddr,
                                c.session.ReadTotal(), c.session.WriteTotal(),
                                c.session.ReqNum(),
                                err, gotrack.CurrentStackTrace(0))

                        proxyState.PanicClientConnServe.Inc(1)
                }</span>
                <span class="cov0" title="0">c.server.connWaitGroup.Done()</span>
        }()

        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                // callback of finish connection
                c.finish()
                c.close()

                if len(session.Proto) &gt; 0 </span><span class="cov0" title="0">{
                        proxyState.ClientConnActiveDec(session.Proto, 1)
                }</span>
                <span class="cov0" title="0">if session.ReqNumActive() != 0 </span><span class="cov0" title="0">{
                        proxyState.ClientConnUnfinishedReq.Inc(1)
                }</span>
        }()

        // Callback for HANDLE_ACCEPT
        <span class="cov0" title="0">hl = c.server.CallBacks.GetHandlerList(bfe_module.HandleAccept)
        if hl != nil </span><span class="cov0" title="0">{
                retVal = hl.FilterAccept(c.session)
                if retVal == bfe_module.BfeHandlerClose </span><span class="cov0" title="0">{
                        // close the connection
                        return
                }</span>
        }

        <span class="cov0" title="0">if tlsConn, ok := c.rwc.(*bfe_tls.Conn); ok </span><span class="cov0" title="0">{
                proxyState.TlsHandshakeAll.Inc(1)
                var d time.Duration
                // set tls handshake timeout
                if d = c.server.TlsHandshakeTimeout; d != 0 </span><span class="cov0" title="0">{
                        c.rwc.SetReadDeadline(time.Now().Add(d))
                }</span>

                // start tls handshake
                <span class="cov0" title="0">start := time.Now()
                if err := tlsConn.Handshake(); err != nil </span><span class="cov0" title="0">{
                        log.Logger.Info("conn.serve(): Handshake error %s (remote %s, vip %s), elapse %d us",
                                err, c.remoteAddr, session.Vip, time.Since(start).Nanoseconds()/1000)
                        session.SetError(bfe_basic.ErrClientTlsHandshake, err.Error())
                        return
                }</span>
                <span class="cov0" title="0">c.rwc.SetReadDeadline(time.Time{})
                tlsState := tlsConn.ConnectionState()
                c.session.TlsState = &amp;tlsState

                log.Logger.Debug("conn.serve(): Handshake success (remote %s, vip %s, resume %v), elapse %d us",
                        c.remoteAddr, session.Vip, tlsState.DidResume, time.Since(start).Nanoseconds()/1000)
                proxyState.TlsHandshakeSucc.Inc(1)
                serverStatus.ProxyHandshakeDelay.AddDuration(tlsState.HandshakeTime)
                if tlsState.DidResume </span><span class="cov0" title="0">{
                        serverStatus.ProxyHandshakeResumeDelay.AddDuration(tlsState.HandshakeTime)
                }</span> else<span class="cov0" title="0"> {
                        serverStatus.ProxyHandshakeFullDelay.AddDuration(tlsState.HandshakeTime)
                }</span>

                // Callback for HANDLE_HANDSHAKE
                <span class="cov0" title="0">hl = c.server.CallBacks.GetHandlerList(bfe_module.HandleHandshake)
                if hl != nil </span><span class="cov0" title="0">{
                        retVal = hl.FilterAccept(c.session)
                        if retVal == bfe_module.BfeHandlerClose </span><span class="cov0" title="0">{
                                // close the connection
                                return
                        }</span>
                }

                // upgrade to negotiated protocol
                <span class="cov0" title="0">proto := tlsState.NegotiatedProtocol
                if mandatoryProtocol, ok := c.getMandatoryProtocol(tlsConn); ok </span><span class="cov0" title="0">{
                        // Note: if mandatory protocol configured, use it anyway
                        proto = mandatoryProtocol
                }</span>
                <span class="cov0" title="0">if validNPN(proto) </span><span class="cov0" title="0">{
                        if fn := c.server.TLSNextProto[proto]; fn != nil </span><span class="cov0" title="0">{
                                log.Logger.Debug("conn.serve(): Use negotiated protocol %s over TLS", proto)
                                proxyState.ClientConnServedInc(proto, 1) // Note: counter for negotiated protocol
                                proxyState.ClientConnActiveInc(proto, 1)
                                c.session.Proto = proto

                                // process protocol over TLS connection (spdy, http2, etc)
                                handler := NewProtocolHandler(c, proto)
                                fn(&amp;c.server.Server, tlsConn, handler)
                        }</span> else<span class="cov0" title="0"> {
                                // never go here
                                log.Logger.Info("conn.serve(): unknown negotiated protocol %s over TLS", proto)
                        }</span>
                        <span class="cov0" title="0">return</span>
                }
        }

        // process requests from http/https protocol
        <span class="cov0" title="0">if _, ok := c.rwc.(*bfe_tls.Conn); ok </span><span class="cov0" title="0">{
                c.session.Proto = "https"
        }</span> else<span class="cov0" title="0"> {
                c.session.Proto = "http"
        }</span>
        <span class="cov0" title="0">proxyState.ClientConnServedInc(c.session.Proto, 1) // Note: counter for http/https protocol
        proxyState.ClientConnActiveInc(c.session.Proto, 1)

        firstRequest := true
        for </span><span class="cov0" title="0">{
                if firstRequest </span><span class="cov0" title="0">{
                        // set timeout only for first request
                        // following request's timeout is controlled by TimeoutReadClientAgain
                        // the read again timeout is different for each cluster
                        // so it's not set here, see reverseproxy.go
                        if d := c.server.ReadTimeout; d != 0 </span><span class="cov0" title="0">{
                                c.rwc.SetReadDeadline(time.Now().Add(d))
                        }</span>
                }

                <span class="cov0" title="0">request, err := c.readRequest()
                if err != nil </span><span class="cov0" title="0">{
                        if err == errTooLarge </span><span class="cov0" title="0">{
                                session.SetError(bfe_basic.ErrClientLongHeader, "request entity too large")
                                proxyState.ErrClientLongHeader.Inc(1)
                                // Their HTTP client may or may not be
                                // able to read this if we're
                                // responding to them and hanging up
                                // while they're still writing their
                                // request.  Undefined behavior.
                                io.WriteString(c.rwc, "HTTP/1.1 413 Request Entity Too Large\r\n\r\n")
                                c.closeWriteAndWait()
                                break</span>
                        } else<span class="cov0" title="0"> if strings.Contains(err.Error(), "exceed maxUriBytes") </span><span class="cov0" title="0">{
                                session.SetError(bfe_basic.ErrClientLongUrl, err.Error())
                                proxyState.ErrClientLongUrl.Inc(1)
                                io.WriteString(c.rwc, "HTTP/1.1 414 Request-URI Too Long\r\n\r\n")
                                break</span>
                        } else<span class="cov0" title="0"> if err == io.EOF </span><span class="cov0" title="0">{
                                session.SetError(bfe_basic.ErrClientClose, err.Error())
                                proxyState.ErrClientClose.Inc(1)
                                break</span> // Don't reply
                        } else<span class="cov0" title="0"> if neterr, ok := err.(net.Error); ok &amp;&amp; neterr.Timeout() </span><span class="cov0" title="0">{
                                session.SetError(bfe_basic.ErrClientTimeout, err.Error())
                                proxyState.ErrClientTimeout.Inc(1)
                                break</span> // Don't reply
                        } else<span class="cov0" title="0"> if strings.Contains(err.Error(), "connection reset by peer") </span><span class="cov0" title="0">{
                                session.SetError(bfe_basic.ErrClientReset, err.Error())
                                proxyState.ErrClientReset.Inc(1)
                                break</span>
                        }

                        <span class="cov0" title="0">session.SetError(bfe_basic.ErrClientBadRequest, err.Error())
                        proxyState.ErrClientBadRequest.Inc(1)
                        io.WriteString(c.rwc, "HTTP/1.1 400 Bad Request\r\n\r\n")
                        break</span>
                }

                <span class="cov0" title="0">req := request.HttpRequest

                // create context for response
                w := newResponse(c, req)

                // Expect 100 Continue support
                if req.ExpectsContinue() </span><span class="cov0" title="0">{
                        session.Use100Continue = true
                        proxyState.ClientConnUse100Continue.Inc(1)

                        if req.ProtoAtLeast(1, 1) </span><span class="cov0" title="0">{
                                // Wrap the Body reader with one that replies on the connection
                                req.Body = &amp;expectContinueReader{readCloser: req.Body, resp: w}
                                w.canWriteContinue.setTrue()
                        }</span>
                        <span class="cov0" title="0">if req.ContentLength == 0 </span><span class="cov0" title="0">{
                                session.SetError(bfe_basic.ErrClientZeroContentlen, "content length is zero")
                                proxyState.ErrClientZeroContentlen.Inc(1)

                                w.Header().Set("Connection", "close")
                                w.WriteHeader(bfe_http.StatusBadRequest)
                                w.finishRequest()
                                break</span>
                        }
                        <span class="cov0" title="0">req.Header.Del("Expect")</span>
                } else<span class="cov0" title="0"> if req.Header.GetDirect("Expect") != "" </span><span class="cov0" title="0">{
                        session.SetError(bfe_basic.ErrClientExpectFail, "invalid Expect header")
                        proxyState.ErrClientExpectFail.Inc(1)

                        w.sendExpectationFailed()
                        break</span>
                }

                // check whether client request for http upgrade (over http/https conn)
                <span class="cov0" title="0">if firstRequest </span><span class="cov0" title="0">{
                        nextProto := checkHttpUpgrade(request)
                        fn := c.server.HTTPNextProto[nextProto]

                        switch nextProto </span>{
                        case bfe_websocket.WebSocket:<span class="cov0" title="0">
                                // update counters for websocket
                                proxyState.ClientConnActiveDec(c.session.Proto, 1)
                                c.session.Proto = bfe_websocket.Scheme(c.rwc)
                                proxyState.ClientConnServedInc(c.session.Proto, 1)
                                proxyState.ClientConnActiveInc(c.session.Proto, 1)

                                // Note: The runtime will not GC the objects referenced by request.SvrDataConf until the websocket connection
                                // has been processed. But the connection may last a long time. It's better to remove the reference to objects
                                // which are not used any more.
                                request.SvrDataConf = nil

                                // switching to websocket protocol
                                log.Logger.Debug("conn.serve(): upgrade to websocket protocol over http/https")
                                fn(&amp;c.server.Server, w, req)
                                return</span>
                        default:<span class="cov0" title="0">
                                log.Logger.Debug("conn.serve(): not upgrade to other protocol over http/https")</span>
                        }
                        <span class="cov0" title="0">firstRequest = false</span>
                }

                <span class="cov0" title="0">isKeepAlive := c.serveRequest(w, request)

                /* close connection if needed:
                 * - server-level close (closeAfterReply):
                 *   connection blocked, request processed error, etc
                 *
                 * - http-level close (w.closeAfterReply):
                 *   proto version &lt; 1.1, request or response with header "connection: close",
                 *   keepalive disabled, etc
                 */
                if !isKeepAlive || w.closeAfterReply </span><span class="cov0" title="0">{
                        if w.requestBodyLimitHit </span><span class="cov0" title="0">{
                                c.closeWriteAndWait()
                        }</span>
                        <span class="cov0" title="0">break</span>
                }
        }
}

func (c *conn) serveRequest(w bfe_http.ResponseWriter, request *bfe_basic.Request) (isKeepAlive bool) <span class="cov0" title="0">{
        session := c.session
        serverStatus := c.server.serverStatus
        proxyState := serverStatus.ProxyState

        session.IncReqNum(1)
        session.IncReqNumActive(1)

        proxyState.ClientReqServedInc(session.Proto, 1)
        proxyState.ClientReqActiveInc(session.Proto, 1)

        // HTTP cannot have multiple simultaneous active requests.[*]
        // Until the server replies to this request, it can't read another,
        // so we might as well run the handler in this goroutine.
        // [*] Not strictly true: HTTP pipelining.  We could let them all process
        // in parallel even if their responses need to be serialized.

        // serve the request
        ret1 := c.server.ReverseProxy.ServeHTTP(w, request)

        // if there is some response, count the time
        if !request.Stat.ResponseStart.IsZero() </span><span class="cov0" title="0">{
                request.Stat.ResponseEnd = time.Now()
        }</span>

        // finish process for http/https protocol
        <span class="cov0" title="0">res, ok := w.(*response)
        if ok </span><span class="cov0" title="0">{
                if ret1 == closeDirectly </span><span class="cov0" title="0">{
                        res.prepareForCloseConn()
                }</span> else<span class="cov0" title="0"> {
                        res.finishRequest()
                }</span>
                <span class="cov0" title="0">if !request.Stat.ResponseStart.IsZero() </span><span class="cov0" title="0">{
                        request.Stat.HeaderLenOut = int(res.headerWritten)
                        request.Stat.BodyLenOut = res.cw.length
                }</span>
        }

        // callback for finish request
        <span class="cov0" title="0">ret2 := c.server.ReverseProxy.FinishReq(w, request)

        // modify state counters
        session.IncReqNumActive(-1)
        proxyState.ClientReqActiveDec(session.Proto, 1)
        if request.ErrCode != nil </span><span class="cov0" title="0">{
                proxyState.ClientReqFail.Inc(1)
        }</span> else<span class="cov0" title="0"> {
                // only counter "internal delay" for successful request
                if !request.Stat.BackendFirst.IsZero() </span><span class="cov0" title="0">{
                        // In redirect and some other cases, BackendFirst may be not set

                        if request.HttpRequest.ContentLength == 0 </span><span class="cov0" title="0">{
                                // for get/head request
                                serverStatus.ProxyDelay.AddBySub(request.Stat.ReadReqEnd, request.Stat.BackendFirst)
                        }</span> else<span class="cov0" title="0"> {
                                // for post/put request
                                serverStatus.ProxyPostDelay.AddBySub(request.Stat.ReadReqEnd, request.Stat.BackendFirst)
                        }</span>
                }
        }

        <span class="cov0" title="0">isKeepAlive = (ret1 == keepAlive) &amp;&amp; (ret2 == keepAlive)
        return</span>
}

// validNPN reports whether the proto is not a blocklisted Next
// Protocol Negotiation protocol.  Empty and built-in protocol types
// are blocklisted and can't be overridden with alternate
// implementations.
func validNPN(proto string) bool <span class="cov0" title="0">{
        switch proto </span>{
        case "", "http/1.1", "http/1.0":<span class="cov0" title="0">
                return false</span>
        }
        <span class="cov0" title="0">return true</span>
}

func checkHttpUpgrade(req *bfe_basic.Request) string <span class="cov0" title="0">{
        if bfe_websocket.CheckUpgradeWebSocket(req.HttpRequest) </span><span class="cov0" title="0">{
                return bfe_websocket.WebSocket
        }</span>
        <span class="cov0" title="0">return ""</span>
}
</pre>
		
		<pre class="file" id="file220" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// HTTP server.  See RFC 2616.

package bfe_server

import (
        "net"
        "time"
)

import (
        "github.com/baidu/go-lib/log"
)

func delayCalc(delay time.Duration) time.Duration <span class="cov0" title="0">{
        if delay == 0 </span><span class="cov0" title="0">{
                delay = 5 * time.Millisecond
        }</span> else<span class="cov0" title="0"> {
                delay *= 2
        }</span>
        <span class="cov0" title="0">if max := 1 * time.Second; delay &gt; max </span><span class="cov0" title="0">{
                delay = max
        }</span>
        <span class="cov0" title="0">return delay</span>
}

func isTimeout(err error) bool <span class="cov0" title="0">{
        e, ok := err.(net.Error)
        return ok &amp;&amp; e.Timeout()
}</span>

// ServeHttp accept incoming http connections
func (srv *BfeServer) ServeHttp(ln net.Listener) error <span class="cov0" title="0">{
        return srv.Serve(ln, ln, "HTTP")
}</span>

// ServeHttps accept incoming https connections
func (srv *BfeServer) ServeHttps(ln *HttpsListener) error <span class="cov0" title="0">{
        return srv.Serve(ln.tlsListener, ln.tcpListener, "HTTPS")
}</span>

// Serve accepts incoming connections on the Listener l, creating a
// new service goroutine for each.  The service goroutines read requests and
// then call srv.Handler to reply to them.
//
// Params
//     - l  : net listener
//     - raw: underlying tcp listener (different from `l` in HTTPS)
//
// Return
//     - err: error
func (srv *BfeServer) Serve(l net.Listener, raw net.Listener, proto string) error <span class="cov0" title="0">{
        var tempDelay time.Duration // how long to sleep on accept failure
        proxyState := srv.serverStatus.ProxyState

        for </span><span class="cov0" title="0">{
                // accept new connection
                rw, e := l.Accept()
                if e != nil </span><span class="cov0" title="0">{
                        if isTimeout(e) </span><span class="cov0" title="0">{
                                proxyState.ErrClientTimeout.Inc(1)
                                continue</span>
                        }
                        <span class="cov0" title="0">proxyState.ErrClientConnAccept.Inc(1)

                        if ne, ok := e.(net.Error); ok &amp;&amp; ne.Temporary() </span><span class="cov0" title="0">{
                                tempDelay = delayCalc(tempDelay)

                                log.Logger.Error("http: Accept error: %v; retrying in %v", e, tempDelay)
                                time.Sleep(tempDelay)
                                continue</span>
                        }

                        // if in GraceShutdown state, exit accept loop after timeout
                        <span class="cov0" title="0">if srv.CheckGracefulShutdown() </span><span class="cov0" title="0">{
                                shutdownTimeout := srv.Config.Server.GracefulShutdownTimeout
                                time.Sleep(time.Duration(shutdownTimeout) * time.Second)
                        }</span>

                        <span class="cov0" title="0">return e</span>
                }

                // start go-routine for new connection
                <span class="cov0" title="0">go func(rwc net.Conn, srv *BfeServer) </span><span class="cov0" title="0">{
                        // create data structure for new connection
                        c, err := newConn(rwc, srv)
                        if err != nil </span><span class="cov0" title="0">{
                                // current, here is unreachable
                                return
                        }</span>

                        // process new connection
                        <span class="cov0" title="0">c.serve()</span>
                }(rw, srv)
        }
}
</pre>
		
		<pre class="file" id="file221" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// wrapper of tls.listener

package bfe_server

import (
        "net"
        "sync"
)

import (
        "github.com/bfenetworks/bfe/bfe_tls"
)

type HttpsListener struct {
        tlsListener net.Listener // listener for https
        tcpListener net.Listener // underlying tcp listener

        config *bfe_tls.Config // tls config for listener
        lock   sync.Mutex
}

func NewHttpsListener(listener net.Listener, config *bfe_tls.Config) *HttpsListener <span class="cov0" title="0">{
        httpsListener := &amp;HttpsListener{
                tcpListener: listener,
                config:      config,
                tlsListener: bfe_tls.NewListener(listener, config),
        }
        return httpsListener
}</span>

// UpdateSessionTicketKey updates session ticket key.
func (l *HttpsListener) UpdateSessionTicketKey(key []byte) <span class="cov0" title="0">{
        l.lock.Lock()
        defer l.lock.Unlock()

        // clone and modify config
        config := l.config.Clone()
        copy(config.SessionTicketKeyName[:], key[:16])
        copy(config.SessionTicketKey[:], key[16:])

        // update config for listener
        l.config = config
        bfe_tls.UpdateListener(l.tlsListener, config)
}</span>
</pre>
		
		<pre class="file" id="file222" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// web monitor module stat

package bfe_server

import (
        "fmt"
        "net/url"
)

import (
        "github.com/baidu/go-lib/web-monitor/kv_encode"
)

import (
        "github.com/bfenetworks/bfe/bfe_util/json"
)

// HostTableStatusGet returns status of HostTable in json.
func (srv *BfeServer) HostTableStatusGet(query url.Values) ([]byte, error) <span class="cov0" title="0">{
        srv.confLock.RLock()
        serverConf := srv.ServerConf
        srv.confLock.RUnlock()

        s := serverConf.HostTable.GetStatus()

        // get param for format
        format := query.Get("format")
        if len(format) == 0 </span><span class="cov0" title="0">{
                // default format is json
                format = "json"
        }</span>

        <span class="cov0" title="0">var buff []byte
        var err error

        switch format </span>{
        case "json":<span class="cov0" title="0">
                buff, err = json.Marshal(s)</span>
        case "kv":<span class="cov0" title="0">
                buff, err = kv_encode.Encode(s)</span>
        default:<span class="cov0" title="0">
                err = fmt.Errorf("invalid format:%s", format)</span>
        }
        <span class="cov0" title="0">return buff, err</span>
}

// HostTableVersionGet returns version of HostTable in json.
func (srv *BfeServer) HostTableVersionGet(query url.Values) ([]byte, error) <span class="cov0" title="0">{
        srv.confLock.RLock()
        serverConf := srv.ServerConf
        srv.confLock.RUnlock()

        versions := serverConf.HostTable.GetVersions()

        // get param for format
        format := query.Get("format")
        if len(format) == 0 </span><span class="cov0" title="0">{
                // default format is json
                format = "json"
        }</span>

        <span class="cov0" title="0">var buff []byte
        var err error

        switch format </span>{
        case "json":<span class="cov0" title="0">
                buff, err = json.Marshal(versions)</span>
        case "kv":<span class="cov0" title="0">
                buff, err = kv_encode.Encode(versions)</span>
        default:<span class="cov0" title="0">
                err = fmt.Errorf("invalid format:%s", format)</span>
        }
        <span class="cov0" title="0">return buff, err</span>
}

// ClusterTableVersionGet returns versions of clusterTable.
func (srv *BfeServer) ClusterTableVersionGet(query url.Values) ([]byte, error) <span class="cov0" title="0">{
        srv.confLock.RLock()
        serverConf := srv.ServerConf
        srv.confLock.RUnlock()

        // get versions
        output := serverConf.ClusterTable.GetVersions()

        // get param for format
        format := query.Get("format")
        if len(format) == 0 </span><span class="cov0" title="0">{
                // default format is json
                format = "json"
        }</span>

        <span class="cov0" title="0">var buff []byte
        var err error

        switch format </span>{
        case "json":<span class="cov0" title="0">
                buff, err = json.Marshal(output)</span>
        case "kv":<span class="cov0" title="0">
                buff, err = kv_encode.Encode(output)</span>
        default:<span class="cov0" title="0">
                err = fmt.Errorf("invalid format:%s", format)</span>
        }
        <span class="cov0" title="0">return buff, err</span>
}

// BalTableStatusGet returns state of balTable.
func (srv *BfeServer) BalTableStatusGet(query url.Values) ([]byte, error) <span class="cov0" title="0">{
        var buff []byte
        var err error
        // cluster_name is not giving
        clusterName := query.Get("cluster_name")

        if len(clusterName) == 0 </span><span class="cov0" title="0">{
                // get states
                output := srv.balTable.GetState()

                // convert to json
                buff, err = json.Marshal(output)
        }</span> else<span class="cov0" title="0"> {
                // search cluster whether is in balTable or not
                if bal, err1 := srv.balTable.Lookup(clusterName); err1 != nil </span><span class="cov0" title="0">{
                        buff = []byte("{\"status\": \"Not Exist\"}")
                }</span> else<span class="cov0" title="0"> if bal.SubClusterNum() == 0 </span><span class="cov0" title="0">{
                        buff = []byte("{\"status\": \"No SubCluster\"}")
                }</span> else<span class="cov0" title="0"> {
                        buff = []byte("{\"status\": \"Exist\"}")
                }</span>
        }

        <span class="cov0" title="0">return buff, err</span>
}

// BalTableVersionGet returns versions of balTable.
func (srv *BfeServer) BalTableVersionGet(query url.Values) ([]byte, error) <span class="cov0" title="0">{
        // get versions
        output := srv.balTable.GetVersions()

        // get param for format
        format := query.Get("format")
        if len(format) == 0 </span><span class="cov0" title="0">{
                // default format is json
                format = "json"
        }</span>

        <span class="cov0" title="0">var buff []byte
        var err error
        switch format </span>{
        case "json":<span class="cov0" title="0">
                buff, err = json.Marshal(output)</span>
        case "kv":<span class="cov0" title="0">
                buff, err = kv_encode.Encode(output)</span>
        default:<span class="cov0" title="0">
                err = fmt.Errorf("invalid format:%s", format)</span>
        }
        <span class="cov0" title="0">return buff, err</span>
}
</pre>
		
		<pre class="file" id="file223" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// handler for application layer protocol over TLS connection

package bfe_server

import (
        "sync"
        "time"
)

import (
        "github.com/baidu/go-lib/log"
)

import (
        "github.com/bfenetworks/bfe/bfe_basic"
        "github.com/bfenetworks/bfe/bfe_config/bfe_tls_conf/tls_rule_conf"
        "github.com/bfenetworks/bfe/bfe_http"
        "github.com/bfenetworks/bfe/bfe_http2"
        "github.com/bfenetworks/bfe/bfe_spdy"
)

type ProtocolHandler struct {
        server    *BfeServer // the server on which the connection arrived
        conn      *conn      // connection for handler
        proto     string     // name of application layer protocol
        closeOnce sync.Once  // for connection close
}

func NewProtocolHandler(conn *conn, proto string) *ProtocolHandler <span class="cov0" title="0">{
        p := new(ProtocolHandler)
        p.server = conn.server
        p.conn = conn
        p.proto = proto
        return p
}</span>

// ServeHTTP processes http request and send http response.
//
// Params:
//         - w : a response writer
//         - r : a http request
func (p *ProtocolHandler) ServeHTTP(rw bfe_http.ResponseWriter, request *bfe_http.Request) <span class="cov0" title="0">{
        log.Logger.Debug("ProtocolHandler(%s): start process request", p.proto)
        sf := p.server.GetServerConf()

        reqStat := bfe_basic.NewRequestStat(request.State.StartTime)
        reqStat.ReadReqEnd = time.Now()
        reqInfo := bfe_basic.NewRequest(request, p.conn.rwc, reqStat, p.conn.session, sf)

        // process request
        isKeepAlive := p.conn.serveRequest(rw, reqInfo)

        // close connection if needed
        if !isKeepAlive </span><span class="cov0" title="0">{
                closeFunc := func() </span><span class="cov0" title="0">{
                        switch p.proto </span>{
                        case tls_rule_conf.SPDY31:<span class="cov0" title="0">
                                bfe_spdy.CloseConn(request.Body)</span>
                        case tls_rule_conf.HTTP2:<span class="cov0" title="0">
                                bfe_http2.CloseConn(request.Body)</span>
                        /* never go here */
                        default:<span class="cov0" title="0">
                                return</span>
                        }
                }
                <span class="cov0" title="0">p.closeOnce.Do(closeFunc)</span>
        }
}

// CheckSupportMultiplex checks whether protocol support request multiplexing on a conn.
func CheckSupportMultiplex(proto string) bool <span class="cov0" title="0">{
        switch proto </span>{
        case tls_rule_conf.SPDY31:<span class="cov0" title="0">
                return true</span>
        case tls_rule_conf.HTTP2:<span class="cov0" title="0">
                return true</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}
</pre>
		
		<pre class="file" id="file224" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// proxy internal status

package bfe_server

import (
        "github.com/baidu/go-lib/web-monitor/metrics"
)

type ProxyState struct {
        // panic
        PanicClientConnServe *metrics.Counter // panic when accept from client
        PanicBackendWrite    *metrics.Counter // panic when write to backend
        PanicBackendRead     *metrics.Counter // panic when read from backend

        // client side errors
        ErrClientLongUrl        *metrics.Counter
        ErrClientLongHeader     *metrics.Counter
        ErrClientClose          *metrics.Counter
        ErrClientTimeout        *metrics.Counter
        ErrClientBadRequest     *metrics.Counter
        ErrClientZeroContentlen *metrics.Counter
        ErrClientExpectFail     *metrics.Counter
        ErrClientConnAccept     *metrics.Counter
        ErrClientWrite          *metrics.Counter
        ErrClientReset          *metrics.Counter

        // route config errors
        ErrBkFindProduct  *metrics.Counter
        ErrBkFindLocation *metrics.Counter
        ErrBkNoBalance    *metrics.Counter
        ErrBkNoCluster    *metrics.Counter

        // backend side errors
        ErrBkConnectBackend    *metrics.Counter
        ErrBkRequestBackend    *metrics.Counter
        ErrBkWriteRequest      *metrics.Counter
        ErrBkReadRespHeader    *metrics.Counter
        ErrBkRespHeaderTimeout *metrics.Counter
        ErrBkTransportBroken   *metrics.Counter

        // tls handshake
        TlsHandshakeAll  *metrics.Counter
        TlsHandshakeSucc *metrics.Counter

        // tls session cache
        SessionCacheConn         *metrics.Counter
        SessionCacheConnFail     *metrics.Counter
        SessionCacheSet          *metrics.Counter
        SessionCacheSetFail      *metrics.Counter
        SessionCacheGet          *metrics.Counter
        SessionCacheGetFail      *metrics.Counter
        SessionCacheTypeNotBytes *metrics.Counter
        SessionCacheMiss         *metrics.Counter
        SessionCacheHit          *metrics.Counter
        SessionCacheNoInstance   *metrics.Counter

        // tls multiply certificates
        TlsMultiCertGet            *metrics.Counter
        TlsMultiCertConnWithoutVip *metrics.Counter
        TlsMultiCertConnVipUnknown *metrics.Counter
        TlsMultiCertConnWithoutSni *metrics.Counter
        TlsMultiCertUseDefault     *metrics.Counter
        TlsMultiCertUpdate         *metrics.Counter
        TlsMultiCertUpdateErr      *metrics.Counter

        // client side
        ClientReqWithRetry       *metrics.Counter // req served with retry
        ClientReqWithCrossRetry  *metrics.Counter // req served with cross cluster retry
        ClientReqFail            *metrics.Counter // req with ErrCode != nil
        ClientReqFailWithNoRetry *metrics.Counter // req fail with no retry
        ClientConnUse100Continue *metrics.Counter // connection used Expect 100 Continue
        ClientConnUnfinishedReq  *metrics.Counter // connection closed with unfinished request

        // request successful received
        ClientReqServed      *metrics.Counter
        HttpClientReqServed  *metrics.Counter
        HttpsClientReqServed *metrics.Counter
        Http2ClientReqServed *metrics.Counter
        SpdyClientReqServed  *metrics.Counter

        // active request
        ClientReqActive      *metrics.Gauge
        HttpClientReqActive  *metrics.Gauge
        HttpsClientReqActive *metrics.Gauge
        Http2ClientReqActive *metrics.Gauge
        SpdyClientReqActive  *metrics.Gauge

        // connection successful accepted
        ClientConnServed       *metrics.Counter
        HttpClientConnServed   *metrics.Counter
        HttpsClientConnServed  *metrics.Counter
        Http2ClientConnServed  *metrics.Counter
        SpdyClientConnServed   *metrics.Counter
        StreamClientConnServed *metrics.Counter
        WsClientConnServed     *metrics.Counter
        WssClientConnServed    *metrics.Counter

        // active connection
        ClientConnActive       *metrics.Gauge
        HttpClientConnActive   *metrics.Gauge
        HttpsClientConnActive  *metrics.Gauge
        Http2ClientConnActive  *metrics.Gauge
        SpdyClientConnActive   *metrics.Gauge
        StreamClientConnActive *metrics.Gauge
        WsClientConnActive     *metrics.Gauge
        WssClientConnActive    *metrics.Gauge
}

func (s *ProxyState) ClientConnServedInc(proto string, value uint) <span class="cov0" title="0">{
        switch proto </span>{
        case "http":<span class="cov0" title="0">
                s.HttpClientConnServed.Inc(value)</span>
        case "https":<span class="cov0" title="0">
                s.HttpsClientConnServed.Inc(value)</span>
        case "h2":<span class="cov0" title="0">
                s.Http2ClientConnServed.Inc(value)</span>
        case "spdy/3.1":<span class="cov0" title="0">
                s.SpdyClientConnServed.Inc(value)</span>
        case "ws":<span class="cov0" title="0">
                s.WsClientConnServed.Inc(value)</span>
        case "wss":<span class="cov0" title="0">
                s.WssClientConnServed.Inc(value)</span>
        case "stream":<span class="cov0" title="0">
                s.StreamClientConnServed.Inc(value)</span>
        }
        <span class="cov0" title="0">s.ClientConnServed.Inc(value)</span>
}

func (s *ProxyState) ClientConnActiveInc(proto string, value uint) <span class="cov0" title="0">{
        switch proto </span>{
        case "http":<span class="cov0" title="0">
                s.HttpClientConnActive.Inc(value)</span>
        case "https":<span class="cov0" title="0">
                s.HttpsClientConnActive.Inc(value)</span>
        case "h2":<span class="cov0" title="0">
                s.Http2ClientConnActive.Inc(value)</span>
        case "spdy/3.1":<span class="cov0" title="0">
                s.SpdyClientConnActive.Inc(value)</span>
        case "ws":<span class="cov0" title="0">
                s.WsClientConnActive.Inc(value)</span>
        case "wss":<span class="cov0" title="0">
                s.WssClientConnActive.Inc(value)</span>
        case "stream":<span class="cov0" title="0">
                s.StreamClientConnActive.Inc(value)</span>
        }
        <span class="cov0" title="0">s.ClientConnActive.Inc(value)</span>
}

func (s *ProxyState) ClientConnActiveDec(proto string, value uint) <span class="cov0" title="0">{
        switch proto </span>{
        case "http":<span class="cov0" title="0">
                s.HttpClientConnActive.Dec(value)</span>
        case "https":<span class="cov0" title="0">
                s.HttpsClientConnActive.Dec(value)</span>
        case "h2":<span class="cov0" title="0">
                s.Http2ClientConnActive.Dec(value)</span>
        case "spdy/3.1":<span class="cov0" title="0">
                s.SpdyClientConnActive.Dec(value)</span>
        case "ws":<span class="cov0" title="0">
                s.WsClientConnActive.Dec(value)</span>
        case "wss":<span class="cov0" title="0">
                s.WssClientConnActive.Dec(value)</span>
        case "stream":<span class="cov0" title="0">
                s.StreamClientConnActive.Dec(value)</span>
        }
        <span class="cov0" title="0">s.ClientConnActive.Dec(value)</span>
}

func (s *ProxyState) ClientReqServedInc(proto string, value uint) <span class="cov0" title="0">{
        switch proto </span>{
        case "http":<span class="cov0" title="0">
                s.HttpClientReqServed.Inc(value)</span>
        case "https":<span class="cov0" title="0">
                s.HttpsClientReqServed.Inc(value)</span>
        case "h2":<span class="cov0" title="0">
                s.Http2ClientReqServed.Inc(value)</span>
        case "spdy/3.1":<span class="cov0" title="0">
                s.SpdyClientReqServed.Inc(value)</span>
        }
        <span class="cov0" title="0">s.ClientReqServed.Inc(value)</span>
}

func (s *ProxyState) ClientReqActiveInc(proto string, value uint) <span class="cov0" title="0">{
        switch proto </span>{
        case "http":<span class="cov0" title="0">
                s.HttpClientReqActive.Inc(value)</span>
        case "https":<span class="cov0" title="0">
                s.HttpsClientReqActive.Inc(value)</span>
        case "h2":<span class="cov0" title="0">
                s.Http2ClientReqActive.Inc(value)</span>
        case "spdy/3.1":<span class="cov0" title="0">
                s.SpdyClientReqActive.Inc(value)</span>
        }
        <span class="cov0" title="0">s.ClientReqActive.Inc(value)</span>
}

func (s *ProxyState) ClientReqActiveDec(proto string, value uint) <span class="cov0" title="0">{
        switch proto </span>{
        case "http":<span class="cov0" title="0">
                s.HttpClientReqActive.Dec(value)</span>
        case "https":<span class="cov0" title="0">
                s.HttpsClientReqActive.Dec(value)</span>
        case "h2":<span class="cov0" title="0">
                s.Http2ClientReqActive.Dec(value)</span>
        case "spdy/3.1":<span class="cov0" title="0">
                s.SpdyClientReqActive.Dec(value)</span>
        }
        <span class="cov0" title="0">s.ClientReqActive.Dec(value)</span>
}
</pre>
		
		<pre class="file" id="file225" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// HTTP server.  See RFC 2616.

package bfe_server

import (
        "fmt"
        "net/url"
        "path"
        "strings"
)

import (
        "github.com/bfenetworks/bfe/bfe_http"
)

// Redirect replies to the request with a redirect to url,
// which may be a path relative to the request path.
func Redirect(w bfe_http.ResponseWriter, r *bfe_http.Request, urlStr string, code int, extraHeader bfe_http.Header) <span class="cov0" title="0">{
        if u, err := url.Parse(urlStr); err == nil </span><span class="cov0" title="0">{
                // If url was relative, make absolute by
                // combining with request path.
                // The browser would probably do this for us,
                // but doing it ourselves is more reliable.

                // NOTE(rsc): RFC 2616 says that the Location
                // line must be an absolute URI, like
                // "http://www.google.com/redirect/",
                // not a path like "/redirect/".
                // Unfortunately, we don't know what to
                // put in the host name section to get the
                // client to connect to us again, so we can't
                // know the right absolute URI to send back.
                // Because of this problem, no one pays attention
                // to the RFC; they all send back just a new path.
                // So do we.
                oldpath := r.URL.Path
                if oldpath == "" </span><span class="cov0" title="0">{ // should not happen, but avoid a crash if it does
                        oldpath = "/"
                }</span>
                <span class="cov0" title="0">if u.Scheme == "" </span><span class="cov0" title="0">{
                        // no leading http://server
                        if urlStr == "" || urlStr[0] != '/' </span><span class="cov0" title="0">{
                                // make relative path absolute
                                olddir, _ := path.Split(oldpath)
                                urlStr = olddir + urlStr
                        }</span>

                        <span class="cov0" title="0">var query string
                        if i := strings.Index(urlStr, "?"); i != -1 </span><span class="cov0" title="0">{
                                urlStr, query = urlStr[:i], urlStr[i:]
                        }</span>

                        // clean up but preserve trailing slash
                        <span class="cov0" title="0">trailing := strings.HasSuffix(urlStr, "/")
                        urlStr = path.Clean(urlStr)
                        if trailing &amp;&amp; !strings.HasSuffix(urlStr, "/") </span><span class="cov0" title="0">{
                                urlStr += "/"
                        }</span>
                        <span class="cov0" title="0">urlStr += query</span>
                }
        }

        <span class="cov0" title="0">header := w.Header()
        for key, values := range extraHeader </span><span class="cov0" title="0">{
                for _, value := range values </span><span class="cov0" title="0">{
                        header.Add(key, value)
                }</span>
        }
        <span class="cov0" title="0">header.Set("Location", urlStr)
        header.Set("Server", "bfe")
        w.WriteHeader(code)

        // RFC2616 recommends that a short note "SHOULD" be included in the
        // response because older user agents may not understand 301/307.
        // Shouldn't send the response for POST or HEAD; that leaves GET.
        if r.Method == "GET" </span><span class="cov0" title="0">{
                note := "&lt;a href=\"" + htmlEscape(urlStr) + "\"&gt;" + bfe_http.StatusText[code] + "&lt;/a&gt;.\n"
                fmt.Fprintln(w, note)
        }</span>
}

func htmlEscape(s string) string <span class="cov0" title="0">{
        return htmlReplacer.Replace(s)
}</span>

var htmlReplacer = strings.NewReplacer(
        "&amp;", "&amp;amp;",
        "&lt;", "&amp;lt;",
        "&gt;", "&amp;gt;",
        // "&amp;#34;" is shorter than "&amp;quot;".
        `"`, "&amp;#34;",
        // "&amp;#39;" is shorter than "&amp;apos;" and apos was not in HTML until HTML5.
        "'", "&amp;#39;",
)
</pre>
		
		<pre class="file" id="file226" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// register modules for bfe

package bfe_server

import (
        "strings"
)

import (
        "github.com/baidu/go-lib/log"
)

// RegisterModules registers bfe work module.
func (srv *BfeServer) RegisterModules(modules []string) error <span class="cov0" title="0">{
        if modules == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">for _, moduleName := range modules </span><span class="cov0" title="0">{
                moduleName = strings.TrimSpace(moduleName)
                if len(moduleName) == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">if err := srv.Modules.RegisterModule(moduleName); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">log.Logger.Info("RegisterModule():moduleName=%s", moduleName)</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file227" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// HTTP server.  See RFC 2616.

package bfe_server

import (
        "errors"
        "io"
        "net"
        "os"
        "strconv"
        "sync"
        "sync/atomic"
        "time"
)

import (
        "github.com/baidu/go-lib/log"
)

import (
        "github.com/bfenetworks/bfe/bfe_bufio"
        "github.com/bfenetworks/bfe/bfe_http"
)

const (
        sniffLen = 512 // previous defined in net/http/sniff.go
)

// The CloseNotifier interface is implemented by ResponseWriters which
// allow detecting when the underlying connection has gone away.
//
// This mechanism can be used to cancel long operations on the server
// if the client has disconnected before the response is ready.
type CloseNotifier interface {
        // CloseNotify returns a channel that receives a single value
        // when the client connection has gone away.
        CloseNotify() &lt;-chan bool
}

// Errors introduced by the HTTP server.
var (
        ErrBodyNotAllowed = errors.New("http: request method or response status code does not allow body")
        ErrContentLength  = errors.New("Conn.Write wrote more than the declared Content-Length")
        ErrHijacked       = errors.New("http: connection has been hijacked")
)

// A switchWriter can have its Writer changed at runtime.
// It's not safe for concurrent Writes and switches.
type switchWriter struct {
        io.Writer
}

type atomicBool int32

func (b *atomicBool) isSet() bool <span class="cov0" title="0">{ return atomic.LoadInt32((*int32)(b)) != 0 }</span>
func (b *atomicBool) setTrue()    <span class="cov0" title="0">{ atomic.StoreInt32((*int32)(b), 1) }</span>
func (b *atomicBool) setFalse()   <span class="cov0" title="0">{ atomic.StoreInt32((*int32)(b), 0) }</span>

// A response represents the server side of an HTTP response.
type response struct {
        conn          *conn
        req           *bfe_http.Request // request for this response
        wroteHeader   bool              // reply header has been (logically) written
        wroteContinue bool              // 100 Continue response was written

        // canWriteContinue is a boolean value accessed as an atomic int32
        // that says whether or not a 100 Continue header can be written
        // to the connection.
        // writeContinueMu must be held while writing the header.
        // These two fields together synchronize the body reader
        // (the expectContinueReader, which wants to write 100 Continue)
        // against the main writer.
        canWriteContinue atomicBool
        writeContinueMu  sync.Mutex

        w  *bfe_bufio.Writer // buffers output in chunks to chunkWriter
        cw chunkWriter
        sw *switchWriter // of the bufio.Writer, for return to putBufioWriter

        // handlerHeader is the Header that Handlers get access to,
        // which may be retained and mutated even after WriteHeader.
        // handlerHeader is copied into cw.header at WriteHeader
        // time, and privately mutated thereafter.
        handlerHeader bfe_http.Header
        calledHeader  bool // handler accessed handlerHeader via Header

        headerWritten int64 // number of bytes written in header
        written       int64 // number of bytes written in body
        contentLength int64 // explicitly-declared Content-Length; or -1
        status        int   // status code passed to WriteHeader

        // close connection after this reply.  set on request and
        // updated after response from handler if there's a
        // "Connection: keep-alive" response header and a
        // Content-Length.
        closeAfterReply bool

        // requestBodyLimitHit is set by requestTooLarge when
        // maxBytesReader hits its max size. It is checked in
        // WriteHeader, to make sure we don't consume the
        // remaining request body to try to advance to the next HTTP
        // request. Instead, when this is set, we stop reading
        // subsequent requests on this connection and stop reading
        // input from it.
        requestBodyLimitHit bool

        handlerDone bool // set true when the handler exits
        hijackedv   bool

        // Buffers for Date and Content-Length
        dateBuf [len(bfe_http.TimeFormat)]byte
        clenBuf [10]byte
}

func newResponse(c *conn, req *bfe_http.Request) *response <span class="cov0" title="0">{
        w := &amp;response{
                conn:          c,
                req:           req,
                handlerHeader: make(bfe_http.Header),
                contentLength: -1,
        }
        w.cw.res = w
        w.w = c.server.BufioCache.newBufioWriterSize(&amp;w.cw, bufferBeforeChunkingSize)
        return w
}</span>

// requestTooLarge is called by maxBytesReader when too much input has
// been read from the client.
func (w *response) requestTooLarge() <span class="cov0" title="0">{
        w.closeAfterReply = true
        w.requestBodyLimitHit = true
        if !w.wroteHeader </span><span class="cov0" title="0">{
                w.Header().Set("Connection", "close")
        }</span>
}

// needsSniff reports whether a Content-Type still needs to be sniffed.
func (w *response) needsSniff() bool <span class="cov8" title="1">{
        _, haveType := w.handlerHeader["Content-Type"]
        return !w.cw.wroteHeader &amp;&amp; !haveType &amp;&amp; w.written &lt; sniffLen
}</span>

// writerOnly hides an io.Writer value's optional ReadFrom method
// from io.Copy.
type writerOnly struct {
        io.Writer
}

func srcIsRegularFile(src io.Reader) (isRegular bool, err error) <span class="cov0" title="0">{
        switch v := src.(type) </span>{
        case *os.File:<span class="cov0" title="0">
                fi, err := v.Stat()
                if err != nil </span><span class="cov0" title="0">{
                        return false, err
                }</span>
                <span class="cov0" title="0">return fi.Mode().IsRegular(), nil</span>
        case *io.LimitedReader:<span class="cov0" title="0">
                return srcIsRegularFile(v.R)</span>
        default:<span class="cov0" title="0">
                return</span>
        }
}

// SetSigner set signature calculator for response
func (w *response) SetSigner(signer bfe_http.SignCalculator) <span class="cov0" title="0">{
        w.cw.Signer = signer
}</span>

// ReadFrom is here to optimize copying from an *os.File regular file
// to a *net.TCPConn with sendfile.
func (w *response) ReadFrom(src io.Reader) (n int64, err error) <span class="cov0" title="0">{
        // Our underlying w.conn.rwc is usually a *TCPConn (with its
        // own ReadFrom method). If not, or if our src isn't a regular
        // file, just fall back to the normal copy method.
        rf, ok := w.conn.rwc.(io.ReaderFrom)
        regFile, err := srcIsRegularFile(src)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">if !ok || !regFile </span><span class="cov0" title="0">{
                return io.Copy(writerOnly{w}, src)
        }</span>

        // sendfile path:

        <span class="cov0" title="0">if !w.wroteHeader </span><span class="cov0" title="0">{
                w.WriteHeader(bfe_http.StatusOK)
        }</span>

        <span class="cov0" title="0">if w.needsSniff() </span><span class="cov0" title="0">{
                n0, err := io.Copy(writerOnly{w}, io.LimitReader(src, sniffLen))
                n += n0
                if err != nil </span><span class="cov0" title="0">{
                        return n, err
                }</span>
        }

        <span class="cov0" title="0">w.w.Flush()  // get rid of any previous writes
        w.cw.flush() // make sure Header is written; flush data to rwc

        // Now that cw has been flushed, its chunking field is guaranteed initialized.
        if !w.cw.chunking &amp;&amp; w.bodyAllowed() </span><span class="cov0" title="0">{
                n0, err := rf.ReadFrom(src)
                n += n0
                w.written += n0
                return n, err
        }</span>

        <span class="cov0" title="0">n0, err := io.Copy(writerOnly{w}, src)
        n += n0
        return n, err</span>
}

func (w *response) Header() bfe_http.Header <span class="cov0" title="0">{
        if w.cw.header == nil &amp;&amp; w.wroteHeader &amp;&amp; !w.cw.wroteHeader </span><span class="cov0" title="0">{
                // Accessing the header between logically writing it
                // and physically writing it means we need to allocate
                // a clone to snapshot the logically written state.
                w.cw.header = w.handlerHeader.Clone()
        }</span>
        <span class="cov0" title="0">w.calledHeader = true
        return w.handlerHeader</span>
}

func (w *response) WriteHeader(code int) <span class="cov0" title="0">{
        if w.wroteHeader </span><span class="cov0" title="0">{
                log.Logger.Warn("http: multiple response.WriteHeader calls")
                return
        }</span>
        <span class="cov0" title="0">w.wroteHeader = true
        w.status = code

        // if server in graceful shutdown state, signal client that
        // the connection will be closed after completion of the response
        if w.conn.server.CheckGracefulShutdown() </span><span class="cov0" title="0">{
                if w.req.Proto == "HTTP/1.1" </span><span class="cov0" title="0">{
                        w.handlerHeader.Set("Connection", "close")
                }</span>
                // Note: http &lt;1.1 application do not support persistent
                // connections and will close connection directly after
                // completion of the response
        }

        <span class="cov0" title="0">if w.calledHeader &amp;&amp; w.cw.header == nil </span><span class="cov0" title="0">{
                w.cw.header = w.handlerHeader.Clone()
        }</span>

        <span class="cov0" title="0">if cl := w.handlerHeader.GetDirect("Content-Length"); cl != "" </span><span class="cov0" title="0">{
                v, err := strconv.ParseInt(cl, 10, 64)
                if err == nil &amp;&amp; v &gt;= 0 </span><span class="cov0" title="0">{
                        w.contentLength = v
                }</span> else<span class="cov0" title="0"> {
                        log.Logger.Warn("http: invalid Content-Length of %q", cl)
                        w.handlerHeader.Del("Content-Length")
                }</span>
        }
}

// bodyAllowed returns true if a Write is allowed for this response type.
// It's illegal to call this before the header has been flushed.
func (w *response) bodyAllowed() bool <span class="cov0" title="0">{
        if !w.wroteHeader </span><span class="cov0" title="0">{
                panic("")</span>
        }
        <span class="cov0" title="0">return w.status != bfe_http.StatusNotModified</span>
}

// The Life Of A Write is like this:
//
// Handler starts. No header has been sent. The handler can either
// write a header, or just start writing.  Writing before sending a header
// sends an implicitly empty 200 OK header.
//
// If the handler didn't declare a Content-Length up front, we either
// go into chunking mode or, if the handler finishes running before
// the chunking buffer size, we compute a Content-Length and send that
// in the header instead.
//
// Likewise, if the handler didn't set a Content-Type, we sniff that
// from the initial chunk of output.
//
// The Writers are wired together like:
//
// 1. *response (the ResponseWriter) -&gt;
// 2. (*response).w, a *bufio.Writer of bufferBeforeChunkingSize bytes
// 3. chunkWriter.Writer (whose writeHeader finalizes Content-Length/Type)
//    and which writes the chunk headers, if needed.
// 4. conn.buf, a bufio.Writer of default (4kB) bytes
// 5. the rwc, the net.Conn.
//
// TODO(bradfitz): short-circuit some of the buffering when the
// initial header contains both a Content-Type and Content-Length.
// Also short-circuit in (1) when the header's been sent and not in
// chunking mode, writing directly to (4) instead, if (2) has no
// buffered data.  More generally, we could short-circuit from (1) to
// (3) even in chunking mode if the write size from (1) is over some
// threshold and nothing is in (2).  The answer might be mostly making
// bufferBeforeChunkingSize smaller and having bufio's fast-paths deal
// with this instead.
func (w *response) Write(data []byte) (n int, err error) <span class="cov0" title="0">{
        return w.write(len(data), data, "")
}</span>

func (w *response) WriteString(data string) (n int, err error) <span class="cov0" title="0">{
        return w.write(len(data), nil, data)
}</span>

// either dataB or dataS is non-zero.
func (w *response) write(lenData int, dataB []byte, dataS string) (n int, err error) <span class="cov0" title="0">{
        if w.canWriteContinue.isSet() </span><span class="cov0" title="0">{
                // Body reader wants to write 100 Continue but hasn't yet.
                // Tell it not to. The store must be done while holding the lock
                // because the lock makes sure that there is not an active write
                // this very moment.
                w.writeContinueMu.Lock()
                w.canWriteContinue.setFalse()
                w.writeContinueMu.Unlock()
        }</span>

        <span class="cov0" title="0">if !w.wroteHeader </span><span class="cov0" title="0">{
                w.WriteHeader(bfe_http.StatusOK)
        }</span>
        <span class="cov0" title="0">if lenData == 0 </span><span class="cov0" title="0">{
                return 0, nil
        }</span>
        <span class="cov0" title="0">if !w.bodyAllowed() </span><span class="cov0" title="0">{
                return 0, ErrBodyNotAllowed
        }</span>

        <span class="cov0" title="0">w.written += int64(lenData) // ignoring errors, for errorKludge
        if w.contentLength != -1 &amp;&amp; w.written &gt; w.contentLength </span><span class="cov0" title="0">{
                return 0, ErrContentLength
        }</span>
        <span class="cov0" title="0">if dataB != nil </span><span class="cov0" title="0">{
                return w.w.Write(dataB)
        }</span>
        <span class="cov0" title="0">return w.w.WriteString(dataS)</span>
}

func (w *response) finishRequest() <span class="cov0" title="0">{
        w.handlerDone = true

        if !w.wroteHeader </span><span class="cov0" title="0">{
                w.WriteHeader(bfe_http.StatusOK)
        }</span>

        <span class="cov0" title="0">w.w.Flush()
        w.conn.server.BufioCache.putBufioWriter(w.w)
        w.cw.close()
        w.conn.buf.Flush()

        // Close the body, unless we're about to close the whole TCP connection
        // anyway.
        if !w.closeAfterReply </span><span class="cov0" title="0">{
                w.req.Body.Close()
        }</span>
        <span class="cov0" title="0">if w.req.MultipartForm != nil </span><span class="cov0" title="0">{
                w.req.MultipartForm.RemoveAll()
        }</span>

        <span class="cov0" title="0">if w.req.Method != "HEAD" &amp;&amp; w.contentLength != -1 &amp;&amp; w.bodyAllowed() &amp;&amp; w.contentLength != w.written </span><span class="cov0" title="0">{
                // Did not write enough. Avoid getting out of sync.
                w.closeAfterReply = true
        }</span>
}

func (w *response) Flush() error <span class="cov0" title="0">{
        if !w.wroteHeader </span><span class="cov0" title="0">{
                w.WriteHeader(bfe_http.StatusOK)
        }</span>
        <span class="cov0" title="0">w.w.Flush()
        w.cw.flush()
        return nil</span>
}

func (w *response) sendExpectationFailed() <span class="cov0" title="0">{
        // TODO(bradfitz): let ServeHTTP handlers handle
        // requests with non-standard expectation[s]? Seems
        // theoretical at best, and doesn't fit into the
        // current ServeHTTP model anyway.  We'd need to
        // make the ResponseWriter an optional
        // "ExpectReplier" interface or something.
        //
        // For now we'll just obey RFC 2616 14.20 which says
        // "If a server receives a request containing an
        // Expect field that includes an expectation-
        // extension that it does not support, it MUST
        // respond with a 417 (Expectation Failed) status."
        w.Header().Set("Connection", "close")
        w.WriteHeader(bfe_http.StatusExpectationFailed)
        w.finishRequest()
}</span>

func (w *response) CloseNotify() &lt;-chan bool <span class="cov0" title="0">{
        return w.conn.closeNotify()
}</span>

func (w *response) prepareForCloseConn() <span class="cov0" title="0">{
        if w.req.MultipartForm != nil </span><span class="cov0" title="0">{
                w.req.MultipartForm.RemoveAll()
        }</span>
}

// Hijack implements the Hijacker.Hijack method. Our response is both a ResponseWriter
// and a Hijacker.
func (w *response) Hijack() (rwc net.Conn, buf *bfe_bufio.ReadWriter, err error) <span class="cov0" title="0">{
        if w.hijackedv </span><span class="cov0" title="0">{
                return nil, nil, ErrHijacked
        }</span>
        <span class="cov0" title="0">w.hijackedv = true

        if w.wroteHeader </span><span class="cov0" title="0">{
                w.cw.flush()
        }</span>

        <span class="cov0" title="0">c := w.conn
        c.rwc.SetDeadline(time.Time{})
        return c.rwc, c.buf, nil</span>
}
</pre>
		
		<pre class="file" id="file228" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Copyright 2011 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// HTTP reverse proxy handler

package bfe_server

import (
        "crypto/tls"
        "io"
        "net"
        "reflect"
        "strconv"
        "strings"
        "sync"
        "time"
)

import (
        "golang.org/x/net/http2"

        "github.com/baidu/go-lib/log"
)

import (
        bfe_cluster_backend "github.com/bfenetworks/bfe/bfe_balance/backend"
        "github.com/bfenetworks/bfe/bfe_balance/bal_gslb"
        "github.com/bfenetworks/bfe/bfe_basic"
        "github.com/bfenetworks/bfe/bfe_config/bfe_cluster_conf/cluster_conf"
        "github.com/bfenetworks/bfe/bfe_debug"
        "github.com/bfenetworks/bfe/bfe_fcgi"
        "github.com/bfenetworks/bfe/bfe_http"
        "github.com/bfenetworks/bfe/bfe_http2"
        "github.com/bfenetworks/bfe/bfe_module"
        "github.com/bfenetworks/bfe/bfe_route"
        "github.com/bfenetworks/bfe/bfe_route/bfe_cluster"
        "github.com/bfenetworks/bfe/bfe_spdy"
        "github.com/bfenetworks/bfe/bfe_util"
)

// TrailerPrefix is a magic prefix for ResponseWriter.Header map keys
// that, if present, signals that the map entry is actually for
// the response trailers, and not the response headers. The prefix
// is stripped after the ServeHTTP call finishes and the values are
// sent in the trailers.
//
// This mechanism is intended only for trailers that are not known
// prior to the headers being written. If the set of trailers is fixed
// or known before the header is written, the normal Go trailers mechanism
// is preferred:
//    https://golang.org/pkg/net/http/#ResponseWriter
//    https://golang.org/pkg/net/http/#example_ResponseWriter_trailers
const TrailerPrefix = "Trailer:"

// RoundTripperMap holds mappings from cluster-name to RoundTripper.
type RoundTripperMap map[string]bfe_http.RoundTripper

// ReverseProxy takes an incoming request and sends it to another server,
// proxying the response back to the client.
type ReverseProxy struct {
        // The transport used to perform proxy requests.
        // If no transport from clustername-&gt;transport map, create one.
        tsMu       sync.RWMutex
        transports RoundTripperMap
        bufferPool *bfe_util.FixedPool

        server     *BfeServer  // link to bfe server
        proxyState *ProxyState // state of proxy
}

// NewReverseProxy returns a new ReverseProxy.
func NewReverseProxy(server *BfeServer, state *ProxyState) *ReverseProxy <span class="cov0" title="0">{
        rp := new(ReverseProxy)
        rp.transports = make(RoundTripperMap)
        rp.server = server
        rp.proxyState = state
        rp.bufferPool = bfe_util.NewFixedPool(32 * 1024)
        return rp
}</span>

// httpProtoSet set http proto for out request.
func httpProtoSet(outreq *bfe_http.Request) <span class="cov0" title="0">{
        outreq.Proto = "HTTP/1.1"
        outreq.ProtoMajor = 1
        outreq.ProtoMinor = 1
        outreq.Close = false
}</span>

// hopByHopHeaderRemove remove hop-by-hop headers.
func hopByHopHeaderRemove(outreq, req *bfe_http.Request) <span class="cov0" title="0">{
        // Remove hop-by-hop headers to the backend.  Especially
        // important is "Connection" because we want a persistent
        // connection, regardless of what the client sent to us.  This
        // is modifying the same underlying map from req (shallow
        // copied above) so we only copy it if necessary.
        copiedHeaders := false
        for _, h := range bfe_basic.HopHeaders </span><span class="cov0" title="0">{
                hv := outreq.Header.Get(h)
                if hv == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">if h == "Te" &amp;&amp; hv == "trailers" </span><span class="cov0" title="0">{
                        // Issue 21096: tell backend applications that
                        // care about trailer support that we support
                        // trailers. (We do, but we don't go out of
                        // our way to advertise that unless the
                        // incoming client request thought it was
                        // worth mentioning)
                        continue</span>
                }

                <span class="cov0" title="0">if !copiedHeaders </span><span class="cov0" title="0">{
                        outreq.Header = make(bfe_http.Header, len(req.Header))
                        bfe_http.CopyHeader(outreq.Header, req.Header)
                        copiedHeaders = true
                }</span>
                <span class="cov0" title="0">outreq.Header.Del(h)</span>
        }
}

// setBackendAddr set backend addr to host of request url.
func setBackendAddr(req *bfe_http.Request, backend *bfe_cluster_backend.BfeBackend) <span class="cov0" title="0">{
        req.URL.Scheme = "http"
        req.URL.Host = backend.GetAddrInfo()
}</span>

func (p *ReverseProxy) setTransports(clusterMap bfe_route.ClusterMap) <span class="cov0" title="0">{
        p.tsMu.Lock()
        defer p.tsMu.Unlock()

        newTransports := make(RoundTripperMap)
        for cluster, conf := range clusterMap </span><span class="cov0" title="0">{
                transport, ok := p.transports[cluster]
                if !ok </span><span class="cov0" title="0">{
                        transport = createTransport(conf)
                        newTransports[cluster] = transport
                        continue</span>
                }

                <span class="cov0" title="0">switch t := transport.(type) </span>{
                case *bfe_http.Transport:<span class="cov0" title="0">
                        // get transport, check if transport needs update
                        backendConf := conf.BackendConf()
                        if (t.MaxIdleConnsPerHost != *backendConf.MaxIdleConnsPerHost) ||
                                (t.MaxConnsPerHost != *backendConf.MaxConnsPerHost) ||
                                (t.ResponseHeaderTimeout != time.Millisecond*time.Duration(*backendConf.TimeoutResponseHeader)) ||
                                (t.ReqWriteBufferSize != conf.ReqWriteBufferSize()) ||
                                (t.ReqFlushInterval != conf.ReqFlushInterval()) </span><span class="cov0" title="0">{
                                // create new transport with newConf instead of update transport
                                // update transport needs lock
                                transport = createTransport(conf)
                                newTransports[cluster] = transport
                                continue</span>
                        }

                        <span class="cov0" title="0">newTransports[cluster] = transport</span>
                default:<span class="cov0" title="0">
                        transport = createTransport(conf)
                        newTransports[cluster] = transport</span>
                }
        }

        <span class="cov0" title="0">p.transports = newTransports</span>
}

// getTransport return transport from map, if not exist, create a transport.
func (p *ReverseProxy) getTransport(cluster *bfe_cluster.BfeCluster) bfe_http.RoundTripper <span class="cov0" title="0">{
        p.tsMu.RLock()
        transport, ok := p.transports[cluster.Name]
        p.tsMu.RUnlock()

        if !ok </span><span class="cov0" title="0">{
                transport = createTransport(cluster)
                p.tsMu.Lock()
                p.transports[cluster.Name] = transport
                p.tsMu.Unlock()
        }</span>

        <span class="cov0" title="0">return transport</span>
}

func createTransport(cluster *bfe_cluster.BfeCluster) bfe_http.RoundTripper <span class="cov0" title="0">{
        backendConf := cluster.BackendConf()
        protocol := *backendConf.Protocol

        log.Logger.Debug("create a new transport for %s, timeout %d", cluster.Name, *backendConf.TimeoutResponseHeader)

        switch protocol </span>{
        case "http":<span class="cov0" title="0">
                // cluster has its own Connect Server Timeout.
                // so each cluster has a different transport
                // once cluster's timeout updated, dailer use new value
                dailer := func(network, add string) (net.Conn, error) </span><span class="cov0" title="0">{
                        timeout := time.Duration(cluster.TimeoutConnSrv()) * time.Millisecond
                        return net.DialTimeout(network, add, timeout)
                }</span>

                <span class="cov0" title="0">return &amp;bfe_http.Transport{
                        Dial:                  dailer,
                        DisableKeepAlives:     (*backendConf.MaxIdleConnsPerHost) == 0,
                        MaxIdleConnsPerHost:   *backendConf.MaxIdleConnsPerHost,
                        ResponseHeaderTimeout: time.Millisecond * time.Duration(*backendConf.TimeoutResponseHeader),
                        ReqWriteBufferSize:    cluster.ReqWriteBufferSize(),
                        ReqFlushInterval:      cluster.ReqFlushInterval(),
                        DisableCompression:    true,
                        MaxConnsPerHost:       *backendConf.MaxConnsPerHost,
                }</span>
        case "fcgi":<span class="cov0" title="0">
                return &amp;bfe_fcgi.Transport{
                        Root:    backendConf.FCGIConf.Root,
                        EnvVars: backendConf.FCGIConf.EnvVars,
                }</span>
        case "h2c":<span class="cov0" title="0">
                return &amp;bfe_http2.Transport{
                        T: &amp;http2.Transport{
                                AllowHTTP: true,
                                DialTLS: func(network, addr string, cfg *tls.Config) (net.Conn, error) </span><span class="cov0" title="0">{
                                        timeout := time.Duration(cluster.TimeoutConnSrv()) * time.Millisecond
                                        return net.DialTimeout(network, addr, timeout)
                                }</span>,
                        },
                }
        default:<span class="cov0" title="0">
                /* never come here */
                log.Logger.Warn("unknown cluster protocol %s", protocol)
                return nil</span>
        }
}

// clusterInvoke invoke cluster to get response.
func (p *ReverseProxy) clusterInvoke(srv *BfeServer, cluster *bfe_cluster.BfeCluster,
        request *bfe_basic.Request, rw bfe_http.ResponseWriter) (
        res *bfe_http.Response, action int, err error) <span class="cov0" title="0">{
        var clusterBackend *bfe_cluster_backend.BfeBackend
        var bal *bal_gslb.BalanceGslb
        var outreq *bfe_http.Request = request.OutRequest

        // mark start/end of cluster invoke
        request.Stat.ClusterStart = time.Now()
        defer func() </span><span class="cov0" title="0">{
                request.Stat.ClusterEnd = time.Now()
        }</span>()

        <span class="cov0" title="0">clusterTransport := p.getTransport(cluster)

        // look up for balance
        bal, err = srv.balTable.Lookup(cluster.Name)
        if err != nil </span><span class="cov0" title="0">{
                log.Logger.Warn("no balance for %s", cluster.Name)
                request.Stat.ResponseStart = time.Now()
                request.ErrCode = bfe_basic.ErrBkNoCluster
                request.ErrMsg = err.Error()
                p.proxyState.ErrBkNoBalance.Inc(1)
                action = closeAfterReply
                return
        }</span>

        // When request.RetryTime exceeds some value, srv.clusterTable.Lookup()
        // will return error. Here set a limit of 20, to avoid endless loop
        <span class="cov0" title="0">for i := 0; i &lt; 20; i++ </span><span class="cov0" title="0">{
                // get backend with cluster-name and request
                clusterBackend, err = bal.Balance(request)
                if err == bfe_basic.ErrBkCrossRetryBalance </span><span class="cov0" title="0">{
                        request.RetryTime += 1
                        continue</span>
                }

                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        // p.proxystate counter is set by bal.Balance(), only log
                        log.Logger.Warn("cluster [%s] select backend failed, err[%s]", cluster.Name,
                                err.Error())
                        break</span>
                }

                // err == nil if and only if we choose a new backend,
                // decr old backend connection num
                <span class="cov0" title="0">if request.Trans.Backend != nil </span><span class="cov0" title="0">{
                        request.Trans.Backend.DecConnNum()
                        request.Trans.Backend = nil
                }</span>
                <span class="cov0" title="0">request.SetRequestTransport(clusterBackend, clusterTransport)

                log.Logger.Debug("ReverseProxy.Invoke(): before HandleForward backend %s:%d",
                        request.Trans.Backend.Addr, request.Trans.Backend.Port)

                // Callback for HandleForward
                hl := srv.CallBacks.GetHandlerList(bfe_module.HandleForward)
                if hl != nil </span><span class="cov0" title="0">{
                        retVal := hl.FilterForward(request)
                        switch retVal </span>{
                        case bfe_module.BfeHandlerFinish:<span class="cov0" title="0">
                                // close the connection after response
                                action = closeAfterReply
                                return</span>
                        }
                }

                <span class="cov0" title="0">log.Logger.Debug("ReverseProxy.Invoke(): after HandleForward backend %s:%d",
                        request.Trans.Backend.Addr, request.Trans.Backend.Port)

                // set backend addr to out request
                backend := request.Trans.Backend
                backend.IncConnNum()
                setBackendAddr(outreq, backend)

                // invoke backend
                request.Stat.BackendStart = time.Now()
                if i == 0 </span><span class="cov0" title="0">{
                        // record start time of the first try
                        request.Stat.BackendFirst = request.Stat.BackendStart
                }</span>

                <span class="cov0" title="0">transport := request.Trans.Transport

                res, err = transport.RoundTrip(outreq)

                request.Stat.BackendEnd = time.Now()

                // record backend info to request, no matter succeed or fail
                request.Backend.SubclusterName = backend.SubCluster
                request.Backend.BackendName = backend.Name
                request.Backend.BackendAddr = backend.Addr
                request.Backend.BackendPort = uint32(backend.Port)

                if err == nil </span><span class="cov0" title="0">{
                        if checkBackendStatus(cluster.OutlierDetectionHttpCode(), res.StatusCode) </span><span class="cov0" title="0">{
                                backend.OnFail(cluster.Name)
                        }</span> else<span class="cov0" title="0"> {
                                backend.OnSuccess()
                        }</span>

                        // clear err msg in req.
                        // this step is required, if finally succeed after retry
                        <span class="cov0" title="0">request.ErrCode = nil
                        request.ErrMsg = ""

                        // record body size of request after forward
                        request.Stat.BodyLenIn = int(outreq.State.BodySize)

                        if bfe_debug.DebugServHTTP </span><span class="cov0" title="0">{
                                log.Logger.Debug("ReverseProxy.ServeHTTP(): get response from %s", backend.Name)
                        }</span>
                        <span class="cov0" title="0">break</span>
                }

                // fail in invoking backend
                <span class="cov0" title="0">log.Logger.Info("[%s] [%s:%d] roundtrip %s", cluster.Name, backend.Addr, backend.Port, err)
                p.proxyState.ErrBkRequestBackend.Inc(1)

                // deal with errors here, possible error type:
                //  1. connect backend error
                //  2. read client request body error(POST/PUT)
                //  3. write backend error
                //     a. haven't write any byte
                //     b. already write part of data
                //  4. read backend error
                //  5. other error
                allowRetry := false
                switch err.(type) </span>{
                case bfe_http.ConnectError, bfe_fcgi.ConnectError:<span class="cov0" title="0">
                        // if error happens in dial phrase, we can retry
                        request.ErrCode = bfe_basic.ErrBkConnectBackend
                        request.ErrMsg = err.Error()
                        p.proxyState.ErrBkConnectBackend.Inc(1)
                        allowRetry = true
                        backend.OnFail(cluster.Name)</span>

                case bfe_http.WriteRequestError, bfe_fcgi.WriteRequestError:<span class="cov0" title="0">
                        request.ErrCode = bfe_basic.ErrBkWriteRequest
                        request.ErrMsg = err.Error()
                        p.proxyState.ErrBkWriteRequest.Inc(1)
                        allowRetry = checkAllowRetry(cluster.RetryLevel(), outreq)

                        // if error is caused by backend server
                        rerr := err.(bfe_http.WriteRequestError)
                        if !rerr.CheckTargetError(request.RemoteAddr) </span><span class="cov0" title="0">{
                                backend.OnFail(cluster.Name)
                        }</span>

                case bfe_http.ReadRespHeaderError, bfe_fcgi.ReadRespHeaderError:<span class="cov0" title="0">
                        request.ErrCode = bfe_basic.ErrBkReadRespHeader
                        request.ErrMsg = err.Error()
                        p.proxyState.ErrBkReadRespHeader.Inc(1)
                        allowRetry = checkAllowRetry(cluster.RetryLevel(), outreq)
                        backend.OnFail(cluster.Name)</span>

                case bfe_http.RespHeaderTimeoutError:<span class="cov0" title="0">
                        request.ErrCode = bfe_basic.ErrBkRespHeaderTimeout
                        request.ErrMsg = err.Error()
                        p.proxyState.ErrBkRespHeaderTimeout.Inc(1)
                        allowRetry = checkAllowRetry(cluster.RetryLevel(), outreq)
                        backend.OnFail(cluster.Name)</span>

                case bfe_http.TransportBrokenError:<span class="cov0" title="0">
                        request.ErrCode = bfe_basic.ErrBkTransportBroken
                        request.ErrMsg = err.Error()
                        p.proxyState.ErrBkTransportBroken.Inc(1)
                        allowRetry = checkAllowRetry(cluster.RetryLevel(), outreq)</span>

                default:<span class="cov0" title="0">
                        // never go here
                        log.Logger.Info("roundtrip %s %s", reflect.TypeOf(err), err)</span>
                }

                <span class="cov0" title="0">if !allowRetry </span><span class="cov0" title="0">{
                        log.Logger.Debug("request fail, not retry now")
                        p.proxyState.ClientReqFailWithNoRetry.Inc(1)
                        break</span>
                }

                <span class="cov0" title="0">request.RetryTime += 1</span>
        }

        // have retry?
        <span class="cov0" title="0">if request.RetryTime &gt; 0 </span><span class="cov0" title="0">{
                p.proxyState.ClientReqWithRetry.Inc(1)
        }</span>
        // have cross-cluster retry?
        <span class="cov0" title="0">if request.Stat.IsCrossCluster </span><span class="cov0" title="0">{
                p.proxyState.ClientReqWithCrossRetry.Inc(1)
        }</span>

        <span class="cov0" title="0">log.Logger.Debug("clusterInvoke %v %v", res, err)
        return</span>
}

// sendResponse send http response to client.
func (p *ReverseProxy) sendResponse(rw bfe_http.ResponseWriter, res *bfe_http.Response,
        flushInterval time.Duration, cancelOnClientClose bool) error <span class="cov0" title="0">{
        // prepare SignCalculator for response
        p.prepareSigner(rw, res)

        bfe_http.CopyHeader(rw.Header(), res.Header)

        // note: writeheader don't guarantee send header
        rw.WriteHeader(res.StatusCode)

        err := p.copyResponse(rw, res.Body, flushInterval, cancelOnClientClose)
        res.Body.Close() // close now, instead of defer, to populate res.Trailer
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if res.H2Trailer == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">if len(*res.H2Trailer) &gt; 0 </span><span class="cov0" title="0">{
                // Force chunking if we saw a response trailer.
                // This prevents net/http from calculating the length for short
                // bodies and adding a Content-Length.
                if fl, ok := rw.(bfe_http.Flusher); ok </span><span class="cov0" title="0">{
                        fl.Flush()
                }</span>
        }

        <span class="cov0" title="0">for k, vv := range *res.H2Trailer </span><span class="cov0" title="0">{
                k = TrailerPrefix + k
                for _, v := range vv </span><span class="cov0" title="0">{
                        rw.Header().Add(k, v)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// prepareSigner prepare SignCalculator for response.
func (p *ReverseProxy) prepareSigner(rw bfe_http.ResponseWriter, res *bfe_http.Response) <span class="cov0" title="0">{
        // not need to add signature for respsone
        if res.Signer == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // prepare Singer for signature
        <span class="cov0" title="0">if resp, ok := rw.(*response); ok </span><span class="cov0" title="0">{
                resp.SetSigner(res.Signer)
        }</span>
}

// FinishReq should be invoked after quit ServHTTP().
func (p *ReverseProxy) FinishReq(rw bfe_http.ResponseWriter, request *bfe_basic.Request) (action int) <span class="cov0" title="0">{
        // get instance of BfeServer
        srv := p.server

        // desc connection num after request finish
        defer func() </span><span class="cov0" title="0">{
                // desc backend connection counter
                if request.Trans.Backend != nil </span><span class="cov0" title="0">{
                        request.Trans.Backend.DecConnNum()
                }</span>
        }()

        // Callback for HandleRequestFinish
        <span class="cov0" title="0">hl := srv.CallBacks.GetHandlerList(bfe_module.HandleRequestFinish)
        if hl != nil </span><span class="cov0" title="0">{
                retVal := hl.FilterResponse(request, request.HttpResponse)
                switch retVal </span>{
                case bfe_module.BfeHandlerFinish:<span class="cov0" title="0">
                        // close the connection after response
                        action = closeAfterReply
                        return</span>
                }
        }

        <span class="cov0" title="0">return</span>
}

func (p *ReverseProxy) setTimeout(stage bfe_basic.OperationStage,
        conn net.Conn, req *bfe_http.Request, d time.Duration) <span class="cov0" title="0">{
        switch b := req.Body.(type) </span>{
        case *bfe_http2.RequestBody:<span class="cov0" title="0"> // http2
                if stage == bfe_basic.StageReadReqBody </span><span class="cov0" title="0">{
                        bfe_http2.SetReadStreamTimeout(b, d)
                }</span>
                <span class="cov0" title="0">if stage == bfe_basic.StageWriteClient </span><span class="cov0" title="0">{
                        bfe_http2.SetWriteStreamTimeout(b, d)
                }</span>
                <span class="cov0" title="0">if stage == bfe_basic.StageEndRequest </span><span class="cov0" title="0">{
                        bfe_http2.SetConnTimeout(b, d)
                }</span>
        case *bfe_spdy.RequestBody:<span class="cov0" title="0"> // spdy
                if stage == bfe_basic.StageReadReqBody </span><span class="cov0" title="0">{
                        bfe_spdy.SetReadStreamTimeout(b, d)
                }</span>
                <span class="cov0" title="0">if stage == bfe_basic.StageWriteClient </span><span class="cov0" title="0">{
                        bfe_spdy.SetWriteStreamTimeout(b, d)
                }</span>
                <span class="cov0" title="0">if stage == bfe_basic.StageEndRequest </span><span class="cov0" title="0">{
                        bfe_spdy.SetConnTimeout(b, d)
                }</span>
        default:<span class="cov0" title="0"> // http
                if stage == bfe_basic.StageReadReqBody || stage == bfe_basic.StageEndRequest </span><span class="cov0" title="0">{
                        conn.SetReadDeadline(time.Now().Add(d))
                }</span>
                <span class="cov0" title="0">if stage == bfe_basic.StageWriteClient </span><span class="cov0" title="0">{
                        conn.SetWriteDeadline(time.Now().Add(d))
                }</span>
        }
}

func (p *ReverseProxy) setReadClientAgainTimeout(cluster *bfe_cluster.BfeCluster, conn net.Conn) <span class="cov0" title="0">{
        // for idle time + read next header time
        conn.SetReadDeadline(time.Now().Add(cluster.TimeoutReadClientAgain()))
}</span>

// ServeHTTP processes http request and send http response.
//
// Params:
//    - rw : context for sending response
//    - request: context for request
//
// Return:
//    - action: action to do after ServeHTTP
func (p *ReverseProxy) ServeHTTP(rw bfe_http.ResponseWriter, basicReq *bfe_basic.Request) (action int) <span class="cov0" title="0">{
        var err error
        var res *bfe_http.Response
        var hl *bfe_module.HandlerList
        var retVal int
        var clusterName string
        var cluster *bfe_cluster.BfeCluster
        var outreq *bfe_http.Request
        var serverConf *bfe_route.ServerDataConf
        var writeTimer *time.Timer

        req := basicReq.HttpRequest
        isRedirect := false
        resFlushInterval := time.Duration(0)
        cancelOnClientClose := false

        timeoutWriteClient := time.Duration(cluster_conf.DefaultWriteClientTimeout) * time.Millisecond
        timeoutReadClientAgain := time.Duration(cluster_conf.DefaultReadClientAgainTimeout) * time.Millisecond

        // get instance of BfeServer
        srv := p.server

        // set clientip of original user for request
        setClientAddr(basicReq)

        // Callback for HandleBeforeLocation
        hl = srv.CallBacks.GetHandlerList(bfe_module.HandleBeforeLocation)
        if hl != nil </span><span class="cov0" title="0">{
                retVal, res = hl.FilterRequest(basicReq)
                basicReq.HttpResponse = res
                switch retVal </span>{
                case bfe_module.BfeHandlerClose:<span class="cov0" title="0">
                        // close the connection directly (with no response)
                        action = closeDirectly
                        return</span>
                case bfe_module.BfeHandlerFinish:<span class="cov0" title="0">
                        // close the connection after response
                        action = closeAfterReply
                        basicReq.BfeStatusCode = bfe_http.StatusInternalServerError
                        return</span>
                case bfe_module.BfeHandlerRedirect:<span class="cov0" title="0">
                        // make redirect
                        Redirect(rw, req, basicReq.Redirect.Url, basicReq.Redirect.Code, basicReq.Redirect.Header)
                        isRedirect = true
                        basicReq.BfeStatusCode = basicReq.Redirect.Code
                        goto send_response</span>
                case bfe_module.BfeHandlerResponse:<span class="cov0" title="0">
                        goto response_got</span>
                }
        }

        // find product
        <span class="cov0" title="0">if err := srv.findProduct(basicReq); err != nil </span><span class="cov0" title="0">{
                basicReq.ErrCode = bfe_basic.ErrBkFindProduct
                basicReq.ErrMsg = err.Error()
                p.proxyState.ErrBkFindProduct.Inc(1)
                log.Logger.Info("FindProduct error[%s] host[%s] vip[%s] clientip[%s]", err.Error(),
                        basicReq.HttpRequest.Host, basicReq.Session.Vip, basicReq.ClientAddr)

                // close connection
                res = bfe_basic.CreateInternalSrvErrResp(basicReq)
                action = closeAfterReply
                goto response_got</span>
        }

        // Callback for HandleFoundProduct
        <span class="cov0" title="0">hl = srv.CallBacks.GetHandlerList(bfe_module.HandleFoundProduct)
        if hl != nil </span><span class="cov0" title="0">{
                retVal, res = hl.FilterRequest(basicReq)
                basicReq.HttpResponse = res
                switch retVal </span>{
                case bfe_module.BfeHandlerClose:<span class="cov0" title="0">
                        // close the connection directly (with no response)
                        action = closeDirectly
                        return</span>
                case bfe_module.BfeHandlerFinish:<span class="cov0" title="0">
                        // close the connection after response
                        action = closeAfterReply
                        basicReq.BfeStatusCode = bfe_http.StatusInternalServerError
                        return</span>
                case bfe_module.BfeHandlerRedirect:<span class="cov0" title="0">
                        // make redirect
                        Redirect(rw, req, basicReq.Redirect.Url, basicReq.Redirect.Code, basicReq.Redirect.Header)
                        isRedirect = true
                        basicReq.BfeStatusCode = basicReq.Redirect.Code
                        goto send_response</span>
                case bfe_module.BfeHandlerResponse:<span class="cov0" title="0">
                        goto response_got</span>
                }
        }

        // find cluster
        <span class="cov0" title="0">if err = srv.findCluster(basicReq); err != nil </span><span class="cov0" title="0">{
                basicReq.ErrCode = bfe_basic.ErrBkFindLocation
                basicReq.ErrMsg = err.Error()
                p.proxyState.ErrBkFindLocation.Inc(1)
                log.Logger.Info("FindLocation error[%s] host[%s]", err, basicReq.HttpRequest.Host)

                // close connection
                res = bfe_basic.CreateInternalSrvErrResp(basicReq)
                action = closeAfterReply
                goto response_got</span>
        }
        <span class="cov0" title="0">clusterName = basicReq.Route.ClusterName

        // look up for cluster
        serverConf = basicReq.SvrDataConf.(*bfe_route.ServerDataConf)
        cluster, err = serverConf.ClusterTable.Lookup(clusterName)
        if err != nil </span><span class="cov0" title="0">{
                log.Logger.Warn("no cluster for %s", clusterName)
                basicReq.Stat.ResponseStart = time.Now()
                basicReq.ErrCode = bfe_basic.ErrBkNoCluster
                basicReq.ErrMsg = err.Error()
                p.proxyState.ErrBkNoCluster.Inc(1)

                res = bfe_basic.CreateInternalSrvErrResp(basicReq)
                action = closeAfterReply
                goto response_got</span>
        }

        <span class="cov0" title="0">basicReq.Backend.ClusterName = clusterName

        // set deadline to finish read client request body
        p.setTimeout(bfe_basic.StageReadReqBody, basicReq.Connection, req, cluster.TimeoutReadClient())
        resFlushInterval = cluster.ResFlushInterval()
        cancelOnClientClose = cluster.CancelOnClientClose()
        timeoutWriteClient = cluster.TimeoutWriteClient()
        timeoutReadClientAgain = cluster.TimeoutReadClientAgain()

        // Callback for HandleAfterLocation
        hl = srv.CallBacks.GetHandlerList(bfe_module.HandleAfterLocation)
        if hl != nil </span><span class="cov0" title="0">{
                retVal, res = hl.FilterRequest(basicReq)
                basicReq.HttpResponse = res
                switch retVal </span>{
                case bfe_module.BfeHandlerClose:<span class="cov0" title="0">
                        // close the connection directly (with no response)
                        action = closeDirectly
                        return</span>
                case bfe_module.BfeHandlerFinish:<span class="cov0" title="0">
                        // close the connection after response
                        action = closeAfterReply
                        basicReq.BfeStatusCode = bfe_http.StatusInternalServerError
                        return</span>
                case bfe_module.BfeHandlerRedirect:<span class="cov0" title="0">
                        // make redirect
                        Redirect(rw, req, basicReq.Redirect.Url, basicReq.Redirect.Code, basicReq.Redirect.Header)

                        isRedirect = true

                        basicReq.BfeStatusCode = basicReq.Redirect.Code
                        goto send_response</span>
                case bfe_module.BfeHandlerResponse:<span class="cov0" title="0">
                        goto response_got</span>
                }
        }

        <span class="cov0" title="0">if bfe_debug.DebugServHTTP </span><span class="cov0" title="0">{
                log.Logger.Debug("ReverseProxy.ServeHTTP(): cluster name = %s", clusterName)
        }</span>

        // prepare out request to downstream RS backend
        <span class="cov0" title="0">outreq = new(bfe_http.Request)
        *outreq = *req // includes shallow copies of maps, but okay
        basicReq.OutRequest = outreq

        // set http proto for out request
        httpProtoSet(outreq)
        // remove hop-by-hop headers
        hopByHopHeaderRemove(outreq, req)

        // invoke cluster to get response
        res, action, err = p.clusterInvoke(srv, cluster, basicReq, rw)
        basicReq.HttpResponse = res

        // Note: The runtime will not GC the objects referenced by basicReq.SvrDataConf until the request
        // has been processed. But the request may last a long time. It's better to remove the reference
        // to objects which are not used any more.
        basicReq.SvrDataConf = nil

        if err != nil || res == nil </span><span class="cov0" title="0">{
                basicReq.Stat.ResponseStart = time.Now()
                basicReq.BfeStatusCode = bfe_http.StatusInternalServerError
                res = bfe_basic.CreateInternalSrvErrResp(basicReq)
                goto response_got</span>
        }
        <span class="cov0" title="0">if resFlushInterval == 0 &amp;&amp; basicReq.HttpRequest.Header.Get("Accept") == "text/event-stream" </span><span class="cov0" title="0">{
                resFlushInterval = cluster.DefaultSSEFlushInterval()
        }</span>

response_got:
        // timeout for write response to client
        // Note: we use io.Copy() to read from backend and write to client.
        // For avoid from blocking on client conn or backend conn forever,
        // we must timeout both conns after specified duration.
        <span class="cov0" title="0">p.setTimeout(bfe_basic.StageWriteClient, basicReq.Connection, req, timeoutWriteClient)
        writeTimer = time.AfterFunc(timeoutWriteClient, func() </span><span class="cov0" title="0">{
                if basicReq.Trans.Transport != nil </span><span class="cov0" title="0">{
                        // TODO: process bfe_fcgi.Transport &amp; bfe_http2.Transport
                        switch t := basicReq.Trans.Transport.(type) </span>{
                        case *bfe_http.Transport:<span class="cov0" title="0">
                                t.CancelRequest(req)</span>
                        default:<span class="cov0" title="0"></span>
                                // do nothing
                        }
                }

        })
        <span class="cov0" title="0">defer writeTimer.Stop()

        // for read next request
        defer p.setTimeout(bfe_basic.StageEndRequest, basicReq.Connection, req, timeoutReadClientAgain)

        defer res.Body.Close()

        // Callback for HandleReadResponse
        hl = srv.CallBacks.GetHandlerList(bfe_module.HandleReadResponse)
        if hl != nil </span><span class="cov0" title="0">{
                retVal = hl.FilterResponse(basicReq, res)
                switch retVal </span>{
                case bfe_module.BfeHandlerFinish:<span class="cov0" title="0">
                        // close the connection after response
                        action = closeAfterReply
                        basicReq.BfeStatusCode = bfe_http.StatusInternalServerError
                        return</span>
                case bfe_module.BfeHandlerRedirect:<span class="cov0" title="0">
                        // make redirect
                        Redirect(rw, req, basicReq.Redirect.Url, basicReq.Redirect.Code, basicReq.Redirect.Header)
                        isRedirect = true
                        basicReq.BfeStatusCode = basicReq.Redirect.Code
                        goto send_response</span>
                }
        }

send_response:
        // send http response to client
        <span class="cov0" title="0">basicReq.Stat.ResponseStart = time.Now()

        if !isRedirect &amp;&amp; res != nil </span><span class="cov0" title="0">{
                err = p.sendResponse(rw, res, resFlushInterval, cancelOnClientClose)
                if err != nil </span><span class="cov0" title="0">{
                        // Note: for h2/spdy protocol, not close client conn when send
                        // response error. h2/spdy module will close conn/stream properly
                        if !CheckSupportMultiplex(basicReq.Session.Proto) </span><span class="cov0" title="0">{
                                action = closeAfterReply
                        }</span>
                        <span class="cov0" title="0">basicReq.ErrCode = bfe_basic.ErrClientWrite
                        basicReq.ErrMsg = err.Error()

                        p.proxyState.ErrClientWrite.Inc(1)</span>
                }
        }
        <span class="cov0" title="0">return</span>
}

func (p *ReverseProxy) copyResponse(dst io.Writer, src io.ReadCloser,
        flushInterval time.Duration, cancelOnClientClose bool) error <span class="cov0" title="0">{

        // Note: When server is blocking on read from backend (eg. io.Copy(dst, src)),
        // if the client has disconnected, cancel the block operation immediately.
        //
        // Note: cancelOnClientClose feature must be enabled for AVS client (over http2)
        if cancelOnClientClose </span><span class="cov0" title="0">{
                if cn, ok := dst.(bfe_http.CloseNotifier); ok </span><span class="cov0" title="0">{
                        cw := bfe_http.NewCloseWatcher(cn, func() </span><span class="cov0" title="0">{
                                // Note: src is type of bfe_http.bodyEofSignal. Close() on src will
                                // close the underlying connection if response not ready.
                                // Duplicated Close() will be ignore.
                                src.Close()
                        }</span>)
                        <span class="cov0" title="0">go cw.WatchLoop()
                        defer cw.Stop()</span>
                }
        }

        <span class="cov0" title="0">if flushInterval &lt; 0 </span><span class="cov0" title="0">{
                if wf, ok := dst.(bfe_http.WriteFlusher); ok </span><span class="cov0" title="0">{
                        // Note: Flush response header immediately
                        if err := wf.Flush(); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">_, err := bfe_util.CopyWithoutBuffer(wf, src)
                        return err</span>
                }
        }

        <span class="cov0" title="0">if flushInterval &gt; 0 </span><span class="cov0" title="0">{
                if wf, ok := dst.(bfe_http.WriteFlusher); ok </span><span class="cov0" title="0">{
                        mlw := bfe_http.NewMaxLatencyWriter(wf, flushInterval, nil)
                        go mlw.FlushLoop()
                        defer mlw.Stop()
                        dst = mlw
                }</span>
        }

        <span class="cov0" title="0">buf := p.bufferPool.GetBlock()
        defer p.bufferPool.PutBlock(buf)

        _, err := io.CopyBuffer(dst, src, buf)
        return err</span>
}

func checkAllowRetry(retryLevel int, outreq *bfe_http.Request) bool <span class="cov0" title="0">{
        if retryLevel == cluster_conf.RetryGet </span><span class="cov0" title="0">{
                // if forward GET request error (eg. backend restart)
                if outreq.Method == "GET" &amp;&amp; checkRequestWithoutBody(outreq) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// checkRequestWithoutBody check whether request without entity body.
func checkRequestWithoutBody(req *bfe_http.Request) bool <span class="cov0" title="0">{
        // Note: RFC 2616 doesn't explicitly permit nor forbid an
        // entity-body on a GET request
        if req.Body == nil || req.Body == bfe_http.EofReader </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">if body, ok := req.Body.(*bfe_spdy.RequestBody); ok </span><span class="cov0" title="0">{
                return body.Eof()
        }</span>
        <span class="cov0" title="0">return false</span>
}

func checkBackendStatus(outlierDetectionHttpCodeStr string, statusCode int) bool <span class="cov0" title="0">{
        if outlierDetectionHttpCodeStr == "" </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">for _, code := range strings.Split(outlierDetectionHttpCodeStr, "|") </span><span class="cov0" title="0">{
                switch code </span>{
                case "3xx", "4xx", "5xx":<span class="cov0" title="0">
                        if strconv.Itoa(statusCode/100) == code[0:1] </span><span class="cov0" title="0">{
                                return true
                        }</span>
                default:<span class="cov0" title="0">
                        codeInt, err := strconv.Atoi(code)
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">if codeInt == statusCode </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
        }
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file229" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// server internal status

package bfe_server

import (
        "github.com/baidu/go-lib/web-monitor/delay_counter"
        "github.com/baidu/go-lib/web-monitor/metrics"
)

import (
        bal "github.com/bfenetworks/bfe/bfe_balance/bal_gslb"
        "github.com/bfenetworks/bfe/bfe_http"
        "github.com/bfenetworks/bfe/bfe_http2"
        "github.com/bfenetworks/bfe/bfe_module"
        "github.com/bfenetworks/bfe/bfe_proxy"
        "github.com/bfenetworks/bfe/bfe_spdy"
        "github.com/bfenetworks/bfe/bfe_stream"
        "github.com/bfenetworks/bfe/bfe_tls"
        "github.com/bfenetworks/bfe/bfe_websocket"
)

// setting for delay
const (
        DC_INTERVAL          = 60  // interval for moving current to past (in s)
        DC_BUCKET_SIZE_PROXY = 1   // size of delay counter bucket for forwarding (in ms)
        DC_BUCKET_SIZE_HS    = 100 // size of delay counter bucket for handshake (in ms)
        DC_BUCKET_NUM        = 10  // number of delay counter bucket
)

// key prefix
const (
        KP_PROXY_DELAY                  = "proxy_delay"
        KP_PROXY_POST_DEALY             = "proxy_post_delay"
        KP_PROXY_HANDSHAKE_DELAY        = "proxy_handshake_delay"
        KP_PROXY_HANDSHAKE_FULL_DELAY   = "proxy_handshake_full_delay"
        KP_PROXY_HANDSHAKE_RESUME_DELAY = "proxy_handshake_resume_delay"
        KP_PROXY_STATE                  = "proxy_state"
)

type ServerStatus struct {
        // for proxy protocol
        ProxyProtocolState   *bfe_proxy.ProxyState
        ProxyProtocolMetrics metrics.Metrics

        // for tls protocol
        TlsState   *bfe_tls.TlsState
        TlsMetrics metrics.Metrics

        // for spdy protocol
        SpdyState   *bfe_spdy.SpdyState
        SpdyMetrics metrics.Metrics

        // for http2 protocol
        Http2State   *bfe_http2.Http2State
        Http2Metrics metrics.Metrics

        // for http protocol
        HttpState   *bfe_http.HttpState
        HttpMetrics metrics.Metrics

        // for stream protocol (tls proxy)
        StreamState   *bfe_stream.StreamState
        StreamMetrics metrics.Metrics

        // for websocket protocol (websocket proxy)
        WebSocketState   *bfe_websocket.WebSocketState
        WebSocketMetrics metrics.Metrics

        // for balance
        BalState   *bal.BalErrState
        BalMetrics metrics.Metrics

        // for proxy
        ProxyState   *ProxyState
        ProxyMetrics metrics.Metrics

        // for monitor "internal delay"
        ProxyDelay *delay_counter.DelayRecent

        // for monitor "internal delay" of post/put request
        ProxyPostDelay *delay_counter.DelayRecent

        // for monitor "internal delay" of tls handshake
        ProxyHandshakeDelay       *delay_counter.DelayRecent
        ProxyHandshakeFullDelay   *delay_counter.DelayRecent
        ProxyHandshakeResumeDelay *delay_counter.DelayRecent
}

func NewServerStatus() *ServerStatus <span class="cov0" title="0">{
        m := new(ServerStatus)

        // initialize counter state
        m.ProxyProtocolState = bfe_proxy.GetProxyState()
        m.TlsState = bfe_tls.GetTlsState()
        m.SpdyState = bfe_spdy.GetSpdyState()
        m.Http2State = bfe_http2.GetHttp2State()
        m.HttpState = bfe_http.GetHttpState()
        m.StreamState = bfe_stream.GetStreamState()
        m.WebSocketState = bfe_websocket.GetWebSocketState()
        m.ProxyState = new(ProxyState)
        m.BalState = bal.GetBalErrState()

        // initialize metrics
        m.ProxyProtocolMetrics.Init(m.ProxyProtocolState, KP_PROXY_STATE, 0)
        m.TlsMetrics.Init(m.TlsState, KP_PROXY_STATE, 0)
        m.SpdyMetrics.Init(m.SpdyState, KP_PROXY_STATE, 0)
        m.Http2Metrics.Init(m.Http2State, KP_PROXY_STATE, 0)
        m.HttpMetrics.Init(m.HttpState, KP_PROXY_STATE, 0)
        m.StreamMetrics.Init(m.StreamState, KP_PROXY_STATE, 0)
        m.WebSocketMetrics.Init(m.WebSocketState, KP_PROXY_STATE, 0)
        m.ProxyMetrics.Init(m.ProxyState, KP_PROXY_STATE, 0)
        m.BalMetrics.Init(m.BalState, KP_PROXY_STATE, 0)

        // initialize delay counter
        m.ProxyDelay = new(delay_counter.DelayRecent)
        m.ProxyPostDelay = new(delay_counter.DelayRecent)
        m.ProxyHandshakeDelay = new(delay_counter.DelayRecent)
        m.ProxyHandshakeFullDelay = new(delay_counter.DelayRecent)
        m.ProxyHandshakeResumeDelay = new(delay_counter.DelayRecent)

        m.ProxyDelay.Init(DC_INTERVAL, DC_BUCKET_SIZE_PROXY, DC_BUCKET_NUM)
        m.ProxyPostDelay.Init(DC_INTERVAL, DC_BUCKET_SIZE_PROXY, DC_BUCKET_NUM)
        m.ProxyHandshakeDelay.Init(DC_INTERVAL, DC_BUCKET_SIZE_HS, DC_BUCKET_NUM)
        m.ProxyHandshakeFullDelay.Init(DC_INTERVAL, DC_BUCKET_SIZE_HS, DC_BUCKET_NUM)
        m.ProxyHandshakeResumeDelay.Init(DC_INTERVAL, DC_BUCKET_SIZE_HS, DC_BUCKET_NUM)

        m.ProxyDelay.SetKeyPrefix(KP_PROXY_DELAY)
        m.ProxyPostDelay.SetKeyPrefix(KP_PROXY_POST_DEALY)
        m.ProxyHandshakeDelay.SetKeyPrefix(KP_PROXY_HANDSHAKE_DELAY)
        m.ProxyHandshakeFullDelay.SetKeyPrefix(KP_PROXY_HANDSHAKE_FULL_DELAY)
        m.ProxyHandshakeResumeDelay.SetKeyPrefix(KP_PROXY_HANDSHAKE_RESUME_DELAY)

        return m
}</span>

func (srv *BfeServer) proxyProtocolStateGetAll(params map[string][]string) ([]byte, error) <span class="cov0" title="0">{
        s := srv.serverStatus.ProxyProtocolMetrics.GetAll()
        return s.Format(params)
}</span>

func (srv *BfeServer) proxyProtocolStateGetDiff(params map[string][]string) ([]byte, error) <span class="cov0" title="0">{
        s := srv.serverStatus.ProxyProtocolMetrics.GetDiff()
        return s.Format(params)
}</span>

func (srv *BfeServer) tlsStateGetAll(params map[string][]string) ([]byte, error) <span class="cov0" title="0">{
        s := srv.serverStatus.TlsMetrics.GetAll()
        return s.Format(params)
}</span>

func (srv *BfeServer) tlsStateGetDiff(params map[string][]string) ([]byte, error) <span class="cov0" title="0">{
        s := srv.serverStatus.TlsMetrics.GetDiff()
        return s.Format(params)
}</span>

func (srv *BfeServer) spdyStateGetAll(params map[string][]string) ([]byte, error) <span class="cov0" title="0">{
        s := srv.serverStatus.SpdyMetrics.GetAll()
        return s.Format(params)
}</span>

func (srv *BfeServer) spdyStateGetDiff(params map[string][]string) ([]byte, error) <span class="cov0" title="0">{
        s := srv.serverStatus.SpdyMetrics.GetDiff()
        return s.Format(params)
}</span>

func (srv *BfeServer) http2StateGetAll(params map[string][]string) ([]byte, error) <span class="cov0" title="0">{
        s := srv.serverStatus.Http2Metrics.GetAll()
        return s.Format(params)
}</span>

func (srv *BfeServer) http2StateGetDiff(params map[string][]string) ([]byte, error) <span class="cov0" title="0">{
        s := srv.serverStatus.Http2Metrics.GetDiff()
        return s.Format(params)
}</span>

func (srv *BfeServer) httpStateGetAll(params map[string][]string) ([]byte, error) <span class="cov0" title="0">{
        s := srv.serverStatus.HttpMetrics.GetAll()
        return s.Format(params)
}</span>

func (srv *BfeServer) httpStateGetDiff(params map[string][]string) ([]byte, error) <span class="cov0" title="0">{
        s := srv.serverStatus.HttpMetrics.GetDiff()
        return s.Format(params)
}</span>

func (srv *BfeServer) streamStateGetAll(params map[string][]string) ([]byte, error) <span class="cov0" title="0">{
        s := srv.serverStatus.StreamMetrics.GetAll()
        return s.Format(params)
}</span>

func (srv *BfeServer) streamStateGetDiff(params map[string][]string) ([]byte, error) <span class="cov0" title="0">{
        s := srv.serverStatus.StreamMetrics.GetDiff()
        return s.Format(params)
}</span>

func (srv *BfeServer) websocketStateGetAll(params map[string][]string) ([]byte, error) <span class="cov0" title="0">{
        s := srv.serverStatus.WebSocketMetrics.GetAll()
        return s.Format(params)
}</span>

func (srv *BfeServer) websocketStateGetDiff(params map[string][]string) ([]byte, error) <span class="cov0" title="0">{
        s := srv.serverStatus.WebSocketMetrics.GetDiff()
        return s.Format(params)
}</span>

func (srv *BfeServer) proxyStateGetAll(params map[string][]string) ([]byte, error) <span class="cov0" title="0">{
        s := srv.serverStatus.ProxyMetrics.GetAll()
        return s.Format(params)
}</span>

func (srv *BfeServer) proxyStateGetDiff(params map[string][]string) ([]byte, error) <span class="cov0" title="0">{
        s := srv.serverStatus.ProxyMetrics.GetDiff()
        return s.Format(params)
}</span>

func (srv *BfeServer) balStateGetAll(params map[string][]string) ([]byte, error) <span class="cov0" title="0">{
        s := srv.serverStatus.BalMetrics.GetAll()
        return s.Format(params)
}</span>

func (srv *BfeServer) balStateGetDiff(params map[string][]string) ([]byte, error) <span class="cov0" title="0">{
        s := srv.serverStatus.BalMetrics.GetDiff()
        return s.Format(params)
}</span>

func (srv *BfeServer) proxyDelayGet(params map[string][]string) ([]byte, error) <span class="cov0" title="0">{
        d := srv.serverStatus.ProxyDelay
        return d.FormatOutput(params)
}</span>

func (srv *BfeServer) proxyPostDelayGet(params map[string][]string) ([]byte, error) <span class="cov0" title="0">{
        d := srv.serverStatus.ProxyPostDelay
        return d.FormatOutput(params)
}</span>

func (srv *BfeServer) proxyHandshakeDelayGet(params map[string][]string) ([]byte, error) <span class="cov0" title="0">{
        d := srv.serverStatus.ProxyHandshakeDelay
        return d.FormatOutput(params)
}</span>

func (srv *BfeServer) proxyHandshakeFullDelayGet(params map[string][]string) ([]byte, error) <span class="cov0" title="0">{
        d := srv.serverStatus.ProxyHandshakeFullDelay
        return d.FormatOutput(params)
}</span>

func (srv *BfeServer) proxyHandshakeResumeDelayGet(params map[string][]string) ([]byte, error) <span class="cov0" title="0">{
        d := srv.serverStatus.ProxyHandshakeResumeDelay
        return d.FormatOutput(params)
}</span>

func (srv *BfeServer) ModuleStatusGetJSON() ([]byte, error) <span class="cov0" title="0">{
        return bfe_module.ModuleStatusGetJSON()
}</span>

func (srv *BfeServer) ModuleHandlersGetJSON() ([]byte, error) <span class="cov0" title="0">{
        return srv.CallBacks.ModuleHandlersGetJSON()
}</span>
</pre>
		
		<pre class="file" id="file230" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package bfe_server

import (
        "net"
        "strconv"
        "strings"
)

import (
        "github.com/bfenetworks/bfe/bfe_basic"
)

// setClientAddr set real client addr from headers.
func setClientAddr(req *bfe_basic.Request) <span class="cov0" title="0">{
        // use remote addr
        if !req.Session.TrustSource() </span><span class="cov0" title="0">{ // request not from upstream bfe server
                req.ClientAddr = req.RemoteAddr
                return
        }</span>

        <span class="cov0" title="0">req.ClientAddr = nil
        clientip := req.HttpRequest.Header.Get(bfe_basic.HeaderRealIP)
        clientport := req.HttpRequest.Header.Get(bfe_basic.HeaderRealPort)
        if clientip == "" </span><span class="cov0" title="0">{
                clientip = getFirstSplitFromHeader(req, bfe_basic.HeaderForwardedFor, ",")
                clientport = getFirstSplitFromHeader(req, bfe_basic.HeaderForwardedPort, ",")
        }</span>
        <span class="cov0" title="0">if clientip != "" </span><span class="cov0" title="0">{
                parseClientAddr(req, clientip, clientport)
        }</span>
}

func getFirstSplitFromHeader(req *bfe_basic.Request, header string, sep string) string <span class="cov0" title="0">{
        ret := ""
        if str := req.HttpRequest.Header.Get(header); str != "" </span><span class="cov0" title="0">{
                l := strings.SplitN(str, sep, 2)
                ret = strings.TrimSpace(l[0]) // get first split from header
        }</span>
        <span class="cov0" title="0">return ret</span>
}

func parseClientAddr(req *bfe_basic.Request, clientip string, clientport string) <span class="cov0" title="0">{
        if ip := net.ParseIP(clientip); ip != nil </span><span class="cov0" title="0">{ // valid clientip
                req.ClientAddr = new(net.TCPAddr)
                req.ClientAddr.IP = ip
                if port, err := strconv.Atoi(clientport); err == nil </span><span class="cov0" title="0">{ // valid port
                        req.ClientAddr.Port = port
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file231" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// an implementation of tls.MultiCertificate

package bfe_server

import (
        "fmt"
        "strings"
        "sync"
)

import (
        "github.com/bfenetworks/bfe/bfe_config/bfe_tls_conf/server_cert_conf"
        "github.com/bfenetworks/bfe/bfe_config/bfe_tls_conf/tls_rule_conf"
        "github.com/bfenetworks/bfe/bfe_tls"
)

type MultiCertMap struct {
        vipCertMap  map[string]*bfe_tls.Certificate // vip -&gt; certificate
        nameCertMap *NameCertMap                    // name -&gt; certificate
        defaultCert *bfe_tls.Certificate            // default cert
        lock        sync.RWMutex
        state       *ProxyState // state for MultiCertMap
}

func NewMultiCertMap(state *ProxyState) *MultiCertMap <span class="cov0" title="0">{
        m := new(MultiCertMap)
        m.vipCertMap = make(map[string]*bfe_tls.Certificate)
        m.nameCertMap = NewNameCertMap()
        m.state = state
        return m
}</span>

// Get gets certificate for given connection.
func (m *MultiCertMap) Get(c *bfe_tls.Conn) *bfe_tls.Certificate <span class="cov0" title="0">{
        var cert *bfe_tls.Certificate
        m.state.TlsMultiCertGet.Inc(1)

        m.lock.RLock()
        defer m.lock.RUnlock()

        // choose certificate by vip
        vip := c.GetVip()
        if vip != nil </span><span class="cov0" title="0">{
                key := vip.String()
                cert = m.vipCertMap[key]
                if cert == nil </span><span class="cov0" title="0">{
                        m.state.TlsMultiCertConnVipUnknown.Inc(1)
                }</span>
        } else<span class="cov0" title="0"> {
                m.state.TlsMultiCertConnWithoutVip.Inc(1)
        }</span>

        // if vip for connection is not found unexpectedly, or vip for connection is unknown,
        // try to choose cert by SNI (Server Name Indication)
        <span class="cov0" title="0">if cert == nil </span><span class="cov0" title="0">{
                serverName := c.GetServerName()
                if len(serverName) &gt; 0 </span><span class="cov0" title="0">{
                        cert = m.nameCertMap.Get(serverName)
                }</span> else<span class="cov0" title="0"> {
                        m.state.TlsMultiCertConnWithoutSni.Inc(1)
                }</span>
        }

        // choose default cert
        <span class="cov0" title="0">if cert == nil </span><span class="cov0" title="0">{
                cert = m.defaultCert
                m.state.TlsMultiCertUseDefault.Inc(1)
        }</span>

        <span class="cov0" title="0">return cert</span>
}

func (m *MultiCertMap) GetDefault() *bfe_tls.Certificate <span class="cov0" title="0">{
        m.lock.RLock()
        defer m.lock.RUnlock()

        if m.defaultCert == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return m.defaultCert</span>
}

// Update updates all certificates.
func (m *MultiCertMap) Update(certConf map[string]*bfe_tls.Certificate,
        ruleMap tls_rule_conf.TlsRuleMap) error <span class="cov0" title="0">{
        m.state.TlsMultiCertUpdate.Inc(1)

        vipCertMap := make(map[string]*bfe_tls.Certificate)
        for _, ruleConf := range ruleMap </span><span class="cov0" title="0">{
                cert, ok := certConf[ruleConf.CertName]
                if !ok </span><span class="cov0" title="0">{
                        m.state.TlsMultiCertUpdateErr.Inc(1)
                        return fmt.Errorf("certificate %s not exist", ruleConf.CertName)
                }</span>
                <span class="cov0" title="0">for _, vip := range ruleConf.VipConf </span><span class="cov0" title="0">{
                        vipCertMap[vip] = cert
                }</span>
        }

        <span class="cov0" title="0">nameCertMap := NewNameCertMap()
        nameCertMap.Update(certConf)

        defaultCert := certConf[server_cert_conf.DefaultCert]
        if defaultCert == nil </span><span class="cov0" title="0">{
                m.state.TlsMultiCertUpdateErr.Inc(1)
                return fmt.Errorf("default certificate not exist")
        }</span>

        <span class="cov0" title="0">m.lock.Lock()
        m.vipCertMap = vipCertMap
        m.nameCertMap = nameCertMap
        m.defaultCert = defaultCert
        m.lock.Unlock()

        return nil</span>
}

type NameCertMap struct {
        normalCertMap   map[string]*bfe_tls.Certificate // cert map for normal name
        wildcardCertMap map[string]*bfe_tls.Certificate // cert map for wildcard name
}

func NewNameCertMap() *NameCertMap <span class="cov0" title="0">{
        m := new(NameCertMap)
        m.normalCertMap = make(map[string]*bfe_tls.Certificate)
        m.wildcardCertMap = make(map[string]*bfe_tls.Certificate)
        return m
}</span>

func (m *NameCertMap) Get(serverName string) *bfe_tls.Certificate <span class="cov0" title="0">{
        serverName = strings.ToLower(serverName)
        for len(serverName) &gt; 0 &amp;&amp; serverName[len(serverName)-1] == '.' </span><span class="cov0" title="0">{
                serverName = serverName[:len(serverName)-1]
        }</span>

        <span class="cov0" title="0">if cert, ok := m.normalCertMap[serverName]; ok </span><span class="cov0" title="0">{
                return cert
        }</span>

        // Note: Since number of wildcard names is too small,
        // just perform sequent matching here
        <span class="cov0" title="0">for name, cert := range m.wildcardCertMap </span><span class="cov0" title="0">{
                if tls_rule_conf.MatchHostnames(name, serverName) </span><span class="cov0" title="0">{
                        return cert
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (m *NameCertMap) Update(certConf map[string]*bfe_tls.Certificate) <span class="cov0" title="0">{
        normalCertMap := make(map[string]*bfe_tls.Certificate)
        wildcardCertMap := make(map[string]*bfe_tls.Certificate)

        for _, cert := range certConf </span><span class="cov0" title="0">{
                names := server_cert_conf.GetNamesForCert(cert)
                for _, name := range names </span><span class="cov0" title="0">{
                        if strings.Contains(name, "*") </span><span class="cov0" title="0">{
                                wildcardCertMap[name] = cert
                        }</span> else<span class="cov0" title="0"> {
                                normalCertMap[name] = cert
                        }</span>
                }
        }
        <span class="cov0" title="0">m.normalCertMap = normalCertMap
        m.wildcardCertMap = wildcardCertMap</span>
}
</pre>
		
		<pre class="file" id="file232" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// server rule for tls

package bfe_server

import (
        "crypto/x509"
        "net"
        "strings"
        "sync"
)

import (
        "github.com/baidu/go-lib/log"
        "github.com/spaolacci/murmur3"
)

import (
        "github.com/bfenetworks/bfe/bfe_config/bfe_tls_conf/tls_rule_conf"
        "github.com/bfenetworks/bfe/bfe_http2"
        "github.com/bfenetworks/bfe/bfe_stream"
        "github.com/bfenetworks/bfe/bfe_tls"
)

var (
        DefaultNextProtos = []string{tls_rule_conf.HTTP11}
)

type ServerRule struct {
        TlsRule    bfe_tls.Rule    // server rule for tls
        H2Rule     bfe_http2.Rule  // server rule for h2
        StreamRule bfe_stream.Rule // server rule for stream
}

type TLSServerRuleMap struct {
        lock       sync.RWMutex
        vipRuleMap map[string]*ServerRule // tls server rule for specified conn
        sniRuleMap map[string]*ServerRule // tls server rule for specified host (optional)

        nextProtosDef *NextProtosConf // default next protos conf
        enableHttp2   bool            // enable http2 globally or not
        enableSpdy    bool            // enable spdy globally or not
        chacha20Def   bool            // default chacha20 conf
        dynRecordDef  bool            // default dynamic record conf

        versions Version // version of tls_rule_conf

        state *ProxyState
}

type Version struct {
        TlsRuleConfVersion string
}

func NewTLSServerRuleMap(state *ProxyState) *TLSServerRuleMap <span class="cov0" title="0">{
        m := new(TLSServerRuleMap)
        m.vipRuleMap = make(map[string]*ServerRule)
        m.sniRuleMap = make(map[string]*ServerRule)
        m.enableHttp2 = true
        m.enableSpdy = true
        m.state = state
        return m
}</span>

// Get returns tls rule for given connection.
func (m *TLSServerRuleMap) Get(c *bfe_tls.Conn) *bfe_tls.Rule <span class="cov0" title="0">{
        r := m.getRule(c)
        return &amp;r.TlsRule
}</span>

// GetHTTP2Rule returns h2 rule for given connection.
func (m *TLSServerRuleMap) GetHTTP2Rule(c *bfe_tls.Conn) *bfe_http2.Rule <span class="cov0" title="0">{
        r := m.getRule(c)
        return &amp;r.H2Rule
}</span>

// GetStreamRule returns stream rule for given connection.
func (m *TLSServerRuleMap) GetStreamRule(c *bfe_tls.Conn) *bfe_stream.Rule <span class="cov0" title="0">{
        r := m.getRule(c)
        return &amp;r.StreamRule
}</span>

func (m *TLSServerRuleMap) getRule(c *bfe_tls.Conn) *ServerRule <span class="cov0" title="0">{
        m.lock.RLock()
        defer m.lock.RUnlock()

        // get tls rule conf by vip
        if rule := m.getRuleByVip(c); rule != nil </span><span class="cov0" title="0">{
                return rule
        }</span>

        // get tls rule conf by sni (supported by modern browser)
        <span class="cov0" title="0">if rule := m.getRuleBySni(c); rule != nil </span><span class="cov0" title="0">{
                return rule
        }</span>

        // get default rule
        <span class="cov0" title="0">return m.getDefaultRule(c)</span>
}

func (m *TLSServerRuleMap) getRuleByVip(c *bfe_tls.Conn) *ServerRule <span class="cov0" title="0">{
        vip := c.GetVip()
        if vip == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">key := vip.String()
        return m.vipRuleMap[key]</span>
}

func (m *TLSServerRuleMap) getRuleBySni(c *bfe_tls.Conn) *ServerRule <span class="cov0" title="0">{
        name := c.GetServerName()
        return m.sniRuleMap[name]
}</span>

func (m *TLSServerRuleMap) getDefaultRule(c *bfe_tls.Conn) *ServerRule <span class="cov0" title="0">{
        rule := new(ServerRule)

        rule.TlsRule.NextProtos = m.nextProtosDef
        rule.TlsRule.Grade = bfe_tls.GradeC
        rule.TlsRule.ClientAuth = false
        rule.TlsRule.Chacha20 = m.chacha20Def
        rule.TlsRule.DynamicRecord = m.dynRecordDef

        rule.H2Rule.MaxConcurrentStreams = 0
        rule.H2Rule.MaxUploadBufferPerStream = 0
        rule.H2Rule.DisableDegrade = false

        rule.StreamRule.ProxyProtocol = 0

        return rule
}</span>

func (m *TLSServerRuleMap) Update(conf tls_rule_conf.BfeTlsRuleConf,
        clientCAMap map[string]*x509.CertPool, clientCRLPoolMap map[string]*bfe_tls.CRLPool) <span class="cov0" title="0">{
        vipRuleMap := make(map[string]*ServerRule)
        sniRuleMap := make(map[string]*ServerRule)

        for _, ruleConf := range conf.Config </span><span class="cov0" title="0">{
                clientCAs := clientCAMap[ruleConf.ClientCAName]
                clientCRLPool := clientCRLPoolMap[ruleConf.ClientCAName]
                rule := m.createServerRule(ruleConf, clientCAs, clientCRLPool, conf.DefaultNextProtos)
                for _, vip := range ruleConf.VipConf </span><span class="cov0" title="0">{
                        vipRuleMap[vip] = rule
                }</span>
                <span class="cov0" title="0">for _, name := range ruleConf.SniConf </span><span class="cov0" title="0">{
                        sniRuleMap[name] = rule
                }</span>
        }

        <span class="cov0" title="0">defaultNextProtos := DefaultNextProtos
        if len(conf.DefaultNextProtos) != 0 </span><span class="cov0" title="0">{
                defaultNextProtos = conf.DefaultNextProtos
        }</span>
        <span class="cov0" title="0">nextProtosDef := NewNextProtosConf(m, defaultNextProtos)

        versions := Version{
                TlsRuleConfVersion: conf.Version,
        }

        m.lock.Lock()
        m.vipRuleMap = vipRuleMap
        m.sniRuleMap = sniRuleMap
        m.nextProtosDef = nextProtosDef
        m.chacha20Def = conf.DefaultChacha20
        m.dynRecordDef = conf.DefaultDynamicRecord
        m.versions = versions
        m.lock.Unlock()</span>
}

func (m *TLSServerRuleMap) createServerRule(conf *tls_rule_conf.TlsRuleConf,
        clientCAs *x509.CertPool, clientCRLPool *bfe_tls.CRLPool, defaultNextProtos []string) *ServerRule <span class="cov0" title="0">{
        r := new(ServerRule)

        // tls next protos
        if len(conf.NextProtos) != 0 </span><span class="cov0" title="0">{
                r.TlsRule.NextProtos = NewNextProtosConf(m, conf.NextProtos)
        }</span> else<span class="cov0" title="0"> {
                r.TlsRule.NextProtos = NewNextProtosConf(m, defaultNextProtos)
        }</span>

        // tls security grade
        <span class="cov0" title="0">if conf.Grade != "" </span><span class="cov0" title="0">{
                r.TlsRule.Grade = conf.Grade
        }</span> else<span class="cov0" title="0"> {
                r.TlsRule.Grade = bfe_tls.GradeC
        }</span>

        // tls client auth policy
        <span class="cov0" title="0">r.TlsRule.ClientAuth = conf.ClientAuth
        r.TlsRule.ClientCAs = clientCAs
        r.TlsRule.ClientCAName = conf.ClientCAName
        r.TlsRule.ClientCRLPool = clientCRLPool

        // enable chacha20-poly1305 cipher suites
        r.TlsRule.Chacha20 = conf.Chacha20

        // enable dynamic tls record
        r.TlsRule.DynamicRecord = conf.DynamicRecord

        // h2/stream related settings
        for _, protoConf := range conf.NextProtos </span><span class="cov0" title="0">{
                proto, params, _ := tls_rule_conf.ParseNextProto(protoConf)
                switch proto </span>{
                case tls_rule_conf.HTTP2:<span class="cov0" title="0">
                        r.H2Rule.MaxConcurrentStreams = uint32(params.Mcs)
                        r.H2Rule.MaxUploadBufferPerStream = uint32(params.Isw)
                        r.H2Rule.DisableDegrade = (params.Level &gt; tls_rule_conf.PROTO_OPTIONAL)</span>
                case tls_rule_conf.STREAM:<span class="cov0" title="0">
                        r.StreamRule.ProxyProtocol = params.PP</span>
                }
        }

        <span class="cov0" title="0">return r</span>
}

func (m *TLSServerRuleMap) EnableNextProto(proto string, state bool) <span class="cov0" title="0">{
        m.lock.Lock()
        defer m.lock.Unlock()

        if proto == "h2" </span><span class="cov0" title="0">{
                m.enableHttp2 = state
        }</span> else<span class="cov0" title="0"> if strings.HasPrefix(proto, "spdy") </span><span class="cov0" title="0">{
                m.enableSpdy = state
        }</span>
        <span class="cov0" title="0">log.Logger.Info("TLSServerRuleMap: enable %s %v", proto, state)</span>
}

func (m *TLSServerRuleMap) StatusNextProto() (enableHttp2 bool, enableSpdy bool) <span class="cov0" title="0">{
        m.lock.RLock()
        enableHttp2, enableSpdy = m.enableHttp2, m.enableSpdy
        m.lock.RUnlock()

        return enableHttp2, enableSpdy
}</span>

type NextProtosConf struct {
        serverRule *TLSServerRuleMap // link back to TLSServerRuleMap
        protos     []string          // application level protocol over tls
        level      []int             // negatiation level for each protocol
        mcs        []int             // max concurrency per conn for each protocol
        rate       []int             // presence rate for each protocol
        pp         []int             // PROXY protocol option for connections to backend
}

func NewNextProtosConf(rule *TLSServerRuleMap, protoConf []string) *NextProtosConf <span class="cov0" title="0">{
        c := new(NextProtosConf)
        c.serverRule = rule
        c.protos = make([]string, len(protoConf))
        c.level = make([]int, len(protoConf))
        c.mcs = make([]int, len(protoConf))
        c.rate = make([]int, len(protoConf))
        c.pp = make([]int, len(protoConf))

        for i, protoString := range protoConf </span><span class="cov0" title="0">{
                proto, params, _ := tls_rule_conf.ParseNextProto(protoString)
                c.protos[i] = proto
                c.level[i] = params.Level
                c.mcs[i] = params.Mcs
                c.rate[i] = params.Rate
                c.pp[i] = params.PP
        }</span>
        <span class="cov0" title="0">return c</span>
}

func (c *NextProtosConf) Get(conn *bfe_tls.Conn) []string <span class="cov0" title="0">{
        r := c.serverRule

        // check if h2/spdy should be enabled
        enableHttp2, enableSpdy := r.StatusNextProto()

        // select next protos for current conn
        protos := make([]string, 0, len(c.protos))
        value := getHashValue(conn)

        for i, proto := range c.protos </span><span class="cov0" title="0">{
                // ignore optional protocol if needed
                if c.level[i] == tls_rule_conf.PROTO_OPTIONAL </span><span class="cov0" title="0">{
                        if value &gt;= c.rate[i] </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">if !enableHttp2 &amp;&amp; strings.HasPrefix(proto, "h2") </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">if !enableSpdy &amp;&amp; strings.HasPrefix(proto, "spdy") </span><span class="cov0" title="0">{
                                continue</span>
                        }
                }
                <span class="cov0" title="0">protos = append(protos, proto)</span>
        }

        <span class="cov0" title="0">if len(protos) == 0 </span><span class="cov0" title="0">{
                return DefaultNextProtos
        }</span>

        <span class="cov0" title="0">return protos</span>
}

func (c *NextProtosConf) Mandatory(conn *bfe_tls.Conn) (string, bool) <span class="cov0" title="0">{
        if len(c.protos) != 1 </span><span class="cov0" title="0">{
                return "", false
        }</span>
        <span class="cov0" title="0">if c.level[0] != tls_rule_conf.PROTO_MANDATORY </span><span class="cov0" title="0">{
                return "", false
        }</span>
        <span class="cov0" title="0">return c.protos[0], true</span>
}

func getHashValue(conn *bfe_tls.Conn) int <span class="cov0" title="0">{
        remoteAddr := conn.RemoteAddr().(*net.TCPAddr)
        return int(murmur3.Sum32(remoteAddr.IP) % 100)
}</span>
</pre>
		
		<pre class="file" id="file233" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// an implementation of tls.ServerSessionCache

package bfe_server

import (
        "fmt"
        "math/rand"
        "reflect"
        "sync"
        "time"
)

import (
        "github.com/baidu/go-lib/log"
        "github.com/gomodule/redigo/redis"
)

import (
        "github.com/bfenetworks/bfe/bfe_config/bfe_conf"
        "github.com/bfenetworks/bfe/bfe_util/bns"
)

type ServerSessionCache struct {
        Servers     []string     // tcp address for redis servers
        serversLock sync.RWMutex // lock for servers
        bnsClient   *bns.Client  // name client

        ConnectTimeout time.Duration // connect timeout (ms)
        ReadTimeout    time.Duration // read timeout (ms)
        WriteTimeout   time.Duration // write timeout (ms)
        KeyPrefix      string        // prefix for cache key

        SessionExpire int          // expire time for tls session state (s)
        MaxIdle       int          // max idle connections in pool
        pool          *redis.Pool  // connection pool to redis server
        poolLock      sync.RWMutex // lock for pool

        state *ProxyState // state for session cache
}

func NewServerSessionCache(conf bfe_conf.ConfigSessionCache, state *ProxyState) (
        c *ServerSessionCache) <span class="cov0" title="0">{
        var err error
        c = new(ServerSessionCache)

        // get address list of redis servers
        c.bnsClient = bns.NewClient()
        if c.Servers, err = c.bnsClient.GetInstancesAddr(conf.Servers); err != nil </span><span class="cov0" title="0">{
                log.Logger.Warn("ServerSessionCache: get instance for %s error (%s)", conf.Servers, err)
                c.Servers = make([]string, 0)
        }</span>

        <span class="cov0" title="0">c.ConnectTimeout = time.Duration(conf.ConnectTimeout) * time.Millisecond
        c.ReadTimeout = time.Duration(conf.ReadTimeout) * time.Millisecond
        c.WriteTimeout = time.Duration(conf.WriteTimeout) * time.Millisecond
        c.KeyPrefix = conf.KeyPrefix

        c.SessionExpire = conf.SessionExpire
        c.MaxIdle = conf.MaxIdle
        c.pool = &amp;redis.Pool{
                MaxIdle: c.MaxIdle,
                Dial:    c.dial,
        }

        c.state = state
        go c.checkServerInstance(conf.Servers)

        return c</span>
}

func (c *ServerSessionCache) dial() (redis.Conn, error) <span class="cov0" title="0">{
        c.state.SessionCacheConn.Inc(1)

        // choose a random server
        c.serversLock.RLock()
        if len(c.Servers) == 0 </span><span class="cov0" title="0">{
                c.serversLock.RUnlock()
                return nil, fmt.Errorf("no available connection in pool")
        }</span>
        <span class="cov0" title="0">server := c.Servers[rand.Intn(len(c.Servers))]
        c.serversLock.RUnlock()

        // create connection to server
        conn, err := redis.Dial("tcp", server,
                redis.DialConnectTimeout(c.ConnectTimeout),
                redis.DialReadTimeout(c.ReadTimeout),
                redis.DialWriteTimeout(c.WriteTimeout))
        if err != nil </span><span class="cov0" title="0">{
                log.Logger.Debug("ServerSessionCache:dail() to %s err(%v)", server, err)
                c.state.SessionCacheConnFail.Inc(1)
                return nil, err
        }</span>
        <span class="cov0" title="0">return conn, err</span>
}

// Put saves sessionState to session cache.
func (c *ServerSessionCache) Put(sessionKey string, sessionState []byte) (err error) <span class="cov0" title="0">{
        c.state.SessionCacheSet.Inc(1)
        sessionKey = fmt.Sprintf("%s:%s", c.KeyPrefix, sessionKey)

        c.poolLock.RLock()
        pool := c.pool
        c.poolLock.RUnlock()

        // get connection from pool
        conn := pool.Get()
        defer conn.Close()

        // save session state to redis
        conn.Send("SET", sessionKey, sessionState)
        conn.Send("EXPIRE", sessionKey, c.SessionExpire)
        conn.Flush()
        if _, err = conn.Receive(); err != nil </span><span class="cov0" title="0">{
                log.Logger.Debug("ServerSessionCache:put() sessionState %v", err)
                c.state.SessionCacheSetFail.Inc(1)
                return err
        }</span>
        <span class="cov0" title="0">if _, err = conn.Receive(); err != nil </span><span class="cov0" title="0">{
                log.Logger.Debug("ServerSessionCache:put() sessionState %v", err)
                c.state.SessionCacheSetFail.Inc(1)
                return err
        }</span>

        <span class="cov0" title="0">log.Logger.Debug("ServerSessionCache:put() sessionState success (%s: %x)",
                sessionKey, sessionState)
        return nil</span>
}

// Get gets sessionState from session cache.
func (c *ServerSessionCache) Get(sessionKey string) ([]byte, bool) <span class="cov0" title="0">{
        c.state.SessionCacheGet.Inc(1)
        sessionKey = fmt.Sprintf("%s:%s", c.KeyPrefix, sessionKey)

        c.poolLock.RLock()
        pool := c.pool
        c.poolLock.RUnlock()

        // get connection from pool
        conn := pool.Get()
        defer conn.Close()

        // get session state from redis
        sessionParam, err := conn.Do("GET", sessionKey)
        if err != nil </span><span class="cov0" title="0">{
                log.Logger.Debug("ServerSessionCache:get() sessionState %v", err)
                if err != redis.ErrNil </span><span class="cov0" title="0">{
                        c.state.SessionCacheGetFail.Inc(1)
                }</span> else<span class="cov0" title="0"> {
                        c.state.SessionCacheMiss.Inc(1)
                }</span>
                <span class="cov0" title="0">return nil, false</span>
        }

        <span class="cov0" title="0">sessionState, ok := sessionParam.([]byte)
        if !ok </span><span class="cov0" title="0">{
                c.state.SessionCacheTypeNotBytes.Inc(1)
                log.Logger.Debug("ServerSessionCache:get() sessionState type not []byte(%s: %T)",
                        sessionKey, sessionParam)
                return nil, false
        }</span>

        <span class="cov0" title="0">log.Logger.Debug("ServerSessionCache:get() sessionState success (%s: %x)",
                sessionKey, sessionState)
        c.state.SessionCacheHit.Inc(1)
        return sessionState, true</span>
}

func (c *ServerSessionCache) UpdateServers(servers []string) <span class="cov0" title="0">{
        c.serversLock.Lock()
        c.Servers = servers
        c.serversLock.Unlock()
}</span>

func (c *ServerSessionCache) UpdatePool(pool *redis.Pool) *redis.Pool <span class="cov0" title="0">{
        c.poolLock.Lock()
        oldPool := c.pool
        c.pool = pool
        c.poolLock.Unlock()

        return oldPool
}</span>

func (c *ServerSessionCache) checkServerInstance(name string) <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                time.Sleep(10 * time.Second)

                // check addresses of redis servers
                servers, err := c.bnsClient.GetInstancesAddr(name)
                if err != nil </span><span class="cov0" title="0">{
                        log.Logger.Warn("ServerSessionCache: get instance address %s", err.Error())
                        continue</span>
                }
                <span class="cov0" title="0">if len(servers) == 0 </span><span class="cov0" title="0">{
                        log.Logger.Warn("ServerSessionCache: no address configured for %v", name)
                        c.state.SessionCacheNoInstance.Inc(1)
                        continue</span>
                }
                <span class="cov0" title="0">if reflect.DeepEqual(servers, c.Servers) </span><span class="cov0" title="0">{
                        continue</span>
                }

                // update addresses of redis servers
                <span class="cov0" title="0">log.Logger.Debug("ServerSessionCache: update instances %s", servers)
                c.UpdateServers(servers)

                // update connection pool
                pool := &amp;redis.Pool{
                        MaxIdle: c.MaxIdle,
                        Dial:    c.dial,
                }
                oldPool := c.UpdatePool(pool)
                oldPool.Close()</span>
        }
}
</pre>
		
		<pre class="file" id="file234" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// embedded web server in bfe

package bfe_server

import (
        "github.com/baidu/go-lib/log"
        "github.com/baidu/go-lib/web-monitor/web_monitor"
)

type BfeMonitor struct {
        WebServer   *web_monitor.MonitorServer
        WebHandlers *web_monitor.WebHandlers
        srv         *BfeServer
}

func newBfeMonitor(srv *BfeServer, monitorPort int) (*BfeMonitor, error) <span class="cov0" title="0">{
        m := &amp;BfeMonitor{nil, nil, srv}

        // initialize web handlers
        m.WebHandlers = web_monitor.NewWebHandlers()
        if err := m.WebHandlersInit(m.srv); err != nil </span><span class="cov0" title="0">{
                log.Logger.Error("newBfeMonitor(): in WebHandlersInit(): ", err.Error())
                return nil, err
        }</span>

        // initialize web server
        <span class="cov0" title="0">m.WebServer = web_monitor.NewMonitorServer("bfe", srv.Version, monitorPort)
        m.WebServer.HandlersSet(m.WebHandlers)

        return m, nil</span>
}

// monitorHandlers holds all monitor handlers.
func (m *BfeMonitor) monitorHandlers() map[string]interface{} <span class="cov0" title="0">{
        handlers := map[string]interface{}{
                // for host-table
                "host_table_status":  m.srv.HostTableStatusGet,
                "host_table_version": m.srv.HostTableVersionGet,

                // for cluster-table: only contain cluster_conf version
                "cluster_table_version": m.srv.ClusterTableVersionGet,

                // for bal-table
                "bal_table_status":  m.srv.BalTableStatusGet,
                "bal_table_version": m.srv.BalTableVersionGet,

                // for proxy_state
                "proxy_state":      m.srv.proxyStateGetAll,
                "proxy_state_diff": m.srv.proxyStateGetDiff,

                // for balance
                "bal_state":      m.srv.balStateGetAll,
                "bal_state_diff": m.srv.balStateGetDiff,

                // for proxy protocol
                "proxy_protocol_state":      m.srv.proxyProtocolStateGetAll,
                "proxy_protocol_state_diff": m.srv.proxyProtocolStateGetDiff,

                // for tls
                "tls_state":      m.srv.tlsStateGetAll,
                "tls_state_diff": m.srv.tlsStateGetDiff,

                // for spdy
                "spdy_state":      m.srv.spdyStateGetAll,
                "spdy_state_diff": m.srv.spdyStateGetDiff,

                // for http2
                "http2_state":      m.srv.http2StateGetAll,
                "http2_state_diff": m.srv.http2StateGetDiff,

                // for http
                "http_state":      m.srv.httpStateGetAll,
                "http_state_diff": m.srv.httpStateGetDiff,

                // for stream
                "stream_state":      m.srv.streamStateGetAll,
                "stream_state_diff": m.srv.streamStateGetDiff,

                // for websocket
                "websocket_state":      m.srv.websocketStateGetAll,
                "websocket_state_diff": m.srv.websocketStateGetDiff,

                // for proxy delay
                "proxy_delay":      m.srv.proxyDelayGet,
                "proxy_post_delay": m.srv.proxyPostDelayGet,

                // for handshake dely
                "proxy_handshake_delay":        m.srv.proxyHandshakeDelayGet,
                "proxy_handshake_full_delay":   m.srv.proxyHandshakeFullDelayGet,
                "proxy_handshake_resume_delay": m.srv.proxyHandshakeResumeDelayGet,

                // for module status
                "module_status":   m.srv.ModuleStatusGetJSON,
                "module_handlers": m.srv.ModuleHandlersGetJSON,

                // for proxy memory stat
                "proxy_mem_stat": web_monitor.CreateMemStatsHandler("proxy_mem_stat"),
        }
        return handlers
}</span>

// reloadHandlers holds all reload handlers.
func (m *BfeMonitor) reloadHandlers() map[string]interface{} <span class="cov0" title="0">{
        handlers := map[string]interface{}{
                // for server data conf
                "server_data_conf": m.srv.ServerDataConfReload,

                // for gslb data conf
                "gslb_data_conf": m.srv.GslbDataConfReload,

                // for name conf
                "name_conf": m.srv.NameConfReload,

                // for tls
                "tls_conf":               m.srv.TLSConfReload,
                "tls_session_ticket_key": m.srv.SessionTicketKeyReload,
        }
        return handlers
}</span>

func (m *BfeMonitor) WebHandlersInit(srv *BfeServer) error <span class="cov0" title="0">{
        // register handlers for monitor
        err := web_monitor.RegisterHandlers(m.WebHandlers, web_monitor.WebHandleMonitor,
                m.monitorHandlers())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // register handlers for for reload
        <span class="cov0" title="0">err = web_monitor.RegisterHandlers(m.WebHandlers, web_monitor.WebHandleReload,
                m.reloadHandlers())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (m *BfeMonitor) Start() <span class="cov0" title="0">{
        go m.WebServer.Start()
}</span>
</pre>
		
		<pre class="file" id="file235" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Copyright 2014 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Flow control

package bfe_spdy

import (
        "fmt"
)

// flow is the flow control window's size.
type flow struct {
        // n is the number of DATA bytes we're allowed to send.
        // A flow is kept both on a conn and a per-stream.
        n int32

        // conn points to the shared connection-level flow that is
        // shared by all streams on that conn. It is nil for the flow
        // that's on the conn directly.
        conn *flow
}

func (f *flow) setConnFlow(cf *flow) <span class="cov8" title="1">{ f.conn = cf }</span>

func (f *flow) available() int32 <span class="cov8" title="1">{
        n := f.n
        if f.conn != nil &amp;&amp; f.conn.n &lt; n </span><span class="cov8" title="1">{
                n = f.conn.n
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (f *flow) take(n int32) <span class="cov8" title="1">{
        if n &gt; f.available() </span><span class="cov0" title="0">{
                panic("internal error: took too much")</span>
        }
        <span class="cov8" title="1">f.n -= n
        if f.conn != nil </span><span class="cov8" title="1">{
                f.conn.n -= n
        }</span>
}

// add adds n bytes (positive or negative) to the flow control window.
// It returns false if the sum would exceed 2^31-1.
func (f *flow) add(n int32) bool <span class="cov8" title="1">{
        remain := (1&lt;&lt;31 - 1) - f.n
        if n &gt; remain </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">f.n += n
        return true</span>
}

func (f *flow) String() string <span class="cov0" title="0">{
        if f.conn != nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("flow(stream:%d, conn:%d)", f.n, f.conn.n)
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("flow(conn:%d)", f.n)</span>
}
</pre>
		
		<pre class="file" id="file236" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Copyright 2011 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package bfe_spdy

import (
        "compress/zlib"
        "encoding/binary"
        "fmt"
        "io"
        "strings"
)

import (
        http "github.com/bfenetworks/bfe/bfe_http"
)

func (frame *SynStreamFrame) read(h ControlFrameHeader, f *Framer) error <span class="cov8" title="1">{
        return f.readSynStreamFrame(h, frame)
}</span>

func (frame *SynReplyFrame) read(h ControlFrameHeader, f *Framer) error <span class="cov8" title="1">{
        return f.readSynReplyFrame(h, frame)
}</span>

func (frame *RstStreamFrame) read(h ControlFrameHeader, f *Framer) error <span class="cov8" title="1">{
        frame.CFHeader = h
        if err := binary.Read(f.r, binary.BigEndian, &amp;frame.StreamId); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">frame.StreamId = frame.StreamId &amp; 0x7fffffff
        if err := binary.Read(f.r, binary.BigEndian, &amp;frame.Status); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if frame.Status == 0 </span><span class="cov0" title="0">{
                return &amp;Error{InvalidControlFrame, frame.StreamId}
        }</span>
        <span class="cov8" title="1">if frame.StreamId == 0 </span><span class="cov0" title="0">{
                return &amp;Error{ZeroStreamId, 0}
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (frame *SettingsFrame) read(h ControlFrameHeader, f *Framer) error <span class="cov8" title="1">{
        frame.CFHeader = h
        var numSettings uint32
        if err := binary.Read(f.r, binary.BigEndian, &amp;numSettings); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if numSettings &gt; MaxNumSettings </span><span class="cov0" title="0">{
                return fmt.Errorf("SettingsFrame with invalid numSettings: %d", numSettings)
        }</span>

        <span class="cov8" title="1">frame.FlagIdValues = make([]SettingsFlagIdValue, numSettings)
        for i := uint32(0); i &lt; numSettings; i++ </span><span class="cov8" title="1">{
                if err := binary.Read(f.r, binary.BigEndian, &amp;frame.FlagIdValues[i].Id); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">frame.FlagIdValues[i].Flag = SettingsFlag((frame.FlagIdValues[i].Id &amp; 0xff000000) &gt;&gt; 24)
                frame.FlagIdValues[i].Id &amp;= 0xffffff
                if err := binary.Read(f.r, binary.BigEndian, &amp;frame.FlagIdValues[i].Value); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (frame *PingFrame) read(h ControlFrameHeader, f *Framer) error <span class="cov8" title="1">{
        frame.CFHeader = h
        if err := binary.Read(f.r, binary.BigEndian, &amp;frame.Id); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if frame.Id == 0 </span><span class="cov0" title="0">{
                return &amp;Error{ZeroStreamId, 0}
        }</span>
        <span class="cov8" title="1">if frame.CFHeader.Flags != 0 </span><span class="cov0" title="0">{
                return &amp;Error{InvalidControlFrame, StreamId(frame.Id)}
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (frame *GoAwayFrame) read(h ControlFrameHeader, f *Framer) error <span class="cov8" title="1">{
        frame.CFHeader = h
        if err := binary.Read(f.r, binary.BigEndian, &amp;frame.LastGoodStreamId); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">frame.LastGoodStreamId = frame.LastGoodStreamId &amp; 0x7fffffff
        if frame.CFHeader.Flags != 0 </span><span class="cov0" title="0">{
                return &amp;Error{InvalidControlFrame, frame.LastGoodStreamId}
        }</span>
        <span class="cov8" title="1">if frame.CFHeader.length != 8 </span><span class="cov0" title="0">{
                return &amp;Error{InvalidControlFrame, frame.LastGoodStreamId}
        }</span>
        <span class="cov8" title="1">if err := binary.Read(f.r, binary.BigEndian, &amp;frame.Status); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (frame *HeadersFrame) read(h ControlFrameHeader, f *Framer) error <span class="cov8" title="1">{
        return f.readHeadersFrame(h, frame)
}</span>

func (frame *WindowUpdateFrame) read(h ControlFrameHeader, f *Framer) error <span class="cov8" title="1">{
        frame.CFHeader = h
        if err := binary.Read(f.r, binary.BigEndian, &amp;frame.StreamId); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">frame.StreamId = frame.StreamId &amp; 0x7fffffff
        if frame.CFHeader.Flags != 0 </span><span class="cov0" title="0">{
                return &amp;Error{InvalidControlFrame, frame.StreamId}
        }</span>
        <span class="cov8" title="1">if frame.CFHeader.length != 8 </span><span class="cov0" title="0">{
                return &amp;Error{InvalidControlFrame, frame.StreamId}
        }</span>
        <span class="cov8" title="1">if err := binary.Read(f.r, binary.BigEndian, &amp;frame.DeltaWindowSize); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">frame.DeltaWindowSize = frame.DeltaWindowSize &amp; 0x7fffffff
        return nil</span>
}

func newControlFrame(frameType ControlFrameType) (controlFrame, error) <span class="cov8" title="1">{
        ctor, ok := cframeCtor[frameType]
        if !ok </span><span class="cov0" title="0">{
                return nil, &amp;Error{Err: InvalidControlFrame}
        }</span>
        <span class="cov8" title="1">return ctor(), nil</span>
}

var cframeCtor = map[ControlFrameType]func() controlFrame{
        TypeSynStream:    func() controlFrame <span class="cov8" title="1">{ return new(SynStreamFrame) }</span>,
        TypeSynReply:     func() controlFrame <span class="cov8" title="1">{ return new(SynReplyFrame) }</span>,
        TypeRstStream:    func() controlFrame <span class="cov8" title="1">{ return new(RstStreamFrame) }</span>,
        TypeSettings:     func() controlFrame <span class="cov8" title="1">{ return new(SettingsFrame) }</span>,
        TypePing:         func() controlFrame <span class="cov8" title="1">{ return new(PingFrame) }</span>,
        TypeGoAway:       func() controlFrame <span class="cov8" title="1">{ return new(GoAwayFrame) }</span>,
        TypeHeaders:      func() controlFrame <span class="cov8" title="1">{ return new(HeadersFrame) }</span>,
        TypeWindowUpdate: func() controlFrame <span class="cov8" title="1">{ return new(WindowUpdateFrame) }</span>,
}

func (f *Framer) uncorkHeaderDecompressor(payloadSize int64) error <span class="cov8" title="1">{
        if f.headerDecompressor != nil </span><span class="cov8" title="1">{
                f.headerReader.N = payloadSize
                return nil
        }</span>
        <span class="cov8" title="1">f.headerReader = io.LimitedReader{R: f.r, N: payloadSize}
        decompressor, err := zlib.NewReaderDict(&amp;f.headerReader, []byte(headerDictionary))
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">f.headerDecompressor = decompressor
        return nil</span>
}

// ReadFrame reads SPDY encoded data and returns a decompressed Frame.
func (f *Framer) ReadFrame() (frame Frame, err error) <span class="cov8" title="1">{
        var firstWord uint32
        if err = binary.Read(f.r, binary.BigEndian, &amp;firstWord); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if firstWord&amp;0x80000000 != 0 </span><span class="cov8" title="1">{
                frameType := ControlFrameType(firstWord &amp; 0xffff)
                version := uint16(firstWord &gt;&gt; 16 &amp; 0x7fff)
                frame, err = f.parseControlFrame(version, frameType)
        }</span> else<span class="cov8" title="1"> {
                frame, err = f.parseDataFrame(StreamId(firstWord &amp; 0x7fffffff))
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                frame = nil
        }</span>
        <span class="cov8" title="1">return frame, err</span>
}

func (f *Framer) parseControlFrame(version uint16, frameType ControlFrameType) (Frame, error) <span class="cov8" title="1">{
        var length uint32
        if err := binary.Read(f.r, binary.BigEndian, &amp;length); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">flags := ControlFlags((length &amp; 0xff000000) &gt;&gt; 24)
        length &amp;= 0xffffff
        header := ControlFrameHeader{version, frameType, flags, length}
        cframe, err := newControlFrame(frameType)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err = cframe.read(header, f); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return cframe, nil</span>
}

func parseHeaderValueBlock(r io.Reader, streamId StreamId) (http.Header, uint32, error) <span class="cov8" title="1">{
        headerLen := uint32(0) // length of header decompressed

        var numHeaders uint32
        if err := binary.Read(r, binary.BigEndian, &amp;numHeaders); err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>
        <span class="cov8" title="1">if numHeaders &gt; MaxNumHeaders </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("HeaderValueBlock with invalid numHeaders: %d", numHeaders)
        }</span>

        <span class="cov8" title="1">var e error
        h := make(http.Header, int(numHeaders))
        for i := 0; i &lt; int(numHeaders); i++ </span><span class="cov8" title="1">{
                var length uint32
                if err := binary.Read(r, binary.BigEndian, &amp;length); err != nil </span><span class="cov0" title="0">{
                        return nil, 0, err
                }</span>
                <span class="cov8" title="1">headerLen += length
                nameBytes := make([]byte, length)
                if _, err := io.ReadFull(r, nameBytes); err != nil </span><span class="cov0" title="0">{
                        return nil, 0, err
                }</span>
                <span class="cov8" title="1">name := string(nameBytes)
                if name != strings.ToLower(name) </span><span class="cov0" title="0">{
                        e = &amp;Error{UnlowercasedHeaderName, streamId}
                        name = strings.ToLower(name)
                }</span>
                <span class="cov8" title="1">if h[name] != nil </span><span class="cov0" title="0">{
                        e = &amp;Error{DuplicateHeaders, streamId}
                }</span>
                <span class="cov8" title="1">if err := binary.Read(r, binary.BigEndian, &amp;length); err != nil </span><span class="cov0" title="0">{
                        return nil, 0, err
                }</span>
                <span class="cov8" title="1">headerLen += length
                value := make([]byte, length)
                if _, err := io.ReadFull(r, value); err != nil </span><span class="cov0" title="0">{
                        return nil, 0, err
                }</span>
                <span class="cov8" title="1">valueList := strings.Split(string(value), headerValueSeparator)
                for _, v := range valueList </span><span class="cov8" title="1">{
                        h.Add(name, v)
                }</span>
        }
        <span class="cov8" title="1">if e != nil </span><span class="cov0" title="0">{
                return h, 0, e
        }</span>
        <span class="cov8" title="1">headerLen += numHeaders * 4 // add estimated overhead associate with header field
        return h, headerLen, nil</span>
}

func (f *Framer) readSynStreamFrame(h ControlFrameHeader, frame *SynStreamFrame) error <span class="cov8" title="1">{
        frame.CFHeader = h
        var headerLen uint32 // length of header decompressed
        var err error
        if err = binary.Read(f.r, binary.BigEndian, &amp;frame.StreamId); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">frame.StreamId = frame.StreamId &amp; 0x7fffffff
        if err = binary.Read(f.r, binary.BigEndian, &amp;frame.AssociatedToStreamId); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">frame.AssociatedToStreamId = frame.AssociatedToStreamId &amp; 0x7fffffff
        if err = binary.Read(f.r, binary.BigEndian, &amp;frame.Priority); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">frame.Priority &gt;&gt;= 5
        if err = binary.Read(f.r, binary.BigEndian, &amp;frame.Slot); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">reader := f.r
        if !f.headerCompressionDisabled </span><span class="cov8" title="1">{
                err := f.uncorkHeaderDecompressor(int64(h.length - 10))
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">reader = f.headerDecompressor</span>
        }
        <span class="cov8" title="1">frame.Headers, headerLen, err = parseHeaderValueBlock(reader, frame.StreamId)
        if !f.headerCompressionDisabled &amp;&amp; (err == io.EOF &amp;&amp; f.headerReader.N == 0 || f.headerReader.N != 0) </span><span class="cov0" title="0">{
                err = &amp;Error{WrongCompressedPayloadSize, 0}
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">for h := range frame.Headers </span><span class="cov8" title="1">{
                if invalidReqHeaders[h] </span><span class="cov0" title="0">{
                        return &amp;Error{InvalidHeaderPresent, frame.StreamId}
                }</span>
        }

        // check url length
        <span class="cov8" title="1">if err := f.checkHeaderFieldLimit(frame.Headers); err != nil </span><span class="cov0" title="0">{
                return &amp;Error{ErrTooLongUrl, frame.StreamId}
        }</span>

        <span class="cov8" title="1">if frame.StreamId == 0 </span><span class="cov0" title="0">{
                return &amp;Error{ZeroStreamId, 0}
        }</span>

        <span class="cov8" title="1">state.SpdyReqHeaderOriginalSize.Inc(uint(headerLen))
        state.SpdyReqHeaderCompressSize.Inc(uint(h.length + 8)) // size of SynStream frame

        return nil</span>
}

func (f *Framer) readSynReplyFrame(h ControlFrameHeader, frame *SynReplyFrame) error <span class="cov8" title="1">{
        frame.CFHeader = h
        var err error
        if err = binary.Read(f.r, binary.BigEndian, &amp;frame.StreamId); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">frame.StreamId = frame.StreamId &amp; 0x7fffffff
        reader := f.r
        if !f.headerCompressionDisabled </span><span class="cov8" title="1">{
                err := f.uncorkHeaderDecompressor(int64(h.length - 4))
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">reader = f.headerDecompressor</span>
        }
        <span class="cov8" title="1">frame.Headers, _, err = parseHeaderValueBlock(reader, frame.StreamId)
        if !f.headerCompressionDisabled &amp;&amp; (err == io.EOF &amp;&amp; f.headerReader.N == 0 || f.headerReader.N != 0) </span><span class="cov0" title="0">{
                err = &amp;Error{WrongCompressedPayloadSize, 0}
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">for h := range frame.Headers </span><span class="cov8" title="1">{
                if invalidRespHeaders[h] </span><span class="cov0" title="0">{
                        return &amp;Error{InvalidHeaderPresent, frame.StreamId}
                }</span>
        }
        <span class="cov8" title="1">if frame.StreamId == 0 </span><span class="cov0" title="0">{
                return &amp;Error{ZeroStreamId, 0}
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (f *Framer) maxHeaderUriSize() uint32 <span class="cov8" title="1">{
        if f.MaxHeaderUriSize == 0 </span><span class="cov8" title="1">{
                return http.DefaultMaxHeaderUriBytes
        }</span>

        <span class="cov8" title="1">return f.MaxHeaderUriSize</span>
}

func (f *Framer) checkHeaderFieldLimit(header http.Header) error <span class="cov8" title="1">{
        uri := header.Get(":path")
        if len(uri) &gt; int(f.maxHeaderUriSize()) </span><span class="cov0" title="0">{
                return fmt.Errorf("exceed max url size %d!", len(uri))
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (f *Framer) readHeadersFrame(h ControlFrameHeader, frame *HeadersFrame) error <span class="cov8" title="1">{
        frame.CFHeader = h
        var err error
        if err = binary.Read(f.r, binary.BigEndian, &amp;frame.StreamId); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">frame.StreamId = frame.StreamId &amp; 0x7fffffff
        reader := f.r
        if !f.headerCompressionDisabled </span><span class="cov8" title="1">{
                err := f.uncorkHeaderDecompressor(int64(h.length - 4))
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">reader = f.headerDecompressor</span>
        }
        <span class="cov8" title="1">frame.Headers, _, err = parseHeaderValueBlock(reader, frame.StreamId)
        if !f.headerCompressionDisabled &amp;&amp; (err == io.EOF &amp;&amp; f.headerReader.N == 0 || f.headerReader.N != 0) </span><span class="cov0" title="0">{
                err = &amp;Error{WrongCompressedPayloadSize, 0}
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">var invalidHeaders map[string]bool
        if frame.StreamId%2 == 0 </span><span class="cov8" title="1">{
                invalidHeaders = invalidReqHeaders
        }</span> else<span class="cov0" title="0"> {
                invalidHeaders = invalidRespHeaders
        }</span>
        <span class="cov8" title="1">for h := range frame.Headers </span><span class="cov8" title="1">{
                if invalidHeaders[h] </span><span class="cov0" title="0">{
                        return &amp;Error{InvalidHeaderPresent, frame.StreamId}
                }</span>
        }

        // check uri length
        <span class="cov8" title="1">if err := f.checkHeaderFieldLimit(frame.Headers); err != nil </span><span class="cov0" title="0">{
                return &amp;Error{ErrTooLongUrl, frame.StreamId}
        }</span>

        <span class="cov8" title="1">if frame.StreamId == 0 </span><span class="cov0" title="0">{
                return &amp;Error{ZeroStreamId, 0}
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (f *Framer) parseDataFrame(streamId StreamId) (*DataFrame, error) <span class="cov8" title="1">{
        var length uint32
        if err := binary.Read(f.r, binary.BigEndian, &amp;length); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">var frame DataFrame
        frame.StreamId = streamId
        frame.Flags = DataFlags(length &gt;&gt; 24)
        length &amp;= 0xffffff
        frame.Data = make([]byte, length)
        if _, err := io.ReadFull(f.r, frame.Data); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if frame.StreamId == 0 </span><span class="cov0" title="0">{
                return nil, &amp;Error{ZeroStreamId, 0}
        }</span>
        <span class="cov8" title="1">return &amp;frame, nil</span>
}
</pre>
		
		<pre class="file" id="file237" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Copyright 2011 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package bfe_spdy

import (
        "bytes"
        "compress/zlib"
        "fmt"
        "io"
        "sync"
)

import (
        http "github.com/bfenetworks/bfe/bfe_http"
)

// Version is the protocol version number that this package implements (spdy3.1/spdy3).
const Version = 3

// ControlFrameType stores the type field in a control frame header.
type ControlFrameType uint16

const (
        TypeSynStream    ControlFrameType = 0x0001
        TypeSynReply                      = 0x0002
        TypeRstStream                     = 0x0003
        TypeSettings                      = 0x0004
        TypePing                          = 0x0006
        TypeGoAway                        = 0x0007
        TypeHeaders                       = 0x0008
        TypeWindowUpdate                  = 0x0009
)

// ControlFlags are the flags that can be set on a control frame.
type ControlFlags uint8

const (
        ControlFlagFin                   ControlFlags = 0x01
        ControlFlagUnidirectional                     = 0x02
        ControlFlagSettingsClearSettings              = 0x01
)

// DataFlags are the flags that can be set on a data frame.
type DataFlags uint8

const (
        DataFlagFin DataFlags = 0x01
)

// MaxDataLength is the maximum number of bytes that can be stored in one frame.
const MaxDataLength = 1&lt;&lt;24 - 1

const MinMaxFrameSize = 1 &lt;&lt; 14
const MaxFrameSize = 1&lt;&lt;24 - 1

const MaxNumSettings = 1024
const MaxNumHeaders = 1024

// headerValueSepator separates multiple header values.
const headerValueSeparator = "\x00"

// Frame is a single SPDY frame in its unpacked in-memory representation. Use
// Framer to read and write it.
type Frame interface {
        write(f *Framer) error
}

// ControlFrameHeader contains all the fields in a control frame header,
// in its unpacked in-memory representation.
type ControlFrameHeader struct {
        // Note, high bit is the "Control" bit.
        version   uint16 // spdy version number
        frameType ControlFrameType
        Flags     ControlFlags
        length    uint32 // length of data field
}

type controlFrame interface {
        Frame
        read(h ControlFrameHeader, f *Framer) error
}

// StreamId represents a 31-bit value identifying the stream.
type StreamId uint32

// SynStreamFrame is the unpacked, in-memory representation of a SYN_STREAM
// frame.
type SynStreamFrame struct {
        CFHeader             ControlFrameHeader
        StreamId             StreamId
        AssociatedToStreamId StreamId // stream id for a stream which this stream is associated to
        Priority             uint8    // priority of this frame (3-bit)
        Slot                 uint8    // index in the server's credential vector of the client certificate
        Headers              http.Header
}

func (f *SynStreamFrame) StreamEnded() bool <span class="cov8" title="1">{
        return (f.CFHeader.Flags &amp; ControlFlagFin) != 0
}</span>

// SynReplyFrame is the unpacked, in-memory representation of a SYN_REPLY frame.
type SynReplyFrame struct {
        CFHeader ControlFrameHeader
        StreamId StreamId
        Headers  http.Header
}

func (f *SynReplyFrame) StreamEnded() bool <span class="cov8" title="1">{
        return (f.CFHeader.Flags &amp; ControlFlagFin) != 0
}</span>

// RstStreamStatus represents the status that led to a RST_STREAM.
type RstStreamStatus uint32

const (
        ProtocolError RstStreamStatus = iota + 1
        InvalidStream
        RefusedStream
        UnsupportedVersion
        Cancel
        InternalError
        FlowControlError
        StreamInUse
        StreamAlreadyClosed
        InvalidCredentials
        FrameTooLarge
)

// RstStreamFrame is the unpacked, in-memory representation of a RST_STREAM
// frame.
type RstStreamFrame struct {
        CFHeader ControlFrameHeader
        StreamId StreamId
        Status   RstStreamStatus
}

// SettingsFlag represents a flag in a SETTINGS frame.
type SettingsFlag uint8

const (
        FlagSettingsPersistValue SettingsFlag = 0x1
        FlagSettingsPersisted                 = 0x2
)

// SettingsId represents the id of an id/value pair in a SETTINGS frame.
type SettingsId uint32

const (
        SettingsUploadBandwidth SettingsId = iota + 1
        SettingsDownloadBandwidth
        SettingsRoundTripTime
        SettingsMaxConcurrentStreams
        SettingsCurrentCwnd
        SettingsDownloadRetransRate
        SettingsInitialWindowSize
        SettingsClientCretificateVectorSize
)

// SettingsFlagIdValue is the unpacked, in-memory representation of the
// combined flag/id/value for a setting in a SETTINGS frame.
type SettingsFlagIdValue struct {
        Flag  SettingsFlag
        Id    SettingsId
        Value uint32
}

// SettingsFrame is the unpacked, in-memory representation of a SPDY
// SETTINGS frame.
type SettingsFrame struct {
        CFHeader     ControlFrameHeader
        FlagIdValues []SettingsFlagIdValue
}

// PingFrame is the unpacked, in-memory representation of a PING frame.
type PingFrame struct {
        CFHeader ControlFrameHeader
        Id       uint32 // unique id for this ping, from server is even, from client is odd.
}

// GoAwayStatus represents the status in a GoAwayFrame.
type GoAwayStatus uint32

const (
        GoAwayOK GoAwayStatus = iota
        GoAwayProtocolError
        GoAwayInternalError
)

// GoAwayFrame is the unpacked, in-memory representation of a GOAWAY frame.
type GoAwayFrame struct {
        CFHeader         ControlFrameHeader
        LastGoodStreamId StreamId // last stream id which was accepted by sender
        Status           GoAwayStatus
}

// HeadersFrame is the unpacked, in-memory representation of a HEADERS frame.
type HeadersFrame struct {
        CFHeader ControlFrameHeader
        StreamId StreamId
        Headers  http.Header
}

// WindowUpdateFrame is the unpacked, in-memory representation of a
// WINDOW_UPDATE frame.
type WindowUpdateFrame struct {
        CFHeader        ControlFrameHeader
        StreamId        StreamId
        DeltaWindowSize uint32 // additional number of bytes to existing window size
}

// TODO: Implement credential frame and related methods.

// DataFrame is the unpacked, in-memory representation of a DATA frame.
type DataFrame struct {
        // Note, high bit is the "Control" bit. Should be 0 for data frames.
        StreamId StreamId
        Flags    DataFlags
        Data     []byte // payload data of this frame
}

func (f *DataFrame) StreamEnded() bool <span class="cov8" title="1">{
        return (f.Flags &amp; DataFlagFin) != 0
}</span>

func (f *DataFrame) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("DataFrame(StreamId:%d, Flags:%d, Data:%d)",
                f.StreamId, f.Flags, len(f.Data))
}</span>

// FlushFrame is the special frame for flush connection buffer.
type FlushFrame struct{}

// FinFrame is the special frame for finish connection.
type FinFrame struct{}

// PanicFrame is the special frame for reset stream with panic.
type PanicFrame struct{}

// ErrorCode represents SPDY specific error.
type ErrorCode string

const (
        UnlowercasedHeaderName     ErrorCode = "header was not lowercased"
        DuplicateHeaders                     = "multiple headers with same name"
        WrongCompressedPayloadSize           = "compressed payload size was incorrect"
        UnknownFrameType                     = "unknown frame type"
        InvalidControlFrame                  = "invalid control frame"
        InvalidDataFrame                     = "invalid data frame"
        InvalidHeaderPresent                 = "frame contained invalid header"
        ZeroStreamId                         = "stream id zero is disallowed"
        ErrTooLongUrl                        = "url is too long"
)

// Error contains both the type of error and additional values. StreamId is 0
// if Error is not associated with a stream.
type Error struct {
        Err      ErrorCode
        StreamId StreamId
}

func (e *Error) Error() string <span class="cov0" title="0">{
        return string(e.Err)
}</span>

var invalidReqHeaders = map[string]bool{
        "Connection":        true,
        "Host":              true,
        "Keep-Alive":        true,
        "Proxy-Connection":  true,
        "Transfer-Encoding": true,
}

var invalidRespHeaders = map[string]bool{
        "Connection":        true,
        "Keep-Alive":        true,
        "Proxy-Connection":  true,
        "Transfer-Encoding": true,
}

// Framer handles serializing/deserializing SPDY frames, including compressing/
// decompressing payloads.
type Framer struct {
        // for unit test and debug usage. Header block is always compressed
        // using zlib compression in SPDY, See 2.6.10.1.
        headerCompressionDisabled bool

        w                  io.Writer
        headerBuf          *bytes.Buffer
        headerCompressor   *zlib.Writer
        r                  io.Reader
        headerReader       io.LimitedReader
        headerDecompressor io.ReadCloser
        maxReadFrameSize   int

        // max uri size
        MaxHeaderUriSize uint32
}

var zlibWriterPool = sync.Pool{
        New: func() interface{} <span class="cov8" title="1">{
                compressor, err := zlib.NewWriterLevelDict(nil, zlib.BestCompression, []byte(headerDictionary))
                if err != nil </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov8" title="1">return compressor</span>
        },
}

// NewFramer allocates a new Framer for a given SPDY connection, represented by
// a io.Writer and io.Reader. Note that Framer will read and write individual fields
// from/to the Reader and Writer, so the caller should pass in an appropriately
// buffered implementation to optimize performance.
func NewFramer(w io.Writer, r io.Reader) (*Framer, error) <span class="cov8" title="1">{
        compressBuf := new(bytes.Buffer)
        writer := zlibWriterPool.Get()
        if writer == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error create zlib writer")
        }</span>
        <span class="cov8" title="1">compressor := writer.(*zlib.Writer)
        compressor.Reset(compressBuf)

        framer := &amp;Framer{
                w:                w,
                headerBuf:        compressBuf,
                headerCompressor: compressor,
                r:                r,
        }
        return framer, nil</span>
}

func (f *Framer) ReleaseWriter() <span class="cov8" title="1">{
        compressor := f.headerCompressor
        f.headerCompressor = nil
        zlibWriterPool.Put(compressor)
}</span>
</pre>
		
		<pre class="file" id="file238" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Copyright 2011 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package bfe_spdy

import (
        "encoding/binary"
        "io"
        "strings"
)

import (
        http "github.com/bfenetworks/bfe/bfe_http"
)

func (frame *SynStreamFrame) write(f *Framer) error <span class="cov8" title="1">{
        return f.writeSynStreamFrame(frame)
}</span>

func (frame *SynReplyFrame) write(f *Framer) error <span class="cov8" title="1">{
        return f.writeSynReplyFrame(frame)
}</span>

func (frame *RstStreamFrame) write(f *Framer) (err error) <span class="cov8" title="1">{
        if frame.StreamId == 0 </span><span class="cov0" title="0">{
                return &amp;Error{ZeroStreamId, 0}
        }</span>
        <span class="cov8" title="1">frame.CFHeader.version = Version
        frame.CFHeader.frameType = TypeRstStream
        frame.CFHeader.Flags = 0
        frame.CFHeader.length = 8

        // Serialize frame to Writer.
        if err = writeControlFrameHeader(f.w, frame.CFHeader); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if err = binary.Write(f.w, binary.BigEndian, frame.StreamId); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if frame.Status == 0 </span><span class="cov0" title="0">{
                return &amp;Error{InvalidControlFrame, frame.StreamId}
        }</span>
        <span class="cov8" title="1">if err = binary.Write(f.w, binary.BigEndian, frame.Status); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">return</span>
}

func (frame *SettingsFrame) write(f *Framer) (err error) <span class="cov8" title="1">{
        frame.CFHeader.version = Version
        frame.CFHeader.frameType = TypeSettings
        frame.CFHeader.length = uint32(len(frame.FlagIdValues)*8 + 4)

        // Serialize frame to Writer.
        if err = writeControlFrameHeader(f.w, frame.CFHeader); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if err = binary.Write(f.w, binary.BigEndian, uint32(len(frame.FlagIdValues))); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">for _, flagIdValue := range frame.FlagIdValues </span><span class="cov8" title="1">{
                flagId := uint32(flagIdValue.Flag)&lt;&lt;24 | uint32(flagIdValue.Id)
                if err = binary.Write(f.w, binary.BigEndian, flagId); err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov8" title="1">if err = binary.Write(f.w, binary.BigEndian, flagIdValue.Value); err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
        }
        <span class="cov8" title="1">return</span>
}

func (frame *PingFrame) write(f *Framer) (err error) <span class="cov8" title="1">{
        if frame.Id == 0 </span><span class="cov0" title="0">{
                return &amp;Error{ZeroStreamId, 0}
        }</span>
        <span class="cov8" title="1">frame.CFHeader.version = Version
        frame.CFHeader.frameType = TypePing
        frame.CFHeader.Flags = 0
        frame.CFHeader.length = 4

        // Serialize frame to Writer.
        if err = writeControlFrameHeader(f.w, frame.CFHeader); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if err = binary.Write(f.w, binary.BigEndian, frame.Id); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">return</span>
}

func (frame *GoAwayFrame) write(f *Framer) (err error) <span class="cov8" title="1">{
        frame.CFHeader.version = Version
        frame.CFHeader.frameType = TypeGoAway
        frame.CFHeader.Flags = 0
        frame.CFHeader.length = 8

        // Serialize frame to Writer.
        if err = writeControlFrameHeader(f.w, frame.CFHeader); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if err = binary.Write(f.w, binary.BigEndian, frame.LastGoodStreamId); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if err = binary.Write(f.w, binary.BigEndian, frame.Status); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (frame *HeadersFrame) write(f *Framer) error <span class="cov8" title="1">{
        return f.writeHeadersFrame(frame)
}</span>

func (frame *WindowUpdateFrame) write(f *Framer) (err error) <span class="cov8" title="1">{
        frame.CFHeader.version = Version
        frame.CFHeader.frameType = TypeWindowUpdate
        frame.CFHeader.Flags = 0
        frame.CFHeader.length = 8

        // Serialize frame to Writer.
        if err = writeControlFrameHeader(f.w, frame.CFHeader); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if err = binary.Write(f.w, binary.BigEndian, frame.StreamId); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if err = binary.Write(f.w, binary.BigEndian, frame.DeltaWindowSize); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (frame *DataFrame) write(f *Framer) error <span class="cov8" title="1">{
        return f.writeDataFrame(frame)
}</span>

func (frame *FlushFrame) write(f *Framer) error <span class="cov0" title="0">{
        return nil
}</span>

func (frame *FinFrame) write(f *Framer) error <span class="cov0" title="0">{
        return nil
}</span>

func (frame *PanicFrame) write(f *Framer) error <span class="cov0" title="0">{
        return nil
}</span>

// WriteFrame writes a frame.
func (f *Framer) WriteFrame(frame Frame) error <span class="cov8" title="1">{
        return frame.write(f)
}</span>

func writeControlFrameHeader(w io.Writer, h ControlFrameHeader) error <span class="cov8" title="1">{
        if err := binary.Write(w, binary.BigEndian, 0x8000|h.version); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := binary.Write(w, binary.BigEndian, h.frameType); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">flagsAndLength := uint32(h.Flags)&lt;&lt;24 | h.length
        if err := binary.Write(w, binary.BigEndian, flagsAndLength); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func writeHeaderValueBlock(w io.Writer, h http.Header) (n int, err error) <span class="cov8" title="1">{
        n = 0
        if err = binary.Write(w, binary.BigEndian, uint32(len(h))); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">n += 2
        for name, values := range h </span><span class="cov8" title="1">{
                if err = binary.Write(w, binary.BigEndian, uint32(len(name))); err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov8" title="1">n += 2
                name = strings.ToLower(name)
                if _, err = io.WriteString(w, name); err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov8" title="1">n += len(name)
                v := strings.Join(values, headerValueSeparator)
                if err = binary.Write(w, binary.BigEndian, uint32(len(v))); err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov8" title="1">n += 2
                if _, err = io.WriteString(w, v); err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov8" title="1">n += len(v)</span>
        }
        <span class="cov8" title="1">return</span>
}

func (f *Framer) writeSynStreamFrame(frame *SynStreamFrame) (err error) <span class="cov8" title="1">{
        if frame.StreamId == 0 </span><span class="cov0" title="0">{
                return &amp;Error{ZeroStreamId, 0}
        }</span>
        // Marshal the headers.
        <span class="cov8" title="1">var writer io.Writer = f.headerBuf
        if !f.headerCompressionDisabled </span><span class="cov8" title="1">{
                writer = f.headerCompressor
        }</span>
        <span class="cov8" title="1">if _, err = writeHeaderValueBlock(writer, frame.Headers); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if !f.headerCompressionDisabled </span><span class="cov8" title="1">{
                f.headerCompressor.Flush()
        }</span>

        // Set ControlFrameHeader.
        <span class="cov8" title="1">frame.CFHeader.version = Version
        frame.CFHeader.frameType = TypeSynStream
        frame.CFHeader.length = uint32(len(f.headerBuf.Bytes()) + 10)

        // Serialize frame to Writer.
        if err = writeControlFrameHeader(f.w, frame.CFHeader); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err = binary.Write(f.w, binary.BigEndian, frame.StreamId); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err = binary.Write(f.w, binary.BigEndian, frame.AssociatedToStreamId); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err = binary.Write(f.w, binary.BigEndian, frame.Priority&lt;&lt;5); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err = binary.Write(f.w, binary.BigEndian, frame.Slot); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if _, err = f.w.Write(f.headerBuf.Bytes()); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">f.headerBuf.Reset()
        return nil</span>
}

func (f *Framer) writeSynReplyFrame(frame *SynReplyFrame) (err error) <span class="cov8" title="1">{
        var headerLen int // estimated length of header uncompressed
        if frame.StreamId == 0 </span><span class="cov0" title="0">{
                return &amp;Error{ZeroStreamId, 0}
        }</span>
        // Marshal the headers.
        <span class="cov8" title="1">var writer io.Writer = f.headerBuf
        if !f.headerCompressionDisabled </span><span class="cov8" title="1">{
                writer = f.headerCompressor
        }</span>
        <span class="cov8" title="1">if headerLen, err = writeHeaderValueBlock(writer, frame.Headers); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if !f.headerCompressionDisabled </span><span class="cov8" title="1">{
                f.headerCompressor.Flush()
        }</span>

        // Set ControlFrameHeader.
        <span class="cov8" title="1">frame.CFHeader.version = Version
        frame.CFHeader.frameType = TypeSynReply
        frame.CFHeader.length = uint32(len(f.headerBuf.Bytes()) + 4)

        // Serialize frame to Writer.
        if err = writeControlFrameHeader(f.w, frame.CFHeader); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if err = binary.Write(f.w, binary.BigEndian, frame.StreamId); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if _, err = f.w.Write(f.headerBuf.Bytes()); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">f.headerBuf.Reset()

        state.SpdyResHeaderOriginalSize.Inc(uint(headerLen))
        state.SpdyResHeaderCompressSize.Inc(uint(frame.CFHeader.length + 8)) // size of SynReply frame

        return</span>
}

func (f *Framer) writeHeadersFrame(frame *HeadersFrame) (err error) <span class="cov8" title="1">{
        if frame.StreamId == 0 </span><span class="cov0" title="0">{
                return &amp;Error{ZeroStreamId, 0}
        }</span>
        // Marshal the headers.
        <span class="cov8" title="1">var writer io.Writer = f.headerBuf
        if !f.headerCompressionDisabled </span><span class="cov8" title="1">{
                writer = f.headerCompressor
        }</span>
        <span class="cov8" title="1">if _, err = writeHeaderValueBlock(writer, frame.Headers); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if !f.headerCompressionDisabled </span><span class="cov8" title="1">{
                f.headerCompressor.Flush()
        }</span>

        // Set ControlFrameHeader.
        <span class="cov8" title="1">frame.CFHeader.version = Version
        frame.CFHeader.frameType = TypeHeaders
        frame.CFHeader.length = uint32(len(f.headerBuf.Bytes()) + 4)

        // Serialize frame to Writer.
        if err = writeControlFrameHeader(f.w, frame.CFHeader); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if err = binary.Write(f.w, binary.BigEndian, frame.StreamId); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if _, err = f.w.Write(f.headerBuf.Bytes()); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">f.headerBuf.Reset()
        return</span>
}

func (f *Framer) writeDataFrame(frame *DataFrame) (err error) <span class="cov8" title="1">{
        if frame.StreamId == 0 </span><span class="cov0" title="0">{
                return &amp;Error{ZeroStreamId, 0}
        }</span>
        <span class="cov8" title="1">if frame.StreamId&amp;0x80000000 != 0 || len(frame.Data) &gt; MaxDataLength </span><span class="cov0" title="0">{
                return &amp;Error{InvalidDataFrame, frame.StreamId}
        }</span>

        // Serialize frame to Writer.
        <span class="cov8" title="1">if err = binary.Write(f.w, binary.BigEndian, frame.StreamId); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">flagsAndLength := uint32(frame.Flags)&lt;&lt;24 | uint32(len(frame.Data))
        if err = binary.Write(f.w, binary.BigEndian, flagsAndLength); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if _, err = f.w.Write(frame.Data); err != nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file239" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Copyright 2014 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package bfe_spdy

import (
        "io"
)

import (
        "github.com/bfenetworks/bfe/bfe_util/pipe"
)

type RequestBody struct {
        stream        *stream
        conn          *serverConn
        closed        bool
        pipe          *pipe.Pipe // non-nil if we have a HTTP entity message body
        needsContinue bool       // need to send a 100-continue
}

func (b *RequestBody) Read(p []byte) (n int, err error) <span class="cov8" title="1">{
        if b.needsContinue </span><span class="cov8" title="1">{
                b.needsContinue = false
                b.conn.write100ContinueHeaders(b.stream)
        }</span>
        <span class="cov8" title="1">if b.pipe == nil </span><span class="cov8" title="1">{
                return 0, io.EOF
        }</span>
        <span class="cov8" title="1">n, err = b.pipe.Read(p)
        if n &gt; 0 </span><span class="cov8" title="1">{
                b.conn.noteBodyReadFromHandler(b.stream, n)
        }</span>
        <span class="cov8" title="1">return</span>
}

func (b *RequestBody) Close() error <span class="cov8" title="1">{
        if b.pipe != nil </span><span class="cov8" title="1">{
                b.pipe.CloseWithError(errClosedBody)
        }</span>
        <span class="cov8" title="1">b.closed = true
        return nil</span>
}

// Eof check whether without entity body
func (b *RequestBody) Eof() bool <span class="cov0" title="0">{
        return b.pipe == nil
}</span>
</pre>
		
		<pre class="file" id="file240" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Copyright 2014 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package bfe_spdy

import (
        "bufio"
        "sync"
)

import (
        http "github.com/bfenetworks/bfe/bfe_http"
)

// responseWriter is the http.ResponseWriter implementation.  It's
// intentionally small (1 pointer wide) to minimize garbage.  The
// responseWriterState pointer inside is zeroed at the end of a
// request (in handlerDone) and calls on the responseWriter thereafter
// simply crash (caller's mistake), but the much larger responseWriterState
// and buffers are reused between multiple requests.
type responseWriter struct {
        rws *responseWriterState
}

// Optional http.ResponseWriter interfaces implemented.
var (
        _ http.CloseNotifier = (*responseWriter)(nil)
        _ http.Flusher       = (*responseWriter)(nil)
        _ stringWriter       = (*responseWriter)(nil)
)

type responseWriterState struct {
        // immutable within a request:
        stream *stream
        req    *http.Request
        body   *RequestBody // to close at end of request, if DATA frames didn't
        conn   *serverConn
        bw     *bufio.Writer // writing to a chunkWriter{this *responseWriterState}

        // mutated by http.Handler goroutine:
        handlerHeader http.Header // nil until called
        snapHeader    http.Header // snapshot of handlerHeader at WriteHeader time
        status        int         // status code passed to WriteHeader
        wroteHeader   bool        // WriteHeader called (explicitly or implicitly). Not necessarily sent to user yet.
        sentHeader    bool        // have we sent the header frame?
        handlerDone   bool        // handler has finished

        closeNotifierMu sync.Mutex // guards closeNotifierCh
        closeNotifierCh chan bool  // nil until first used
}

var responseWriterStatePool = sync.Pool{
        New: func() interface{} <span class="cov8" title="1">{
                rws := &amp;responseWriterState{}
                rws.bw = bufio.NewWriterSize(chunkWriter{rws}, handlerChunkWriteSize)
                return rws
        }</span>,
}

type chunkWriter struct {
        rws *responseWriterState
}

func (cw chunkWriter) Write(p []byte) (n int, err error) <span class="cov8" title="1">{
        return cw.rws.writeChunk(p)
}</span>

// writeChunk writes chunks from the bufio.Writer. But because
// bufio.Writer may bypass its chunking, sometimes p may be
// arbitrarily large.
//
// writeChunk is also responsible (on the first chunk) for sending the
// HEADER response.
func (rws *responseWriterState) writeChunk(p []byte) (n int, err error) <span class="cov8" title="1">{
        if !rws.wroteHeader </span><span class="cov8" title="1">{
                rws.writeHeader(200)
        }</span>
        <span class="cov8" title="1">if !rws.sentHeader </span><span class="cov8" title="1">{
                rws.sentHeader = true
                endStream := rws.handlerDone &amp;&amp; len(p) == 0
                err = rws.conn.writeHeaders(rws.stream, rws.status, rws.snapHeader, endStream)
                if err != nil </span><span class="cov8" title="1">{
                        return 0, err
                }</span>
                <span class="cov8" title="1">if endStream </span><span class="cov8" title="1">{
                        return 0, nil
                }</span>
        }
        <span class="cov8" title="1">if len(p) == 0 &amp;&amp; !rws.handlerDone </span><span class="cov8" title="1">{
                return 0, nil
        }</span>

        <span class="cov8" title="1">if err := rws.conn.writeDataFromHandler(rws.stream, p, rws.handlerDone); err != nil </span><span class="cov8" title="1">{
                return 0, err
        }</span>
        <span class="cov8" title="1">return len(p), nil</span>
}

func (rws *responseWriterState) writeHeader(code int) <span class="cov8" title="1">{
        if !rws.wroteHeader </span><span class="cov8" title="1">{
                rws.wroteHeader = true
                rws.status = code
                if len(rws.handlerHeader) &gt; 0 </span><span class="cov8" title="1">{
                        rws.snapHeader = cloneHeader(rws.handlerHeader)
                }</span>
        }
}

func (w *responseWriter) Header() http.Header <span class="cov8" title="1">{
        rws := w.rws
        if rws == nil </span><span class="cov0" title="0">{
                panic("Header called after Handler finished")</span>
        }
        <span class="cov8" title="1">if rws.handlerHeader == nil </span><span class="cov8" title="1">{
                rws.handlerHeader = make(http.Header)
        }</span>
        <span class="cov8" title="1">return rws.handlerHeader</span>
}

func (w *responseWriter) WriteHeader(code int) <span class="cov8" title="1">{
        rws := w.rws
        if rws == nil </span><span class="cov0" title="0">{
                panic("WriteHeader called after Handler finished")</span>
        }
        <span class="cov8" title="1">rws.writeHeader(code)</span>
}

func cloneHeader(h http.Header) http.Header <span class="cov8" title="1">{
        h2 := make(http.Header, len(h))
        for k, vv := range h </span><span class="cov8" title="1">{
                vv2 := make([]string, len(vv))
                copy(vv2, vv)
                h2[k] = vv2
        }</span>
        <span class="cov8" title="1">return h2</span>
}

// The Life Of A Write is like this:
//
// * Handler calls w.Write or w.WriteString -&gt;
// * -&gt; rws.bw (*bufio.Writer) -&gt;
// * (Handler might call Flush)
// * -&gt; chunkWriter{rws}
// * -&gt; responseWriterState.writeChunk(p []byte)
// * -&gt; responseWriterState.writeChunk (most of the magic; see comment there)
func (w *responseWriter) Write(p []byte) (n int, err error) <span class="cov8" title="1">{
        return w.write(len(p), p, "")
}</span>

func (w *responseWriter) WriteString(s string) (n int, err error) <span class="cov8" title="1">{
        return w.write(len(s), nil, s)
}</span>

// either dataB or dataS is non-zero.
func (w *responseWriter) write(lenData int, dataB []byte, dataS string) (n int, err error) <span class="cov8" title="1">{
        rws := w.rws
        if rws == nil </span><span class="cov0" title="0">{
                panic("Write called after Handler finished")</span>
        }
        <span class="cov8" title="1">if !rws.wroteHeader </span><span class="cov8" title="1">{
                w.WriteHeader(200)
        }</span>
        <span class="cov8" title="1">if dataB != nil </span><span class="cov8" title="1">{
                return rws.bw.Write(dataB)
        }</span>
        <span class="cov8" title="1">return rws.bw.WriteString(dataS)</span>
}

func (w *responseWriter) handlerDone() <span class="cov8" title="1">{
        rws := w.rws
        if rws == nil </span><span class="cov0" title="0">{
                panic("handlerDone called twice")</span>
        }
        <span class="cov8" title="1">rws.handlerDone = true
        w.Flush()
        w.rws = nil
        responseWriterStatePool.Put(rws)</span>
}

func (w *responseWriter) Flush() error <span class="cov8" title="1">{
        rws := w.rws
        if rws == nil </span><span class="cov0" title="0">{
                panic("Header called after Handler finished")</span>
        }
        <span class="cov8" title="1">if rws.bw.Buffered() &gt; 0 </span><span class="cov8" title="1">{
                if err := rws.bw.Flush(); err != nil </span><span class="cov8" title="1">{
                        // Ignore the error. The frame writer already knows.
                        return nil
                }</span>
        } else<span class="cov8" title="1"> {
                // The bufio.Writer won't call chunkWriter.Write
                // (writeChunk with zero bytes, so we have to do it
                // ourselves to force the HTTP response header and/or
                // final DATA frame (with END_STREAM) to be sent.
                rws.writeChunk(nil)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (w *responseWriter) CloseNotify() &lt;-chan bool <span class="cov8" title="1">{
        rws := w.rws
        if rws == nil </span><span class="cov0" title="0">{
                panic("CloseNotify called after Handler finished")</span>
        }
        <span class="cov8" title="1">rws.closeNotifierMu.Lock()
        ch := rws.closeNotifierCh
        if ch == nil </span><span class="cov8" title="1">{
                ch = make(chan bool, 1)
                rws.closeNotifierCh = ch
                go func() </span><span class="cov8" title="1">{
                        rws.stream.cw.Wait() // wait for close
                        ch &lt;- true
                }</span>()
        }
        <span class="cov8" title="1">rws.closeNotifierMu.Unlock()
        return ch</span>
}
</pre>
		
		<pre class="file" id="file241" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Copyright 2014 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// spdy connection for server side

package bfe_spdy

import (
        "errors"
        "fmt"
        "io"
        "net"
        "strings"
        "sync"
        "time"
)

import (
        "github.com/baidu/go-lib/gotrack"
        "github.com/baidu/go-lib/log"
)

import (
        http "github.com/bfenetworks/bfe/bfe_http"
        tls "github.com/bfenetworks/bfe/bfe_tls"
        "github.com/bfenetworks/bfe/bfe_util/pipe"
)

const (
        handlerChunkWriteSize = 4 &lt;&lt; 10
        // https://www.chromium.org/spdy/spdy-protocol/spdy-protocol-draft3-1
        // 2.6.4 SETTINGS, For implementors it is recommended that this value be no smaller than 100
        defaultMaxStreams             = 200
        defaultReadClientAgainTimeout = 60 * time.Second
)

var (
        errClientDisconnected = errors.New("client disconnected")
        errClosedBody         = errors.New("body closed by handler")
        errHandlerComplete    = errors.New("spdy: request body closed due to handler exiting")
        errHandlerPanic       = errors.New("spdy: request handler goroutine panic")
        errStreamClosed       = errors.New("spdy: stream closed")
)

// fix buffer for recv window
var fixBufferPool = sync.Pool{
        New: func() interface{} <span class="cov8" title="1">{
                buffer := make([]byte, initialWindowSize)
                return pipe.NewFixedBuffer(buffer)
        }</span>,
}

var (
        testHookOnPanicMu *sync.Mutex // nil except in tests
        testHookOnPanic   func(sc *serverConn, panicVal interface{}) (rePanic bool)
)

type Server struct {
        // MaxConcurrentStreams optionally specifies the number of
        // concurrent streams that each client may have open at a
        // time. This is unrelated to the number of http.Handler goroutines
        // which may be active globally, which is MaxHandlers.
        // If zero, MaxConcurrentStreams defaults to at least 100, per
        // the SPDY spec's recommendations.
        MaxConcurrentStreams uint32

        // MaxReadFrameSize optionally specifies the largest frame
        // this server is willing to read. A valid value is between
        // 16k and 16M, inclusive. If zero or otherwise invalid, a
        // default value is used.
        MaxReadFrameSize uint32
}

func (s *Server) maxReadFrameSize() uint32 <span class="cov0" title="0">{
        if v := s.MaxReadFrameSize; v &gt;= MinMaxFrameSize &amp;&amp; v &lt;= MaxFrameSize </span><span class="cov0" title="0">{
                return v
        }</span>
        <span class="cov0" title="0">return defaultMaxReadFrameSize</span>
}

func (s *Server) maxConcurrentStreams() uint32 <span class="cov8" title="1">{
        if v := s.MaxConcurrentStreams; v &gt; 0 </span><span class="cov8" title="1">{
                return v
        }</span>
        <span class="cov0" title="0">return defaultMaxStreams</span>
}

// NewProtoHandler creates TLS application level protocol handler for spdy
func NewProtoHandler(conf *Server) func(*http.Server, *tls.Conn, http.Handler) <span class="cov0" title="0">{
        if conf == nil </span><span class="cov0" title="0">{
                conf = new(Server)
        }</span>

        <span class="cov0" title="0">protoHandler := func(hs *http.Server, c *tls.Conn, h http.Handler) </span><span class="cov0" title="0">{
                // create and initial server conn
                if sc := conf.handleConn(hs, c, h); sc != nil </span><span class="cov0" title="0">{
                        // check conn rate limit
                        if !acceptConn() </span><span class="cov0" title="0">{
                                state.SpdyConnOverload.Inc(1)
                                sc.rejectConn("spdy overload")
                                return
                        }</span>

                        // process server conn
                        <span class="cov0" title="0">sc.serve()</span>
                }
        }
        <span class="cov0" title="0">return protoHandler</span>
}

func SetConnTimeout(body *RequestBody, d time.Duration) <span class="cov8" title="1">{
        sc := body.conn
        sc.serveG.CheckNotOn() // NOT on serve goroutine
        select </span>{
        // just send timeout value to chan
        case sc.timeoutValueCh &lt;- timeoutValueElem{
                tag:      ConnTag,
                rb:       body,
                duration: d,
        }:<span class="cov8" title="1"></span>
        case &lt;-sc.doneServing:<span class="cov0" title="0">
                return</span>
        }
}

func SetReadStreamTimeout(body *RequestBody, d time.Duration) <span class="cov8" title="1">{
        setStreamTimeout(ReadStreamTag, body, d)
}</span>

func SetWriteStreamTimeout(body *RequestBody, d time.Duration) <span class="cov8" title="1">{
        setStreamTimeout(WriteStreamTag, body, d)
}</span>

func setStreamTimeout(tag timeoutTag, body *RequestBody, d time.Duration) <span class="cov8" title="1">{
        sc := body.conn
        sc.serveG.CheckNotOn() // NOT on serve goroutine
        select </span>{
        // just send timeout value to chan
        case sc.timeoutValueCh &lt;- timeoutValueElem{
                tag:      tag,
                rb:       body,
                duration: d,
        }:<span class="cov8" title="1"></span>
        case &lt;-sc.doneServing:<span class="cov0" title="0">
                return</span>
        }
}

func (sc *serverConn) maxHeaderUriSize() uint32 <span class="cov8" title="1">{
        n := sc.hs.MaxHeaderUriBytes
        if n &lt;= 0 </span><span class="cov8" title="1">{
                n = http.DefaultMaxHeaderUriBytes
        }</span>

        <span class="cov8" title="1">return uint32(n)</span>
}

func (srv *Server) handleConn(hs *http.Server, c net.Conn, h http.Handler) *serverConn <span class="cov8" title="1">{
        sc := &amp;serverConn{
                srv:               srv,
                hs:                hs,
                conn:              c,
                remoteAddrStr:     c.RemoteAddr().String(),
                bw:                newBufferedWriter(c),
                handler:           h,
                streams:           make(map[uint32]*stream),
                recvChan:          make(chan readFrameResult),
                sendChan:          make(chan frameWriteMsg, 1),    // buffered; one recv in writeFrames
                wroteChan:         make(chan frameWriteResult, 1), // buffered; one send in writeFrames
                bodyReadCh:        make(chan bodyReadMsg),         // buffering doesn't matter either way
                writeMsgChan:      make(chan frameWriteMsg, 8),
                doneServing:       make(chan struct{}),
                closeNotifyCh:     hs.CloseNotifyCh,
                advMaxStreams:     srv.maxConcurrentStreams(),
                writeSched:        writeScheduler{maxFrameSize: defaultMaxWriteFrameSize},
                initialWindowSize: initialWindowSize,
                serveG:            gotrack.NewGoroutineLock(),

                readClientAgainTimeout: defaultReadClientAgainTimeout,
                timeoutEventCh:         make(chan timeoutEventElem, srv.maxConcurrentStreams()),
                timeoutValueCh:         make(chan timeoutValueElem, srv.maxConcurrentStreams()),
        }
        sc.flow.add(initialWindowSize)
        sc.inflow.add(initialWindowSize)

        fr, err := NewFramer(sc.bw, c)
        if err != nil </span><span class="cov0" title="0">{
                state.SpdyErrNewFramer.Inc(1)
                log.Logger.Debug("bfe_spdy: conn %s: NewFramer() err %s", sc.remoteAddrStr, err)
                return nil
        }</span>
        <span class="cov8" title="1">fr.MaxHeaderUriSize = sc.maxHeaderUriSize()

        sc.framer = fr

        if tc, ok := c.(*tls.Conn); ok </span><span class="cov0" title="0">{
                sc.tlsState = new(tls.ConnectionState)
                *sc.tlsState = tc.ConnectionState()
        }</span>
        <span class="cov8" title="1">return sc</span>
}

type serverConn struct {
        // Immutable:
        srv           *Server
        hs            *http.Server
        conn          net.Conn
        bw            *bufferedWriter // writing to conn
        handler       http.Handler
        framer        *Framer
        doneServing   chan struct{}         // closed when serverConn.serve ends
        recvChan      chan readFrameResult  // written by serverConn.readFrames
        sendChan      chan frameWriteMsg    // from serve -&gt; writeFrames
        wroteChan     chan frameWriteResult // from writeFrames -&gt; serve, tickles more frame writes
        bodyReadCh    chan bodyReadMsg      // from handlers -&gt; serve
        writeMsgChan  chan frameWriteMsg    // from handlers -&gt; serve
        closeNotifyCh chan bool             // from outside -&gt; serve
        flow          flow                  // conn-wide (not stream-specific) outbound flow control
        inflow        flow                  // conn-wide inbound flow control
        tlsState      *tls.ConnectionState  // shared by all handlers, like net/http
        remoteAddrStr string

        // Everything following is owned by the serve loop; use serveG.Check():
        serveG            gotrack.GoroutineLock // used to verify funcs are on serve()
        advMaxStreams     uint32                // our SETTINGS_MAX_CONCURRENT_STREAMS advertised the client
        curOpenStreams    uint32                // client's number of open streams
        maxStreamID       uint32                // max ever seen
        streams           map[uint32]*stream    // stream table
        initialWindowSize int32
        writingFrame      bool // started write frame but haven't heard back on wroteChan
        needsFrameFlush   bool // last frame write wasn't a flush
        writeSched        writeScheduler
        inGoAway          bool // we've started to or sent GOAWAY
        needToSendGoAway  bool // we need to schedule a GOAWAY frame write
        goAwayCode        GoAwayStatus
        shutdownTimerCh   &lt;-chan time.Time // nil until used
        shutdownTimer     *time.Timer      // nil until used

        // how long to wait when there is no request processing on the connection
        // it is updated once ServeHTTP() routine found a request is finished
        // but only used when connection become idle(no left request if processing)
        readClientAgainTimeout time.Duration

        // when timeout, timer hook write to chan
        // main routine read from chan
        timeoutEventCh chan timeoutEventElem

        // when save timeout, ServeHTTP() routine write to chan
        // main routine read from chan
        timeoutValueCh chan timeoutValueElem
}

// timeout event
type timeoutEventElem struct {
        tag      timeoutTag
        streamID uint32
}

// timeout value
type timeoutValueElem struct {
        tag      timeoutTag
        rb       *RequestBody
        duration time.Duration
}

// stream represents a stream. This is the minimal metadata needed by
// the serve goroutine. Most of the actual stream state is owned by
// the http.Handler's goroutine in the responseWriter. Because the
// responseWriter's responseWriterState is recycled at the end of a
// handler, this struct intentionally has no pointer to the
// *responseWriter{,State} itself, as the Handler ending nils out the
// responseWriter's state field.
type stream struct {
        // immutable:
        id   uint32      // stream id
        body *pipe.Pipe  // non-nil if expecting DATA frames
        cw   closeWaiter // closed wait stream transitions to closed state

        // owned by serverConn's serve loop:
        bodyBytes     int64 // body bytes seen so far
        declBodyBytes int64 // or -1 if undeclared
        flow          flow  // limits writing from Handler to client
        inflow        flow  // what the client is allowed to POST/etc to us
        weight        uint8
        state         streamState
        sentReset     bool // only true once detached from streams map
        gotReset      bool // only true once detacted from streams map

        // timeout timer, used both for TimeoutReadClient and TimeoutWriteClient
        // need to stop if it is not timeout
        timeoutTimer *time.Timer
}

// readFrameResult is the message passed from readFrames goroutine to the serve goroutine.
type readFrameResult struct {
        f   Frame
        err error
}

// readFrames is the loop that reads incoming frames.
// It's run on its own goroutine.
func (sc *serverConn) readFrames() <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                f, err := sc.framer.ReadFrame()
                if err == nil &amp;&amp; f != nil </span><span class="cov8" title="1">{
                        if _, ok := f.(*SynStreamFrame); ok </span><span class="cov8" title="1">{
                                // no timeout till now, cancel read timeout
                                var zero time.Time
                                sc.conn.SetReadDeadline(zero)
                        }</span>
                }

                <span class="cov8" title="1">select </span>{
                case sc.recvChan &lt;- readFrameResult{f, err}:<span class="cov8" title="1"></span>
                case &lt;-sc.doneServing:<span class="cov8" title="1">
                        return</span>
                }
        }
}

// frameWriteResult is the message passed from writeFrames to the serve goroutine.
type frameWriteResult struct {
        wm  frameWriteMsg // what was written (or attempted)
        err error         // result of the writeFrame call
}

// writeFrames runs in its own goroutine and writes frame
// and then reports when it's done.
// At most one frame can be added to sendChan per serverConn.
func (sc *serverConn) writeFrames() <span class="cov8" title="1">{
        var wm frameWriteMsg
        var err error
        defer sc.framer.ReleaseWriter()

        for </span><span class="cov8" title="1">{
                // get frame from sendChan
                select </span>{
                case wm = &lt;-sc.sendChan:<span class="cov8" title="1"></span>
                case &lt;-sc.doneServing:<span class="cov8" title="1">
                        return</span>
                }

                // write frame
                <span class="cov8" title="1">switch wm.frame.(type) </span>{
                case *FlushFrame:<span class="cov8" title="1">
                        err = sc.Flush()</span>

                default:<span class="cov8" title="1">
                        err = sc.framer.WriteFrame(wm.frame)</span>
                }

                // report write result
                <span class="cov8" title="1">select </span>{
                case sc.wroteChan &lt;- frameWriteResult{wm, err}:<span class="cov8" title="1"></span>
                case &lt;-sc.doneServing:<span class="cov8" title="1">
                        return</span>
                }
        }
}

// Note: should not be called after serve() conn
func (sc *serverConn) rejectConn(debug string) <span class="cov0" title="0">{
        log.Logger.Info("bfe_spdy: server rejecting conn: %s", debug)
        // ignoring errors. hanging up anyway.
        // If no streams were replied to, last-good-streams-id Must be 0.
        // See Spdy Protocol(draft-mbelshe-httpbis-spdy-00) Section 2.6.6
        sc.framer.WriteFrame(&amp;GoAwayFrame{Status: GoAwayOK})
        sc.bw.Flush()
        sc.conn.Close()
        sc.framer.ReleaseWriter()
}</span>

func (sc *serverConn) serve() <span class="cov8" title="1">{
        sc.serveG.Check()
        defer sc.notePanic()
        defer sc.conn.Close()
        defer sc.closeAllStreamsOnConnClose()
        defer sc.stopShutdownTimer()
        defer close(sc.doneServing) // unblocks handlers trying to send

        log.Logger.Debug("bfe_spdy: SPDY connection from %v on %p", sc.conn.RemoteAddr(), sc.hs)

        // set read client timeout for the first request on connection
        sc.conn.SetReadDeadline(time.Now().Add(sc.hs.ReadTimeout))

        settings := new(SettingsFrame)
        settings.FlagIdValues = []SettingsFlagIdValue{
                {0, SettingsInitialWindowSize, uint32(sc.initialWindowSize)},
                // we don't set MaxConcurrentStreams in setting frame here, because some browser
                // such as chrome version 48.0.2564.116 (64-bit) won't recognize it, and the
                // connection will be broken.
                //{0, SettingsMaxConcurrentStreams, uint32(sc.advMaxStreams)},
        }
        sc.writeFrame(frameWriteMsg{frame: settings})

        // Get us out of the"StateNew" state.  We can't go directly to idle, though.
        // Active means we read some data and anticipate a request. We'll
        // do another Active when we get a SYN_STREAM frame.
        sc.setConnState(http.StateActive)
        sc.setConnState(http.StateIdle)

        go sc.readFrames()  // closed by defer sc.conn.Close above
        go sc.writeFrames() // closed by defer sc.conn.Close above

        for </span><span class="cov8" title="1">{
                select </span>{
                case res := &lt;-sc.recvChan:<span class="cov8" title="1">
                        if !sc.processFrameFromReader(res) </span><span class="cov8" title="1">{
                                return
                        }</span>
                case m := &lt;-sc.bodyReadCh:<span class="cov8" title="1">
                        sc.noteBodyRead(m.st, m.n)</span>
                case wm := &lt;-sc.writeMsgChan:<span class="cov8" title="1">
                        if !sc.writeFrame(wm) </span><span class="cov8" title="1">{
                                return
                        }</span>
                case res := &lt;-sc.wroteChan:<span class="cov8" title="1">
                        sc.wroteFrame(res)</span>
                case &lt;-sc.shutdownTimerCh:<span class="cov0" title="0">
                        log.Logger.Debug("bfe_spdy: GOAWAY close timer fired; closing conn from %v",
                                sc.conn.RemoteAddr())
                        return</span>
                case ch := &lt;-sc.timeoutEventCh:<span class="cov8" title="1"> // timeout event happens
                        sc.handleTimeout(ch)</span>
                case v := &lt;-sc.timeoutValueCh:<span class="cov8" title="1"> // get timeout value update notification
                        // set timeout value
                        sc.setTimeout(v)</span>
                case &lt;-sc.closeNotifyCh:<span class="cov0" title="0"> // graceful shutdown
                        log.Logger.Debug("bfe_spdy: graceful closing spdy conn from %v", sc.conn.RemoteAddr())
                        sc.closeNotifyCh = nil
                        sc.goAway(GoAwayOK)</span>
                }
        }
}

// hand timeout event for stream timeout, stream timeout, rst stream
func (sc *serverConn) handleTimeout(ch timeoutEventElem) <span class="cov8" title="1">{
        tag := ch.tag
        log.Logger.Debug("bfe_spdy: %s timeout, resetting frame id[%d] from %v",
                tag.String(), ch.streamID, sc.conn.RemoteAddr())
        // stream timeout, rst the stream
        errRst := StreamError{ch.streamID, ProtocolError}
        sc.resetStream(errRst)
}</span>

func (sc *serverConn) setTimeout(elem timeoutValueElem) <span class="cov8" title="1">{
        tag := elem.tag
        rb := elem.rb
        duration := elem.duration
        stream := rb.stream

        if sc != rb.conn </span><span class="cov0" title="0">{
                // there Must be some error, panic
                panic("internal error: bad request body")</span>
        }

        <span class="cov8" title="1">if tag == ConnTag </span><span class="cov8" title="1">{
                // just update timeout value here
                sc.readClientAgainTimeout = duration
        }</span>
        <span class="cov8" title="1">if (tag == ReadStreamTag &amp;&amp; stream.body != nil) || tag == WriteStreamTag </span><span class="cov8" title="1">{
                // just launch timeout timer for TimeoutReadClient/TimeoutWriteClient
                stream.timeoutTimer = time.AfterFunc(duration, func() </span><span class="cov8" title="1">{
                        select </span>{
                        // timer hook: send timeout event to chan
                        case sc.timeoutEventCh &lt;- timeoutEventElem{
                                streamID: stream.id,
                                tag:      tag,
                        }:<span class="cov8" title="1"></span>
                        case &lt;-sc.doneServing:<span class="cov0" title="0">
                                return</span>
                        }
                        <span class="cov8" title="1">if tag == ReadStreamTag </span><span class="cov8" title="1">{
                                state.SpdyTimeoutReadStream.Inc(1)
                        }</span>
                        <span class="cov8" title="1">if tag == WriteStreamTag </span><span class="cov8" title="1">{
                                state.SpdyTimeoutWriteStream.Inc(1)
                        }</span>
                })
        }
}

// processFrameFromReader processes the serve loop's read from recvChan from the
// frame-reading goroutine.
// processFrameFromReader returns whether the connection should be kept open.
func (sc *serverConn) processFrameFromReader(res readFrameResult) bool <span class="cov8" title="1">{
        sc.serveG.Check()
        err := res.err
        if err != nil </span><span class="cov8" title="1">{
                //TODO: check errFrameTooLarge
                clientGone := err == io.EOF || strings.Contains(err.Error(), "use of closed network connection")
                if clientGone </span><span class="cov8" title="1">{
                        // TODO: could we also get into this state if
                        // the peer does a half close
                        // (e.g. CloseWrite) because they're done
                        // sending frames but they're still wanting
                        // our open replies?  Investigate.
                        return false
                }</span>
        } else<span class="cov8" title="1"> {
                f := res.f
                log.Logger.Debug("bfe_spdy: got frame: %#v", f)
                err = sc.processFrame(f)
                if err == nil </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        <span class="cov8" title="1">switch ev := err.(type) </span>{
        case net.Error:<span class="cov8" title="1">
                if ev.Timeout() </span><span class="cov8" title="1">{
                        state.SpdyTimeoutConn.Inc(1)
                        log.Logger.Debug("bfe_spdy: conn timeout from %v, closing the conn.",
                                sc.conn.RemoteAddr())
                }</span>
                <span class="cov8" title="1">return false</span>
        case StreamError:<span class="cov8" title="1">
                sc.resetStream(ev)
                return true</span>
        case goAwayFlowError:<span class="cov8" title="1">
                sc.goAway(GoAwayStatus(FlowControlError))
                return true</span>
        case ConnectionError:<span class="cov0" title="0">
                log.Logger.Debug("bfe_spdy: %v: %v", sc.conn.RemoteAddr(), ev)
                sc.goAway(GoAwayStatus(ev))
                return true</span> // goAway will handle shutdown
        default:<span class="cov8" title="1">
                if res.err != nil </span><span class="cov0" title="0">{
                        log.Logger.Debug("bfe_spdy: disconnecting; error reading frame from client %s: %v",
                                sc.conn.RemoteAddr(), err)
                }</span> else<span class="cov8" title="1"> {
                        log.Logger.Debug("bfe_spdy: disconnection due to other error: %v", err)
                }</span>
                <span class="cov8" title="1">return false</span>
        }
}

// writeFrame schedules a frame to write and sends it if there's nothing
// already being written.
//
// There is no pushback here (the serve goroutine never blocks). It's
// the http.Handlers that block, waiting for their previous frames to
// make it onto the wire
//
// If you're not on the serve goroutine, use writeFrameFromHandler instead.
//
// writeFrame returns whether the connection should be kept open.
func (sc *serverConn) writeFrame(wm frameWriteMsg) bool <span class="cov8" title="1">{
        sc.serveG.Check()

        // process special frame
        switch wm.frame.(type) </span>{
        case *PanicFrame:<span class="cov0" title="0">
                sc.closeStream(wm.stream, errHandlerPanic)
                return true</span>
        case *FinFrame:<span class="cov8" title="1">
                return false</span>
        }

        <span class="cov8" title="1">sc.writeSched.add(wm)
        sc.scheduleFrameWrite()
        return true</span>
}

// scheduleFrameWrite tickles the frame writing scheduler.
func (sc *serverConn) scheduleFrameWrite() <span class="cov8" title="1">{
        sc.serveG.Check()

        // If a frame is already being written, nothing happens. This will be called again
        // when the frame is done being written.
        if sc.writingFrame </span><span class="cov8" title="1">{
                return
        }</span>

        // If a frame isn't being written we need to send one, the best frame
        // to send is selected, preferring first things that aren't
        // stream-specific (e.g. GoAway frame), and then finding the
        // highest priority stream.
        <span class="cov8" title="1">if sc.needToSendGoAway </span><span class="cov8" title="1">{
                sc.needToSendGoAway = false
                sc.startFrameWrite(frameWriteMsg{
                        frame: &amp;GoAwayFrame{
                                LastGoodStreamId: StreamId(sc.maxStreamID),
                                Status:           sc.goAwayCode,
                        },
                })
                return
        }</span>
        <span class="cov8" title="1">if !sc.inGoAway || sc.goAwayCode == GoAwayOK </span><span class="cov8" title="1">{
                if wm, ok := sc.writeSched.take(); ok </span><span class="cov8" title="1">{
                        sc.startFrameWrite(wm)
                        return
                }</span>
        }

        // If a frame isn't being written and there's nothing else to send, we
        // flush the write buffer.
        <span class="cov8" title="1">if sc.needsFrameFlush </span><span class="cov8" title="1">{
                sc.startFrameWrite(frameWriteMsg{frame: &amp;FlushFrame{}})
                sc.needsFrameFlush = false // after startFrameWrite, since it sets this true
                return
        }</span>
}

// startFrameWrite starts a goroutine to write wm (in a separate
// goroutine since that might block on the network), and updates the
// serve goroutine's state about the world, updated from info in wm.
func (sc *serverConn) startFrameWrite(wm frameWriteMsg) <span class="cov8" title="1">{
        sc.serveG.Check()
        if sc.writingFrame </span><span class="cov0" title="0">{
                panic("internal error: can only be writing one frame at a time")</span>
        }

        <span class="cov8" title="1">st := wm.stream
        if st != nil </span><span class="cov8" title="1">{
                switch st.state </span>{
                case stateHalfClosedLocal:<span class="cov0" title="0">
                        panic("internal error: attempt to send frame on half-closed-local stream")</span>
                case stateClosed:<span class="cov8" title="1">
                        if st.sentReset || st.gotReset </span><span class="cov8" title="1">{
                                // Skip this frame.
                                sc.scheduleFrameWrite()
                                return
                        }</span>
                        <span class="cov0" title="0">panic(fmt.Sprintf("internal error: attempt to send a write %v on a closed stream", wm))</span>
                }
        }

        <span class="cov8" title="1">sc.writingFrame = true
        sc.needsFrameFlush = true
        sc.sendChan &lt;- wm</span>
}

// wroteFrame is called on the serve goroutine with the result of
// whatever happened on writeFrames.
func (sc *serverConn) wroteFrame(res frameWriteResult) <span class="cov8" title="1">{
        sc.serveG.Check()
        if !sc.writingFrame </span><span class="cov0" title="0">{
                panic("internal error: expected to be already writing a frame")</span>
        }
        <span class="cov8" title="1">sc.writingFrame = false

        wm := res.wm
        st := wm.stream

        closeStream := endsStream(wm.frame)

        // Reply (if requested) to the blocked ServeHTTP goroutine.
        if ch := wm.done; ch != nil </span><span class="cov8" title="1">{
                select </span>{
                case ch &lt;- res.err:<span class="cov8" title="1"></span>
                default:<span class="cov0" title="0">
                        panic(fmt.Sprintf("unbuffered done channel passed in for type %T", wm.frame))</span>
                }
        }

        <span class="cov8" title="1">wm.frame = nil // prevent use (assume it's tainted after wm.done send)

        if closeStream </span><span class="cov8" title="1">{
                if st == nil </span><span class="cov0" title="0">{
                        panic("internal error: expecting non-nil stream")</span>
                }
                <span class="cov8" title="1">switch st.state </span>{
                case stateOpen:<span class="cov0" title="0">
                        // Here we would go to stateHalfClosedLocal in
                        // theory, but since our handler is done and
                        // the net/http package provides no mechanism
                        // for finishing writing to a ResponseWriter
                        // while still reading data, we go into closed
                        // state here anyway, after telling the peer
                        // we're hanging up on them.
                        st.state = stateHalfClosedLocal // won't last long, but necessary for closeStream via resetStream
                        errCancel := StreamError{st.id, Cancel}
                        sc.resetStream(errCancel)
                        state.SpdyErrStreamCancel.Inc(1)</span>
                case stateHalfClosedRemote:<span class="cov8" title="1">
                        sc.closeStream(st, errHandlerComplete)</span>
                }
        }

        <span class="cov8" title="1">sc.scheduleFrameWrite()</span>
}

// endsStream reports whether the given frame writer w will locally
// close the stream.
func endsStream(w Frame) bool <span class="cov8" title="1">{
        switch v := w.(type) </span>{
        case *DataFrame:<span class="cov8" title="1">
                return (v.Flags &amp; DataFlagFin) != 0</span>
        case *SynReplyFrame:<span class="cov8" title="1">
                return (v.CFHeader.Flags &amp; ControlFlagFin) != 0</span>
        case nil:<span class="cov0" title="0">
                // This can only happen if the caller reuses w after it's
                // been intentionally nil'ed out to prevent use. Keep this
                // here to catch future refactoring breaking it.
                panic("endsStream called on nil writeFramer")</span>
        }
        <span class="cov8" title="1">return false</span>
}

func (sc *serverConn) goAway(code GoAwayStatus) <span class="cov8" title="1">{
        sc.serveG.Check()
        if sc.inGoAway </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if code != GoAwayOK </span><span class="cov8" title="1">{
                sc.shutDownIn(250 * time.Millisecond)
        }</span> else<span class="cov0" title="0"> {
                sc.shutDownIn(sc.hs.GracefulShutdownTimeout)
        }</span>
        <span class="cov8" title="1">sc.inGoAway = true
        sc.needToSendGoAway = true
        sc.goAwayCode = code
        sc.scheduleFrameWrite()</span>
}

func (sc *serverConn) shutDownIn(d time.Duration) <span class="cov8" title="1">{
        sc.serveG.Check()
        sc.shutdownTimer = time.NewTimer(d)
        sc.shutdownTimerCh = sc.shutdownTimer.C
}</span>

func (sc *serverConn) resetStream(se StreamError) <span class="cov8" title="1">{
        sc.serveG.Check()
        sc.writeFrame(frameWriteMsg{
                frame: &amp;RstStreamFrame{
                        StreamId: StreamId(se.StreamID),
                        Status:   se.Code,
                },
        })
        if st, ok := sc.streams[se.StreamID]; ok </span><span class="cov8" title="1">{
                st.sentReset = true
                sc.closeStream(st, se)
        }</span>
}

func (sc *serverConn) CloseConn() error <span class="cov0" title="0">{
        return sc.conn.Close()
}</span>

func (sc *serverConn) Flush() error <span class="cov8" title="1">{
        return sc.bw.Flush()
}</span>

func (sc *serverConn) closeStream(st *stream, err error) <span class="cov8" title="1">{
        sc.serveG.Check()
        if st.state == stateIdle || st.state == stateClosed </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("invariant; can't close stream in state %v", st.state))</span>
        }
        <span class="cov8" title="1">if t := st.timeoutTimer; t != nil </span><span class="cov8" title="1">{
                t.Stop()
        }</span>

        <span class="cov8" title="1">st.state = stateClosed
        sc.curOpenStreams--
        if sc.curOpenStreams == 0 </span><span class="cov8" title="1">{
                // no request processing on the conn, set read client again timeout
                sc.setReadClientAgainTimeout()
                sc.setConnState(http.StateIdle)
        }</span>
        <span class="cov8" title="1">delete(sc.streams, st.id)
        if p := st.body; p != nil </span><span class="cov8" title="1">{
                p.CloseWithError(err)
                p.Release(&amp;fixBufferPool)
        }</span>
        <span class="cov8" title="1">st.cw.Close() // signals Handler's CloseNotifier, unblocks writes, etc
        sc.writeSched.forgetStream(st.id)</span>
}

func (sc *serverConn) setReadClientAgainTimeout() <span class="cov8" title="1">{
        t := time.Now().Add(sc.readClientAgainTimeout)
        sc.conn.SetReadDeadline(t)
}</span>

func (sc *serverConn) closeAllStreamsOnConnClose() <span class="cov8" title="1">{
        sc.serveG.Check()
        for _, st := range sc.streams </span><span class="cov8" title="1">{
                sc.closeStream(st, errClientDisconnected)
        }</span>
}

func (sc *serverConn) stopShutdownTimer() <span class="cov8" title="1">{
        sc.serveG.Check()
        if t := sc.shutdownTimer; t != nil </span><span class="cov8" title="1">{
                t.Stop()
        }</span>
}

func (sc *serverConn) notePanic() <span class="cov8" title="1">{
        if e := recover(); e != nil </span><span class="cov0" title="0">{
                state.SpdyPanicConn.Inc(1)
                if testHookOnPanicMu != nil </span><span class="cov0" title="0">{
                        testHookOnPanicMu.Lock()
                        defer testHookOnPanicMu.Unlock()
                }</span>
                <span class="cov0" title="0">if testHookOnPanic != nil </span><span class="cov0" title="0">{
                        if testHookOnPanic(sc, e) </span><span class="cov0" title="0">{
                                panic(e)</span>
                        }
                }
        }
}

func (sc *serverConn) state(streamID uint32) (streamState, *stream) <span class="cov8" title="1">{
        sc.serveG.Check()
        if st, ok := sc.streams[streamID]; ok </span><span class="cov8" title="1">{
                return st.state, st
        }</span>
        // The first use of a new stream identifier implicitly closes all
        // streams in the "idle" state that might have been initiated by
        // that peer with a lower-valued stream identifier. For example, if
        // a client sends a SynStream frame on stream 7 without ever sending a
        // frame on stream 5, then stream 5 transitions to the "closed"
        // state when the first frame for stream 7 is sent or received.
        <span class="cov8" title="1">if streamID &lt;= sc.maxStreamID </span><span class="cov8" title="1">{
                return stateClosed, nil
        }</span>
        <span class="cov0" title="0">return stateIdle, nil</span>
}

// setConnState calls the net/http ConnState hook for this connection, if configured.
// Note that the net/http package does StateNew and StateClosed for us.
// There is currently no plan for StateHijacked or hijacking spdy connections.
func (sc *serverConn) setConnState(state http.ConnState) <span class="cov8" title="1">{
        if sc.hs.ConnState != nil </span><span class="cov0" title="0">{
                sc.hs.ConnState(sc.conn, state)
        }</span>
}

// writeHeaders writes response header to specified stream.
// Note: called from handler goroutines
func (sc *serverConn) writeHeaders(st *stream, status int, header http.Header, endStream bool) error <span class="cov8" title="1">{
        sc.serveG.CheckNotOn() // NOT on serve goroutine

        // prepare SynReplyFrame
        frame := &amp;SynReplyFrame{StreamId: StreamId(st.id), Headers: header}
        if frame.Headers == nil </span><span class="cov8" title="1">{
                frame.Headers = make(http.Header)
        }</span>
        <span class="cov8" title="1">frame.Headers.Set(":status", fmt.Sprintf("%d", status))
        frame.Headers.Set(":version", "HTTP/1.1")
        for field := range invalidRespHeaders </span><span class="cov8" title="1">{
                frame.Headers.Del(field)
        }</span>
        <span class="cov8" title="1">if endStream </span><span class="cov8" title="1">{
                frame.CFHeader.Flags = ControlFlagFin
        }</span>

        <span class="cov8" title="1">errc := make(chan error, 1)

        // request for writing SynReplyFrame
        if err := sc.writeFrameFromHandler(frameWriteMsg{
                frame:  frame,
                stream: st,
                done:   errc,
        }); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // wait for write result
        <span class="cov8" title="1">select </span>{
        case err := &lt;-errc:<span class="cov8" title="1">
                return err</span>
        case &lt;-sc.doneServing:<span class="cov8" title="1">
                return errClientDisconnected</span>
        case &lt;-st.cw:<span class="cov8" title="1">
                return errStreamClosed</span>
        }
}

// write100ContinueHeaders writes 100 continue response to specified stream.
// Note: called from handler goroutines
func (sc *serverConn) write100ContinueHeaders(st *stream) <span class="cov8" title="1">{
        sc.serveG.CheckNotOn() // NOT on serve goroutine

        header := make(http.Header)
        header.Set(":status", "100")
        header.Set(":version", "HTTP/1.1")
        sc.writeFrameFromHandler(frameWriteMsg{
                frame:  &amp;SynReplyFrame{StreamId: StreamId(st.id), Headers: header},
                stream: st,
        })
}</span>

// writeDataFromHandler writes DATA response frames from a handler on the given stream.
// Note: called from handler goroutines
func (sc *serverConn) writeDataFromHandler(stream *stream, data []byte, endStream bool) error <span class="cov8" title="1">{
        sc.serveG.CheckNotOn() // NOT on serve goroutine

        // prepare DataFrame
        frame := &amp;DataFrame{
                StreamId: StreamId(stream.id),
                Data:     data,
        }
        if endStream </span><span class="cov8" title="1">{
                frame.Flags = DataFlagFin
        }</span>
        <span class="cov8" title="1">errc := make(chan error, 1)

        // request for writing DataFrame
        err := sc.writeFrameFromHandler(frameWriteMsg{
                frame:  frame,
                stream: stream,
                done:   errc,
        })
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // wait for write result
        <span class="cov8" title="1">select </span>{
        case err = &lt;-errc:<span class="cov8" title="1">
                return err</span>
        case &lt;-sc.doneServing:<span class="cov8" title="1">
                return errClientDisconnected</span>
        case &lt;-stream.cw:<span class="cov8" title="1">
                // If both ch and stream.cw were ready (as might
                // happen on the final Write after an http.Handler
                // ends), prefer the write result. Otherwise this
                // might just be us successfully closing the stream.
                // The writeFrames and serve goroutines guarantee
                // that the ch send will happen before the stream.cw
                // close.
                select </span>{
                case err = &lt;-errc:<span class="cov0" title="0">
                        return err</span>
                default:<span class="cov8" title="1">
                        return errStreamClosed</span>
                }
        }
}

// writeFrameFromHandler sends wm to sc.writeMsgChan, but aborts
// if the connection has gone away.
//
// This must not be run from the serve goroutine itself, else it might
// deadlock writing to sc.writeMsgChan (which is only mildly
// buffered and is read by serve itself). If you're on the serve
// goroutine, call writeFrame instead.
func (sc *serverConn) writeFrameFromHandler(wm frameWriteMsg) error <span class="cov8" title="1">{
        sc.serveG.CheckNotOn() // NOT on serve goroutine
        select </span>{
        case sc.writeMsgChan &lt;- wm:<span class="cov8" title="1">
                return nil</span>
        case &lt;-sc.doneServing:<span class="cov8" title="1">
                // Serve loop is gone.
                // Client has closed their connection to the server.
                return errClientDisconnected</span>
        }
}

// Close requests serverConn to finish
func (sc *serverConn) Close() <span class="cov8" title="1">{
        sc.serveG.CheckNotOn() // NOT on serve goroutine
        sc.writeFrameFromHandler(frameWriteMsg{frame: &amp;FinFrame{}})
}</span>
</pre>
		
		<pre class="file" id="file242" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Copyright 2014 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package bfe_spdy

// A bodyReadMsg tells the server loop that the http.Handler read n
// bytes of the DATA from the client on the given stream.
type bodyReadMsg struct {
        st *stream
        n  int
}

// called from handler goroutines.
// Notes that the handler for the given stream ID read n bytes of its body
// and schedules flow control tokens to be sent.
func (sc *serverConn) noteBodyReadFromHandler(st *stream, n int) <span class="cov8" title="1">{
        sc.serveG.CheckNotOn() // NOT on
        select </span>{
        case sc.bodyReadCh &lt;- bodyReadMsg{st, n}:<span class="cov8" title="1"></span>
        case &lt;-sc.doneServing:<span class="cov0" title="0"></span>
        }
}

func (sc *serverConn) noteBodyRead(st *stream, n int) <span class="cov8" title="1">{
        sc.serveG.Check()
        sc.sendWindowUpdate(nil, n) // conn-level
        if st.state != stateHalfClosedRemote &amp;&amp; st.state != stateClosed </span><span class="cov8" title="1">{
                // Don't send this WINDOW_UPDATE if the stream is closed
                // remotely.
                sc.sendWindowUpdate(st, n)
        }</span>
}

// st may be nil for conn-level
func (sc *serverConn) sendWindowUpdate(st *stream, n int) <span class="cov8" title="1">{
        sc.serveG.Check()
        // "The legal range for the increment to the flow control
        // window is 1 to 2^31-1 (2,147,483,647) octets."
        // A Go Read call on 64-bit machines could in theory read
        // a larger Read than this. Very unlikely, but we handle it here
        // rather than elsewhere for now.
        const maxUint31 = 1&lt;&lt;31 - 1
        for n &gt;= maxUint31 </span><span class="cov0" title="0">{
                sc.sendWindowUpdate32(st, maxUint31)
                n -= maxUint31
        }</span>
        <span class="cov8" title="1">sc.sendWindowUpdate32(st, int32(n))</span>
}

// st may be nil for conn-level
func (sc *serverConn) sendWindowUpdate32(st *stream, n int32) <span class="cov8" title="1">{
        sc.serveG.Check()
        if n == 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if n &lt; 0 </span><span class="cov0" title="0">{
                panic("negative update")</span>
        }
        <span class="cov8" title="1">var streamID uint32
        if st != nil </span><span class="cov8" title="1">{
                streamID = st.id
        }</span>

        <span class="cov8" title="1">frame := WindowUpdateFrame{StreamId: StreamId(streamID), DeltaWindowSize: uint32(n)}
        sc.writeFrame(frameWriteMsg{frame: &amp;frame, stream: st})

        var ok bool
        if st == nil </span><span class="cov8" title="1">{
                ok = sc.inflow.add(n)
        }</span> else<span class="cov8" title="1"> {
                ok = st.inflow.add(n)
        }</span>
        <span class="cov8" title="1">if !ok </span><span class="cov0" title="0">{
                panic("internal error; sent too many window updates without decrements?")</span>
        }
}
</pre>
		
		<pre class="file" id="file243" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Copyright 2014 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package bfe_spdy

import (
        "fmt"
        "io"
        "net/url"
        "strconv"
        "strings"
        "time"
)

import (
        "github.com/baidu/go-lib/gotrack"
        "github.com/baidu/go-lib/log"
)

import (
        http "github.com/bfenetworks/bfe/bfe_http"
        tls "github.com/bfenetworks/bfe/bfe_tls"
        "github.com/bfenetworks/bfe/bfe_util/pipe"
)

func (sc *serverConn) processFrame(f Frame) error <span class="cov8" title="1">{
        sc.serveG.Check()

        switch f := f.(type) </span>{
        case *SynStreamFrame:<span class="cov8" title="1">
                return sc.processSynStream(f)</span>
        case *DataFrame:<span class="cov8" title="1">
                return sc.processData(f)</span>
        case *WindowUpdateFrame:<span class="cov8" title="1">
                return sc.processWindowUpdate(f)</span>
        case *RstStreamFrame:<span class="cov8" title="1">
                return sc.processResetStream(f)</span>
        case *SettingsFrame:<span class="cov8" title="1">
                return sc.processSettings(f)</span>
        case *PingFrame:<span class="cov8" title="1">
                return sc.processPing(f)</span>
        default:<span class="cov0" title="0">
                state.SpdyUnknownFrame.Inc(1)
                log.Logger.Debug("bfe_spdy: Ignoring frame: %v", f)
                return nil</span>
        }
}

func (sc *serverConn) processPing(f *PingFrame) error <span class="cov8" title="1">{
        sc.serveG.Check()
        if f.Id%2 == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">sc.writeFrame(frameWriteMsg{frame: f})
        return nil</span>
}

func (sc *serverConn) processWindowUpdate(f *WindowUpdateFrame) error <span class="cov8" title="1">{
        sc.serveG.Check()
        switch </span>{
        case f.StreamId != 0:<span class="cov8" title="1"> // stream-level flow control
                st := sc.streams[uint32(f.StreamId)]
                if st == nil </span><span class="cov0" title="0">{
                        // "A sender should ignore all the WINDOW_UPDATE frames
                        // associated with the stream after it send the last frame
                        // for the stream, see Section 2.6.8"
                        return nil
                }</span>
                <span class="cov8" title="1">if !st.flow.add(int32(f.DeltaWindowSize)) </span><span class="cov0" title="0">{
                        state.SpdyErrFlowControl.Inc(1)
                        return StreamError{uint32(f.StreamId), FlowControlError}
                }</span>
        default:<span class="cov8" title="1"> // connection-level flow control
                if !sc.flow.add(int32(f.DeltaWindowSize)) </span><span class="cov8" title="1">{
                        state.SpdyErrFlowControl.Inc(1)
                        return goAwayFlowError{}
                }</span>
        }
        <span class="cov8" title="1">sc.scheduleFrameWrite()
        return nil</span>
}

func (sc *serverConn) processResetStream(f *RstStreamFrame) error <span class="cov8" title="1">{
        sc.serveG.Check()

        streamState, st := sc.state(uint32(f.StreamId))
        if streamState == stateIdle </span><span class="cov0" title="0">{
                // RST_STREAM frames MUST NOT be sent for a
                // stream in the "idle" state. If a RST_STREAM frame
                // identifying an idle stream is received, the
                // recipient MUST treat this as a connection error
                // of type PROTOCOL_ERROR.
                return ConnectionError(ProtocolError)
        }</span>
        <span class="cov8" title="1">if st != nil </span><span class="cov8" title="1">{
                state.SpdyErrGotReset.Inc(1)
                st.gotReset = true
                sc.closeStream(st, StreamError{uint32(f.StreamId), f.Status})
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (sc *serverConn) processSettings(f *SettingsFrame) error <span class="cov8" title="1">{
        sc.serveG.Check()
        for _, setting := range f.FlagIdValues </span><span class="cov8" title="1">{
                if err := sc.processSetting(setting); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (sc *serverConn) processSetting(s SettingsFlagIdValue) error <span class="cov8" title="1">{
        sc.serveG.Check()
        log.Logger.Debug("bfe_spdy: processing setting %v", s)
        switch s.Id </span>{
        case SettingsInitialWindowSize:<span class="cov8" title="1">
                return sc.processSettingInitialWindowSize(s.Value)</span>
        default:<span class="cov0" title="0"></span>
                // ignore unknown setting
        }
        <span class="cov0" title="0">return nil</span>
}

func (sc *serverConn) processSettingInitialWindowSize(val uint32) error <span class="cov8" title="1">{
        sc.serveG.Check()
        // Note: val already validated to be within range by
        // processSetting's Valid call.

        // "A SETTINGS frame can alter the initial flow control window
        // size for all current streams. When the value of
        // SETTINGS_INITIAL_WINDOW_SIZE changes, a receiver MUST
        // adjust the size of all stream flow control windows that it
        // maintains by the difference between the new value and the
        // old value. See Section 2.6.8"
        old := sc.initialWindowSize
        sc.initialWindowSize = int32(val)
        growth := sc.initialWindowSize - old // may be negative
        for _, st := range sc.streams </span><span class="cov0" title="0">{
                if !st.flow.add(growth) </span><span class="cov0" title="0">{
                        // "If a sender receivers a WINDOW_UPDATE that causes a
                        // flow control window to exceed this maximum it MUST
                        // terminate either the stream or the connection, as
                        // appropriate. see Section 2.6.8"
                        // Note: We just terminate connection here.
                        state.SpdyErrFlowControl.Inc(1)
                        return ConnectionError(FlowControlError)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (sc *serverConn) processData(f *DataFrame) error <span class="cov8" title="1">{
        sc.serveG.Check()

        // If a DATA frame is received whose stream is not in "open"
        // or "half closed (local)" state, the recipient MUST respond
        // with a stream error of type STREAM_CLOSED.
        id := uint32(f.StreamId)
        st, ok := sc.streams[id]
        if !ok </span><span class="cov0" title="0">{
                state.SpdyErrInvalidDataStream.Inc(1)
                return StreamError{id, InvalidStream}
        }</span>
        <span class="cov8" title="1">if st.state != stateOpen </span><span class="cov0" title="0">{
                // This includes sending a RST_STREAM if the stream is
                // in stateHalfClosedLocal (which currently means that
                // the http.Handler returned, so it's done reading &amp;
                // done writing). Try to stop the client from sending
                // more DATA.
                state.SpdyErrStreamAlreadyClosed.Inc(1)
                return StreamError{id, StreamAlreadyClosed}
        }</span>
        <span class="cov8" title="1">if st.body == nil </span><span class="cov0" title="0">{
                panic("internal error: should have a body in this state")</span>
        }
        <span class="cov8" title="1">data := f.Data

        // Sender sending more than they'd declared?
        if st.declBodyBytes != -1 &amp;&amp; st.bodyBytes+int64(len(data)) &gt; st.declBodyBytes </span><span class="cov8" title="1">{
                // "If a server receives a request where the sum of the data frame
                // payload lengths does not equal the size of the Content-Length
                // header, the server MUST return a 400 (Bad Request) error, see
                // Section 3.2.1"
                // Note: we just treat that as a stream error here
                state.SpdyErrBadRequest.Inc(1)
                st.body.CloseWithError(fmt.Errorf("sender tried to send more than declared Content-Length of %d bytes", st.declBodyBytes))
                return StreamError{id, ProtocolError}
        }</span>
        <span class="cov8" title="1">if len(data) &gt; 0 </span><span class="cov8" title="1">{
                // Check whether the client has flow control quota.
                if int(st.inflow.available()) &lt; len(data) </span><span class="cov0" title="0">{
                        state.SpdyErrFlowControl.Inc(1)
                        return StreamError{id, FlowControlError}
                }</span>
                <span class="cov8" title="1">st.inflow.take(int32(len(data)))
                wrote, err := st.body.Write(data)
                if err != nil </span><span class="cov0" title="0">{
                        state.SpdyErrStreamAlreadyClosed.Inc(1)
                        return StreamError{id, StreamAlreadyClosed}
                }</span>
                <span class="cov8" title="1">if wrote != len(data) </span><span class="cov0" title="0">{
                        panic("internal error: bad Writer")</span>
                }
                <span class="cov8" title="1">st.bodyBytes += int64(len(data))</span>
        }
        <span class="cov8" title="1">if f.StreamEnded() </span><span class="cov8" title="1">{
                if t := st.timeoutTimer; t != nil </span><span class="cov0" title="0">{
                        t.Stop()
                }</span>

                <span class="cov8" title="1">if st.declBodyBytes != -1 &amp;&amp; st.declBodyBytes != st.bodyBytes </span><span class="cov8" title="1">{
                        state.SpdyErrBadRequest.Inc(1)
                        st.body.CloseWithError(fmt.Errorf("request declared a Content-Length of %d but only wrote %d bytes",
                                st.declBodyBytes, st.bodyBytes))
                        return StreamError{id, ProtocolError}
                }</span>
                <span class="cov8" title="1">st.body.CloseWithError(io.EOF)
                st.state = stateHalfClosedRemote</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (sc *serverConn) processSynStream(f *SynStreamFrame) error <span class="cov8" title="1">{
        sc.serveG.Check()
        id := uint32(f.StreamId)
        if sc.inGoAway </span><span class="cov0" title="0">{
                // Ignore.
                return nil
        }</span>

        // check request rate limit
        <span class="cov8" title="1">if !acceptRequest() </span><span class="cov0" title="0">{
                state.SpdyReqOverload.Inc(1)
                sc.goAway(GoAwayOK)
        }</span>

        <span class="cov8" title="1">if id%2 != 1 || id &lt; sc.maxStreamID </span><span class="cov0" title="0">{
                // "If the client is initiating the stream, the Stream-ID must
                // be even. [...] The stream-id MUST increase with each new stream.
                // If an endpoint receives a SYN_STREAM with a stream id which is
                // less than any previously received SYN_STREAM, it MUST issue a
                // session error with the status PROTOCOL_ERROR. See Section 2.3.2"
                state.SpdyErrInvalidSynStream.Inc(1)
                return ConnectionError(ProtocolError)
        }</span>
        <span class="cov8" title="1">if id == sc.maxStreamID </span><span class="cov0" title="0">{
                // "If a recipient receives a second SYN_STREAM for the same stream,
                // it MUST issue a stream error Section (2.4.2) with the status
                // code PROTOCOL_ERROR. See Section 2.3.2"
                state.SpdyErrInvalidSynStream.Inc(1)
                return StreamError{id, ProtocolError}
        }</span>

        <span class="cov8" title="1">if id &gt; sc.maxStreamID </span><span class="cov8" title="1">{
                sc.maxStreamID = id
        }</span>
        <span class="cov8" title="1">st := &amp;stream{
                id:     id,
                state:  stateOpen,
                weight: f.Priority,
        }
        if f.StreamEnded() </span><span class="cov8" title="1">{
                st.state = stateHalfClosedRemote
        }</span>
        <span class="cov8" title="1">st.cw.Init()

        st.flow.conn = &amp;sc.flow // link to conn-level counter
        st.flow.add(sc.initialWindowSize)
        st.inflow.conn = &amp;sc.inflow      // link to conn-level counter
        st.inflow.add(initialWindowSize) // TODO: update this when we send a higher initial window size in the initial settings

        sc.streams[id] = st
        sc.curOpenStreams++
        if sc.curOpenStreams &gt; sc.advMaxStreams </span><span class="cov8" title="1">{
                state.SpdyErrMaxStreamPerConn.Inc(1)
                return fmt.Errorf("user-agent[%s] curOpenStreams[%d] exceeds maxCurStreams[%d]",
                        f.Headers.Get("user-agent"), sc.curOpenStreams, sc.advMaxStreams)
        }</span>
        <span class="cov8" title="1">if sc.curOpenStreams == 1 </span><span class="cov8" title="1">{
                sc.setConnState(http.StateActive)
        }</span>

        <span class="cov8" title="1">rw, req, err := sc.newWriterAndRequest(st, f)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">st.body = req.Body.(*RequestBody).pipe // may be nil
        st.declBodyBytes = req.ContentLength

        handler := sc.handler.ServeHTTP
        go sc.runHandler(rw, req, handler)
        return nil</span>
}

func (sc *serverConn) newWriterAndRequest(st *stream, f *SynStreamFrame) (
        *responseWriter, *http.Request, error) <span class="cov8" title="1">{
        sc.serveG.Check()

        header := f.Headers
        method := header.Get(headerMethod)
        path := header.Get(headerPath)
        version := header.Get(headerVersion)
        host := header.Get(headerHost)
        scheme := header.Get(headerScheme)

        if method == "" || path == "" || version == "" || host == "" || (scheme != "https" &amp;&amp; scheme != "http") </span><span class="cov0" title="0">{
                // "If a client send a SYN_STREAM without all the method, host, path,
                // scheme, and version headers, the server MUST reply with a HTTP 400
                // Bad Request reply, see Section 3.2.1"
                // Note: we just treat malformed requests as a stream error of
                // PROTOCOL_ERROR here.
                state.SpdyErrBadRequest.Inc(1)
                return nil, nil, StreamError{st.id, ProtocolError}
        }</span>
        <span class="cov8" title="1">bodyOpen := st.state == stateOpen
        if method == "HEAD" &amp;&amp; bodyOpen </span><span class="cov0" title="0">{
                // HEAD requests can't have bodies
                state.SpdyErrBadRequest.Inc(1)
                return nil, nil, StreamError{st.id, ProtocolError}
        }</span>
        <span class="cov8" title="1">var tlsState *tls.ConnectionState // nil if not scheme https
        if scheme == "https" </span><span class="cov8" title="1">{
                tlsState = sc.tlsState
        }</span>
        <span class="cov8" title="1">needsContinue := header.Get("Expect") == "100-continue"
        if needsContinue </span><span class="cov8" title="1">{
                header.Del("Expect")
        }</span>
        // Merge Cookie headers into one "; "-delimited value.
        <span class="cov8" title="1">if cookies := header["Cookie"]; len(cookies) &gt; 1 </span><span class="cov0" title="0">{
                header.Set("Cookie", strings.Join(cookies, "; "))
        }</span>
        <span class="cov8" title="1">body := &amp;RequestBody{
                conn:          sc,
                stream:        st,
                needsContinue: needsContinue,
        }
        url, err := url.ParseRequestURI(path)
        if err != nil </span><span class="cov0" title="0">{
                state.SpdyErrBadRequest.Inc(1)
                return nil, nil, StreamError{st.id, ProtocolError}
        }</span>

        // remove pesudo headers
        <span class="cov8" title="1">header.Del(headerMethod)
        header.Del(headerPath)
        header.Del(headerVersion)
        header.Del(headerHost)
        header.Del(headerScheme)
        header.Set("Host", host)

        req := &amp;http.Request{
                Method:     method,
                URL:        url,
                RemoteAddr: sc.remoteAddrStr,
                Header:     header,
                RequestURI: path,
                Proto:      version,
                ProtoMajor: 1,
                ProtoMinor: 1,
                TLS:        tlsState,
                Host:       host,
                Body:       body,
                State: &amp;http.RequestState{
                        SerialNumber: st.id/2 + 1,
                        StartTime:    time.Now(),
                },
        }
        if bodyOpen </span><span class="cov8" title="1">{
                if vv, ok := header["Content-Length"]; ok </span><span class="cov8" title="1">{
                        // Any Content-Length greater than or equal to zero is a valid
                        // value. See HTTP section 14.13
                        len, err := strconv.ParseInt(vv[0], 10, 64)
                        if len &lt; 0 || err != nil </span><span class="cov0" title="0">{
                                state.SpdyErrBadRequest.Inc(1)
                                return nil, nil, StreamError{st.id, ProtocolError}
                        }</span>
                        <span class="cov8" title="1">req.ContentLength = len</span>
                } else<span class="cov8" title="1"> {
                        req.ContentLength = -1
                }</span>
                <span class="cov8" title="1">body.pipe = pipe.NewPipeFromBufferPool(&amp;fixBufferPool)</span>
        }

        <span class="cov8" title="1">rws := responseWriterStatePool.Get().(*responseWriterState)
        bwSave := rws.bw
        *rws = responseWriterState{} // zero all the fields
        rws.conn = sc
        rws.bw = bwSave
        rws.bw.Reset(chunkWriter{rws})
        rws.stream = st
        rws.req = req
        rws.body = body

        rw := &amp;responseWriter{rws: rws}
        return rw, req, nil</span>
}

// Run on its own goroutine.
func (sc *serverConn) runHandler(rw *responseWriter, req *http.Request, handler func(http.ResponseWriter, *http.Request)) <span class="cov8" title="1">{
        defer func() </span><span class="cov8" title="1">{
                if e := recover(); e != nil </span><span class="cov0" title="0">{
                        state.SpdyPanicStream.Inc(1)
                        log.Logger.Warn("bfe_spdy: panic serving %v:%v\n%s", sc.conn.RemoteAddr(), e, gotrack.CurrentStackTrace(0))

                        sc.writeFrameFromHandler(frameWriteMsg{
                                frame:  &amp;PanicFrame{},
                                stream: rw.rws.stream,
                        })
                        return
                }</span>

                <span class="cov8" title="1">rw.handlerDone()</span>
        }()

        <span class="cov8" title="1">handler(rw, req)</span>
}
</pre>
		
		<pre class="file" id="file244" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Copyright 2014 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package bfe_spdy

import "fmt"

// frameWriteMsg is a request to write a frame.
type frameWriteMsg struct {
        // frame in its unpacked in-memory representation
        frame Frame

        // used for prioritization. nil for non-stream frames.
        stream *stream

        // done, if non-nil, must be a buffered channel with space for
        // 1 message and is sent the return value from write (or an
        // earlier error) when the frame has been written.
        done chan error
}

// for debugging only:
func (wm frameWriteMsg) String() string <span class="cov0" title="0">{
        var streamID uint32
        if wm.stream != nil </span><span class="cov0" title="0">{
                streamID = wm.stream.id
        }</span>
        <span class="cov0" title="0">var des string
        if s, ok := wm.frame.(fmt.Stringer); ok </span><span class="cov0" title="0">{
                des = s.String()
        }</span> else<span class="cov0" title="0"> {
                des = fmt.Sprintf("%T", wm.frame)
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("[frameWriteMsg stream=%d, ch=%v, type: %v, ends: %v]",
                streamID, wm.done != nil, des, endsStream(wm.frame))</span>
}

// writeScheduler tracks pending frames to write, priorities, and decides
// the next one to use. It is not thread-safe.
type writeScheduler struct {
        // zero are frames not associated with a specific stream.
        // They're sent before any stream-specific freams.
        zero writeQueue

        // maxFrameSize is the maximum size of a DATA frame
        // we'll write. Must be non-zero and between 16K-16M.
        maxFrameSize uint32

        // sq contains the stream-specific queues, keyed by stream ID.
        // when a stream is idle, it's deleted from the map.
        sq map[uint32]*writeQueue

        // canSend is a slice of memory that's reused between frame
        // scheduling decisions to hold the list of writeQueues (from sq)
        // which have enough flow control data to send. After canSend is
        // built, the best is selected.
        canSend []*writeQueue

        // pool of empty queues for reuse.
        queuePool []*writeQueue
}

func (ws *writeScheduler) putEmptyQueue(q *writeQueue) <span class="cov8" title="1">{
        if len(q.s) != 0 </span><span class="cov0" title="0">{
                panic("queue must be empty")</span>
        }
        <span class="cov8" title="1">ws.queuePool = append(ws.queuePool, q)</span>
}

func (ws *writeScheduler) getEmptyQueue() *writeQueue <span class="cov8" title="1">{
        ln := len(ws.queuePool)
        if ln == 0 </span><span class="cov8" title="1">{
                return new(writeQueue)
        }</span>
        <span class="cov8" title="1">q := ws.queuePool[ln-1]
        ws.queuePool = ws.queuePool[:ln-1]
        return q</span>
}

func (ws *writeScheduler) empty() bool <span class="cov0" title="0">{ return ws.zero.empty() &amp;&amp; len(ws.sq) == 0 }</span>

func (ws *writeScheduler) add(wm frameWriteMsg) <span class="cov8" title="1">{
        st := wm.stream
        if st == nil </span><span class="cov8" title="1">{
                ws.zero.push(wm)
        }</span> else<span class="cov8" title="1"> {
                ws.streamQueue(st.id).push(wm)
        }</span>
}

func (ws *writeScheduler) streamQueue(streamID uint32) *writeQueue <span class="cov8" title="1">{
        if q, ok := ws.sq[streamID]; ok </span><span class="cov0" title="0">{
                return q
        }</span>
        <span class="cov8" title="1">if ws.sq == nil </span><span class="cov8" title="1">{
                ws.sq = make(map[uint32]*writeQueue)
        }</span>
        <span class="cov8" title="1">q := ws.getEmptyQueue()
        ws.sq[streamID] = q
        return q</span>
}

// take returns the most important frame to write and removes it from the scheduler.
// It is illegal to call this if the scheduler is empty or if there are no connection-level
// flow control bytes available.
func (ws *writeScheduler) take() (wm frameWriteMsg, ok bool) <span class="cov8" title="1">{
        if ws.maxFrameSize == 0 </span><span class="cov0" title="0">{
                panic("internal error: ws.maxFrameSize not initialized or invalid")</span>
        }

        // If there any frames not associated with streams, prefer those first.
        // These are usually SETTINGS, etc.
        <span class="cov8" title="1">if !ws.zero.empty() </span><span class="cov8" title="1">{
                return ws.zero.shift(), true
        }</span>
        <span class="cov8" title="1">if len(ws.sq) == 0 </span><span class="cov8" title="1">{
                return
        }</span>

        // Next, prioritize frames on streams that aren't DATA frames (no cost).
        <span class="cov8" title="1">for id, q := range ws.sq </span><span class="cov8" title="1">{
                if q.firstIsNoCost() </span><span class="cov8" title="1">{
                        return ws.takeFrom(id, q)
                }</span>
        }

        // Now, all that remains are DATA frames with non-zero bytes to
        // send. So pick the best one.
        <span class="cov8" title="1">if len(ws.canSend) != 0 </span><span class="cov0" title="0">{
                panic("should be empty")</span>
        }
        <span class="cov8" title="1">for _, q := range ws.sq </span><span class="cov8" title="1">{
                if n := ws.streamWritableBytes(q); n &gt; 0 </span><span class="cov8" title="1">{
                        ws.canSend = append(ws.canSend, q)
                }</span>
        }
        <span class="cov8" title="1">if len(ws.canSend) == 0 </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">defer ws.zeroCanSend()

        // TODO: find the best queue
        q := ws.canSend[0]

        return ws.takeFrom(q.streamID(), q)</span>
}

// zeroCanSend is deferred from take.
func (ws *writeScheduler) zeroCanSend() <span class="cov8" title="1">{
        for i := range ws.canSend </span><span class="cov8" title="1">{
                ws.canSend[i] = nil
        }</span>
        <span class="cov8" title="1">ws.canSend = ws.canSend[:0]</span>
}

// streamWritableBytes returns the number of DATA bytes we could write
// from the given queue's stream, if this stream/queue were
// selected. It is an error to call this if q's head isn't a
// *writeData.
func (ws *writeScheduler) streamWritableBytes(q *writeQueue) int32 <span class="cov8" title="1">{
        wm := q.head()
        ret := wm.stream.flow.available() // max we can write
        if ret == 0 </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">if int32(ws.maxFrameSize) &lt; ret </span><span class="cov8" title="1">{
                ret = int32(ws.maxFrameSize)
        }</span>
        <span class="cov8" title="1">if ret == 0 </span><span class="cov0" title="0">{
                panic("internal error: ws.maxFrameSize not initialized or invalid")</span>
        }
        <span class="cov8" title="1">wd := wm.frame.(*DataFrame)
        if len(wd.Data) &lt; int(ret) </span><span class="cov8" title="1">{
                ret = int32(len(wd.Data))
        }</span>
        <span class="cov8" title="1">return ret</span>
}

func (ws *writeScheduler) takeFrom(id uint32, q *writeQueue) (wm frameWriteMsg, ok bool) <span class="cov8" title="1">{
        wm = q.head()
        // If the first item in this queue costs flow control tokens
        // and we don't have enough, write as much as we can.
        if wd, ok := wm.frame.(*DataFrame); ok &amp;&amp; len(wd.Data) &gt; 0 </span><span class="cov8" title="1">{
                allowed := wm.stream.flow.available() // max we can write
                if allowed == 0 </span><span class="cov0" title="0">{
                        // No quota available. Caller can try the next stream.
                        return frameWriteMsg{}, false
                }</span>
                <span class="cov8" title="1">if int32(ws.maxFrameSize) &lt; allowed </span><span class="cov8" title="1">{
                        allowed = int32(ws.maxFrameSize)
                }</span>
                // TODO: further restrict the allowed size, because even if
                // the peer says it's okay to write 16MB data frames, we might
                // want to write smaller ones to properly weight competing
                // streams' priorities.

                <span class="cov8" title="1">if len(wd.Data) &gt; int(allowed) </span><span class="cov8" title="1">{
                        wm.stream.flow.take(allowed)
                        chunk := wd.Data[:allowed]
                        wd.Data = wd.Data[allowed:]
                        // Make up a new write message of a valid size, rather
                        // than shifting one off the queue.
                        return frameWriteMsg{
                                stream: wm.stream,
                                frame: &amp;DataFrame{
                                        StreamId: wd.StreamId,
                                        Data:     chunk,
                                        // even if the original had endStream set, there
                                        // arebytes remaining because len(wd.p) &gt; allowed,
                                        // so we know endStream is false:
                                        Flags: 0,
                                },
                                // our caller is blocking on the final DATA frame, not
                                // these intermediates, so no need to wait:
                                done: nil,
                        }, true
                }</span>
                <span class="cov8" title="1">wm.stream.flow.take(int32(len(wd.Data)))</span>
        }

        <span class="cov8" title="1">q.shift()
        if q.empty() </span><span class="cov8" title="1">{
                ws.putEmptyQueue(q)
                delete(ws.sq, id)
        }</span>
        <span class="cov8" title="1">return wm, true</span>
}

func (ws *writeScheduler) forgetStream(id uint32) <span class="cov8" title="1">{
        q, ok := ws.sq[id]
        if !ok </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">delete(ws.sq, id)

        // But keep it for others later.
        for i := range q.s </span><span class="cov8" title="1">{
                q.s[i] = frameWriteMsg{}
        }</span>
        <span class="cov8" title="1">q.s = q.s[:0]
        ws.putEmptyQueue(q)</span>
}

type writeQueue struct {
        s []frameWriteMsg
}

// streamID returns the stream ID for a non-empty stream-specific queue.
func (q *writeQueue) streamID() uint32 <span class="cov8" title="1">{ return q.s[0].stream.id }</span>

func (q *writeQueue) empty() bool <span class="cov8" title="1">{ return len(q.s) == 0 }</span>

func (q *writeQueue) push(wm frameWriteMsg) <span class="cov8" title="1">{
        q.s = append(q.s, wm)
}</span>

// head returns the next item that would be removed by shift.
func (q *writeQueue) head() frameWriteMsg <span class="cov8" title="1">{
        if len(q.s) == 0 </span><span class="cov0" title="0">{
                panic("invalid use of queue")</span>
        }
        <span class="cov8" title="1">return q.s[0]</span>
}

func (q *writeQueue) shift() frameWriteMsg <span class="cov8" title="1">{
        if len(q.s) == 0 </span><span class="cov0" title="0">{
                panic("invalid use of queue")</span>
        }
        <span class="cov8" title="1">wm := q.s[0]
        // TODO: less copy-happy queue.
        copy(q.s, q.s[1:])
        q.s[len(q.s)-1] = frameWriteMsg{}
        q.s = q.s[:len(q.s)-1]
        return wm</span>
}

func (q *writeQueue) firstIsNoCost() bool <span class="cov8" title="1">{
        if df, ok := q.s[0].frame.(*DataFrame); ok </span><span class="cov8" title="1">{
                return len(df.Data) == 0
        }</span>
        <span class="cov8" title="1">return true</span>
}
</pre>
		
		<pre class="file" id="file245" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Copyright 2014 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Copyright 2014 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package bfe_spdy

import (
        "bufio"
        "fmt"
        "io"
        "strconv"
        "sync"
)

import (
        http "github.com/bfenetworks/bfe/bfe_http"
)

var VerboseLogs = false

const (
        // NextProtoTLS is the NPN/ALPN protocol negotiated during SPDY's TLS setup.
        NextProtoTLS = "spdy/3.1"

        initialWindowSize = 65536

        defaultMaxReadFrameSize = 1 &lt;&lt; 20

        defaultMaxWriteFrameSize = 1 &lt;&lt; 14
)

// stream state for server side
//
//      recv S       recv ES                   send ES
// Idle ------&gt; Open -------&gt; HalfClosedRemote -------&gt; Closed
//   |                               ^         send R
//   |        send US                |         recv R
//   +-------------------------------+
//
// send: endpoint sends this frame
// recv: endpoint receives this frame
//
// S : SynStream frame
// US: SynStream frame with UNIDIRECTIONAL flag
// ES: frame with END_STREAM flag
// R : Reset frame
type streamState int

const (
        stateIdle streamState = iota
        stateOpen
        stateHalfClosedLocal
        stateHalfClosedRemote
        stateResvLocal
        stateResvRemote
        stateClosed
)

var stateName = [...]string{
        stateIdle:             "Idle",
        stateOpen:             "Open",
        stateHalfClosedLocal:  "HalfClosedLocal",
        stateHalfClosedRemote: "HalfClosedRemote",
        stateResvLocal:        "ResvLocal",
        stateResvRemote:       "ResvRemote",
        stateClosed:           "Closed",
}

type timeoutTag int

const (
        ConnTag timeoutTag = iota
        ReadStreamTag
        WriteStreamTag
)

var tagString = map[timeoutTag]string{
        ConnTag:        "connection",
        ReadStreamTag:  "read stream",
        WriteStreamTag: "write stream",
}

func (t timeoutTag) String() string <span class="cov8" title="1">{
        return tagString[t]
}</span>

func (st streamState) String() string <span class="cov0" title="0">{
        return stateName[st]
}</span>

// ConnectionError is an error that results in the termination of the
// entire connection.
type ConnectionError RstStreamStatus

func (e ConnectionError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("connection error: %v", RstStreamStatus(e))
}</span>

// StreamError is an error that only affects one stream within an spdy connection.
type StreamError struct {
        StreamID uint32
        Code     RstStreamStatus
}

func (e StreamError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("stream error: stream ID %d; %v", e.StreamID, e.Code)
}</span>

type goAwayFlowError struct{}

func (goAwayFlowError) Error() string <span class="cov0" title="0">{
        return "connection exceeded flow control window size"
}</span>

const (
        headerMethod  = ":method"
        headerPath    = ":path"
        headerVersion = ":version"
        headerHost    = ":host"
        headerScheme  = ":scheme"
)

func validHeader(v string) bool <span class="cov0" title="0">{
        if len(v) == 0 </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">for _, r := range v </span><span class="cov0" title="0">{
                // "Just as in HTTP/1.x, header field names are
                // strings of ASCII characters that are compared in a
                // case-insensitive fashion. However, header field
                // names MUST be converted to lowercase prior to their
                // encoding in SPDY. "
                if r &gt;= 127 || ('A' &lt;= r &amp;&amp; r &lt;= 'Z') </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">return true</span>
}

var httpCodeStringCommon = map[int]string{} // n -&gt; strconv.Itoa(n)

func init() <span class="cov8" title="1">{
        for i := 100; i &lt;= 999; i++ </span><span class="cov8" title="1">{
                if v := http.StatusTextGet(i); v != "" </span><span class="cov8" title="1">{
                        httpCodeStringCommon[i] = strconv.Itoa(i)
                }</span>
        }
}

func httpCodeString(code int) string <span class="cov0" title="0">{
        if s, ok := httpCodeStringCommon[code]; ok </span><span class="cov0" title="0">{
                return s
        }</span>
        <span class="cov0" title="0">return strconv.Itoa(code)</span>
}

// from pkg io
type stringWriter interface {
        WriteString(s string) (n int, err error)
}

// A closeWaiter is like a sync.WaitGroup but only goes 1 to 0 (open to closed).
type closeWaiter chan struct{}

// Init makes a closeWaiter usable.
// It exists because so a closeWaiter value can be placed inside a
// larger struct and have the Mutex and Cond's memory in the same
// allocation.
func (cw *closeWaiter) Init() <span class="cov8" title="1">{
        *cw = make(chan struct{})
}</span>

// Close marks the closeWaiter as closed and unblocks any waiters.
func (cw closeWaiter) Close() <span class="cov8" title="1">{
        close(cw)
}</span>

// Wait waits for the closeWaiter to become closed.
func (cw closeWaiter) Wait() <span class="cov8" title="1">{
        &lt;-cw
}</span>

// bufferedWriter is a buffered writer that writes to w.
// Its buffered writer is lazily allocated as needed, to minimize
// idle memory usage with many connections.
type bufferedWriter struct {
        w  io.Writer     // immutable
        bw *bufio.Writer // non-nil when data is buffered
}

func newBufferedWriter(w io.Writer) *bufferedWriter <span class="cov8" title="1">{
        return &amp;bufferedWriter{w: w}
}</span>

var bufWriterPool = sync.Pool{
        New: func() interface{} <span class="cov8" title="1">{
                // TODO: pick something better? this is a bit under
                // (3 x typical 1500 byte MTU) at least.
                return bufio.NewWriterSize(nil, 4&lt;&lt;10)
        }</span>,
}

func (w *bufferedWriter) Write(p []byte) (n int, err error) <span class="cov8" title="1">{
        if w.bw == nil </span><span class="cov8" title="1">{
                bw := bufWriterPool.Get().(*bufio.Writer)
                bw.Reset(w.w)
                w.bw = bw
        }</span>
        <span class="cov8" title="1">return w.bw.Write(p)</span>
}

func (w *bufferedWriter) Flush() error <span class="cov8" title="1">{
        bw := w.bw
        if bw == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">err := bw.Flush()
        bw.Reset(nil)
        bufWriterPool.Put(bw)
        w.bw = nil
        return err</span>
}

func mustUint31(v int32) uint32 <span class="cov0" title="0">{
        if v &lt; 0 || v &gt; 2147483647 </span><span class="cov0" title="0">{
                panic("out of range")</span>
        }
        <span class="cov0" title="0">return uint32(v)</span>
}

// CloseConn close underlying connection for request
func CloseConn(body io.ReadCloser) <span class="cov8" title="1">{
        if b, ok := body.(*RequestBody); ok </span><span class="cov8" title="1">{
                if b.conn != nil </span><span class="cov8" title="1">{
                        b.conn.Close()
                }</span>
        }
}

var spdyLimiter http.FlowLimiter

// SetFlowLimiter init flow limiter for spdy
func SetFlowLimiter(limiter http.FlowLimiter) <span class="cov0" title="0">{
        spdyLimiter = limiter
}</span>

func acceptConn() bool <span class="cov0" title="0">{
        if spdyLimiter == nil </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">return spdyLimiter.AcceptConn()</span>
}

func acceptRequest() bool <span class="cov8" title="1">{
        if spdyLimiter == nil </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov0" title="0">return spdyLimiter.AcceptRequest()</span>
}
</pre>
		
		<pre class="file" id="file246" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package bfe_spdy

import (
        "github.com/baidu/go-lib/web-monitor/metrics"
)

type SpdyState struct {
        SpdyTimeoutConn            *metrics.Counter
        SpdyTimeoutReadStream      *metrics.Counter
        SpdyTimeoutWriteStream     *metrics.Counter
        SpdyErrInvalidSynStream    *metrics.Counter
        SpdyErrInvalidDataStream   *metrics.Counter
        SpdyErrFlowControl         *metrics.Counter
        SpdyErrBadRequest          *metrics.Counter
        SpdyErrStreamAlreadyClosed *metrics.Counter
        SpdyErrStreamCancel        *metrics.Counter
        SpdyErrMaxStreamPerConn    *metrics.Counter
        SpdyErrGotReset            *metrics.Counter
        SpdyErrNewFramer           *metrics.Counter
        SpdyUnknownFrame           *metrics.Counter
        SpdyPanicConn              *metrics.Counter
        SpdyPanicStream            *metrics.Counter
        SpdyReqHeaderCompressSize  *metrics.Counter
        SpdyReqHeaderOriginalSize  *metrics.Counter
        SpdyResHeaderCompressSize  *metrics.Counter
        SpdyResHeaderOriginalSize  *metrics.Counter
        SpdyReqOverload            *metrics.Counter
        SpdyConnOverload           *metrics.Counter
}

var state SpdyState

func GetSpdyState() *SpdyState <span class="cov0" title="0">{
        return &amp;state
}</span>
</pre>
		
		<pre class="file" id="file247" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package bfe_stream

import (
        "errors"
        "net"
)

import (
        "github.com/baidu/go-lib/web-monitor/metrics"
)

import (
        "github.com/bfenetworks/bfe/bfe_balance/backend"
)

var (
        errBalanceHandler = errors.New("bfe_stream: balanceHandler uninitial")
        errRetryTooMany   = errors.New("bfe_stream: proxy retry too many")
)

// FindProductHandler gets product by conn vip.
type FindProductHandler func(c net.Conn) string

// BalanceHandler selects backend for current conn.
type BalanceHandler func(c interface{}) (*backend.BfeBackend, error)

// ProxyHandler forwards data between client and backend.
type ProxyHandler func(s *Server, c net.Conn, b net.Conn, errCh chan error)

// StreamState is internal state for stream.
type StreamState struct {
        StreamErrBalance  *metrics.Counter
        StreamErrConnect  *metrics.Counter
        StreamErrProxy    *metrics.Counter
        StreamErrTransfer *metrics.Counter
        StreamPanicConn   *metrics.Counter
        StreamBytesRecv   *metrics.Counter
        StreamBytesSent   *metrics.Counter
}

var state StreamState

// GetStreamState returns internal state for stream.
func GetStreamState() *StreamState <span class="cov0" title="0">{
        return &amp;state
}</span>
</pre>
		
		<pre class="file" id="file248" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package bfe_stream

import (
        "net"
)

import (
        "github.com/baidu/go-lib/gotrack"
)

import (
        http "github.com/bfenetworks/bfe/bfe_http"
        tls "github.com/bfenetworks/bfe/bfe_tls"
)

const (
        defaultConnectTimeout  = 1000 // ms
        defaultConnectRetryMax = 3
)

type Server struct {
        // ConnectTimeout optionally specifies the timeout value (ms) to
        // connect backend. If zero, a default value is used.
        ConnectTimeout int

        // ConnectRetryMax optionally specifies the upper limit of connect
        // retris. If zero, a default value is used
        ConnectRetryMax int

        // BalanceHandler optionally specifies the handler for backends balance
        // BalanceHandler should not be nil.
        BalanceHandler BalanceHandler

        // FindProductHandler finds product name for stream proxy
        FindProductHandler FindProductHandler

        // ProxyHandler optionally specifies the handler for process client conn
        // and backend conn. If nil, a default value is used.
        ProxyHandler ProxyHandler

        // ProxyConfig optionally specifies the config for ProxyHandler
        ProxyConfig interface{}
}

func (s *Server) connectTimeout() int <span class="cov8" title="1">{
        if v := s.ConnectTimeout; v &gt; 0 </span><span class="cov8" title="1">{
                return v
        }</span>
        <span class="cov8" title="1">return defaultConnectTimeout</span>
}

func (s *Server) connectRetryMax() int <span class="cov8" title="1">{
        if v := s.ConnectRetryMax; v &gt; 0 </span><span class="cov8" title="1">{
                return v
        }</span>
        <span class="cov8" title="1">return defaultConnectRetryMax</span>
}

func (s *Server) balanceHandler() BalanceHandler <span class="cov8" title="1">{
        return s.BalanceHandler
}</span>

func (s *Server) proxyHandler() ProxyHandler <span class="cov8" title="1">{
        if v := s.ProxyHandler; v != nil </span><span class="cov0" title="0">{
                return v
        }</span>
        <span class="cov8" title="1">return TLSProxyHandler</span>
}

func (s *Server) handleConn(hs *http.Server, c net.Conn, h http.Handler) *serverConn <span class="cov8" title="1">{
        sc := new(serverConn)
        sc.srv = s
        sc.hs = hs
        sc.conn = c
        if tc, ok := c.(*tls.Conn); ok </span><span class="cov8" title="1">{
                sc.tlsState = new(tls.ConnectionState)
                *sc.tlsState = tc.ConnectionState()
                if serverRule != nil </span><span class="cov8" title="1">{
                        sc.rule = serverRule.GetStreamRule(tc)
                }</span>

        }

        <span class="cov8" title="1">sc.closeNotifyCh = hs.CloseNotifyCh
        sc.copyErrCh = make(chan error, 2)
        sc.serveG = gotrack.NewGoroutineLock()

        return sc</span>
}

// FindProduct finds product by conn vip.
func (s *Server) FindProduct(c net.Conn) string <span class="cov0" title="0">{
        productHandler := s.FindProductHandler
        if productHandler == nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">return productHandler(c)</span>
}

// NewProtoHandler creates a protocol handler for stream.
func NewProtoHandler(conf *Server) func(*http.Server, *tls.Conn, http.Handler) <span class="cov8" title="1">{
        if conf == nil </span><span class="cov0" title="0">{
                conf = new(Server)
        }</span>

        <span class="cov8" title="1">protoHandler := func(hs *http.Server, c *tls.Conn, h http.Handler) </span><span class="cov8" title="1">{
                if sc := conf.handleConn(hs, c, h); sc != nil </span><span class="cov8" title="1">{
                        sc.serve()
                }</span>
        }
        <span class="cov8" title="1">return protoHandler</span>
}

// Rule is the customized config for specific conn in server side.
type Rule struct {
        ProxyProtocol int
}

type ServerRule interface {
        GetStreamRule(conn *tls.Conn) *Rule
}

var serverRule ServerRule

func SetServerRule(r ServerRule) <span class="cov8" title="1">{
        serverRule = r
}</span>
</pre>
		
		<pre class="file" id="file249" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package bfe_stream

import (
        "fmt"
        "io"
        "net"
        "time"
)

import (
        "github.com/baidu/go-lib/gotrack"
        "github.com/baidu/go-lib/log"
)

import (
        "github.com/bfenetworks/bfe/bfe_balance/backend"
        http "github.com/bfenetworks/bfe/bfe_http"
        "github.com/bfenetworks/bfe/bfe_proxy"
        tls "github.com/bfenetworks/bfe/bfe_tls"
        "github.com/bfenetworks/bfe/bfe_util"
)

type serverConn struct {
        // Immutable:
        srv           *Server              // server config for tls proxy
        hs            *http.Server         // server config for http
        conn          net.Conn             // underlying conn
        tlsState      *tls.ConnectionState // tls conn state
        closeNotifyCh chan bool            // from outside -&gt; serve
        copyErrCh     chan error           // from copy goroutine -&gt; serve

        // Everything following is owned by the serve loop
        serveG          gotrack.GoroutineLock // to verify funcs are on serve()
        shutdownTimerCh &lt;-chan time.Time      // nil until used
        shutdownTimer   *time.Timer           // nil until used
        rule            *Rule
}

func (sc *serverConn) serve() <span class="cov8" title="1">{
        sc.serveG.Check()
        defer sc.notePanic()
        defer sc.conn.Close()

        log.Logger.Debug("bfe_stream: process stream connection from %v", sc.conn.RemoteAddr())
        var zero time.Time
        sc.conn.SetDeadline(zero)

        // connect start time
        start := time.Now()

        // select and connect to backend
        bc, back, err := sc.findBackend()
        if err != nil </span><span class="cov8" title="1">{
                log.Logger.Info("bfe_stream: findBackend() fail: %v", err)
                return
        }</span>

        <span class="cov8" title="1">defer bc.Close()
        defer back.DecConnNum()
        log.Logger.Debug("bfe_stream: proxy connection %v to %v", sc.conn.RemoteAddr(), bc.RemoteAddr())

        err = sc.processProxyProtocol(bc)
        if err != nil </span><span class="cov0" title="0">{
                log.Logger.Info("bfe_stream: processProxyProtocol() fail: %v", err)
                return
        }</span>

        // copy data between client conn and backend conn
        <span class="cov8" title="1">fn := sc.srv.proxyHandler()
        fn(sc.srv, sc.conn, bc, sc.copyErrCh)

        // wait for finish
        for </span><span class="cov8" title="1">{
                select </span>{
                case err := &lt;-sc.copyErrCh:<span class="cov8" title="1">
                        if err != nil </span><span class="cov8" title="1">{
                                state.StreamErrTransfer.Inc(1)
                                duration := time.Since(start)
                                tlsConn := sc.conn.(*tls.Conn)
                                log.Logger.Info("bfe_stream: stream conn finish: vip:[%s], sni:[%s], clientip:[%v], backend:[%s], "+
                                        "duration:%fs, error:[%v]", tlsConn.GetVip().String(), sc.tlsState.ServerName, sc.conn.RemoteAddr(),
                                        back.AddrInfo, duration.Seconds(), err)
                        }</span>
                        <span class="cov8" title="1">sc.shutDownIn(250 * time.Millisecond)</span>

                case &lt;-sc.closeNotifyCh:<span class="cov8" title="1">
                        log.Logger.Debug("bfe_stream: closing conn from %v", sc.conn.RemoteAddr())
                        sc.shutDownIn(sc.hs.GracefulShutdownTimeout)
                        sc.closeNotifyCh = nil</span>

                case &lt;-sc.shutdownTimerCh:<span class="cov8" title="1">
                        return</span>
                }
        }
}

func (sc *serverConn) processProxyProtocol(bc net.Conn) error <span class="cov8" title="1">{
        if sc.rule == nil || sc.rule.ProxyProtocol == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">var virtualAddr net.Addr
        var destinationIP, sourceIP net.IP
        var destinationPort, sourcePort int
        var err error

        netConn := sc.conn.(*tls.Conn).GetNetConn()

        if addressFetcher, ok := netConn.(bfe_util.AddressFetcher); ok </span><span class="cov0" title="0">{
                virtualAddr = addressFetcher.VirtualAddr()
        }</span>
        <span class="cov8" title="1">if virtualAddr == nil </span><span class="cov8" title="1">{
                virtualAddr = sc.conn.LocalAddr()
                log.Logger.Debug("bfe_stream: get nil virtual addr: %v, using local address: %v", err, sc.conn.LocalAddr())
        }</span>
        <span class="cov8" title="1">destinationIP, destinationPort, err = bfe_util.ParseIpAndPort(virtualAddr.String())
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("parse virtual address error: %v", err)
        }</span>

        <span class="cov8" title="1">sourceIP, sourcePort, err = bfe_util.ParseIpAndPort(sc.conn.RemoteAddr().String())
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("parse remote address error: %v", err)
        }</span>

        <span class="cov8" title="1">proxyHeader := &amp;bfe_proxy.Header{
                Version:            byte(sc.rule.ProxyProtocol),
                Command:            bfe_proxy.PROXY,
                SourceAddress:      sourceIP,
                DestinationAddress: destinationIP,
                SourcePort:         uint16(sourcePort),
                DestinationPort:    uint16(destinationPort),
        }

        if sourceIP.To4() != nil </span><span class="cov8" title="1">{
                proxyHeader.TransportProtocol = bfe_proxy.TCPv4
        }</span> else<span class="cov0" title="0"> {
                proxyHeader.TransportProtocol = bfe_proxy.TCPv6
        }</span>

        <span class="cov8" title="1">log.Logger.Debug("bfe_stream: write proxy header[%v] to backend connection", proxyHeader)
        _, err = proxyHeader.WriteTo(bc)
        return err</span>
}

func (sc *serverConn) findBackend() (net.Conn, *backend.BfeBackend, error) <span class="cov8" title="1">{
        balanceHandler := sc.srv.balanceHandler()
        if balanceHandler == nil </span><span class="cov0" title="0">{
                return nil, nil, errBalanceHandler
        }</span>

        <span class="cov8" title="1">for i := 0; i &lt; sc.srv.connectRetryMax(); i++ </span><span class="cov8" title="1">{
                // balance backend for current client
                backend, err := balanceHandler(sc.conn)
                if err != nil </span><span class="cov8" title="1">{
                        state.StreamErrBalance.Inc(1)
                        log.Logger.Debug("bfe_stream: balance error: %s ", err)
                        continue</span>
                }
                <span class="cov8" title="1">backend.IncConnNum()

                // establish tcp conn to backend
                timeout := time.Duration(sc.srv.connectTimeout()) * time.Millisecond
                bAddr := backend.GetAddrInfo()
                bc, err := net.DialTimeout("tcp", bAddr, timeout)
                if err != nil </span><span class="cov8" title="1">{
                        // connect backend failed, desc connection num
                        backend.DecConnNum()
                        state.StreamErrConnect.Inc(1)
                        log.Logger.Debug("bfe_stream: connect %s error: %s", bAddr, err)
                        continue</span>
                }

                <span class="cov8" title="1">return bc, backend, nil</span>
        }

        <span class="cov8" title="1">state.StreamErrProxy.Inc(1)
        return nil, nil, errRetryTooMany</span>
}

func (sc *serverConn) shutDownIn(d time.Duration) <span class="cov8" title="1">{
        sc.serveG.Check()
        if sc.shutdownTimer != nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">sc.shutdownTimer = time.NewTimer(d)
        sc.shutdownTimerCh = sc.shutdownTimer.C</span>
}

func (sc *serverConn) notePanic() <span class="cov8" title="1">{
        if e := recover(); e != nil </span><span class="cov8" title="1">{
                log.Logger.Warn("bfe_stream: panic serving %v:%v\n%s", sc.conn.RemoteAddr(),
                        e, gotrack.CurrentStackTrace(0))
                state.StreamPanicConn.Inc(1)
        }</span>
}

// TLSProxyHandler copy data between client conn and backend conn.
func TLSProxyHandler(s *Server, c net.Conn, b net.Conn, errCh chan error) <span class="cov8" title="1">{
        // TODO: add read/write timeout
        go func() </span><span class="cov8" title="1">{
                n, err := io.Copy(b, c)
                state.StreamBytesRecv.Inc(uint(n))
                errCh &lt;- err
        }</span>()

        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                n, err := io.Copy(c, b)
                state.StreamBytesSent.Inc(uint(n))
                errCh &lt;- err
        }</span>()
}
</pre>
		
		<pre class="file" id="file250" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package bfe_stream

import (
        "io"
        "net"
        "reflect"
        "strings"
        "testing"
        "time"
)

import (
        "github.com/bfenetworks/bfe/bfe_balance/backend"
        http "github.com/bfenetworks/bfe/bfe_http"
        tls "github.com/bfenetworks/bfe/bfe_tls"
        util "github.com/bfenetworks/bfe/bfe_util"
)

type ServerTester struct {
        t testing.TB

        // for client side
        cc net.Conn

        // for server side
        ms *util.MockServer

        // for backend side
        mb *util.MockServer
}

func NewServerTester(t testing.TB, h util.MockHandler, c *Server) *ServerTester <span class="cov8" title="1">{
        // create ServerTester
        st := &amp;ServerTester{t: t}

        // init backend
        st.mb = util.NewUnstartedServer(h)
        st.mb.StartTCP()

        // init balancer
        if c == nil </span><span class="cov8" title="1">{
                c = new(Server)
        }</span>
        <span class="cov8" title="1">if c.BalanceHandler == nil </span><span class="cov8" title="1">{
                c.BalanceHandler = func(conn interface{}) (*backend.BfeBackend, error) </span><span class="cov8" title="1">{
                        laddr := st.mb.Listener.Addr()

                        b := backend.NewBfeBackend()
                        b.AddrInfo = laddr.String()

                        return b, nil
                }</span>
        }

        // init server
        <span class="cov8" title="1">st.ms = util.NewUnstartedServer(nil)
        st.ms.TLS = new(tls.Config)
        st.ms.TLS.NextProtos = append(st.ms.TLS.NextProtos, "stream")
        st.ms.Config.TLSNextProto = make(map[string]func(*http.Server, *tls.Conn, http.Handler))
        st.ms.Config.TLSNextProto["stream"] = NewProtoHandler(c)
        st.ms.StartTLS()

        // init client
        tlsConfig := &amp;tls.Config{InsecureSkipVerify: true, NextProtos: []string{"stream"}}
        cc, err := tls.Dial("tcp", st.ms.Listener.Addr().String(), tlsConfig)
        if err != nil </span><span class="cov0" title="0">{
                t.Fatal(err)
        }</span>
        <span class="cov8" title="1">st.cc = cc

        return st</span>
}

// client read message until timeout
func (st *ServerTester) Read(buf []byte) error <span class="cov8" title="1">{
        st.cc.SetReadDeadline(time.Now().Add(4 * time.Second))
        _, err := io.ReadFull(st.cc, buf)
        return err
}</span>

// client write message
func (st *ServerTester) Write(data []byte) error <span class="cov8" title="1">{
        _, err := st.cc.Write(data)
        return err
}</span>

// WantData makes client read and check message
func (st *ServerTester) WantData(data []byte) <span class="cov8" title="1">{
        buf := make([]byte, len(data))
        if err := st.Read(buf); err != nil </span><span class="cov0" title="0">{
                st.t.Fatalf("read error: %s", err)
        }</span>

        <span class="cov8" title="1">if !reflect.DeepEqual(buf, data) </span><span class="cov0" title="0">{
                st.t.Fatalf("read error: got %v, want %v", buf, data)
        }</span>
}

// WantError makes client read and check error
func (st *ServerTester) WantError(e string) <span class="cov8" title="1">{
        err := st.Read(make([]byte, 256))
        if err == nil </span><span class="cov0" title="0">{
                st.t.Fatalf("Expecting error")
        }</span>
        <span class="cov8" title="1">if !strings.Contains(err.Error(), e) </span><span class="cov0" title="0">{
                st.t.Fatalf("Expecting error got %v ; want %v", err.Error(), e)
        }</span>
}

func (st *ServerTester) Close() <span class="cov8" title="1">{
        st.cc.Close()
        st.ms.Close()
        st.mb.Close()
}</span>

func testTLSProxy(t *testing.T, f func(st *ServerTester), h util.MockHandler, c *Server) <span class="cov8" title="1">{
        // create server tester
        st := NewServerTester(t, h, c)
        defer st.Close()

        // perform test actions
        f(st)
}</span>
</pre>
		
		<pre class="file" id="file251" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package bfe_tls

import "strconv"

type alert uint8

const (
        // alert level
        alertLevelWarning = 1
        alertLevelError   = 2
)

const (
        alertCloseNotify            alert = 0
        alertUnexpectedMessage      alert = 10
        alertBadRecordMAC           alert = 20
        alertDecryptionFailed       alert = 21
        alertRecordOverflow         alert = 22
        alertDecompressionFailure   alert = 30
        alertHandshakeFailure       alert = 40
        alertBadCertificate         alert = 42
        alertUnsupportedCertificate alert = 43
        alertCertificateRevoked     alert = 44
        alertCertificateExpired     alert = 45
        alertCertificateUnknown     alert = 46
        alertIllegalParameter       alert = 47
        alertUnknownCA              alert = 48
        alertAccessDenied           alert = 49
        alertDecodeError            alert = 50
        alertDecryptError           alert = 51
        alertProtocolVersion        alert = 70
        alertInsufficientSecurity   alert = 71
        alertInternalError          alert = 80
        alertInappropriateFallback  alert = 86
        alertUserCanceled           alert = 90
        alertNoRenegotiation        alert = 100
)

var alertText = map[alert]string{
        alertCloseNotify:            "close notify",
        alertUnexpectedMessage:      "unexpected message",
        alertBadRecordMAC:           "bad record MAC",
        alertDecryptionFailed:       "decryption failed",
        alertRecordOverflow:         "record overflow",
        alertDecompressionFailure:   "decompression failure",
        alertHandshakeFailure:       "handshake failure",
        alertBadCertificate:         "bad certificate",
        alertUnsupportedCertificate: "unsupported certificate",
        alertCertificateRevoked:     "revoked certificate",
        alertCertificateExpired:     "expired certificate",
        alertCertificateUnknown:     "unknown certificate",
        alertIllegalParameter:       "illegal parameter",
        alertUnknownCA:              "unknown certificate authority",
        alertAccessDenied:           "access denied",
        alertDecodeError:            "error decoding message",
        alertDecryptError:           "error decrypting message",
        alertProtocolVersion:        "protocol version not supported",
        alertInsufficientSecurity:   "insufficient security level",
        alertInternalError:          "internal error",
        alertInappropriateFallback:  "inappropriate fallback",
        alertUserCanceled:           "user canceled",
        alertNoRenegotiation:        "no renegotiation",
}

func (e alert) String() string <span class="cov0" title="0">{
        s, ok := alertText[e]
        if ok </span><span class="cov0" title="0">{
                return s
        }</span>
        <span class="cov0" title="0">return "alert(" + strconv.Itoa(int(e)) + ")"</span>
}

func (e alert) Error() string <span class="cov0" title="0">{
        return e.String()
}</span>
</pre>
		
		<pre class="file" id="file252" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Copyright 2010 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package bfe_tls

import (
        "crypto/aes"
        "crypto/cipher"
        "crypto/des"
        "crypto/hmac"
        "crypto/rc4"
        "crypto/sha1"
        "crypto/x509"
        "fmt"
        "hash"
)

import (
        "golang.org/x/crypto/chacha20poly1305"

        "github.com/tjfoc/gmsm/sm3"
        "github.com/tjfoc/gmsm/sm4"
)

// a keyAgreement implements the client and server side of a TLS key agreement
// protocol by generating and processing key exchange messages.
type keyAgreement interface {
        // On the server side, the first two methods are called in order.

        // In the case that the key agreement protocol doesn't use a
        // ServerKeyExchange message, generateServerKeyExchange can return nil,
        // nil.
        generateServerKeyExchange(*Config, *Certificate, *clientHelloMsg, *serverHelloMsg) (*serverKeyExchangeMsg, error)
        processClientKeyExchange(*Config, *Certificate, *clientKeyExchangeMsg, uint16) ([]byte, error)

        // On the client side, the next two methods are called in order.

        // This method may not be called if the server doesn't send a
        // ServerKeyExchange message.
        processServerKeyExchange(*Config, *clientHelloMsg, *serverHelloMsg, *x509.Certificate, *serverKeyExchangeMsg) error
        generateClientKeyExchange(*Config, *clientHelloMsg, *x509.Certificate) ([]byte, *clientKeyExchangeMsg, error)
}

const (
        // suiteECDH indicates that the cipher suite involves elliptic curve
        // Diffie-Hellman. This means that it should only be selected when the
        // client indicates that it supports ECC with a curve and point format
        // that we're happy with.
        suiteECDHE = 1 &lt;&lt; iota
        // suiteECDSA indicates that the cipher suite involves an ECDSA
        // signature and therefore may only be selected when the server's
        // certificate is ECDSA. If this is not set then the cipher suite is
        // RSA based.
        suiteECDSA
        // suiteTLS12 indicates that the cipher suite should only be advertised
        // and accepted when using TLS 1.2.
        suiteTLS12
        // suiteRC4 indicates that the cipher suite involves RC4 cipher.
        suiteRC4
        // suiteChacha20 indicates that the cipher suite involves chacha20-poly1305
        // cipher.
        suiteChacha20
)

// A cipherSuite is a specific combination of key agreement, cipher and MAC
// function. All cipher suites currently assume RSA key agreement.
type cipherSuite struct {
        id uint16
        // the lengths, in bytes, of the key material needed for each component.
        keyLen int
        macLen int
        ivLen  int
        ka     func(version uint16) keyAgreement
        // flags is a bitmask of the suite* values, above.
        flags  int
        cipher func(key, iv []byte, isRead bool) interface{}
        mac    func(version uint16, macKey []byte) macFunction
        aead   func(key, fixedNonce []byte) cipher.AEAD
}

var cipherSuites = []*cipherSuite{
        // Ciphersuite order is chosen so that ECDHE comes before plain RSA
        // and RC4 comes before AES (because of the Lucky13 attack).

        // Note: chacha20 and poly1305 are built into an AEAD algorithm called AEAD_CHACHA20_POLY1305.
        // it requires a 256 bit key and a 96-bit nonce.
        // See RFC 7905: Chacha20-Poly1305 Cipher Suites for TLS
        {TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256, 32, 0, 12, ecdheRSAKA, suiteECDHE | suiteTLS12 | suiteChacha20, nil, nil, aeadChaCha20Poly1305},
        {TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256, 32, 0, 12, ecdheECDSAKA, suiteECDHE | suiteECDSA | suiteTLS12 | suiteChacha20, nil, nil, aeadChaCha20Poly1305},

        {TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256, 16, 0, 4, ecdheRSAKA, suiteECDHE | suiteTLS12, nil, nil, aeadAESGCM},
        {TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256, 16, 0, 4, ecdheECDSAKA, suiteECDHE | suiteECDSA | suiteTLS12, nil, nil, aeadAESGCM},
        {TLS_ECDHE_RSA_WITH_RC4_128_SHA, 16, 20, 0, ecdheRSAKA, suiteECDHE | suiteRC4, cipherRC4, macSHA1, nil},
        {TLS_ECDHE_ECDSA_WITH_RC4_128_SHA, 16, 20, 0, ecdheECDSAKA, suiteECDHE | suiteECDSA | suiteRC4, cipherRC4, macSHA1, nil},
        {TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA, 16, 20, 16, ecdheRSAKA, suiteECDHE, cipherAES, macSHA1, nil},
        {TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA, 16, 20, 16, ecdheECDSAKA, suiteECDHE | suiteECDSA, cipherAES, macSHA1, nil},
        {TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA, 32, 20, 16, ecdheRSAKA, suiteECDHE, cipherAES, macSHA1, nil},
        {TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA, 32, 20, 16, ecdheECDSAKA, suiteECDHE | suiteECDSA, cipherAES, macSHA1, nil},
        {TLS_RSA_WITH_RC4_128_SHA, 16, 20, 0, rsaKA, suiteRC4, cipherRC4, macSHA1, nil},
        {TLS_RSA_WITH_AES_128_CBC_SHA, 16, 20, 16, rsaKA, 0, cipherAES, macSHA1, nil},
        {TLS_RSA_WITH_AES_256_CBC_SHA, 32, 20, 16, rsaKA, 0, cipherAES, macSHA1, nil},
        {TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA, 24, 20, 8, ecdheRSAKA, suiteECDHE, cipher3DES, macSHA1, nil},
        {TLS_RSA_WITH_3DES_EDE_CBC_SHA, 24, 20, 8, rsaKA, 0, cipher3DES, macSHA1, nil},
        {TLS_RSA_WITH_SM4_SM3, 16, 32, 16, rsaKA, 0, cipherSM4, macSM3, nil},
}

// CheckSuiteRSA checks whether cipher suite using RSA key argreement
func CheckSuiteRSA(id uint16) bool <span class="cov0" title="0">{
        switch id </span>{
        case TLS_RSA_WITH_RC4_128_SHA:<span class="cov0" title="0">
                return true</span>
        case TLS_RSA_WITH_AES_128_CBC_SHA:<span class="cov0" title="0">
                return true</span>
        case TLS_RSA_WITH_AES_256_CBC_SHA:<span class="cov0" title="0">
                return true</span>
        case TLS_RSA_WITH_3DES_EDE_CBC_SHA:<span class="cov0" title="0">
                return true</span>
        case TLS_RSA_WITH_SM4_SM3:<span class="cov0" title="0">
                return true</span>
        }
        <span class="cov0" title="0">return false</span>
}

func CheckSuiteECDHE(id uint16) bool <span class="cov8" title="1">{
        switch id </span>{
        case TLS_ECDHE_ECDSA_WITH_RC4_128_SHA:<span class="cov0" title="0">
                return true</span>
        case TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA:<span class="cov0" title="0">
                return true</span>
        case TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA:<span class="cov0" title="0">
                return true</span>
        case TLS_ECDHE_RSA_WITH_RC4_128_SHA:<span class="cov0" title="0">
                return true</span>
        case TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA:<span class="cov0" title="0">
                return true</span>
        case TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA:<span class="cov0" title="0">
                return true</span>
        case TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA:<span class="cov0" title="0">
                return true</span>
        case TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256:<span class="cov0" title="0">
                return true</span>
        case TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256:<span class="cov0" title="0">
                return true</span>
        case TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256:<span class="cov0" title="0">
                return true</span>
        case TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256:<span class="cov0" title="0">
                return true</span>
        }
        <span class="cov8" title="1">return false</span>
}

func CheckSuitePseudo(suite uint16) bool <span class="cov0" title="0">{
        switch suite </span>{
        case TLS_FALLBACK_SCSV:<span class="cov0" title="0">
                return true</span>
        case TLS_EMPTY_RENEGOTIATION_INFO_SCSV:<span class="cov0" title="0">
                return true</span>
        }
        <span class="cov0" title="0">return false</span>
}

// Note: http2 implementation should not use any of the cipher suite in black list.
// See RFC 7540 Appendix A. TLS 1.2 Cipher Suite Black List
func checkCipherSuiteHttp2Accepted(suite uint16) bool <span class="cov0" title="0">{
        switch suite </span>{
        case TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256:<span class="cov0" title="0">
                return true</span>
        case TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256:<span class="cov0" title="0">
                return true</span>
        case TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256:<span class="cov0" title="0">
                return true</span>
        case TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256:<span class="cov0" title="0">
                return true</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

func cipherRC4(key, iv []byte, isRead bool) interface{} <span class="cov8" title="1">{
        cipher, _ := rc4.NewCipher(key)
        return cipher
}</span>

func cipher3DES(key, iv []byte, isRead bool) interface{} <span class="cov8" title="1">{
        block, _ := des.NewTripleDESCipher(key)
        if isRead </span><span class="cov8" title="1">{
                return cipher.NewCBCDecrypter(block, iv)
        }</span>
        <span class="cov8" title="1">return cipher.NewCBCEncrypter(block, iv)</span>
}

func cipherAES(key, iv []byte, isRead bool) interface{} <span class="cov8" title="1">{
        block, _ := aes.NewCipher(key)
        if isRead </span><span class="cov8" title="1">{
                return cipher.NewCBCDecrypter(block, iv)
        }</span>
        <span class="cov8" title="1">return cipher.NewCBCEncrypter(block, iv)</span>
}

func cipherSM4(key, iv []byte, isRead bool) interface{} <span class="cov0" title="0">{
        block, _ := sm4.NewCipher(key)
        if isRead </span><span class="cov0" title="0">{
                return cipher.NewCBCDecrypter(block, iv)
        }</span>
        <span class="cov0" title="0">return cipher.NewCBCEncrypter(block, iv)</span>
}

// macSHA1 returns a macFunction for the given protocol version.
func macSHA1(version uint16, key []byte) macFunction <span class="cov8" title="1">{
        if version == VersionSSL30 </span><span class="cov8" title="1">{
                mac := ssl30MAC{
                        h:   sha1.New(),
                        key: make([]byte, len(key)),
                }
                copy(mac.key, key)
                return mac
        }</span>
        <span class="cov8" title="1">return tls10MAC{hmac.New(sha1.New, key)}</span>
}

func macSM3(version uint16, key []byte) macFunction <span class="cov0" title="0">{
        return sm3MAC{hmac.New(sm3.New, key)}
}</span>

type macFunction interface {
        Size() int
        MAC(digestBuf, seq, header, data []byte) []byte
}

// aead wraps cipher.AEAD
type aead interface {
        cipher.AEAD

        // explicitIVLen returns the number of bytes used by the explicit nonce
        // that is included in the record. This is eight for older AEADs and
        // zero for modern ones.
        explicitNonceLen() int
}

// fixedNonceAEAD wraps an AEAD and prefixes a fixed portion of the nonce to
// each call.
type fixedNonceAEAD struct {
        // sealNonce and openNonce are buffers where the larger nonce will be
        // constructed. Since a seal and open operation may be running
        // concurrently, there is a separate buffer for each.
        sealNonce, openNonce []byte
        aead                 cipher.AEAD
}

func (f *fixedNonceAEAD) NonceSize() int        <span class="cov0" title="0">{ return 8 }</span>
func (f *fixedNonceAEAD) Overhead() int         <span class="cov8" title="1">{ return f.aead.Overhead() }</span>
func (f *fixedNonceAEAD) explicitNonceLen() int <span class="cov8" title="1">{ return 8 }</span>

func (f *fixedNonceAEAD) Seal(out, nonce, plaintext, additionalData []byte) []byte <span class="cov8" title="1">{
        copy(f.sealNonce[len(f.sealNonce)-8:], nonce)
        return f.aead.Seal(out, f.sealNonce, plaintext, additionalData)
}</span>

func (f *fixedNonceAEAD) Open(out, nonce, plaintext, additionalData []byte) ([]byte, error) <span class="cov8" title="1">{
        copy(f.openNonce[len(f.openNonce)-8:], nonce)
        return f.aead.Open(out, f.openNonce, plaintext, additionalData)
}</span>

// xoredNonceAEAD wraps an AEAD and XOR in a fixed pattern to the nonce
// before each call.
type xorNonceAEAD struct {
        // sealNonce and openNonce are buffers where the larger nonce will be
        // constructed. Since a seal and open operation may be running
        // concurrently, there is a separate buffer for each.
        sealNonce, openNonce []byte
        aead                 cipher.AEAD
}

func (f *xorNonceAEAD) NonceSize() int        <span class="cov0" title="0">{ return 8 }</span>
func (f *xorNonceAEAD) Overhead() int         <span class="cov8" title="1">{ return f.aead.Overhead() }</span>
func (f *xorNonceAEAD) explicitNonceLen() int <span class="cov8" title="1">{ return 0 }</span>

func (f *xorNonceAEAD) Seal(out, nonce, plaintext, additionalData []byte) []byte <span class="cov8" title="1">{
        // Note: The 96-bit nonce for Chacha20-Poly1305 is constructed from the record sequence number
        // and the shared IV. (The record sequence number is the second input parameter *nonce*,
        // and the shared IV is stored in nonceMask)
        //
        // Nonce for Chacha20-Poly1305 is formed as follows:
        // 1. the 64-bit record sequence number is serialized as an 8-byte big-endian value
        // 2. the sequence number is XORed with the last 8-byte of the shared IV
        //
        // See RFC 7905: ChaCha20-Poly1305 for tls
        for i, b := range nonce </span><span class="cov8" title="1">{
                f.sealNonce[4+i] ^= b
        }</span>
        <span class="cov8" title="1">result := f.aead.Seal(out, f.sealNonce[:], plaintext, additionalData)
        for i, b := range nonce </span><span class="cov8" title="1">{
                f.sealNonce[4+i] ^= b
        }</span>

        <span class="cov8" title="1">return result</span>
}

func (f *xorNonceAEAD) Open(out, nonce, plaintext, additionalData []byte) ([]byte, error) <span class="cov8" title="1">{
        for i, b := range nonce </span><span class="cov8" title="1">{
                f.openNonce[4+i] ^= b
        }</span>
        <span class="cov8" title="1">result, err := f.aead.Open(out, f.openNonce[:], plaintext, additionalData)
        for i, b := range nonce </span><span class="cov8" title="1">{
                f.openNonce[4+i] ^= b
        }</span>

        <span class="cov8" title="1">return result, err</span>
}

func aeadAESGCM(key, fixedNonce []byte) cipher.AEAD <span class="cov8" title="1">{
        aes, err := aes.NewCipher(key)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">aead, err := cipher.NewGCM(aes)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov8" title="1">nonce1, nonce2 := make([]byte, 12), make([]byte, 12)
        copy(nonce1, fixedNonce)
        copy(nonce2, fixedNonce)

        return &amp;fixedNonceAEAD{nonce1, nonce2, aead}</span>
}

func aeadChaCha20Poly1305(key, fixedNonce []byte) cipher.AEAD <span class="cov8" title="1">{
        aead, err := chacha20poly1305.New(key)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov8" title="1">nonce1, nonce2 := make([]byte, 12), make([]byte, 12)
        copy(nonce1, fixedNonce)
        copy(nonce2, fixedNonce)

        return &amp;xorNonceAEAD{nonce1, nonce2, aead}</span>
}

type sm3MAC struct {
        h hash.Hash
}

func (s sm3MAC) Size() int <span class="cov0" title="0">{
        return s.h.Size()
}</span>

func (s sm3MAC) MAC(digestBuf, seq, header, data []byte) []byte <span class="cov0" title="0">{
        s.h.Reset()
        s.h.Write(seq)
        s.h.Write(header)
        s.h.Write(data)
        res := s.h.Sum(digestBuf[:0])
        return res
}</span>

// ssl30MAC implements the SSLv3 MAC function, as defined in
// www.mozilla.org/projects/security/pki/nss/ssl/draft302.txt section 5.2.3.1
type ssl30MAC struct {
        h   hash.Hash
        key []byte
}

func (s ssl30MAC) Size() int <span class="cov8" title="1">{
        return s.h.Size()
}</span>

var ssl30Pad1 = [48]byte{0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36}

var ssl30Pad2 = [48]byte{0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c}

func (s ssl30MAC) MAC(digestBuf, seq, header, data []byte) []byte <span class="cov8" title="1">{
        padLength := 48
        if s.h.Size() == 20 </span><span class="cov8" title="1">{
                padLength = 40
        }</span>

        <span class="cov8" title="1">s.h.Reset()
        s.h.Write(s.key)
        s.h.Write(ssl30Pad1[:padLength])
        s.h.Write(seq)
        s.h.Write(header[:1])
        s.h.Write(header[3:5])
        s.h.Write(data)
        digestBuf = s.h.Sum(digestBuf[:0])

        s.h.Reset()
        s.h.Write(s.key)
        s.h.Write(ssl30Pad2[:padLength])
        s.h.Write(digestBuf)
        return s.h.Sum(digestBuf[:0])</span>
}

// tls10MAC implements the TLS 1.0 MAC function. RFC 2246, section 6.2.3.
type tls10MAC struct {
        h hash.Hash
}

func (s tls10MAC) Size() int <span class="cov8" title="1">{
        return s.h.Size()
}</span>

func (s tls10MAC) MAC(digestBuf, seq, header, data []byte) []byte <span class="cov8" title="1">{
        s.h.Reset()
        s.h.Write(seq)
        s.h.Write(header)
        s.h.Write(data)
        return s.h.Sum(digestBuf[:0])
}</span>

func rsaKA(version uint16) keyAgreement <span class="cov8" title="1">{
        return rsaKeyAgreement{}
}</span>

func ecdheECDSAKA(version uint16) keyAgreement <span class="cov8" title="1">{
        return &amp;ecdheKeyAgreement{
                sigType: signatureECDSA,
                version: version,
        }
}</span>

func ecdheRSAKA(version uint16) keyAgreement <span class="cov8" title="1">{
        return &amp;ecdheKeyAgreement{
                sigType: signatureRSA,
                version: version,
        }
}</span>

// mutualCipherSuite returns a cipherSuite given a list of supported
// ciphersuites and the id requested by the peer.
func mutualCipherSuite(have []uint16, want uint16) *cipherSuite <span class="cov8" title="1">{
        for _, id := range have </span><span class="cov8" title="1">{
                if id == want </span><span class="cov8" title="1">{
                        for _, suite := range cipherSuites </span><span class="cov8" title="1">{
                                if suite.id == want </span><span class="cov8" title="1">{
                                        return suite
                                }</span>
                        }
                        <span class="cov0" title="0">return nil</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

// A list of the possible cipher suite ids. Taken from
// http://www.iana.org/assignments/tls-parameters/tls-parameters.xml
const (
        TLS_RSA_WITH_RC4_128_SHA                      uint16 = 0x0005
        TLS_RSA_WITH_3DES_EDE_CBC_SHA                 uint16 = 0x000a
        TLS_RSA_WITH_AES_128_CBC_SHA                  uint16 = 0x002f
        TLS_RSA_WITH_AES_256_CBC_SHA                  uint16 = 0x0035
        TLS_ECDHE_ECDSA_WITH_RC4_128_SHA              uint16 = 0xc007
        TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA          uint16 = 0xc009
        TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA          uint16 = 0xc00a
        TLS_ECDHE_RSA_WITH_RC4_128_SHA                uint16 = 0xc011
        TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA           uint16 = 0xc012
        TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA            uint16 = 0xc013
        TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA            uint16 = 0xc014
        TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256         uint16 = 0xc02f
        TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256       uint16 = 0xc02b
        TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256   uint16 = 0xcca8
        TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256 uint16 = 0xcca9
        TLS_RSA_WITH_SM4_SM3                          uint16 = 0xe019

        // TLS_FALLBACK_SCSV isn't a standard cipher suite but an indicator
        // that the client is doing version fallback. See
        // https://tools.ietf.org/html/draft-ietf-tls-downgrade-scsv-00.
        TLS_FALLBACK_SCSV uint16 = 0x5600

        // TLS_EMPTY_RENEGOTIATION_INFO_SCSV isn't a true cipher suite, it has
        // the same semantics as an empty "renegotiation info" extension. See
        // https://tools.ietf.org/html/rfc5746#section-3.3
        TLS_EMPTY_RENEGOTIATION_INFO_SCSV = 0x00ff
)

var cipherSuiteTextMap = map[uint16]string{
        TLS_RSA_WITH_RC4_128_SHA:                      "TLS_RSA_WITH_RC4_128_SHA",
        TLS_RSA_WITH_3DES_EDE_CBC_SHA:                 "TLS_RSA_WITH_3DES_EDE_CBC_SHA",
        TLS_RSA_WITH_AES_128_CBC_SHA:                  "TLS_RSA_WITH_AES_128_CBC_SHA",
        TLS_RSA_WITH_AES_256_CBC_SHA:                  "TLS_RSA_WITH_AES_256_CBC_SHA",
        TLS_ECDHE_ECDSA_WITH_RC4_128_SHA:              "TLS_ECDHE_ECDSA_WITH_RC4_128_SHA",
        TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA:          "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA",
        TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA:          "TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA",
        TLS_ECDHE_RSA_WITH_RC4_128_SHA:                "TLS_ECDHE_RSA_WITH_RC4_128_SHA",
        TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA:           "TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA",
        TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA:            "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA",
        TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA:            "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA",
        TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256:         "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256",
        TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256:       "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256",
        TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256:   "TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256",
        TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256: "TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256",
        TLS_RSA_WITH_SM4_SM3:                          "TLS_RSA_WITH_SM4_SM3",
}

func CipherSuiteText(suite uint16) string <span class="cov0" title="0">{
        if text, ok := cipherSuiteTextMap[suite]; ok </span><span class="cov0" title="0">{
                return text
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("TLS_CIPHER_SUITE_%x", suite)</span>
}

// cipher suite names in OpenSSL
// See: https://www.openssl.org/docs/man1.0.2/apps/ciphers.html
var cipherSuiteTextMapForOpenSSL = map[uint16]string{
        TLS_RSA_WITH_RC4_128_SHA:                      "RC4-SHA",
        TLS_RSA_WITH_3DES_EDE_CBC_SHA:                 "DES-CBC3-SHA",
        TLS_RSA_WITH_AES_128_CBC_SHA:                  "AES128-SHA",
        TLS_RSA_WITH_AES_256_CBC_SHA:                  "AES256-SHA",
        TLS_ECDHE_ECDSA_WITH_RC4_128_SHA:              "ECDHE-ECDSA-RC4-SHA",
        TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA:          "ECDHE-ECDSA-AES128-SHA",
        TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA:          "ECDHE-ECDSA-AES256-SHA",
        TLS_ECDHE_RSA_WITH_RC4_128_SHA:                "ECDHE-RSA-RC4-SHA",
        TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA:           "ECDHE-RSA-DES-CBC3-SHA",
        TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA:            "ECDHE-RSA-AES128-SHA",
        TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA:            "ECDHE-RSA-AES256-SHA",
        TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256:         "ECDHE-RSA-AES128-GCM-SHA256",
        TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256:       "ECDHE-ECDSA-AES128-GCM-SHA256",
        TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256:   "ECDHE-RSA-CHACHA20-POLY1305",
        TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256: "ECDHE-ECDSA-CHACHA20-POLY1305",
}

func CipherSuiteTextForOpenSSL(suite uint16) string <span class="cov0" title="0">{
        if text, ok := cipherSuiteTextMapForOpenSSL[suite]; ok </span><span class="cov0" title="0">{
                return text
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("TLS_CIPHER_SUITE_%x", suite)</span>
}

type CipherFilter func(id uint16) bool

func FilterCiphers(cipherSuites []uint16, filter CipherFilter) ([]uint16, []uint16) <span class="cov0" title="0">{
        // only cipher suites filter accepted
        acceptedCipherSuites := make([]uint16, 0)

        // cipher suites filter rejected
        rejectedCipherSuites := make([]uint16, 0)

        for _, cipher := range cipherSuites </span><span class="cov0" title="0">{
                if filter(cipher) </span><span class="cov0" title="0">{
                        acceptedCipherSuites = append(acceptedCipherSuites, cipher)
                        continue</span>
                }
                <span class="cov0" title="0">rejectedCipherSuites = append(rejectedCipherSuites, cipher)</span>
        }

        <span class="cov0" title="0">return acceptedCipherSuites, rejectedCipherSuites</span>
}
</pre>
		
		<pre class="file" id="file253" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package bfe_tls

import (
        "container/list"
        "crypto"
        "crypto/rand"
        "crypto/x509"
        "fmt"
        "io"
        "math/big"
        "strings"
        "sync"
        "time"
)

import (
        "golang.org/x/crypto/ocsp"
)

const (
        VersionSSL30 = 0x0300
        VersionTLS10 = 0x0301
        VersionTLS11 = 0x0302
        VersionTLS12 = 0x0303
)

const (
        minPlaintext    = 1024         // length plaintext payload that fit into a signle TCP segment
        maxPlaintext    = 16384        // maximum plaintext payload length
        maxCiphertext   = 16384 + 2048 // maximum ciphertext payload length
        recordHeaderLen = 5            // record header length
        maxHandshake    = 65536        // maximum handshake we support (protocol max is 16 MB)

        minVersion = VersionSSL30
        maxVersion = VersionTLS12

        ticketKeyNameLen = 16 // length for session ticket key name
)

// the following grade (A, B, C) is defined by
// www.ssllabs.com
// Grade A+: no ssl3, tls1.0, tls1.1 &amp;&amp; no RC4 ciphers
// Grade A: no ssl3 &amp;&amp; no RC4 ciphers
// Grade B: ssl3 is ok only with RC4 cipher, or
//    modern version(&gt;=tls10) with no RC4 cipher
// Grade C: ssl3 is ok only with RC4 cipher
const (
        GradeAPlus = "A+"
        GradeA     = "A"
        GradeB     = "B"
        GradeC     = "C"
)

/*
 * Note: Google's servers use small TLS records that fit into a sing TCP segment
 * for the first ~1 MB of data, increase record size to 16 KB after that to optimize throughput,
 * and then reset record size back to a single segment after ~1 second of inactivity
 * - lather, rinse, repeat.
 *
 * For more information, see:
 *     http://chimera.labs.oreilly.com/books/1230000000545/ch04.html#TLS_RECORD_SIZE
 */
var (
        initPlaintext  int = minPlaintext // initial length of plaintext payload
        bytesThreshold int = 1024 * 1024  // 1 MB
        inactiveSeconds time.Duration = time.Duration(1 * time.Second) // 1 second
)

// TLS record types.
type recordType uint8

const (
        recordTypeChangeCipherSpec recordType = 20
        recordTypeAlert            recordType = 21
        recordTypeHandshake        recordType = 22
        recordTypeApplicationData  recordType = 23
)

// TLS handshake message types.
const (
        typeClientHello        uint8 = 1
        typeServerHello        uint8 = 2
        typeNewSessionTicket   uint8 = 4
        typeCertificate        uint8 = 11
        typeServerKeyExchange  uint8 = 12
        typeCertificateRequest uint8 = 13
        typeServerHelloDone    uint8 = 14
        typeCertificateVerify  uint8 = 15
        typeClientKeyExchange  uint8 = 16
        typeFinished           uint8 = 20
        typeCertificateStatus  uint8 = 22
        typeNextProtocol       uint8 = 67 // Not IANA assigned
)

// TLS compression types.
const (
        compressionNone uint8 = 0
)

// TLS extension numbers
const (
        extensionServerName          uint16 = 0
        extensionStatusRequest       uint16 = 5
        extensionSupportedCurves     uint16 = 10
        extensionSupportedPoints     uint16 = 11
        extensionSignatureAlgorithms uint16 = 13
        extensionALPN                uint16 = 16
        extensionPadding             uint16 = 21
        extensionSessionTicket       uint16 = 35
        extensionNextProtoNeg        uint16 = 13172 // not IANA assigned
        extensionRenegotiationInfo   uint16 = 0xff01
)

// TLS signaling cipher suite values
const (
        scsvRenegotiation uint16 = 0x00ff
)

// CurveID is the type of a TLS identifier for an elliptic curve. See
// http://www.iana.org/assignments/tls-parameters/tls-parameters.xml#tls-parameters-8
type CurveID uint16

const (
        CurveP256 CurveID = 23
        CurveP384 CurveID = 24
        CurveP521 CurveID = 25
)

// TLS Elliptic Curve Point Formats
// http://www.iana.org/assignments/tls-parameters/tls-parameters.xml#tls-parameters-9
const (
        pointFormatUncompressed uint8 = 0
)

// TLS CertificateStatusType (RFC 3546)
const (
        statusTypeOCSP uint8 = 1
)

// Certificate types (for certificateRequestMsg)
const (
        certTypeRSASign    = 1 // A certificate containing an RSA key
        certTypeDSSSign    = 2 // A certificate containing a DSA key
        certTypeRSAFixedDH = 3 // A certificate containing a static DH key
        certTypeDSSFixedDH = 4 // A certificate containing a static DH key

        // See RFC4492 sections 3 and 5.5.
        certTypeECDSASign      = 64 // A certificate containing an ECDSA-capable public key, signed with ECDSA.
        certTypeRSAFixedECDH   = 65 // A certificate containing an ECDH-capable public key, signed with RSA.
        certTypeECDSAFixedECDH = 66 // A certificate containing an ECDH-capable public key, signed with ECDSA.

        // Rest of these are reserved by the TLS spec
)

// Hash functions for TLS 1.2 (See RFC 5246, section A.4.1)
const (
        hashSHA1   uint8 = 2
        hashSHA256 uint8 = 4
)

// Signature algorithms for TLS 1.2 (See RFC 5246, section A.4.1)
const (
        signatureRSA   uint8 = 1
        signatureECDSA uint8 = 3
)

// signatureAndHash mirrors the TLS 1.2, SignatureAndHashAlgorithm struct. See
// RFC 5246, section A.4.1.
type signatureAndHash struct {
        hash, signature uint8
}

// supportedSKXSignatureAlgorithms contains the signature and hash algorithms
// that the code advertises as supported in a TLS 1.2 ClientHello.
var supportedSKXSignatureAlgorithms = []signatureAndHash{
        {hashSHA256, signatureRSA},
        {hashSHA256, signatureECDSA},
        {hashSHA1, signatureRSA},
        {hashSHA1, signatureECDSA},
}

// supportedClientCertSignatureAlgorithms contains the signature and hash
// algorithms that the code advertises as supported in a TLS 1.2
// CertificateRequest.
var supportedClientCertSignatureAlgorithms = []signatureAndHash{
        {hashSHA256, signatureRSA},
        {hashSHA256, signatureECDSA},
}

// ConnectionState records basic TLS details about the connection.
type ConnectionState struct {
        Version                    uint16                // TLS version used by the connection (e.g. VersionTLS12)
        HandshakeComplete          bool                  // TLS handshake is complete
        DidResume                  bool                  // connection resumes a previous TLS connection
        CipherSuite                uint16                // cipher suite in use (TLS_RSA_WITH_RC4_128_SHA, ...)
        OcspStaple                 bool                  // use ocsp staple (in server side)
        NegotiatedProtocolIsMutual bool                  // negotiated protocol was advertised by server
        NegotiatedProtocol         string                // negotiated next protocol (from Config.NextProtos)
        ServerName                 string                // server name requested by client, if any (server side only)
        HandshakeTime              time.Duration         // TLS handshake time (in server side)
        PeerCertificates           []*x509.Certificate   // certificate chain presented by remote peer
        VerifiedChains             [][]*x509.Certificate // verified chains built from PeerCertificates
        ClientRandom               []byte                // random in client hello
        ServerRandom               []byte                // random in server hello
        MasterSecret               []byte                // master secret used by the connection
        ClientCiphers              []uint16              // ciphers supported by client
        ClientAuth                 bool                  // enable TLS Client Authentication
        ClientCAName               string                // TLS client CA name
        JA3Raw                     string                // JA3 fingerprint string for TLS Client
        JA3Hash                    string                // JA3 fingerprint hash for TLS Client
}

// ClientAuthType declares the policy the server will follow for
// TLS Client Authentication.
type ClientAuthType int

const (
        NoClientCert ClientAuthType = iota
        RequestClientCert
        RequireAnyClientCert
        VerifyClientCertIfGiven
        RequireAndVerifyClientCert
)

// ClientSessionState contains the state needed by clients to resume TLS
// sessions.
type ClientSessionState struct {
        sessionTicket      []uint8             // Encrypted ticket used for session resumption with server
        vers               uint16              // SSL/TLS version negotiated for the session
        cipherSuite        uint16              // Ciphersuite negotiated for the session
        masterSecret       []byte              // MasterSecret generated by client on a full handshake
        serverCertificates []*x509.Certificate // Certificate chain presented by the server
}

// ClientSessionCache is a cache of ClientSessionState objects that can be used
// by a client to resume a TLS session with a given server. ClientSessionCache
// implementations should expect to be called concurrently from different
// goroutines.
type ClientSessionCache interface {
        // Get searches for a ClientSessionState associated with the given key.
        // On return, ok is true if one was found.
        Get(sessionKey string) (session *ClientSessionState, ok bool)

        // Put adds the ClientSessionState to the cache with the given key.
        Put(sessionKey string, cs *ClientSessionState)
}

type ServerSessionCache interface {
        // Get searches for a sessionState associated with the given key.
        // On return, ok is true if one was found.
        Get(sessionKey string) (sessionState []byte, ok bool)

        // Put adds the sessionState to the cache with the given key.
        Put(sessionKey string, sessionState []byte) error
}

type MultiCertificate interface {
        // Get certificate for the given conn
        Get(c *Conn) *Certificate
}

// multiply certificate policy for thirdparty
var tlsMultiCertificate MultiCertificate

func SetTlsMultiCertificate(m MultiCertificate) <span class="cov0" title="0">{
        tlsMultiCertificate = m
}</span>

type NextProtoConf interface {
        // Get next protos for the given conn
        Get(c *Conn) []string
}

// Rule represents customized tls config for specific conn in server side
type Rule struct {
        // NextProtos is a list of supported, application level protocols.
        NextProtos NextProtoConf

        // Security Grade
        Grade string

        // enable TLS Client Authentication
        ClientAuth bool

        // client CA certificate
        ClientCAs *x509.CertPool

        // client CA name
        ClientCAName string

        // client CRL pool
        ClientCRLPool *CRLPool

        // enable Chacha20-poly1305 cipher suites
        Chacha20 bool

        // enable Dynamic TLS record size
        DynamicRecord bool
}

type ServerRule interface {
        // Get tls rule for the given conn
        Get(c *Conn) *Rule
}

// A Config structure is used to configure a TLS client or server.
// After one has been passed to a TLS function it must not be
// modified. A Config may be reused; the tls package will also not
// modify it.
type Config struct {
        // Rand provides the source of entropy for nonces and RSA blinding.
        // If Rand is nil, TLS uses the cryptographic random reader in package
        // crypto/rand.
        // The Reader must be safe for use by multiple goroutines.
        Rand io.Reader

        // Time returns the current time as the number of seconds since the epoch.
        // If Time is nil, TLS uses time.Now.
        Time func() time.Time

        // Certificates contains one or more certificate chains
        // to present to the other side of the connection.
        // Server configurations must include at least one certificate.
        Certificates []Certificate

        // NameToCertificate maps from a certificate name to an element of
        // Certificates. Note that a certificate name can be of the form
        // '*.example.com' and so doesn't have to be a domain name as such.
        // See Config.BuildNameToCertificate
        // The nil value causes the first element of Certificates to be used
        // for all connections.
        NameToCertificate map[string]*Certificate

        // default multiply certificates policy for tls server
        MultiCert MultiCertificate

        // RootCAs defines the set of root certificate authorities
        // that clients use when verifying server certificates.
        // If RootCAs is nil, TLS uses the host's root CA set.
        RootCAs *x509.CertPool

        // NextProtos is a list of supported, application level protocols.
        NextProtos []string

        // ServerName is used to verify the hostname on the returned
        // certificates unless InsecureSkipVerify is given. It is also included
        // in the client's handshake to support virtual hosting.
        ServerName string

        // ClientAuth determines the server's global policy for
        // TLS Client Authentication. The default is NoClientCert.
        ClientAuth ClientAuthType

        // ClientCAs defines the set of root certificate authorities
        // that servers use if required to verify a client certificate
        // by the policy in ClientAuth.
        ClientCAs *x509.CertPool

        // InsecureSkipVerify controls whether a client verifies the
        // server's certificate chain and host name.
        // If InsecureSkipVerify is true, TLS accepts any certificate
        // presented by the server and any host name in that certificate.
        // In this mode, TLS is susceptible to man-in-the-middle attacks.
        // This should be used only for testing.
        InsecureSkipVerify bool

        // CipherSuites is a list of supported cipher suites. If CipherSuites
        // is nil, TLS uses a list of suites supported by the implementation.
        CipherSuites []uint16

        // Priority of cipher suites in server side. If PreferServerCipherSuites
        // is false, CipherSuitesPriority should be ignored during cipher suite
        // negotiation
        CipherSuitesPriority []uint16

        // PreferServerCipherSuites controls whether the server selects the
        // client's most preferred ciphersuite, or the server's most preferred
        // ciphersuite. If true then the server's preference, as expressed in
        // the order of elements in CipherSuites, is used.
        PreferServerCipherSuites bool

        // here prohibit poodle attack by allow RC4 cipher only used with ssl3.0
        Ssl3PoodleProofed bool

        // SessionTicketsDisabled may be set to true to disable session ticket
        // (resumption) support.
        SessionTicketsDisabled bool

        // SessionTicketKey is used by TLS servers to provide session
        // resumption. See RFC 5077. If zero, it will be filled with
        // random data before the first server handshake.
        //
        // If multiple servers are terminating connections for the same host
        // they should all have the same SessionTicketKey. If the
        // SessionTicketKey leaks, previously recorded and future TLS
        // connections using that key are compromised.
        SessionTicketKey [32]byte

        // SessionTicketKeyName is used as an identifier for SessionTicketKey
        // in SessionTicket
        SessionTicketKeyName [16]byte

        // SessionCache is a cache of ClientSessionState entries for TLS session
        // resumption.
        ClientSessionCache ClientSessionCache

        // SessionCache is a cache of sessionState entries for TLS session
        // resumption.
        ServerSessionCache ServerSessionCache

        // SessionCacheDisabled may be set to true to disable session cache
        // (resumption) support.
        SessionCacheDisabled bool

        // MinVersion contains the minimum SSL/TLS version that is acceptable.
        // If zero, then SSLv3 is taken as the minimum.
        MinVersion uint16

        // MaxVersion contains the maximum SSL/TLS version that is acceptable.
        // If zero, then the maximum version supported by this package is used,
        // which is currently TLS 1.2.
        MaxVersion uint16

        // CurvePreferences contains the elliptic curves that will be used in
        // an ECDHE handshake, in preference order. If empty, the default will
        // be used.
        CurvePreferences []CurveID

        // Support SSLv2 ClientHello for backward compatibility with ancient
        // TLS-capable clients.
        EnableSslv2ClientHello bool

        // customized config for server side
        ServerRule ServerRule

        serverInitOnce sync.Once // guards calling (*Config).serverInit
}

// Clone returns a shallow clone of c. It is safe to clone a Config that is
// being used concurrently by a TLS client or server.
func (c *Config) Clone() *Config <span class="cov8" title="1">{
        // Running serverInit ensures that it's safe to read
        // SessionTicketsDisabled.
        c.serverInitOnce.Do(func() </span><span class="cov8" title="1">{ c.serverInit() }</span>)

        <span class="cov8" title="1">return &amp;Config{
                Rand:                     c.Rand,
                Time:                     c.Time,
                Certificates:             c.Certificates,
                NameToCertificate:        c.NameToCertificate,
                MultiCert:                c.MultiCert,
                RootCAs:                  c.RootCAs,
                NextProtos:               c.NextProtos,
                ServerName:               c.ServerName,
                ClientAuth:               c.ClientAuth,
                ClientCAs:                c.ClientCAs,
                InsecureSkipVerify:       c.InsecureSkipVerify,
                CipherSuites:             c.CipherSuites,
                CipherSuitesPriority:     c.CipherSuitesPriority,
                PreferServerCipherSuites: c.PreferServerCipherSuites,
                Ssl3PoodleProofed:        c.Ssl3PoodleProofed,
                SessionTicketsDisabled:   c.SessionTicketsDisabled,
                SessionTicketKey:         c.SessionTicketKey,
                SessionTicketKeyName:     c.SessionTicketKeyName,
                ClientSessionCache:       c.ClientSessionCache,
                ServerSessionCache:       c.ServerSessionCache,
                SessionCacheDisabled:     c.SessionCacheDisabled,
                MinVersion:               c.MinVersion,
                MaxVersion:               c.MaxVersion,
                CurvePreferences:         c.CurvePreferences,
                EnableSslv2ClientHello:   c.EnableSslv2ClientHello,
                ServerRule:               c.ServerRule,
        }</span>
}

func (c *Config) serverInit() <span class="cov8" title="1">{
        if c.SessionTicketsDisabled </span><span class="cov0" title="0">{
                return
        }</span>

        // If the key has already been set then we have nothing to do.
        <span class="cov8" title="1">for _, b := range c.SessionTicketKey </span><span class="cov8" title="1">{
                if b != 0 </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        <span class="cov8" title="1">if _, err := io.ReadFull(c.rand(), c.SessionTicketKey[:]); err != nil </span><span class="cov0" title="0">{
                c.SessionTicketsDisabled = true
        }</span>
}

func (c *Config) rand() io.Reader <span class="cov8" title="1">{
        r := c.Rand
        if r == nil </span><span class="cov8" title="1">{
                return rand.Reader
        }</span>
        <span class="cov8" title="1">return r</span>
}

func (c *Config) time() time.Time <span class="cov0" title="0">{
        t := c.Time
        if t == nil </span><span class="cov0" title="0">{
                t = time.Now
        }</span>
        <span class="cov0" title="0">return t()</span>
}

func (c *Config) cipherSuites() []uint16 <span class="cov8" title="1">{
        s := c.CipherSuites
        if s == nil </span><span class="cov8" title="1">{
                s = defaultCipherSuites()
        }</span>
        <span class="cov8" title="1">return s</span>
}

func (c *Config) minVersion() uint16 <span class="cov8" title="1">{
        if c == nil || c.MinVersion == 0 </span><span class="cov8" title="1">{
                return minVersion
        }</span>
        <span class="cov8" title="1">return c.MinVersion</span>
}

func (c *Config) maxVersion() uint16 <span class="cov8" title="1">{
        if c == nil || c.MaxVersion == 0 </span><span class="cov8" title="1">{
                return maxVersion
        }</span>
        <span class="cov8" title="1">return c.MaxVersion</span>
}

var defaultCurvePreferences = []CurveID{CurveP256, CurveP384, CurveP521}

func (c *Config) curvePreferences() []CurveID <span class="cov8" title="1">{
        if c == nil || len(c.CurvePreferences) == 0 </span><span class="cov8" title="1">{
                return defaultCurvePreferences
        }</span>
        <span class="cov0" title="0">return c.CurvePreferences</span>
}

// mutualVersion returns the protocol version to use given the advertised
// version of the peer.
func (c *Config) mutualVersion(vers uint16) (uint16, bool) <span class="cov8" title="1">{
        minVersion := c.minVersion()
        maxVersion := c.maxVersion()

        if vers &lt; minVersion </span><span class="cov8" title="1">{
                return 0, false
        }</span>
        <span class="cov8" title="1">if vers &gt; maxVersion </span><span class="cov8" title="1">{
                vers = maxVersion
        }</span>
        <span class="cov8" title="1">return vers, true</span>
}

// followed the rule defined in www.ssllabs.com:
// in Grade "A+", ssl version older than tls1.2 is not allowed
// in Grade "A", ssl version older than tls1.0 is not allowed
func (c *Config) checkVersionGrade(vers uint16, grade string) (uint16, bool) <span class="cov8" title="1">{
        // ssl ver older than tls1.0 is not allowed for Grade A
        if grade == GradeA &amp;&amp; vers &lt; VersionTLS10 </span><span class="cov0" title="0">{
                return 0, false
        }</span> else<span class="cov8" title="1"> if grade == GradeAPlus &amp;&amp; vers &lt; VersionTLS12 </span><span class="cov0" title="0">{ // ssl version older than tls1.2 is not allowed for Grade A+
                return 0, false
        }</span>

        <span class="cov8" title="1">return vers, true</span>
}

const (
        disableRC4 uint8 = 1
        enableRC4  uint8 = 2
        onlyRC4    uint8 = 3
)

// currently, Grade A+ and Grade A need to exclude some ciphers with "RC4"
// ssl grade rule is defined by www.ssllabs.com:
// Grade A: no ssl3 &amp;&amp; no RC4 ciphers
// Grade B: ssl3 is ok only with RC4 cipher, or modern version(&gt;=tls10) with no RC4 cipher
// Grade C: ssl3 is ok only with RC4 cipher
func (c *Config) checkCipherGrade(conn *Conn) (useRC4 uint8) <span class="cov8" title="1">{
        switch conn.grade </span>{
        case GradeAPlus:<span class="cov0" title="0">
                fallthrough</span>
        case GradeA:<span class="cov0" title="0">
                return disableRC4</span>
        case GradeB:<span class="cov0" title="0">
                if conn.vers &gt;= VersionTLS10 </span><span class="cov0" title="0">{
                        return disableRC4
                }</span> else<span class="cov0" title="0"> { //ssl3.0
                        return onlyRC4
                }</span>
        case GradeC:<span class="cov8" title="1">
                if c.Ssl3PoodleProofed &amp;&amp; conn.vers == VersionSSL30 </span><span class="cov0" title="0">{
                        return onlyRC4
                }</span>
                <span class="cov8" title="1">return enableRC4</span>
        default:<span class="cov0" title="0">
                // never go here
                return enableRC4</span>
        }
}

// getCertificateForName returns the best certificate for the given name,
// defaulting to the first element of c.Certificates if there are no good
// options.
func (c *Config) getCertificateForName(name string) *Certificate <span class="cov8" title="1">{
        if len(c.Certificates) == 1 || c.NameToCertificate == nil </span><span class="cov0" title="0">{
                // There's only one choice, so no point doing any work.
                return &amp;c.Certificates[0]
        }</span>

        <span class="cov8" title="1">name = strings.ToLower(name)
        for len(name) &gt; 0 &amp;&amp; name[len(name)-1] == '.' </span><span class="cov0" title="0">{
                name = name[:len(name)-1]
        }</span>

        <span class="cov8" title="1">if cert, ok := c.NameToCertificate[name]; ok </span><span class="cov8" title="1">{
                return cert
        }</span>

        // try replacing labels in the name with wildcards until we get a
        // match.
        <span class="cov8" title="1">labels := strings.Split(name, ".")
        for i := range labels </span><span class="cov8" title="1">{
                labels[i] = "*"
                candidate := strings.Join(labels, ".")
                if cert, ok := c.NameToCertificate[candidate]; ok </span><span class="cov8" title="1">{
                        return cert
                }</span>
        }

        // If nothing matches, return the first certificate.
        <span class="cov8" title="1">return &amp;c.Certificates[0]</span>
}

// BuildNameToCertificate parses c.Certificates and builds c.NameToCertificate
// from the CommonName and SubjectAlternateName fields of each of the leaf
// certificates.
func (c *Config) BuildNameToCertificate() <span class="cov8" title="1">{
        c.NameToCertificate = make(map[string]*Certificate)
        for i := range c.Certificates </span><span class="cov8" title="1">{
                cert := &amp;c.Certificates[i]
                x509Cert, err := x509.ParseCertificate(cert.Certificate[0])
                if err != nil </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if len(x509Cert.Subject.CommonName) &gt; 0 </span><span class="cov8" title="1">{
                        c.NameToCertificate[x509Cert.Subject.CommonName] = cert
                }</span>
                <span class="cov8" title="1">for _, san := range x509Cert.DNSNames </span><span class="cov8" title="1">{
                        c.NameToCertificate[san] = cert
                }</span>
        }
}

// A Certificate is a chain of one or more certificates, leaf first.
type Certificate struct {
        Certificate [][]byte
        PrivateKey  crypto.PrivateKey // supported types: *rsa.PrivateKey, *ecdsa.PrivateKey
        // OCSPStaple contains an optional OCSP response which will be served
        // to clients that request it.
        OCSPStaple []byte
        OCSPParse  *ocsp.Response // OCSPParse specify the details of ocsp response
        // Leaf is the parsed form of the leaf certificate, which may be
        // initialized using x509.ParseCertificate to reduce per-handshake
        // processing for TLS clients doing client authentication. If nil, the
        // leaf certificate will be parsed as needed.
        Leaf *x509.Certificate

        // certificate message for tls handshake, which may be initialized
        // using tls.X509Pair to reduce per-handshake processing for TLS server
        message []byte
}

// Prebuild certificate message for tls handshake
func (c *Certificate) buildCertMsg() <span class="cov8" title="1">{
        certMsg := new(certificateMsg)
        certMsg.certificates = c.Certificate
        c.message = certMsg.marshal()
}</span>

// A TLS record.
type record struct {
        contentType  recordType
        major, minor uint8
        payload      []byte
}

type handshakeMessage interface {
        marshal() []byte
        unmarshal([]byte) bool
}

// lruSessionCache is a ClientSessionCache implementation that uses an LRU
// caching strategy.
type lruSessionCache struct {
        sync.Mutex

        m        map[string]*list.Element
        q        *list.List
        capacity int
}

type lruSessionCacheEntry struct {
        sessionKey string
        state      *ClientSessionState
}

// NewLRUClientSessionCache returns a ClientSessionCache with the given
// capacity that uses an LRU strategy. If capacity is &lt; 1, a default capacity
// is used instead.
func NewLRUClientSessionCache(capacity int) ClientSessionCache <span class="cov8" title="1">{
        const defaultSessionCacheCapacity = 64

        if capacity &lt; 1 </span><span class="cov0" title="0">{
                capacity = defaultSessionCacheCapacity
        }</span>
        <span class="cov8" title="1">return &amp;lruSessionCache{
                m:        make(map[string]*list.Element),
                q:        list.New(),
                capacity: capacity,
        }</span>
}

// Put adds the provided (sessionKey, cs) pair to the cache.
func (c *lruSessionCache) Put(sessionKey string, cs *ClientSessionState) <span class="cov8" title="1">{
        c.Lock()
        defer c.Unlock()

        if elem, ok := c.m[sessionKey]; ok </span><span class="cov8" title="1">{
                entry := elem.Value.(*lruSessionCacheEntry)
                entry.state = cs
                c.q.MoveToFront(elem)
                return
        }</span>

        <span class="cov8" title="1">if c.q.Len() &lt; c.capacity </span><span class="cov8" title="1">{
                entry := &amp;lruSessionCacheEntry{sessionKey, cs}
                c.m[sessionKey] = c.q.PushFront(entry)
                return
        }</span>

        <span class="cov8" title="1">elem := c.q.Back()
        entry := elem.Value.(*lruSessionCacheEntry)
        delete(c.m, entry.sessionKey)
        entry.sessionKey = sessionKey
        entry.state = cs
        c.q.MoveToFront(elem)
        c.m[sessionKey] = elem</span>
}

// Get returns the ClientSessionState value associated with a given key. It
// returns (nil, false) if no value is found.
func (c *lruSessionCache) Get(sessionKey string) (*ClientSessionState, bool) <span class="cov8" title="1">{
        c.Lock()
        defer c.Unlock()

        if elem, ok := c.m[sessionKey]; ok </span><span class="cov8" title="1">{
                c.q.MoveToFront(elem)
                return elem.Value.(*lruSessionCacheEntry).state, true
        }</span>
        <span class="cov8" title="1">return nil, false</span>
}

// TODO(jsing): Make these available to both crypto/x509 and crypto/tls.
type dsaSignature struct {
        R, S *big.Int
}

type ecdsaSignature dsaSignature

var emptyConfig Config

func defaultConfig() *Config <span class="cov8" title="1">{
        return &amp;emptyConfig
}</span>

var (
        once                   sync.Once
        varDefaultCipherSuites []uint16
)

func defaultCipherSuites() []uint16 <span class="cov8" title="1">{
        once.Do(initDefaultCipherSuites)
        return varDefaultCipherSuites
}</span>

func initDefaultCipherSuites() <span class="cov8" title="1">{
        varDefaultCipherSuites = make([]uint16, len(cipherSuites))
        for i, suite := range cipherSuites </span><span class="cov8" title="1">{
                varDefaultCipherSuites[i] = suite.id
        }</span>
}

func unexpectedMessageError(wanted, got interface{}) error <span class="cov8" title="1">{
        return fmt.Errorf("tls: received unexpected handshake message of type %T when waiting for %T", got, wanted)
}</span>

var versionTextMap = map[uint16]string{
        VersionSSL30: "TLS_VERSION_SSL30",
        VersionTLS10: "TLS_VERSION_TLS10",
        VersionTLS11: "TLS_VERSION_TLS11",
        VersionTLS12: "TLS_VERSION_TLS12",
}

func VersionText(ver uint16) string <span class="cov0" title="0">{
        if text, ok := versionTextMap[ver]; ok </span><span class="cov0" title="0">{
                return text
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("TLS_VERSION_%x", ver)</span>
}

// version text in OpenSSL format
var versionTextMapForOpenSSL = map[uint16]string{
        VersionSSL30: "SSLv3.0",
        VersionTLS10: "TLSv1.0",
        VersionTLS11: "TLSv1.1",
        VersionTLS12: "TLSv1.2",
}

func VersionTextForOpenSSL(ver uint16) string <span class="cov0" title="0">{
        if text, ok := versionTextMapForOpenSSL[ver]; ok </span><span class="cov0" title="0">{
                return text
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("TLS_VERSION_%x", ver)</span>
}

var (
        helloRandomMagicNum []byte = []byte{66, 73, 68, 85}
        helloRandomFormat   int
)

func SetHelloRandomFormat(format int) <span class="cov0" title="0">{
        helloRandomFormat = format
}</span>

func generateHelloRandom(rand io.Reader) ([]byte, error) <span class="cov8" title="1">{
        random := make([]byte, 32)
        if _, err := io.ReadFull(rand, random); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return random, nil</span>
}

// OcspTimeRangeCheck check ocsp time update range
func OcspTimeRangeCheck(parse *ocsp.Response) bool <span class="cov0" title="0">{
        serverTime := time.Now()
        nextUpdate := parse.NextUpdate
        thisUpdate := parse.ThisUpdate

        // default tolerant time, one hour
        deltaTime := time.Duration(3600) * time.Second

        // serverTime should be [thisUpdate+deltaTime, nextUpdate-deltaTime]
        if serverTime.Sub(thisUpdate) &lt; deltaTime || nextUpdate.Sub(serverTime) &lt; deltaTime </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return true</span>
}

var keyPairLoader KeyPairLoader

type KeyPairLoader interface {
        LoadX509KeyPair(certFile, keyFile string) (cert Certificate, err error)
}

func SetKeyPairLoader(loader KeyPairLoader) <span class="cov0" title="0">{
        keyPairLoader = loader
}</span>
</pre>
		
		<pre class="file" id="file254" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Copyright 2010 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// TLS low level connection and record layer

package bfe_tls

import (
        "bytes"
        "crypto/cipher"
        "crypto/subtle"
        "crypto/x509"
        "errors"
        "fmt"
        "io"
        "net"
        "sync"
        "time"
)

type ConnParam interface {
        // Get virtual ip for current conn
        GetVip() net.IP
}

// A Conn represents a secured connection.
// It implements the net.Conn interface.
type Conn struct {
        // constant
        conn     net.Conn
        isClient bool

        // constant after initial
        param ConnParam

        // constant after handshake; protected by handshakeMutex
        handshakeMutex    sync.Mutex    // handshakeMutex &lt; in.Mutex, out.Mutex, errMutex
        handshakeErr      error         // error resulting from handshake
        vers              uint16        // TLS version
        haveVers          bool          // version has been negotiated
        config            *Config       // configuration passed to constructor
        handshakeTime     time.Duration // TLS handshake time
        handshakeComplete bool
        didResume         bool // whether this connection was a session resumption
        cipherSuite       uint16
        ocspStaple        bool   // use ocsp stapling (in server side)
        ocspResponse      []byte // stapled OCSP response
        peerCertificates  []*x509.Certificate
        // verifiedChains contains the certificate chains that we built, as
        // opposed to the ones presented by the server.
        verifiedChains [][]*x509.Certificate
        // serverName contains the server name indicated by the client, if any.
        serverName          string
        grade               string         // tls security grade, usually is "A", "B", "C"
        clientAuth          ClientAuthType // tls client auth type
        clientCAs           *x509.CertPool
        clientCAName        string   // tls client CA name
        clientCRLPool       *CRLPool // tls client CRL pool
        enableDynamicRecord bool     // enable dynamic record size or not
        clientRandom        []byte   // random in client hello msg
        serverRandom        []byte   // random in server hello msg
        masterSecret        []byte   // master secret for conn
        clientCiphers       []uint16 // ciphers supported by client
        ja3Raw              string   // JA3 fingerprint string for TLS Client
        ja3Hash             string   // JA3 fingerprint hash for TLS Client

        clientProtocol         string
        clientProtocolFallback bool

        // input/output
        in, out  halfConn     // in.Mutex &lt; out.Mutex
        rawInput *block       // raw input, right off the wire
        input    *block       // application data waiting to be read
        hand     bytes.Buffer // handshake data waiting to be read

        // total bytes of application data sent recently
        // byteOut will be reset to zero after inactivity
        byteOut int

        //readFromUntilLen len
        readFromUntilLen int

        // finish time of last writeRecord()
        lastOut time.Time

        tmp [16]byte

        // for sslv2 client hello
        sslv2Data []byte
}

// Access to net.Conn methods.
// Cannot just embed net.Conn because that would
// export the struct field too.

// LocalAddr returns the local network address.
func (c *Conn) LocalAddr() net.Addr <span class="cov0" title="0">{
        return c.conn.LocalAddr()
}</span>

// RemoteAddr returns the remote network address.
func (c *Conn) RemoteAddr() net.Addr <span class="cov0" title="0">{
        return c.conn.RemoteAddr()
}</span>

// GetNetConn returns the underlying connection.
func (c *Conn) GetNetConn() net.Conn <span class="cov0" title="0">{
        return c.conn
}</span>

// GetVip return the vip for underlying connection.
func (c *Conn) GetVip() net.IP <span class="cov0" title="0">{
        if c.param == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return c.param.GetVip()</span>
}

// GetServerName returns server name indicated by the client, if any.
func (c *Conn) GetServerName() string <span class="cov0" title="0">{
        return c.serverName
}</span>

func (c *Conn) SetConnParam(param ConnParam) <span class="cov0" title="0">{
        c.param = param
}</span>

// SetDeadline sets the read and write deadlines associated with the connection.
// A zero value for t means Read and Write will not time out.
// After a Write has timed out, the TLS state is corrupt and all future writes will return the same error.
func (c *Conn) SetDeadline(t time.Time) error <span class="cov0" title="0">{
        return c.conn.SetDeadline(t)
}</span>

// SetReadDeadline sets the read deadline on the underlying connection.
// A zero value for t means Read will not time out.
func (c *Conn) SetReadDeadline(t time.Time) error <span class="cov0" title="0">{
        return c.conn.SetReadDeadline(t)
}</span>

// SetWriteDeadline sets the write deadline on the underlying connection.
// A zero value for t means Write will not time out.
// After a Write has timed out, the TLS state is corrupt and all future writes will return the same error.
func (c *Conn) SetWriteDeadline(t time.Time) error <span class="cov0" title="0">{
        return c.conn.SetWriteDeadline(t)
}</span>

func (c *Conn) getClientCAs() *x509.CertPool <span class="cov8" title="1">{
        clientCAs := c.config.ClientCAs
        if c.clientCAs != nil </span><span class="cov0" title="0">{
                clientCAs = c.clientCAs
        }</span>

        <span class="cov8" title="1">return clientCAs</span>
}

// A halfConn represents one direction of the record layer
// connection, either sending or receiving.
type halfConn struct {
        sync.Mutex

        err     error       // first permanent error
        version uint16      // protocol version
        cipher  interface{} // cipher algorithm
        mac     macFunction
        seq     [8]byte // 64-bit sequence number
        bfree   *block  // list of free blocks

        nextCipher interface{} // next encryption state
        nextMac    macFunction // next MAC algorithm

        // used to save allocating a new buffer for each MAC.
        inDigestBuf, outDigestBuf []byte
}

func (hc *halfConn) setErrorLocked(err error) error <span class="cov8" title="1">{
        hc.err = err
        return err
}</span>

func (hc *halfConn) error() error <span class="cov8" title="1">{
        hc.Lock()
        err := hc.err
        hc.Unlock()
        return err
}</span>

// prepareCipherSpec sets the encryption and MAC states
// that a subsequent changeCipherSpec will use.
func (hc *halfConn) prepareCipherSpec(version uint16, cipher interface{}, mac macFunction) <span class="cov8" title="1">{
        hc.version = version
        hc.nextCipher = cipher
        hc.nextMac = mac
}</span>

// changeCipherSpec changes the encryption and MAC states
// to the ones previously passed to prepareCipherSpec.
func (hc *halfConn) changeCipherSpec() error <span class="cov8" title="1">{
        if hc.nextCipher == nil </span><span class="cov0" title="0">{
                return alertInternalError
        }</span>
        <span class="cov8" title="1">hc.cipher = hc.nextCipher
        hc.mac = hc.nextMac
        hc.nextCipher = nil
        hc.nextMac = nil
        for i := range hc.seq </span><span class="cov8" title="1">{
                hc.seq[i] = 0
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// incSeq increments the sequence number.
func (hc *halfConn) incSeq() <span class="cov8" title="1">{
        for i := 7; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                hc.seq[i]++
                if hc.seq[i] != 0 </span><span class="cov8" title="1">{
                        return
                }</span>
        }

        // Not allowed to let sequence number wrap.
        // Instead, must renegotiate before it does.
        // Not likely enough to bother.
        <span class="cov0" title="0">panic("TLS: sequence number wraparound")</span>
}

// resetSeq resets the sequence number to zero.
func (hc *halfConn) resetSeq() <span class="cov0" title="0">{
        for i := range hc.seq </span><span class="cov0" title="0">{
                hc.seq[i] = 0
        }</span>
}

// removePadding returns an unpadded slice, in constant time, which is a prefix
// of the input. It also returns a byte which is equal to 255 if the padding
// was valid and 0 otherwise. See RFC 2246, section 6.2.3.2
func removePadding(payload []byte) ([]byte, byte) <span class="cov8" title="1">{
        if len(payload) &lt; 1 </span><span class="cov0" title="0">{
                return payload, 0
        }</span>

        <span class="cov8" title="1">paddingLen := payload[len(payload)-1]
        t := uint(len(payload)-1) - uint(paddingLen)
        // if len(payload) &gt;= (paddingLen - 1) then the MSB of t is zero
        good := byte(int32(^t) &gt;&gt; 31)

        toCheck := 255 // the maximum possible padding length
        // The length of the padded data is public, so we can use an if here
        if toCheck+1 &gt; len(payload) </span><span class="cov8" title="1">{
                toCheck = len(payload) - 1
        }</span>

        <span class="cov8" title="1">for i := 0; i &lt; toCheck; i++ </span><span class="cov8" title="1">{
                t := uint(paddingLen) - uint(i)
                // if i &lt;= paddingLen then the MSB of t is zero
                mask := byte(int32(^t) &gt;&gt; 31)
                b := payload[len(payload)-1-i]
                good &amp;^= mask&amp;paddingLen ^ mask&amp;b
        }</span>

        // We AND together the bits of good and replicate the result across
        // all the bits.
        <span class="cov8" title="1">good &amp;= good &lt;&lt; 4
        good &amp;= good &lt;&lt; 2
        good &amp;= good &lt;&lt; 1
        good = uint8(int8(good) &gt;&gt; 7)

        toRemove := good&amp;paddingLen + 1
        return payload[:len(payload)-int(toRemove)], good</span>
}

// removePaddingSSL30 is a replacement for removePadding in the case that the
// protocol version is SSLv3. In this version, the contents of the padding
// are random and cannot be checked.
func removePaddingSSL30(payload []byte) ([]byte, byte) <span class="cov8" title="1">{
        if len(payload) &lt; 1 </span><span class="cov0" title="0">{
                return payload, 0
        }</span>

        <span class="cov8" title="1">paddingLen := int(payload[len(payload)-1]) + 1
        if paddingLen &gt; len(payload) </span><span class="cov0" title="0">{
                return payload, 0
        }</span>

        <span class="cov8" title="1">return payload[:len(payload)-paddingLen], 255</span>
}

func roundUp(a, b int) int <span class="cov8" title="1">{
        return a + (b-a%b)%b
}</span>

// cbcMode is an interface for block ciphers using cipher block chaining.
type cbcMode interface {
        cipher.BlockMode
        SetIV([]byte)
}

// decrypt checks and strips the mac and decrypts the data in b. Returns a
// success boolean, the number of bytes to skip from the start of the record in
// order to get the application payload, and an optional alert value.
func (hc *halfConn) decrypt(b *block) (ok bool, prefixLen int, alertValue alert) <span class="cov8" title="1">{
        // pull out payload
        payload := b.data[recordHeaderLen:]

        macSize := 0
        if hc.mac != nil </span><span class="cov8" title="1">{
                macSize = hc.mac.Size()
        }</span>

        <span class="cov8" title="1">paddingGood := byte(255)
        explicitIVLen := 0

        // decrypt
        if hc.cipher != nil </span><span class="cov8" title="1">{
                switch c := hc.cipher.(type) </span>{
                case cipher.Stream:<span class="cov8" title="1">
                        c.XORKeyStream(payload, payload)</span>
                case aead:<span class="cov8" title="1">
                        explicitIVLen = c.explicitNonceLen()
                        if len(payload) &lt; explicitIVLen </span><span class="cov0" title="0">{
                                return false, 0, alertBadRecordMAC
                        }</span>
                        <span class="cov8" title="1">nonce := payload[:explicitIVLen]
                        payload = payload[explicitIVLen:]
                        if len(nonce) == 0 </span><span class="cov8" title="1">{
                                nonce = hc.seq[:]
                        }</span>

                        <span class="cov8" title="1">var additionalData [13]byte
                        copy(additionalData[:], hc.seq[:])
                        copy(additionalData[8:], b.data[:3])
                        n := len(payload) - c.Overhead()
                        additionalData[11] = byte(n &gt;&gt; 8)
                        additionalData[12] = byte(n)
                        var err error
                        payload, err = c.Open(payload[:0], nonce, payload, additionalData[:])
                        if err != nil </span><span class="cov0" title="0">{
                                return false, 0, alertBadRecordMAC
                        }</span>
                        <span class="cov8" title="1">b.resize(recordHeaderLen + explicitIVLen + len(payload))</span>
                case cbcMode:<span class="cov8" title="1">
                        blockSize := c.BlockSize()
                        if hc.version &gt;= VersionTLS11 </span><span class="cov8" title="1">{
                                explicitIVLen = blockSize
                        }</span>

                        <span class="cov8" title="1">if len(payload)%blockSize != 0 || len(payload) &lt; roundUp(explicitIVLen+macSize+1, blockSize) </span><span class="cov0" title="0">{
                                return false, 0, alertBadRecordMAC
                        }</span>

                        <span class="cov8" title="1">if explicitIVLen &gt; 0 </span><span class="cov8" title="1">{
                                c.SetIV(payload[:explicitIVLen])
                                payload = payload[explicitIVLen:]
                        }</span>
                        <span class="cov8" title="1">c.CryptBlocks(payload, payload)
                        if hc.version == VersionSSL30 </span><span class="cov8" title="1">{
                                payload, paddingGood = removePaddingSSL30(payload)
                        }</span> else<span class="cov8" title="1"> {
                                payload, paddingGood = removePadding(payload)
                        }</span>
                        <span class="cov8" title="1">b.resize(recordHeaderLen + explicitIVLen + len(payload))</span>

                        // note that we still have a timing side-channel in the
                        // MAC check, below. An attacker can align the record
                        // so that a correct padding will cause one less hash
                        // block to be calculated. Then they can iteratively
                        // decrypt a record by breaking each byte. See
                        // "Password Interception in a SSL/TLS Channel", Brice
                        // Canvel et al.
                        //
                        // However, our behavior matches OpenSSL, so we leak
                        // only as much as they do.
                default:<span class="cov0" title="0">
                        panic("unknown cipher type")</span>
                }
        }

        // check, strip mac
        <span class="cov8" title="1">if hc.mac != nil </span><span class="cov8" title="1">{
                if len(payload) &lt; macSize </span><span class="cov0" title="0">{
                        return false, 0, alertBadRecordMAC
                }</span>

                // strip mac off payload, b.data
                <span class="cov8" title="1">n := len(payload) - macSize
                b.data[3] = byte(n &gt;&gt; 8)
                b.data[4] = byte(n)
                b.resize(recordHeaderLen + explicitIVLen + n)
                remoteMAC := payload[n:]
                localMAC := hc.mac.MAC(hc.inDigestBuf, hc.seq[0:], b.data[:recordHeaderLen], payload[:n])

                if subtle.ConstantTimeCompare(localMAC, remoteMAC) != 1 || paddingGood != 255 </span><span class="cov0" title="0">{
                        return false, 0, alertBadRecordMAC
                }</span>
                <span class="cov8" title="1">hc.inDigestBuf = localMAC</span>
        }
        <span class="cov8" title="1">hc.incSeq()

        return true, recordHeaderLen + explicitIVLen, 0</span>
}

// padToBlockSize calculates the needed padding block, if any, for a payload.
// On exit, prefix aliases payload and extends to the end of the last full
// block of payload. finalBlock is a fresh slice which contains the contents of
// any suffix of payload as well as the needed padding to make finalBlock a
// full block.
func padToBlockSize(payload []byte, blockSize int) (prefix, finalBlock []byte) <span class="cov8" title="1">{
        overrun := len(payload) % blockSize
        paddingLen := blockSize - overrun
        prefix = payload[:len(payload)-overrun]
        finalBlock = make([]byte, blockSize)
        copy(finalBlock, payload[len(payload)-overrun:])
        for i := overrun; i &lt; blockSize; i++ </span><span class="cov8" title="1">{
                finalBlock[i] = byte(paddingLen - 1)
        }</span>
        <span class="cov8" title="1">return</span>
}

// encrypt encrypts and macs the data in b.
func (hc *halfConn) encrypt(b *block, explicitIVLen int) (bool, alert) <span class="cov8" title="1">{
        // mac
        if hc.mac != nil </span><span class="cov8" title="1">{
                mac := hc.mac.MAC(hc.outDigestBuf, hc.seq[0:], b.data[:recordHeaderLen], b.data[recordHeaderLen+explicitIVLen:])

                n := len(b.data)
                b.resize(n + len(mac))
                copy(b.data[n:], mac)
                hc.outDigestBuf = mac
        }</span>

        <span class="cov8" title="1">payload := b.data[recordHeaderLen:]

        // encrypt
        if hc.cipher != nil </span><span class="cov8" title="1">{
                switch c := hc.cipher.(type) </span>{
                case cipher.Stream:<span class="cov8" title="1">
                        c.XORKeyStream(payload, payload)</span>
                case aead:<span class="cov8" title="1">
                        payloadLen := len(b.data) - recordHeaderLen - explicitIVLen
                        b.resize(len(b.data) + c.Overhead())
                        nonce := b.data[recordHeaderLen : recordHeaderLen+explicitIVLen]
                        if len(nonce) == 0 </span><span class="cov8" title="1">{
                                nonce = hc.seq[:]
                        }</span>
                        <span class="cov8" title="1">payload := b.data[recordHeaderLen+explicitIVLen:]
                        payload = payload[:payloadLen]

                        var additionalData [13]byte
                        copy(additionalData[:], hc.seq[:])
                        copy(additionalData[8:], b.data[:3])
                        additionalData[11] = byte(payloadLen &gt;&gt; 8)
                        additionalData[12] = byte(payloadLen)

                        c.Seal(payload[:0], nonce, payload, additionalData[:])</span>
                case cbcMode:<span class="cov8" title="1">
                        blockSize := c.BlockSize()
                        if explicitIVLen &gt; 0 </span><span class="cov8" title="1">{
                                c.SetIV(payload[:explicitIVLen])
                                payload = payload[explicitIVLen:]
                        }</span>
                        <span class="cov8" title="1">prefix, finalBlock := padToBlockSize(payload, blockSize)
                        b.resize(recordHeaderLen + explicitIVLen + len(prefix) + len(finalBlock))
                        c.CryptBlocks(b.data[recordHeaderLen+explicitIVLen:], prefix)
                        c.CryptBlocks(b.data[recordHeaderLen+explicitIVLen+len(prefix):], finalBlock)</span>
                default:<span class="cov0" title="0">
                        panic("unknown cipher type")</span>
                }
        }

        // update length to include MAC and any block padding needed.
        <span class="cov8" title="1">n := len(b.data) - recordHeaderLen
        b.data[3] = byte(n &gt;&gt; 8)
        b.data[4] = byte(n)
        hc.incSeq()

        return true, 0</span>
}

// A block is a simple data buffer.
type block struct {
        data []byte
        off  int // index for Read
        link *block
}

// resize resizes block to be n bytes, growing if necessary.
func (b *block) resize(n int) <span class="cov8" title="1">{
        if n &gt; cap(b.data) </span><span class="cov8" title="1">{
                b.reserve(n)
        }</span>
        <span class="cov8" title="1">b.data = b.data[0:n]</span>
}

// reserve makes sure that block contains a capacity of at least n bytes.
func (b *block) reserve(n int) <span class="cov8" title="1">{
        if cap(b.data) &gt;= n </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">m := cap(b.data)
        if m == 0 </span><span class="cov8" title="1">{
                m = 1024
        }</span>
        <span class="cov8" title="1">for m &lt; n </span><span class="cov0" title="0">{
                m *= 2
        }</span>
        <span class="cov8" title="1">data := make([]byte, len(b.data), m)
        copy(data, b.data)
        b.data = data</span>
}

// readFromUntil reads from r into b until b contains at least n bytes
// or else returns an error.
func (b *block) readFromUntil(c *Conn, n int) error <span class="cov8" title="1">{
        r := c.conn
        // quick case
        if len(b.data) &gt;= n </span><span class="cov8" title="1">{
                return nil
        }</span>

        // read until have enough.
        <span class="cov8" title="1">b.reserve(n)
        for </span><span class="cov8" title="1">{
                m, err := r.Read(b.data[len(b.data):cap(b.data)])
                b.data = b.data[0 : len(b.data)+m]
                c.readFromUntilLen += m
                if len(b.data) &gt;= n </span><span class="cov8" title="1">{
                        // TODO(bradfitz,agl): slightly suspicious
                        // that we're throwing away r.Read's err here.
                        break</span>
                }
                <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (b *block) Read(p []byte) (n int, err error) <span class="cov8" title="1">{
        n = copy(p, b.data[b.off:])
        b.off += n
        return
}</span>

// newBlock allocates a new block, from hc's free list if possible.
func (hc *halfConn) newBlock() *block <span class="cov8" title="1">{
        b := hc.bfree
        if b == nil </span><span class="cov8" title="1">{
                return new(block)
        }</span>
        <span class="cov8" title="1">hc.bfree = b.link
        b.link = nil
        b.resize(0)
        return b</span>
}

// freeBlock returns a block to hc's free list.
// The protocol is such that each side only has a block or two on
// its free list at a time, so there's no need to worry about
// trimming the list, etc.
func (hc *halfConn) freeBlock(b *block) <span class="cov8" title="1">{
        b.link = hc.bfree
        hc.bfree = b
}</span>

// splitBlock splits a block after the first n bytes,
// returning a block with those n bytes and a
// block with the remainder.  the latter may be nil.
func (hc *halfConn) splitBlock(b *block, n int) (*block, *block) <span class="cov8" title="1">{
        if len(b.data) &lt;= n </span><span class="cov8" title="1">{
                return b, nil
        }</span>
        <span class="cov8" title="1">bb := hc.newBlock()
        bb.resize(len(b.data) - n)
        copy(bb.data, b.data[n:])
        b.data = b.data[0:n]
        return b, bb</span>
}

/* convertSSLv2ClientHello - convert SSLv2 ClientHello to TLS ClientHello
 *
 * Note:
 * 1. TLS clients that wish to support SSLv2 servers must send
 *    SSLv2 CLIENT-HELLO messages.
 * 2. Even TLS servers that do not support SSLv2 may accept SSLv2
 *    CLIENT-HELLO messages.
 * 3. For negotiation purposes, SSLv2 CLIENT-HELLO is interpreted
 *    the same way as a TLS ClientHello
 *
 * For more details, see:
 * - tls1.2 https://tools.ietf.org/html/rfc5246#appendix-E
 * - tls1.1 https://tools.ietf.org/html/rfc4346#appendix-E
 * - tls1.0 https://tools.ietf.org/html/rfc2246#appendix-E
 * - sslv3  https://tools.ietf.org/html/draft-ietf-tls-ssl-version3-00
 * - sslv2  http://www-archive.mozilla.org/projects/security/pki/nss/ssl/draft02.html
 *
 * SSLv2 compatible CLIENT-HEELO message
 *
 *   0                                 16 bit
 *   +----------------------------------+
 *   |              MsgLength           |   (Highest bit MUST be 1)
 *   +----------------+-----------------+
 *   |    MsgType     |                     (Must be 1, ClientHello)
 *   +----------------+-----------------+
 *   |  MajorVersion  |  MinorVersion   |
 *   +----------------+-----------------+
 *   |           CipherSpecLen          |   (Must be multiply of 3)
 *   +----------------+-----------------+
 *   |           SessionIdLen           |   (Must be zero or 16 bytes for tls1.0 client,
 *   +----------------+-----------------+    Must be zero for tls1.1/tls1.2 client)
 *   |           ChallengeLen           |
 *   +----------------+-----------------+
 *   |            CipherSpec            |
 *   .       (CipherSpecLen bytes)      .
 *   .                                  .
 *   +----------------+-----------------+
 *   |            Session Id            |
 *   .       (SessionIdLen bytes)       .
 *   .                                  .
 *   +----------------------------------+
 *   |            Challenge             |   (Client Hello random)
 *   .       (ChallengeLen bytes)       .
 *   .                                  .
 *   +----------------------------------+
 */
func convertSSLv2ClientHello(c *Conn, b *block) error <span class="cov0" title="0">{
        // high bit must be 1 for SSLv2 compatible client hello
        if (uint8(b.data[0]) &amp; 128) != 128 </span><span class="cov0" title="0">{
                return c.sendAlert(alertUnexpectedMessage)
        }</span>

        <span class="cov0" title="0">msgLength := (uint16(b.data[0]&amp;0x7f) &lt;&lt; 8) | uint16(b.data[1])
        if msgLength &lt; 12 </span><span class="cov0" title="0">{
                return c.sendAlert(alertHandshakeFailure)
        }</span>

        // check if this is an SSLv2 client-hello but TLS is supported
        <span class="cov0" title="0">msgType := uint8(b.data[2])
        majorVer := uint8(b.data[3])
        minorVer := uint8(b.data[4])
        version := uint16(majorVer)&lt;&lt;8 | uint16(minorVer)
        if !(msgType == typeClientHello &amp;&amp; version &gt;= VersionSSL30) </span><span class="cov0" title="0">{
                c.sendAlert(alertProtocolVersion)
                state.TlsHandshakeSslv2NotSupport.Inc(1)
                return c.in.setErrorLocked(errors.New("tls: unsupported SSLv2 handshake received"))
        }</span>
        <span class="cov0" title="0">state.TlsHandshakeAcceptSslv2ClientHello.Inc(1)

        // read the rest of the bytes for client hello
        if err := b.readFromUntil(c, int(2+msgLength)); err != nil </span><span class="cov0" title="0">{
                if err == io.EOF </span><span class="cov0" title="0">{
                        err = io.ErrUnexpectedEOF
                }</span>
                <span class="cov0" title="0">if e, ok := err.(net.Error); !ok || !e.Temporary() </span><span class="cov0" title="0">{
                        c.in.setErrorLocked(err)
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        // get the cipher spec length
        <span class="cov0" title="0">cipherSpecLength := uint16(b.data[5])&lt;&lt;8 | uint16(b.data[6])
        if cipherSpecLength &lt;= 0 || (cipherSpecLength%3) != 0 </span><span class="cov0" title="0">{
                return c.sendAlert(alertHandshakeFailure)
        }</span>

        // get the session id length
        <span class="cov0" title="0">sessionIdLength := uint16(b.data[7])&lt;&lt;8 | uint16(b.data[8])
        if sessionIdLength != 0 &amp;&amp; sessionIdLength != 16 </span><span class="cov0" title="0">{
                return c.sendAlert(alertHandshakeFailure)
        }</span>

        <span class="cov0" title="0">if len(b.data) &lt; 11+int(cipherSpecLength+sessionIdLength) </span><span class="cov0" title="0">{
                return c.sendAlert(alertHandshakeFailure)
        }</span>

        // read the cipher specs
        <span class="cov0" title="0">cipherSpecs := b.data[11 : 11+cipherSpecLength]

        // read the rest of the data
        challengeData := b.data[11+cipherSpecLength+sessionIdLength:]

        // mark this data as read?
        b, c.rawInput = c.in.splitBlock(b, int(2+msgLength))
        b.off = 2

        // create tls clientHello message
        helloMsg := clientHelloMsg{}
        helloMsg.vers = version
        helloMsg.sessionId = []byte{0}
        helloMsg.compressionMethods = []uint8{compressionNone}

        if len(challengeData) &gt;= 32 </span><span class="cov0" title="0">{
                helloMsg.random = challengeData[:32]
        }</span> else<span class="cov0" title="0"> {
                helloMsg.random = make([]byte, 32-len(challengeData))
                helloMsg.random = append(helloMsg.random, challengeData...)
        }</span>

        <span class="cov0" title="0">helloMsg.cipherSuites = make([]uint16, 0)
        for i := 0; i &lt; len(cipherSpecs); i += 3 </span><span class="cov0" title="0">{
                // we can only support cipher specs starting with a high bit
                if cipherSpecs[i] == 0 </span><span class="cov0" title="0">{
                        cipher := uint16(cipherSpecs[i+1])&lt;&lt;8 | uint16(cipherSpecs[i+2])
                        helloMsg.cipherSuites = append(helloMsg.cipherSuites, cipher)
                }</span>
        }

        // write clientHello message to the handshake buffer
        <span class="cov0" title="0">c.hand.Write(helloMsg.marshal())

        c.sslv2Data = b.data[2:]
        c.in.freeBlock(b)
        return nil</span>
}

// readRecord reads the next TLS record from the connection
// and updates the record layer state.
// c.in.Mutex &lt;= L; c.input == nil.
func (c *Conn) readRecord(want recordType) error <span class="cov8" title="1">{
        // Caller must be in sync with connection:
        // handshake data if handshake not yet completed,
        // else application data.  (We don't support renegotiation.)
        switch want </span>{
        default:<span class="cov0" title="0">
                c.sendAlert(alertInternalError)
                return c.in.setErrorLocked(errors.New("tls: unknown record type requested"))</span>
        case recordTypeHandshake, recordTypeChangeCipherSpec:<span class="cov8" title="1">
                if c.handshakeComplete </span><span class="cov0" title="0">{
                        c.sendAlert(alertInternalError)
                        return c.in.setErrorLocked(errors.New("tls: handshake or ChangeCipherSpec requested after handshake complete"))
                }</span>
        case recordTypeApplicationData:<span class="cov8" title="1">
                if !c.handshakeComplete </span><span class="cov0" title="0">{
                        c.sendAlert(alertInternalError)
                        return c.in.setErrorLocked(errors.New("tls: application data record requested before handshake complete"))
                }</span>
        }

Again:
        <span class="cov8" title="1">if c.rawInput == nil </span><span class="cov8" title="1">{
                c.rawInput = c.in.newBlock()
        }</span>
        <span class="cov8" title="1">b := c.rawInput

        // Read header, payload.
        if err := b.readFromUntil(c, recordHeaderLen); err != nil </span><span class="cov8" title="1">{
                // RFC suggests that EOF without an alertCloseNotify is
                // an error, but popular web sites seem to do this,
                // so we can't make it an error.
                // if err == io.EOF {
                //         err = io.ErrUnexpectedEOF
                // }
                if e, ok := err.(net.Error); !ok || !e.Temporary() </span><span class="cov8" title="1">{
                        c.in.setErrorLocked(err)
                }</span>
                <span class="cov8" title="1">return err</span>
        }
        <span class="cov8" title="1">typ := recordType(b.data[0])

        // No valid TLS record has a type of 0x80, however SSLv2 handshakes
        // start with a uint16 length where the MSB is set and the first record
        // is always &lt; 256 bytes long. Therefore typ == 0x80 strongly suggests
        // an SSLv2 client.
        if want == recordTypeHandshake &amp;&amp; typ == 0x80 </span><span class="cov0" title="0">{
                // if this is an SSLv2 header, lets see if we can upgrade to TLS
                if c.config.EnableSslv2ClientHello </span><span class="cov0" title="0">{
                        return convertSSLv2ClientHello(c, b)
                }</span> else<span class="cov0" title="0"> {
                        c.sendAlert(alertProtocolVersion)
                        state.TlsHandshakeSslv2NotSupport.Inc(1)
                        return c.in.setErrorLocked(errors.New("tls: unsupported SSLv2 handshake received"))
                }</span>
        }

        <span class="cov8" title="1">vers := uint16(b.data[1])&lt;&lt;8 | uint16(b.data[2])
        n := int(b.data[3])&lt;&lt;8 | int(b.data[4])
        if c.haveVers &amp;&amp; vers != c.vers </span><span class="cov0" title="0">{
                c.sendAlert(alertProtocolVersion)
                return c.in.setErrorLocked(fmt.Errorf("tls: received record with version %x when expecting version %x", vers, c.vers))
        }</span>
        <span class="cov8" title="1">if n &gt; maxCiphertext </span><span class="cov0" title="0">{
                c.sendAlert(alertRecordOverflow)
                return c.in.setErrorLocked(fmt.Errorf("tls: oversized record received with length %d", n))
        }</span>
        <span class="cov8" title="1">if !c.haveVers </span><span class="cov8" title="1">{
                // First message, be extra suspicious:
                // this might not be a TLS client.
                // Bail out before reading a full 'body', if possible.
                // The current max version is 3.1.
                // If the version is &gt;= 16.0, it's probably not real.
                // Similarly, a clientHello message encodes in
                // well under a kilobyte.  If the length is &gt;= 12 kB,
                // it's probably not real.
                if (typ != recordTypeAlert &amp;&amp; typ != want) || vers &gt;= 0x1000 || n &gt;= 0x3000 </span><span class="cov0" title="0">{
                        c.sendAlert(alertUnexpectedMessage)
                        return c.in.setErrorLocked(fmt.Errorf("tls: first record does not look like a TLS handshake"))
                }</span>
        }
        <span class="cov8" title="1">if err := b.readFromUntil(c, recordHeaderLen+n); err != nil </span><span class="cov0" title="0">{
                if err == io.EOF </span><span class="cov0" title="0">{
                        err = io.ErrUnexpectedEOF
                }</span>
                <span class="cov0" title="0">if e, ok := err.(net.Error); !ok || !e.Temporary() </span><span class="cov0" title="0">{
                        c.in.setErrorLocked(err)
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        // Process message.
        <span class="cov8" title="1">b, c.rawInput = c.in.splitBlock(b, recordHeaderLen+n)
        ok, off, err := c.in.decrypt(b)
        if !ok </span><span class="cov0" title="0">{
                c.in.setErrorLocked(c.sendAlert(err))
        }</span>
        <span class="cov8" title="1">b.off = off
        data := b.data[b.off:]
        if len(data) &gt; maxPlaintext </span><span class="cov0" title="0">{
                err := c.sendAlert(alertRecordOverflow)
                c.in.freeBlock(b)
                return c.in.setErrorLocked(err)
        }</span>

        <span class="cov8" title="1">switch typ </span>{
        default:<span class="cov0" title="0">
                c.in.setErrorLocked(c.sendAlert(alertUnexpectedMessage))</span>

        case recordTypeAlert:<span class="cov8" title="1">
                if len(data) != 2 </span><span class="cov0" title="0">{
                        c.in.setErrorLocked(c.sendAlert(alertUnexpectedMessage))
                        break</span>
                }
                <span class="cov8" title="1">if alert(data[1]) == alertCloseNotify </span><span class="cov8" title="1">{
                        c.in.setErrorLocked(io.EOF)
                        break</span>
                }
                <span class="cov8" title="1">switch data[0] </span>{
                case alertLevelWarning:<span class="cov0" title="0">
                        // drop on the floor
                        c.in.freeBlock(b)
                        goto Again</span>
                case alertLevelError:<span class="cov8" title="1">
                        c.in.setErrorLocked(&amp;net.OpError{Op: "remote error", Err: alert(data[1])})</span>
                default:<span class="cov0" title="0">
                        c.in.setErrorLocked(c.sendAlert(alertUnexpectedMessage))</span>
                }

        case recordTypeChangeCipherSpec:<span class="cov8" title="1">
                if typ != want || len(data) != 1 || data[0] != 1 </span><span class="cov0" title="0">{
                        c.in.setErrorLocked(c.sendAlert(alertUnexpectedMessage))
                        break</span>
                }
                <span class="cov8" title="1">err := c.in.changeCipherSpec()
                if err != nil </span><span class="cov0" title="0">{
                        c.in.setErrorLocked(c.sendAlert(err.(alert)))
                }</span>

        case recordTypeApplicationData:<span class="cov8" title="1">
                if typ != want </span><span class="cov0" title="0">{
                        c.in.setErrorLocked(c.sendAlert(alertUnexpectedMessage))
                        break</span>
                }
                <span class="cov8" title="1">c.input = b
                b = nil</span>

        case recordTypeHandshake:<span class="cov8" title="1">
                // TODO(rsc): Should at least pick off connection close.
                if typ != want </span><span class="cov0" title="0">{
                        return c.in.setErrorLocked(c.sendAlert(alertNoRenegotiation))
                }</span>
                <span class="cov8" title="1">c.hand.Write(data)</span>
        }

        <span class="cov8" title="1">if b != nil </span><span class="cov8" title="1">{
                c.in.freeBlock(b)
        }</span>
        <span class="cov8" title="1">return c.in.err</span>
}

// sendAlert sends a TLS alert message.
// c.out.Mutex &lt;= L.
func (c *Conn) sendAlertLocked(err alert) error <span class="cov8" title="1">{
        switch err </span>{
        case alertNoRenegotiation, alertCloseNotify:<span class="cov8" title="1">
                c.tmp[0] = alertLevelWarning</span>
        default:<span class="cov8" title="1">
                c.tmp[0] = alertLevelError</span>
        }
        <span class="cov8" title="1">c.tmp[1] = byte(err)
        c.writeRecord(recordTypeAlert, c.tmp[0:2])
        // closeNotify is a special case in that it isn't an error:
        if err != alertCloseNotify </span><span class="cov8" title="1">{
                return c.out.setErrorLocked(&amp;net.OpError{Op: "local error", Err: err})
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// sendAlert sends a TLS alert message.
// L &lt; c.out.Mutex.
func (c *Conn) sendAlert(err alert) error <span class="cov8" title="1">{
        c.out.Lock()
        defer c.out.Unlock()
        return c.sendAlertLocked(err)
}</span>

/* choosePlaintextSize - choose size of record plaintext
 *
 * Note:
 * 1. We use small TLS records that fit into a single TCP segment for the
 *    first `bytesThreshold` Byte of data,
 * 2. increase record size to maxPlaintext after that to optimize throughput,
 * 3. and then reset record size back to a single segment
 *    after `inactiveSeconds` second of inactivity,
 * 4. lather, rinse, repeat
 */
func (c *Conn) choosePlaintextSize() int <span class="cov8" title="1">{
        if !c.enableDynamicRecord </span><span class="cov8" title="1">{
                return initPlaintext
        }</span>

        <span class="cov0" title="0">if c.byteOut &lt; bytesThreshold </span><span class="cov0" title="0">{
                return initPlaintext
        }</span>

        <span class="cov0" title="0">if time.Since(c.lastOut) &lt; inactiveSeconds </span><span class="cov0" title="0">{
                return maxPlaintext
        }</span>

        // reset bytes sent recently
        <span class="cov0" title="0">c.byteOut = 0
        return initPlaintext</span>
}

// writeRecord writes a TLS record with the given type and payload
// to the connection and updates the record layer state.
// c.out.Mutex &lt;= L.
func (c *Conn) writeRecord(typ recordType, data []byte) (n int, err error) <span class="cov8" title="1">{
        // choose appropriate size for record
        // Note: Some IE browsers fail to parse fragmented TLS/SSL handshake message,
        // we just choose dynamic record size for application data message. For more information,
        // see https://support.microsoft.com/en-us/kb/2541763
        plaintextSize := maxPlaintext
        if typ == recordTypeApplicationData </span><span class="cov8" title="1">{
                plaintextSize = c.choosePlaintextSize()
        }</span>

        <span class="cov8" title="1">b := c.out.newBlock()
        for len(data) &gt; 0 </span><span class="cov8" title="1">{
                m := len(data)
                // split data into segment of size 'plaintextSize'
                if m &gt; plaintextSize </span><span class="cov0" title="0">{
                        m = plaintextSize
                }</span>
                <span class="cov8" title="1">explicitIVLen := 0
                explicitIVIsSeq := false

                var cbc cbcMode
                if c.out.version &gt;= VersionTLS11 </span><span class="cov8" title="1">{
                        var ok bool
                        if cbc, ok = c.out.cipher.(cbcMode); ok </span><span class="cov8" title="1">{
                                explicitIVLen = cbc.BlockSize()
                        }</span>
                }
                <span class="cov8" title="1">if explicitIVLen == 0 </span><span class="cov8" title="1">{
                        if c, ok := c.out.cipher.(aead); ok </span><span class="cov8" title="1">{
                                explicitIVLen = c.explicitNonceLen()
                                // The AES-GCM construction in TLS has an
                                // explicit nonce so that the nonce can be
                                // random. However, the nonce is only 8 bytes
                                // which is too small for a secure, random
                                // nonce. Therefore we use the sequence number
                                // as the nonce.
                                explicitIVIsSeq = explicitIVLen &gt; 0
                        }</span>
                }
                <span class="cov8" title="1">b.resize(recordHeaderLen + explicitIVLen + m)
                b.data[0] = byte(typ)
                vers := c.vers
                if vers == 0 </span><span class="cov8" title="1">{
                        // Some TLS servers fail if the record version is
                        // greater than TLS 1.0 for the initial ClientHello.
                        vers = VersionTLS10
                }</span>
                <span class="cov8" title="1">b.data[1] = byte(vers &gt;&gt; 8)
                b.data[2] = byte(vers)
                b.data[3] = byte(m &gt;&gt; 8)
                b.data[4] = byte(m)
                if explicitIVLen &gt; 0 </span><span class="cov8" title="1">{
                        explicitIV := b.data[recordHeaderLen : recordHeaderLen+explicitIVLen]
                        if explicitIVIsSeq </span><span class="cov8" title="1">{
                                copy(explicitIV, c.out.seq[:])
                        }</span> else<span class="cov8" title="1"> {
                                if _, err = io.ReadFull(c.config.rand(), explicitIV); err != nil </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                }
                <span class="cov8" title="1">copy(b.data[recordHeaderLen+explicitIVLen:], data)
                c.out.encrypt(b, explicitIVLen)
                _, err = c.conn.Write(b.data)
                if err != nil </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">n += m
                data = data[m:]</span>
        }
        <span class="cov8" title="1">c.out.freeBlock(b)

        if typ == recordTypeChangeCipherSpec </span><span class="cov8" title="1">{
                err = c.out.changeCipherSpec()
                if err != nil </span><span class="cov0" title="0">{
                        // Cannot call sendAlert directly,
                        // because we already hold c.out.Mutex.
                        c.tmp[0] = alertLevelError
                        c.tmp[1] = byte(err.(alert))
                        c.writeRecord(recordTypeAlert, c.tmp[0:2])
                        return n, c.out.setErrorLocked(&amp;net.OpError{Op: "local error", Err: err})
                }</span>
        }

        // update total bytes of application data sent
        <span class="cov8" title="1">if typ == recordTypeApplicationData </span><span class="cov8" title="1">{
                c.byteOut += n
                c.lastOut = time.Now()
        }</span>
        <span class="cov8" title="1">return</span>
}

// readHandshake reads the next handshake message from
// the record layer.
// c.in.Mutex &lt; L; c.out.Mutex &lt; L.
func (c *Conn) readHandshake() (interface{}, error) <span class="cov8" title="1">{
        for c.hand.Len() &lt; 4 </span><span class="cov8" title="1">{
                if err := c.in.err; err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if err := c.readRecord(recordTypeHandshake); err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">data := c.hand.Bytes()
        n := int(data[1])&lt;&lt;16 | int(data[2])&lt;&lt;8 | int(data[3])
        if n &gt; maxHandshake </span><span class="cov0" title="0">{
                return nil, c.in.setErrorLocked(c.sendAlert(alertInternalError))
        }</span>
        <span class="cov8" title="1">for c.hand.Len() &lt; 4+n </span><span class="cov0" title="0">{
                if err := c.in.err; err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">if err := c.readRecord(recordTypeHandshake); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov8" title="1">data = c.hand.Next(4 + n)
        var m handshakeMessage
        switch data[0] </span>{
        case typeClientHello:<span class="cov8" title="1">
                m = new(clientHelloMsg)</span>
        case typeServerHello:<span class="cov8" title="1">
                m = new(serverHelloMsg)</span>
        case typeNewSessionTicket:<span class="cov8" title="1">
                m = new(newSessionTicketMsg)</span>
        case typeCertificate:<span class="cov8" title="1">
                m = new(certificateMsg)</span>
        case typeCertificateRequest:<span class="cov8" title="1">
                m = &amp;certificateRequestMsg{
                        hasSignatureAndHash: c.vers &gt;= VersionTLS12,
                }</span>
        case typeCertificateStatus:<span class="cov0" title="0">
                m = new(certificateStatusMsg)</span>
        case typeServerKeyExchange:<span class="cov8" title="1">
                m = new(serverKeyExchangeMsg)</span>
        case typeServerHelloDone:<span class="cov8" title="1">
                m = new(serverHelloDoneMsg)</span>
        case typeClientKeyExchange:<span class="cov8" title="1">
                m = new(clientKeyExchangeMsg)</span>
        case typeCertificateVerify:<span class="cov8" title="1">
                m = &amp;certificateVerifyMsg{
                        hasSignatureAndHash: c.vers &gt;= VersionTLS12,
                }</span>
        case typeNextProtocol:<span class="cov0" title="0">
                m = new(nextProtoMsg)</span>
        case typeFinished:<span class="cov8" title="1">
                m = new(finishedMsg)</span>
        default:<span class="cov0" title="0">
                return nil, c.in.setErrorLocked(c.sendAlert(alertUnexpectedMessage))</span>
        }

        // The handshake message unmarshallers
        // expect to be able to keep references to data,
        // so pass in a fresh copy that won't be overwritten.
        <span class="cov8" title="1">data = append([]byte(nil), data...)

        if !m.unmarshal(data) </span><span class="cov0" title="0">{
                return nil, c.in.setErrorLocked(c.sendAlert(alertUnexpectedMessage))
        }</span>
        <span class="cov8" title="1">return m, nil</span>
}

// Write writes data to the connection.
func (c *Conn) Write(b []byte) (int, error) <span class="cov8" title="1">{
        if err := c.Handshake(); err != nil </span><span class="cov8" title="1">{
                return 0, err
        }</span>

        <span class="cov8" title="1">c.out.Lock()
        defer c.out.Unlock()

        if err := c.out.err; err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov8" title="1">if !c.handshakeComplete </span><span class="cov0" title="0">{
                return 0, alertInternalError
        }</span>

        // SSL 3.0 and TLS 1.0 are susceptible to a chosen-plaintext
        // attack when using block mode ciphers due to predictable IVs.
        // This can be prevented by splitting each Application Data
        // record into two records, effectively randomizing the IV.
        //
        // http://www.openssl.org/~bodo/tls-cbc.txt
        // https://bugzilla.mozilla.org/show_bug.cgi?id=665814
        // http://www.imperialviolet.org/2012/01/15/beastfollowup.html

        <span class="cov8" title="1">var m int
        if len(b) &gt; 1 &amp;&amp; c.vers &lt;= VersionTLS10 </span><span class="cov8" title="1">{
                if _, ok := c.out.cipher.(cipher.BlockMode); ok </span><span class="cov8" title="1">{
                        n, err := c.writeRecord(recordTypeApplicationData, b[:1])
                        if err != nil </span><span class="cov0" title="0">{
                                return n, c.out.setErrorLocked(err)
                        }</span>
                        <span class="cov8" title="1">m, b = 1, b[1:]</span>
                }
        }

        <span class="cov8" title="1">n, err := c.writeRecord(recordTypeApplicationData, b)
        return n + m, c.out.setErrorLocked(err)</span>
}

// Read can be made to time out and return a net.Error with Timeout() == true
// after a fixed time limit; see SetDeadline and SetReadDeadline.
func (c *Conn) Read(b []byte) (n int, err error) <span class="cov8" title="1">{
        if err = c.Handshake(); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if len(b) == 0 </span><span class="cov0" title="0">{
                // Put this after Handshake, in case people were calling
                // Read(nil) for the side effect of the Handshake.
                return
        }</span>

        <span class="cov8" title="1">c.in.Lock()
        defer c.in.Unlock()

        // Some OpenSSL servers send empty records in order to randomize the
        // CBC IV. So this loop ignores a limited number of empty records.
        const maxConsecutiveEmptyRecords = 100
        for emptyRecordCount := 0; emptyRecordCount &lt;= maxConsecutiveEmptyRecords; emptyRecordCount++ </span><span class="cov8" title="1">{
                for c.input == nil &amp;&amp; c.in.err == nil </span><span class="cov8" title="1">{
                        if err := c.readRecord(recordTypeApplicationData); err != nil </span><span class="cov0" title="0">{
                                // Soft error, like EAGAIN
                                return 0, err
                        }</span>
                }
                <span class="cov8" title="1">if err := c.in.err; err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>

                <span class="cov8" title="1">n, err = c.input.Read(b)
                if c.input.off &gt;= len(c.input.data) </span><span class="cov8" title="1">{
                        c.in.freeBlock(c.input)
                        c.input = nil
                }</span>

                // If a close-notify alert is waiting, read it so that
                // we can return (n, EOF) instead of (n, nil), to signal
                // to the HTTP response reading goroutine that the
                // connection is now closed. This eliminates a race
                // where the HTTP response reading goroutine would
                // otherwise not observe the EOF until its next read,
                // by which time a client goroutine might have already
                // tried to reuse the HTTP connection for a new
                // request.
                // See https://codereview.appspot.com/76400046
                // and http://golang.org/issue/3514
                <span class="cov8" title="1">if ri := c.rawInput; ri != nil &amp;&amp;
                        n != 0 &amp;&amp; err == nil &amp;&amp;
                        c.input == nil &amp;&amp; len(ri.data) &gt; 0 &amp;&amp; recordType(ri.data[0]) == recordTypeAlert </span><span class="cov8" title="1">{
                        if recErr := c.readRecord(recordTypeApplicationData); recErr != nil </span><span class="cov8" title="1">{
                                err = recErr // will be io.EOF on closeNotify
                        }</span>
                }

                <span class="cov8" title="1">if n != 0 || err != nil </span><span class="cov8" title="1">{
                        return n, err
                }</span>
        }

        <span class="cov0" title="0">return 0, io.ErrNoProgress</span>
}

// Close closes the connection.
func (c *Conn) Close() error <span class="cov8" title="1">{
        var alertErr error

        c.handshakeMutex.Lock()
        defer c.handshakeMutex.Unlock()
        if c.handshakeComplete </span><span class="cov8" title="1">{
                alertErr = c.sendAlert(alertCloseNotify)
        }</span>

        <span class="cov8" title="1">if err := c.conn.Close(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return alertErr</span>
}

// Handshake runs the client or server handshake
// protocol if it has not yet been run.
// Most uses of this package need not call Handshake
// explicitly: the first Read or Write will call it automatically.
func (c *Conn) Handshake() error <span class="cov8" title="1">{
        c.handshakeMutex.Lock()
        defer c.handshakeMutex.Unlock()
        if err := c.handshakeErr; err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if c.handshakeComplete </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">if c.isClient </span><span class="cov8" title="1">{
                c.handshakeErr = c.clientHandshake()
        }</span> else<span class="cov8" title="1"> {
                c.handshakeErr = c.serverHandshake()
        }</span>
        <span class="cov8" title="1">return c.handshakeErr</span>
}

// ConnectionState returns basic TLS details about the connection.
func (c *Conn) ConnectionState() ConnectionState <span class="cov8" title="1">{
        c.handshakeMutex.Lock()
        defer c.handshakeMutex.Unlock()

        var state ConnectionState
        state.HandshakeComplete = c.handshakeComplete
        if c.handshakeComplete </span><span class="cov8" title="1">{
                state.Version = c.vers
                state.NegotiatedProtocol = c.clientProtocol
                state.DidResume = c.didResume
                state.NegotiatedProtocolIsMutual = !c.clientProtocolFallback
                state.CipherSuite = c.cipherSuite
                state.HandshakeTime = c.handshakeTime
                state.OcspStaple = c.ocspStaple
                state.PeerCertificates = c.peerCertificates
                state.VerifiedChains = c.verifiedChains
                state.ServerName = c.serverName
                state.ClientRandom = c.clientRandom
                state.ServerRandom = c.serverRandom
                state.MasterSecret = c.masterSecret
                state.ClientCiphers = c.clientCiphers
                if c.clientAuth == RequireAndVerifyClientCert </span><span class="cov0" title="0">{
                        state.ClientAuth = true
                }</span>
                <span class="cov8" title="1">state.ClientCAName = c.clientCAName
                state.JA3Raw = c.ja3Raw
                state.JA3Hash = c.ja3Hash</span>
        }

        <span class="cov8" title="1">return state</span>
}

// OCSPResponse returns the stapled OCSP response from the TLS server, if
// any. (Only valid for client connections.)
func (c *Conn) OCSPResponse() []byte <span class="cov0" title="0">{
        c.handshakeMutex.Lock()
        defer c.handshakeMutex.Unlock()

        return c.ocspResponse
}</span>

// VerifyHostname checks that the peer certificate chain is valid for
// connecting to host.  If so, it returns nil; if not, it returns an error
// describing the problem.
func (c *Conn) VerifyHostname(host string) error <span class="cov0" title="0">{
        c.handshakeMutex.Lock()
        defer c.handshakeMutex.Unlock()
        if !c.isClient </span><span class="cov0" title="0">{
                return errors.New("tls: VerifyHostname called on TLS server connection")
        }</span>
        <span class="cov0" title="0">if !c.handshakeComplete </span><span class="cov0" title="0">{
                return errors.New("tls: handshake has not yet been performed")
        }</span>
        <span class="cov0" title="0">return c.peerCertificates[0].VerifyHostname(host)</span>
}
</pre>
		
		<pre class="file" id="file255" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package bfe_tls

import (
        "bytes"
        "crypto/x509"
        "crypto/x509/pkix"
        "encoding/asn1"
        "encoding/hex"
        "errors"
        "fmt"
        "math/big"
)

var (
        oidExtensionAuthorityKeyId = []int{2, 5, 29, 35}
)

// RFC 5280,  4.2.1.1
type authKeyId struct {
        Id []byte `asn1:"optional,tag:0"`
}

func unmarshalAuthKeyId(value []byte) (authKeyId, error) <span class="cov0" title="0">{
        var a authKeyId
        if rest, err := asn1.Unmarshal(value, &amp;a); err != nil </span><span class="cov0" title="0">{
                return a, err
        }</span> else<span class="cov0" title="0"> if len(rest) != 0 </span><span class="cov0" title="0">{
                return a, errors.New("x509: trailing data after X.509 authority key-id")
        }</span>
        <span class="cov0" title="0">return a, nil</span>
}

type CRLPool struct {
        byIssuerAndSerial map[string]pkix.RevokedCertificate
}

func NewCRLPool() *CRLPool <span class="cov0" title="0">{
        crlPool := new(CRLPool)
        crlPool.byIssuerAndSerial = make(map[string]pkix.RevokedCertificate)
        return crlPool
}</span>

func getAuthorityKeyId(crl *pkix.CertificateList) (authKeyId, error) <span class="cov0" title="0">{
        var err error
        var a authKeyId

        if crl == nil </span><span class="cov0" title="0">{
                return a, fmt.Errorf("crl is nil")
        }</span>

        <span class="cov0" title="0">for _, exten := range crl.TBSCertList.Extensions </span><span class="cov0" title="0">{
                if exten.Id.Equal(oidExtensionAuthorityKeyId) </span><span class="cov0" title="0">{
                        a, err = unmarshalAuthKeyId(exten.Value)
                        if err != nil </span><span class="cov0" title="0">{
                                return a, err
                        }</span>
                }
        }

        <span class="cov0" title="0">return a, nil</span>
}

func (p *CRLPool) AddCRL(crl *pkix.CertificateList) error <span class="cov0" title="0">{
        if crl == nil </span><span class="cov0" title="0">{
                return errors.New("add nil CertificateList to CRLPool")
        }</span>

        <span class="cov0" title="0">a, err := getAuthorityKeyId(crl)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if len(a.Id) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("AuthorityKeyId not set in crl")
        }</span>

        <span class="cov0" title="0">for _, revokedCert := range crl.TBSCertList.RevokedCertificates </span><span class="cov0" title="0">{
                p.byIssuerAndSerial[genCRLPoolKey(a.Id, revokedCert.SerialNumber)] = revokedCert
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func genCRLPoolKey(authorityKeyId []byte, serialNum *big.Int) string <span class="cov0" title="0">{
        var buf bytes.Buffer
        buf.WriteString(hex.EncodeToString(authorityKeyId))
        buf.WriteString("_")
        buf.WriteString(serialNum.Text(16))
        return buf.String()
}</span>

func (p *CRLPool) CheckCertRevoked(cert *x509.Certificate) bool <span class="cov0" title="0">{
        if _, ok := p.byIssuerAndSerial[genCRLPoolKey(cert.AuthorityKeyId, cert.SerialNumber)]; ok </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file256" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package bfe_tls

import (
        "bytes"
        "crypto/ecdsa"
        "crypto/rsa"
        "crypto/subtle"
        "crypto/x509"
        "encoding/asn1"
        "errors"
        "fmt"
        "io"
        "math/big"
        "net"
        "strconv"
)

type clientHandshakeState struct {
        c            *Conn
        serverHello  *serverHelloMsg
        hello        *clientHelloMsg
        suite        *cipherSuite
        finishedHash finishedHash
        masterSecret []byte
        session      *ClientSessionState
}

func (c *Conn) clientHandshake() error <span class="cov8" title="1">{
        if c.config == nil </span><span class="cov0" title="0">{
                c.config = defaultConfig()
        }</span>

        <span class="cov8" title="1">if len(c.config.ServerName) == 0 &amp;&amp; !c.config.InsecureSkipVerify </span><span class="cov0" title="0">{
                return errors.New("tls: either ServerName or InsecureSkipVerify must be specified in the tls.Config")
        }</span>

        <span class="cov8" title="1">hello := &amp;clientHelloMsg{
                vers:                c.config.maxVersion(),
                compressionMethods:  []uint8{compressionNone},
                random:              make([]byte, 32),
                ocspStapling:        true,
                serverName:          c.config.ServerName,
                supportedCurves:     c.config.curvePreferences(),
                supportedPoints:     []uint8{pointFormatUncompressed},
                nextProtoNeg:        len(c.config.NextProtos) &gt; 0,
                secureRenegotiation: true,
        }

        possibleCipherSuites := c.config.cipherSuites()
        hello.cipherSuites = make([]uint16, 0, len(possibleCipherSuites))

NextCipherSuite:
        for _, suiteId := range possibleCipherSuites </span><span class="cov8" title="1">{
                for _, suite := range cipherSuites </span><span class="cov8" title="1">{
                        if suite.id != suiteId </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        // Don't advertise TLS 1.2-only cipher suites unless
                        // we're attempting TLS 1.2.
                        <span class="cov8" title="1">if hello.vers &lt; VersionTLS12 &amp;&amp; suite.flags&amp;suiteTLS12 != 0 </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">hello.cipherSuites = append(hello.cipherSuites, suiteId)
                        continue NextCipherSuite</span>
                }
        }

        <span class="cov8" title="1">_, err := io.ReadFull(c.config.rand(), hello.random)
        if err != nil </span><span class="cov0" title="0">{
                c.sendAlert(alertInternalError)
                return errors.New("tls: short read from Rand: " + err.Error())
        }</span>

        <span class="cov8" title="1">if hello.vers &gt;= VersionTLS12 </span><span class="cov8" title="1">{
                hello.signatureAndHashes = supportedSKXSignatureAlgorithms
        }</span>

        <span class="cov8" title="1">var session *ClientSessionState
        var cacheKey string
        sessionCache := c.config.ClientSessionCache
        if c.config.SessionTicketsDisabled </span><span class="cov0" title="0">{
                sessionCache = nil
        }</span>

        <span class="cov8" title="1">if sessionCache != nil </span><span class="cov8" title="1">{
                hello.ticketSupported = true

                // Try to resume a previously negotiated TLS session, if
                // available.
                cacheKey = clientSessionCacheKey(c.conn.RemoteAddr(), c.config)
                candidateSession, ok := sessionCache.Get(cacheKey)
                if ok </span><span class="cov8" title="1">{
                        // Check that the ciphersuite/version used for the
                        // previous session are still valid.
                        cipherSuiteOk := false
                        for _, id := range hello.cipherSuites </span><span class="cov8" title="1">{
                                if id == candidateSession.cipherSuite </span><span class="cov8" title="1">{
                                        cipherSuiteOk = true
                                        break</span>
                                }
                        }

                        <span class="cov8" title="1">versOk := candidateSession.vers &gt;= c.config.minVersion() &amp;&amp;
                                candidateSession.vers &lt;= c.config.maxVersion()
                        if versOk &amp;&amp; cipherSuiteOk </span><span class="cov8" title="1">{
                                session = candidateSession
                        }</span>
                }
        }

        <span class="cov8" title="1">if session != nil </span><span class="cov8" title="1">{
                hello.sessionTicket = session.sessionTicket
                // A random session ID is used to detect when the
                // server accepted the ticket and is resuming a session
                // (see RFC 5077).
                hello.sessionId = make([]byte, 16)
                if _, err := io.ReadFull(c.config.rand(), hello.sessionId); err != nil </span><span class="cov0" title="0">{
                        c.sendAlert(alertInternalError)
                        return errors.New("tls: short read from Rand: " + err.Error())
                }</span>
        }

        <span class="cov8" title="1">c.writeRecord(recordTypeHandshake, hello.marshal())

        msg, err := c.readHandshake()
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">serverHello, ok := msg.(*serverHelloMsg)
        if !ok </span><span class="cov0" title="0">{
                c.sendAlert(alertUnexpectedMessage)
                return unexpectedMessageError(serverHello, msg)
        }</span>

        <span class="cov8" title="1">vers, ok := c.config.mutualVersion(serverHello.vers)
        if !ok || vers &lt; VersionTLS10 </span><span class="cov0" title="0">{
                // TLS 1.0 is the minimum version supported as a client.
                c.sendAlert(alertProtocolVersion)
                return fmt.Errorf("tls: server selected unsupported protocol version %x", serverHello.vers)
        }</span>
        <span class="cov8" title="1">c.vers = vers
        c.haveVers = true

        suite := mutualCipherSuite(c.config.cipherSuites(), serverHello.cipherSuite)
        if suite == nil </span><span class="cov0" title="0">{
                c.sendAlert(alertHandshakeFailure)
                return fmt.Errorf("tls: server selected an unsupported cipher suite")
        }</span>

        <span class="cov8" title="1">hs := &amp;clientHandshakeState{
                c:            c,
                serverHello:  serverHello,
                hello:        hello,
                suite:        suite,
                finishedHash: newFinishedHash(c.vers),
                session:      session,
        }

        hs.finishedHash.Write(hs.hello.marshal())
        hs.finishedHash.Write(hs.serverHello.marshal())

        isResume, err := hs.processServerHello()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if isResume </span><span class="cov8" title="1">{
                if err := hs.establishKeys(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if err := hs.readSessionTicket(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if err := hs.readFinished(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if err := hs.sendFinished(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov8" title="1"> {
                if err := hs.doFullHandshake(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if err := hs.establishKeys(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if err := hs.sendFinished(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if err := hs.readSessionTicket(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if err := hs.readFinished(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">if sessionCache != nil &amp;&amp; hs.session != nil &amp;&amp; session != hs.session </span><span class="cov8" title="1">{
                sessionCache.Put(cacheKey, hs.session)
        }</span>

        <span class="cov8" title="1">c.didResume = isResume
        c.handshakeComplete = true
        c.cipherSuite = suite.id
        return nil</span>
}

func (hs *clientHandshakeState) doFullHandshake() error <span class="cov8" title="1">{
        c := hs.c

        msg, err := c.readHandshake()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">certMsg, ok := msg.(*certificateMsg)
        if !ok || len(certMsg.certificates) == 0 </span><span class="cov0" title="0">{
                c.sendAlert(alertUnexpectedMessage)
                return unexpectedMessageError(certMsg, msg)
        }</span>
        <span class="cov8" title="1">hs.finishedHash.Write(certMsg.marshal())

        certs := make([]*x509.Certificate, len(certMsg.certificates))
        for i, asn1Data := range certMsg.certificates </span><span class="cov8" title="1">{
                cert, err := x509.ParseCertificate(asn1Data)
                if err != nil </span><span class="cov0" title="0">{
                        c.sendAlert(alertBadCertificate)
                        return errors.New("tls: failed to parse certificate from server: " + err.Error())
                }</span>
                <span class="cov8" title="1">certs[i] = cert</span>
        }

        <span class="cov8" title="1">if !c.config.InsecureSkipVerify </span><span class="cov0" title="0">{
                opts := x509.VerifyOptions{
                        Roots:         c.config.RootCAs,
                        CurrentTime:   c.config.time(),
                        DNSName:       c.config.ServerName,
                        Intermediates: x509.NewCertPool(),
                }

                for i, cert := range certs </span><span class="cov0" title="0">{
                        if i == 0 </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">opts.Intermediates.AddCert(cert)</span>
                }
                <span class="cov0" title="0">c.verifiedChains, err = certs[0].Verify(opts)
                if err != nil </span><span class="cov0" title="0">{
                        c.sendAlert(alertBadCertificate)
                        return err
                }</span>
        }

        <span class="cov8" title="1">switch certs[0].PublicKey.(type) </span>{
        case *rsa.PublicKey, *ecdsa.PublicKey:<span class="cov8" title="1">
                break</span>
        default:<span class="cov0" title="0">
                c.sendAlert(alertUnsupportedCertificate)
                return fmt.Errorf("tls: server's certificate contains an unsupported type of public key: %T", certs[0].PublicKey)</span>
        }

        <span class="cov8" title="1">c.peerCertificates = certs

        if hs.serverHello.ocspStapling </span><span class="cov0" title="0">{
                msg, err = c.readHandshake()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">cs, ok := msg.(*certificateStatusMsg)
                if !ok </span><span class="cov0" title="0">{
                        c.sendAlert(alertUnexpectedMessage)
                        return unexpectedMessageError(cs, msg)
                }</span>
                <span class="cov0" title="0">hs.finishedHash.Write(cs.marshal())

                if cs.statusType == statusTypeOCSP </span><span class="cov0" title="0">{
                        c.ocspResponse = cs.response
                }</span>
        }

        <span class="cov8" title="1">msg, err = c.readHandshake()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">keyAgreement := hs.suite.ka(c.vers)

        skx, ok := msg.(*serverKeyExchangeMsg)
        if ok </span><span class="cov8" title="1">{
                hs.finishedHash.Write(skx.marshal())
                err = keyAgreement.processServerKeyExchange(c.config, hs.hello, hs.serverHello, certs[0], skx)
                if err != nil </span><span class="cov0" title="0">{
                        c.sendAlert(alertUnexpectedMessage)
                        return err
                }</span>

                <span class="cov8" title="1">msg, err = c.readHandshake()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">var chainToSend *Certificate
        var certRequested bool
        certReq, ok := msg.(*certificateRequestMsg)
        if ok </span><span class="cov8" title="1">{
                certRequested = true

                // RFC 4346 on the certificateAuthorities field:
                // A list of the distinguished names of acceptable certificate
                // authorities. These distinguished names may specify a desired
                // distinguished name for a root CA or for a subordinate CA;
                // thus, this message can be used to describe both known roots
                // and a desired authorization space. If the
                // certificate_authorities list is empty then the client MAY
                // send any certificate of the appropriate
                // ClientCertificateType, unless there is some external
                // arrangement to the contrary.

                hs.finishedHash.Write(certReq.marshal())

                var rsaAvail, ecdsaAvail bool
                for _, certType := range certReq.certificateTypes </span><span class="cov8" title="1">{
                        switch certType </span>{
                        case certTypeRSASign:<span class="cov8" title="1">
                                rsaAvail = true</span>
                        case certTypeECDSASign:<span class="cov8" title="1">
                                ecdsaAvail = true</span>
                        }
                }

                // We need to search our list of client certs for one
                // where SignatureAlgorithm is RSA and the Issuer is in
                // certReq.certificateAuthorities
        <span class="cov8" title="1">findCert:
                for i, chain := range c.config.Certificates </span><span class="cov8" title="1">{
                        if !rsaAvail &amp;&amp; !ecdsaAvail </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov8" title="1">for j, cert := range chain.Certificate </span><span class="cov8" title="1">{
                                x509Cert := chain.Leaf
                                // parse the certificate if this isn't the leaf
                                // node, or if chain.Leaf was nil
                                if j != 0 || x509Cert == nil </span><span class="cov8" title="1">{
                                        if x509Cert, err = x509.ParseCertificate(cert); err != nil </span><span class="cov0" title="0">{
                                                c.sendAlert(alertInternalError)
                                                return errors.New("tls: failed to parse client certificate #" + strconv.Itoa(i) + ": " + err.Error())
                                        }</span>
                                }

                                <span class="cov8" title="1">switch </span>{
                                case rsaAvail &amp;&amp; x509Cert.PublicKeyAlgorithm == x509.RSA:<span class="cov8" title="1"></span>
                                case ecdsaAvail &amp;&amp; x509Cert.PublicKeyAlgorithm == x509.ECDSA:<span class="cov8" title="1"></span>
                                default:<span class="cov0" title="0">
                                        continue findCert</span>
                                }

                                <span class="cov8" title="1">if len(certReq.certificateAuthorities) == 0 </span><span class="cov8" title="1">{
                                        // they gave us an empty list, so just take the
                                        // first RSA cert from c.config.Certificates
                                        chainToSend = &amp;chain
                                        break findCert</span>
                                }

                                <span class="cov0" title="0">for _, ca := range certReq.certificateAuthorities </span><span class="cov0" title="0">{
                                        if bytes.Equal(x509Cert.RawIssuer, ca) </span><span class="cov0" title="0">{
                                                chainToSend = &amp;chain
                                                break findCert</span>
                                        }
                                }
                        }
                }

                <span class="cov8" title="1">msg, err = c.readHandshake()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">shd, ok := msg.(*serverHelloDoneMsg)
        if !ok </span><span class="cov0" title="0">{
                c.sendAlert(alertUnexpectedMessage)
                return unexpectedMessageError(shd, msg)
        }</span>
        <span class="cov8" title="1">hs.finishedHash.Write(shd.marshal())

        // If the server requested a certificate then we have to send a
        // Certificate message, even if it's empty because we don't have a
        // certificate to send.
        if certRequested </span><span class="cov8" title="1">{
                certMsg = new(certificateMsg)
                if chainToSend != nil </span><span class="cov8" title="1">{
                        certMsg.certificates = chainToSend.Certificate
                }</span>
                <span class="cov8" title="1">hs.finishedHash.Write(certMsg.marshal())
                c.writeRecord(recordTypeHandshake, certMsg.marshal())</span>
        }

        <span class="cov8" title="1">preMasterSecret, ckx, err := keyAgreement.generateClientKeyExchange(c.config, hs.hello, certs[0])
        if err != nil </span><span class="cov0" title="0">{
                c.sendAlert(alertInternalError)
                return err
        }</span>
        <span class="cov8" title="1">if ckx != nil </span><span class="cov8" title="1">{
                hs.finishedHash.Write(ckx.marshal())
                c.writeRecord(recordTypeHandshake, ckx.marshal())
        }</span>

        <span class="cov8" title="1">if chainToSend != nil </span><span class="cov8" title="1">{
                var signed []byte
                certVerify := &amp;certificateVerifyMsg{
                        hasSignatureAndHash: c.vers &gt;= VersionTLS12,
                }

                switch key := c.config.Certificates[0].PrivateKey.(type) </span>{
                case *ecdsa.PrivateKey:<span class="cov8" title="1">
                        var r, s *big.Int
                        digest, _, hashId := hs.finishedHash.hashForClientCertificate(signatureECDSA)
                        r, s, err = ecdsa.Sign(c.config.rand(), key, digest)
                        if err == nil </span><span class="cov8" title="1">{
                                signed, err = asn1.Marshal(ecdsaSignature{r, s})
                        }</span>
                        <span class="cov8" title="1">certVerify.signatureAndHash.signature = signatureECDSA
                        certVerify.signatureAndHash.hash = hashId</span>
                case *rsa.PrivateKey:<span class="cov8" title="1">
                        digest, hashFunc, hashId := hs.finishedHash.hashForClientCertificate(signatureRSA)
                        signed, err = rsa.SignPKCS1v15(c.config.rand(), key, hashFunc, digest)
                        certVerify.signatureAndHash.signature = signatureRSA
                        certVerify.signatureAndHash.hash = hashId</span>
                default:<span class="cov0" title="0">
                        err = errors.New("unknown private key type")</span>
                }
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        c.sendAlert(alertInternalError)
                        return errors.New("tls: failed to sign handshake with client certificate: " + err.Error())
                }</span>
                <span class="cov8" title="1">certVerify.signature = signed

                hs.finishedHash.Write(certVerify.marshal())
                c.writeRecord(recordTypeHandshake, certVerify.marshal())</span>
        }

        <span class="cov8" title="1">hs.masterSecret = masterFromPreMasterSecret(c.vers, preMasterSecret, hs.hello.random, hs.serverHello.random)
        return nil</span>
}

func (hs *clientHandshakeState) establishKeys() error <span class="cov8" title="1">{
        c := hs.c

        clientMAC, serverMAC, clientKey, serverKey, clientIV, serverIV :=
                keysFromMasterSecret(c.vers, hs.masterSecret, hs.hello.random, hs.serverHello.random, hs.suite.macLen, hs.suite.keyLen, hs.suite.ivLen)
        var clientCipher, serverCipher interface{}
        var clientHash, serverHash macFunction
        if hs.suite.cipher != nil </span><span class="cov8" title="1">{
                clientCipher = hs.suite.cipher(clientKey, clientIV, false /* not for reading */)
                clientHash = hs.suite.mac(c.vers, clientMAC)
                serverCipher = hs.suite.cipher(serverKey, serverIV, true /* for reading */)
                serverHash = hs.suite.mac(c.vers, serverMAC)
        }</span> else<span class="cov8" title="1"> {
                clientCipher = hs.suite.aead(clientKey, clientIV)
                serverCipher = hs.suite.aead(serverKey, serverIV)
        }</span>

        <span class="cov8" title="1">c.in.prepareCipherSpec(c.vers, serverCipher, serverHash)
        c.out.prepareCipherSpec(c.vers, clientCipher, clientHash)
        return nil</span>
}

func (hs *clientHandshakeState) serverResumedSession() bool <span class="cov8" title="1">{
        // If the server responded with the same sessionId then it means the
        // sessionTicket is being used to resume a TLS session.
        return hs.session != nil &amp;&amp; hs.hello.sessionId != nil &amp;&amp;
                bytes.Equal(hs.serverHello.sessionId, hs.hello.sessionId)
}</span>

func (hs *clientHandshakeState) processServerHello() (bool, error) <span class="cov8" title="1">{
        c := hs.c

        if hs.serverHello.compressionMethod != compressionNone </span><span class="cov0" title="0">{
                c.sendAlert(alertUnexpectedMessage)
                return false, errors.New("tls: server selected unsupported compression format")
        }</span>

        <span class="cov8" title="1">if !hs.hello.nextProtoNeg &amp;&amp; hs.serverHello.nextProtoNeg </span><span class="cov0" title="0">{
                c.sendAlert(alertHandshakeFailure)
                return false, errors.New("server advertised unrequested NPN extension")
        }</span>

        <span class="cov8" title="1">if hs.serverResumedSession() </span><span class="cov8" title="1">{
                // Restore masterSecret and peerCerts from previous state
                hs.masterSecret = hs.session.masterSecret
                c.peerCertificates = hs.session.serverCertificates
                return true, nil
        }</span>
        <span class="cov8" title="1">return false, nil</span>
}

func (hs *clientHandshakeState) readFinished() error <span class="cov8" title="1">{
        c := hs.c

        c.readRecord(recordTypeChangeCipherSpec)
        if err := c.in.error(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">msg, err := c.readHandshake()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">serverFinished, ok := msg.(*finishedMsg)
        if !ok </span><span class="cov0" title="0">{
                c.sendAlert(alertUnexpectedMessage)
                return unexpectedMessageError(serverFinished, msg)
        }</span>

        <span class="cov8" title="1">verify := hs.finishedHash.serverSum(hs.masterSecret)
        if len(verify) != len(serverFinished.verifyData) ||
                subtle.ConstantTimeCompare(verify, serverFinished.verifyData) != 1 </span><span class="cov0" title="0">{
                c.sendAlert(alertHandshakeFailure)
                return errors.New("tls: server's Finished message was incorrect")
        }</span>
        <span class="cov8" title="1">hs.finishedHash.Write(serverFinished.marshal())
        return nil</span>
}

func (hs *clientHandshakeState) readSessionTicket() error <span class="cov8" title="1">{
        if !hs.serverHello.ticketSupported </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">c := hs.c
        msg, err := c.readHandshake()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">sessionTicketMsg, ok := msg.(*newSessionTicketMsg)
        if !ok </span><span class="cov0" title="0">{
                c.sendAlert(alertUnexpectedMessage)
                return unexpectedMessageError(sessionTicketMsg, msg)
        }</span>
        <span class="cov8" title="1">hs.finishedHash.Write(sessionTicketMsg.marshal())

        hs.session = &amp;ClientSessionState{
                sessionTicket:      sessionTicketMsg.ticket,
                vers:               c.vers,
                cipherSuite:        hs.suite.id,
                masterSecret:       hs.masterSecret,
                serverCertificates: c.peerCertificates,
        }

        return nil</span>
}

func (hs *clientHandshakeState) sendFinished() error <span class="cov8" title="1">{
        c := hs.c

        c.writeRecord(recordTypeChangeCipherSpec, []byte{1})
        if hs.serverHello.nextProtoNeg </span><span class="cov0" title="0">{
                nextProto := new(nextProtoMsg)
                proto, fallback := mutualProtocol(c.config.NextProtos, hs.serverHello.nextProtos)
                nextProto.proto = proto
                c.clientProtocol = proto
                c.clientProtocolFallback = fallback

                hs.finishedHash.Write(nextProto.marshal())
                c.writeRecord(recordTypeHandshake, nextProto.marshal())
        }</span>

        <span class="cov8" title="1">finished := new(finishedMsg)
        finished.verifyData = hs.finishedHash.clientSum(hs.masterSecret)
        hs.finishedHash.Write(finished.marshal())
        c.writeRecord(recordTypeHandshake, finished.marshal())
        return nil</span>
}

// clientSessionCacheKey returns a key used to cache sessionTickets that could
// be used to resume previously negotiated TLS sessions with a server.
func clientSessionCacheKey(serverAddr net.Addr, config *Config) string <span class="cov8" title="1">{
        if len(config.ServerName) &gt; 0 </span><span class="cov0" title="0">{
                return config.ServerName
        }</span>
        <span class="cov8" title="1">return serverAddr.String()</span>
}

// mutualProtocol finds the mutual Next Protocol Negotiation protocol given the
// set of client and server supported protocols. The set of client supported
// protocols must not be empty. It returns the resulting protocol and flag
// indicating if the fallback case was reached.
func mutualProtocol(clientProtos, serverProtos []string) (string, bool) <span class="cov8" title="1">{
        for _, s := range serverProtos </span><span class="cov8" title="1">{
                for _, c := range clientProtos </span><span class="cov8" title="1">{
                        if s == c </span><span class="cov8" title="1">{
                                return s, false
                        }</span>
                }
        }

        <span class="cov8" title="1">return clientProtos[0], true</span>
}
</pre>
		
		<pre class="file" id="file257" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package bfe_tls

import (
        "bytes"
        "fmt"
)

type clientHelloMsg struct {
        raw                 []byte
        vers                uint16
        random              []byte
        sessionId           []byte
        cipherSuites        []uint16
        compressionMethods  []uint8
        nextProtoNeg        bool
        serverName          string
        ocspStapling        bool
        supportedCurves     []CurveID
        supportedPoints     []uint8
        ticketSupported     bool
        sessionTicket       []uint8
        signatureAndHashes  []signatureAndHash
        secureRenegotiation bool
        alpnProtocols       []string
        padding             bool
        extensionIds        []uint16
}

func (m *clientHelloMsg) equal(i interface{}) bool <span class="cov8" title="1">{
        m1, ok := i.(*clientHelloMsg)
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">return bytes.Equal(m.raw, m1.raw) &amp;&amp;
                m.vers == m1.vers &amp;&amp;
                bytes.Equal(m.random, m1.random) &amp;&amp;
                bytes.Equal(m.sessionId, m1.sessionId) &amp;&amp;
                eqUint16s(m.cipherSuites, m1.cipherSuites) &amp;&amp;
                bytes.Equal(m.compressionMethods, m1.compressionMethods) &amp;&amp;
                m.nextProtoNeg == m1.nextProtoNeg &amp;&amp;
                m.serverName == m1.serverName &amp;&amp;
                m.ocspStapling == m1.ocspStapling &amp;&amp;
                eqCurveIDs(m.supportedCurves, m1.supportedCurves) &amp;&amp;
                bytes.Equal(m.supportedPoints, m1.supportedPoints) &amp;&amp;
                m.ticketSupported == m1.ticketSupported &amp;&amp;
                bytes.Equal(m.sessionTicket, m1.sessionTicket) &amp;&amp;
                eqSignatureAndHashes(m.signatureAndHashes, m1.signatureAndHashes) &amp;&amp;
                m.secureRenegotiation == m1.secureRenegotiation &amp;&amp;
                eqStrings(m.alpnProtocols, m1.alpnProtocols)</span>
}

// GREASE reserves a set of TLS protocol values that may be advertised to ensure
// peers correctly handle unknown values.
// See: https://datatracker.ietf.org/doc/html/rfc8701#section-2
func isGreaseVal(val uint16) bool <span class="cov8" title="1">{
        return val&amp;0x0F0F == 0x0A0A
}</span>

// JA3String returns a JA3 fingerprint string for TLS client.
// For more information, see https://github.com/salesforce/ja3
func (m *clientHelloMsg) JA3String() string <span class="cov8" title="1">{
        var buf bytes.Buffer

        // The client may advertise one or more GREASE values of cipher suite/extension
        // named group/signature algorithm/version/PskKeyExchangeMode/ALPN identifiers.
        // JA3 should ignores these values completely to ensure that programs utilizing
        // GREASE can still be identified with a single JA3 hash.
        // See: https://datatracker.ietf.org/doc/html/rfc8701#section-3.1

        // version
        fmt.Fprintf(&amp;buf, "%d,", m.vers)
        // cipher surites
        writeJA3Uint16Values(&amp;buf, m.cipherSuites)
        fmt.Fprintf(&amp;buf, ",")
        // extensions
        writeJA3Uint16Values(&amp;buf, m.extensionIds)
        fmt.Fprintf(&amp;buf, ",")
        // elliptic curves
        dashFlag := false
        for _, curve := range m.supportedCurves </span><span class="cov8" title="1">{
                if isGreaseVal(uint16(curve)) </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if dashFlag </span><span class="cov8" title="1">{
                        fmt.Fprintf(&amp;buf, "-")
                }</span>
                <span class="cov8" title="1">fmt.Fprintf(&amp;buf, "%d", curve)
                dashFlag = true</span>
        }
        <span class="cov8" title="1">fmt.Fprintf(&amp;buf, ",")
        // elliptic curves point formats
        for i, point := range m.supportedPoints </span><span class="cov8" title="1">{
                fmt.Fprintf(&amp;buf, "%d", point)
                if i != len(m.supportedPoints)-1 </span><span class="cov8" title="1">{
                        fmt.Fprintf(&amp;buf, "-")
                }</span>
        }
        <span class="cov8" title="1">return buf.String()</span>
}

func writeJA3Uint16Values(buf *bytes.Buffer, values []uint16) <span class="cov8" title="1">{
        dashFlag := false
        for _, value := range values </span><span class="cov8" title="1">{
                if isGreaseVal(value) </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if dashFlag </span><span class="cov8" title="1">{
                        fmt.Fprintf(buf, "-")
                }</span>
                <span class="cov8" title="1">fmt.Fprintf(buf, "%d", value)
                dashFlag = true</span>
        }
}

func (m *clientHelloMsg) marshal() []byte <span class="cov8" title="1">{
        if m.raw != nil </span><span class="cov8" title="1">{
                return m.raw
        }</span>

        <span class="cov8" title="1">length := 2 + 32 + 1 + len(m.sessionId) + 2 + len(m.cipherSuites)*2 + 1 + len(m.compressionMethods)
        numExtensions := 0
        extensionsLength := 0
        if m.nextProtoNeg </span><span class="cov8" title="1">{
                numExtensions++
        }</span>
        <span class="cov8" title="1">if m.ocspStapling </span><span class="cov8" title="1">{
                extensionsLength += 1 + 2 + 2
                numExtensions++
        }</span>
        <span class="cov8" title="1">if len(m.serverName) &gt; 0 </span><span class="cov8" title="1">{
                extensionsLength += 5 + len(m.serverName)
                numExtensions++
        }</span>
        <span class="cov8" title="1">if len(m.supportedCurves) &gt; 0 </span><span class="cov8" title="1">{
                extensionsLength += 2 + 2*len(m.supportedCurves)
                numExtensions++
        }</span>
        <span class="cov8" title="1">if len(m.supportedPoints) &gt; 0 </span><span class="cov8" title="1">{
                extensionsLength += 1 + len(m.supportedPoints)
                numExtensions++
        }</span>
        <span class="cov8" title="1">if m.ticketSupported </span><span class="cov8" title="1">{
                extensionsLength += len(m.sessionTicket)
                numExtensions++
        }</span>
        <span class="cov8" title="1">if len(m.signatureAndHashes) &gt; 0 </span><span class="cov8" title="1">{
                extensionsLength += 2 + 2*len(m.signatureAndHashes)
                numExtensions++
        }</span>
        <span class="cov8" title="1">if m.secureRenegotiation </span><span class="cov8" title="1">{
                extensionsLength += 1
                numExtensions++
        }</span>
        <span class="cov8" title="1">if len(m.alpnProtocols) &gt; 0 </span><span class="cov8" title="1">{
                extensionsLength += 2
                for _, s := range m.alpnProtocols </span><span class="cov8" title="1">{
                        if l := len(s); l == 0 || l &gt; 255 </span><span class="cov0" title="0">{
                                panic("invalid ALPN protocol")</span>
                        }
                        <span class="cov8" title="1">extensionsLength++
                        extensionsLength += len(s)</span>
                }
                <span class="cov8" title="1">numExtensions++</span>
        }
        <span class="cov8" title="1">if numExtensions &gt; 0 </span><span class="cov8" title="1">{
                extensionsLength += 4 * numExtensions
                length += 2 + extensionsLength
        }</span>

        <span class="cov8" title="1">x := make([]byte, 4+length)
        x[0] = typeClientHello
        x[1] = uint8(length &gt;&gt; 16)
        x[2] = uint8(length &gt;&gt; 8)
        x[3] = uint8(length)
        x[4] = uint8(m.vers &gt;&gt; 8)
        x[5] = uint8(m.vers)
        copy(x[6:38], m.random)
        x[38] = uint8(len(m.sessionId))
        copy(x[39:39+len(m.sessionId)], m.sessionId)
        y := x[39+len(m.sessionId):]
        y[0] = uint8(len(m.cipherSuites) &gt;&gt; 7)
        y[1] = uint8(len(m.cipherSuites) &lt;&lt; 1)
        for i, suite := range m.cipherSuites </span><span class="cov8" title="1">{
                y[2+i*2] = uint8(suite &gt;&gt; 8)
                y[3+i*2] = uint8(suite)
        }</span>
        <span class="cov8" title="1">z := y[2+len(m.cipherSuites)*2:]
        z[0] = uint8(len(m.compressionMethods))
        copy(z[1:], m.compressionMethods)

        z = z[1+len(m.compressionMethods):]
        if numExtensions &gt; 0 </span><span class="cov8" title="1">{
                z[0] = byte(extensionsLength &gt;&gt; 8)
                z[1] = byte(extensionsLength)
                z = z[2:]
        }</span>
        <span class="cov8" title="1">if m.nextProtoNeg </span><span class="cov8" title="1">{
                z[0] = byte(extensionNextProtoNeg &gt;&gt; 8)
                z[1] = byte(extensionNextProtoNeg &amp; 0xff)
                // The length is always 0
                z = z[4:]
        }</span>
        <span class="cov8" title="1">if len(m.serverName) &gt; 0 </span><span class="cov8" title="1">{
                z[0] = byte(extensionServerName &gt;&gt; 8)
                z[1] = byte(extensionServerName &amp; 0xff)
                l := len(m.serverName) + 5
                z[2] = byte(l &gt;&gt; 8)
                z[3] = byte(l)
                z = z[4:]

                // RFC 3546, section 3.1
                //
                // struct {
                //     NameType name_type;
                //     select (name_type) {
                //         case host_name: HostName;
                //     } name;
                // } ServerName;
                //
                // enum {
                //     host_name(0), (255)
                // } NameType;
                //
                // opaque HostName&lt;1..2^16-1&gt;;
                //
                // struct {
                //     ServerName server_name_list&lt;1..2^16-1&gt;
                // } ServerNameList;

                z[0] = byte((len(m.serverName) + 3) &gt;&gt; 8)
                z[1] = byte(len(m.serverName) + 3)
                z[3] = byte(len(m.serverName) &gt;&gt; 8)
                z[4] = byte(len(m.serverName))
                copy(z[5:], []byte(m.serverName))
                z = z[l:]
        }</span>
        <span class="cov8" title="1">if m.ocspStapling </span><span class="cov8" title="1">{
                // RFC 4366, section 3.6
                z[0] = byte(extensionStatusRequest &gt;&gt; 8)
                z[1] = byte(extensionStatusRequest)
                z[2] = 0
                z[3] = 5
                z[4] = 1 // OCSP type
                // Two zero valued uint16s for the two lengths.
                z = z[9:]
        }</span>
        <span class="cov8" title="1">if len(m.supportedCurves) &gt; 0 </span><span class="cov8" title="1">{
                // http://tools.ietf.org/html/rfc4492#section-5.5.1
                z[0] = byte(extensionSupportedCurves &gt;&gt; 8)
                z[1] = byte(extensionSupportedCurves)
                l := 2 + 2*len(m.supportedCurves)
                z[2] = byte(l &gt;&gt; 8)
                z[3] = byte(l)
                l -= 2
                z[4] = byte(l &gt;&gt; 8)
                z[5] = byte(l)
                z = z[6:]
                for _, curve := range m.supportedCurves </span><span class="cov8" title="1">{
                        z[0] = byte(curve &gt;&gt; 8)
                        z[1] = byte(curve)
                        z = z[2:]
                }</span>
        }
        <span class="cov8" title="1">if len(m.supportedPoints) &gt; 0 </span><span class="cov8" title="1">{
                // http://tools.ietf.org/html/rfc4492#section-5.5.2
                z[0] = byte(extensionSupportedPoints &gt;&gt; 8)
                z[1] = byte(extensionSupportedPoints)
                l := 1 + len(m.supportedPoints)
                z[2] = byte(l &gt;&gt; 8)
                z[3] = byte(l)
                l--
                z[4] = byte(l)
                z = z[5:]
                for _, pointFormat := range m.supportedPoints </span><span class="cov8" title="1">{
                        z[0] = byte(pointFormat)
                        z = z[1:]
                }</span>
        }
        <span class="cov8" title="1">if m.ticketSupported </span><span class="cov8" title="1">{
                // http://tools.ietf.org/html/rfc5077#section-3.2
                z[0] = byte(extensionSessionTicket &gt;&gt; 8)
                z[1] = byte(extensionSessionTicket)
                l := len(m.sessionTicket)
                z[2] = byte(l &gt;&gt; 8)
                z[3] = byte(l)
                z = z[4:]
                copy(z, m.sessionTicket)
                z = z[len(m.sessionTicket):]
        }</span>
        <span class="cov8" title="1">if len(m.signatureAndHashes) &gt; 0 </span><span class="cov8" title="1">{
                // https://tools.ietf.org/html/rfc5246#section-7.4.1.4.1
                z[0] = byte(extensionSignatureAlgorithms &gt;&gt; 8)
                z[1] = byte(extensionSignatureAlgorithms)
                l := 2 + 2*len(m.signatureAndHashes)
                z[2] = byte(l &gt;&gt; 8)
                z[3] = byte(l)
                z = z[4:]

                l -= 2
                z[0] = byte(l &gt;&gt; 8)
                z[1] = byte(l)
                z = z[2:]
                for _, sigAndHash := range m.signatureAndHashes </span><span class="cov8" title="1">{
                        z[0] = sigAndHash.hash
                        z[1] = sigAndHash.signature
                        z = z[2:]
                }</span>
        }
        <span class="cov8" title="1">if m.secureRenegotiation </span><span class="cov8" title="1">{
                z[0] = byte(extensionRenegotiationInfo &gt;&gt; 8)
                z[1] = byte(extensionRenegotiationInfo &amp; 0xff)
                z[2] = 0
                z[3] = 1
                z = z[5:]
        }</span>
        <span class="cov8" title="1">if len(m.alpnProtocols) &gt; 0 </span><span class="cov8" title="1">{
                z[0] = byte(extensionALPN &gt;&gt; 8)
                z[1] = byte(extensionALPN &amp; 0xff)
                lengths := z[2:]
                z = z[6:]

                stringsLength := 0
                for _, s := range m.alpnProtocols </span><span class="cov8" title="1">{
                        l := len(s)
                        z[0] = byte(l)
                        copy(z[1:], s)
                        z = z[1+l:]
                        stringsLength += 1 + l
                }</span>

                <span class="cov8" title="1">lengths[2] = byte(stringsLength &gt;&gt; 8)
                lengths[3] = byte(stringsLength)
                stringsLength += 2
                lengths[0] = byte(stringsLength &gt;&gt; 8)
                lengths[1] = byte(stringsLength)</span>
        }

        <span class="cov8" title="1">m.raw = x

        return x</span>
}

func (m *clientHelloMsg) unmarshal(data []byte) bool <span class="cov8" title="1">{
        if len(data) &lt; 42 </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">m.raw = data
        m.vers = uint16(data[4])&lt;&lt;8 | uint16(data[5])
        m.random = data[6:38]
        sessionIdLen := int(data[38])
        if sessionIdLen &gt; 32 || len(data) &lt; 39+sessionIdLen </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">m.sessionId = data[39 : 39+sessionIdLen]
        data = data[39+sessionIdLen:]
        if len(data) &lt; 2 </span><span class="cov8" title="1">{
                return false
        }</span>
        // cipherSuiteLen is the number of bytes of cipher suite numbers. Since
        // they are uint16s, the number must be even.
        <span class="cov8" title="1">cipherSuiteLen := int(data[0])&lt;&lt;8 | int(data[1])
        if cipherSuiteLen%2 == 1 || len(data) &lt; 2+cipherSuiteLen </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">numCipherSuites := cipherSuiteLen / 2
        m.cipherSuites = make([]uint16, numCipherSuites)
        for i := 0; i &lt; numCipherSuites; i++ </span><span class="cov8" title="1">{
                m.cipherSuites[i] = uint16(data[2+2*i])&lt;&lt;8 | uint16(data[3+2*i])
                if m.cipherSuites[i] == scsvRenegotiation </span><span class="cov8" title="1">{
                        m.secureRenegotiation = true
                }</span>
        }
        <span class="cov8" title="1">data = data[2+cipherSuiteLen:]
        if len(data) &lt; 1 </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">compressionMethodsLen := int(data[0])
        if len(data) &lt; 1+compressionMethodsLen </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">m.compressionMethods = data[1 : 1+compressionMethodsLen]

        data = data[1+compressionMethodsLen:]

        m.nextProtoNeg = false
        m.serverName = ""
        m.ocspStapling = false
        m.ticketSupported = false
        m.sessionTicket = nil
        m.signatureAndHashes = nil
        m.alpnProtocols = nil

        m.extensionIds = make([]uint16, 0)
        if len(data) == 0 </span><span class="cov8" title="1">{
                // ClientHello is optionally followed by extension data
                return true
        }</span>
        <span class="cov8" title="1">if len(data) &lt; 2 </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">extensionsLength := int(data[0])&lt;&lt;8 | int(data[1])
        data = data[2:]
        if extensionsLength != len(data) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">for len(data) != 0 </span><span class="cov8" title="1">{
                if len(data) &lt; 4 </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov8" title="1">extension := uint16(data[0])&lt;&lt;8 | uint16(data[1])
                length := int(data[2])&lt;&lt;8 | int(data[3])
                data = data[4:]
                if len(data) &lt; length </span><span class="cov0" title="0">{
                        return false
                }</span>

                <span class="cov8" title="1">m.extensionIds = append(m.extensionIds, extension)
                switch extension </span>{
                case extensionServerName:<span class="cov8" title="1">
                        if length &lt; 2 </span><span class="cov0" title="0">{
                                return false
                        }</span>
                        <span class="cov8" title="1">numNames := int(data[0])&lt;&lt;8 | int(data[1])
                        d := data[2:]
                        for i := 0; i &lt; numNames; i++ </span><span class="cov8" title="1">{
                                if len(d) &lt; 3 </span><span class="cov0" title="0">{
                                        return false
                                }</span>
                                <span class="cov8" title="1">nameType := d[0]
                                nameLen := int(d[1])&lt;&lt;8 | int(d[2])
                                d = d[3:]
                                if len(d) &lt; nameLen </span><span class="cov0" title="0">{
                                        return false
                                }</span>
                                <span class="cov8" title="1">if nameType == 0 </span><span class="cov8" title="1">{
                                        m.serverName = string(d[0:nameLen])
                                        break</span>
                                }
                                <span class="cov0" title="0">d = d[nameLen:]</span>
                        }
                case extensionNextProtoNeg:<span class="cov8" title="1">
                        if length &gt; 0 </span><span class="cov0" title="0">{
                                return false
                        }</span>
                        <span class="cov8" title="1">m.nextProtoNeg = true</span>
                case extensionStatusRequest:<span class="cov8" title="1">
                        m.ocspStapling = length &gt; 0 &amp;&amp; data[0] == statusTypeOCSP</span>
                case extensionSupportedCurves:<span class="cov8" title="1">
                        // http://tools.ietf.org/html/rfc4492#section-5.5.1
                        if length &lt; 2 </span><span class="cov0" title="0">{
                                return false
                        }</span>
                        <span class="cov8" title="1">l := int(data[0])&lt;&lt;8 | int(data[1])
                        if l%2 == 1 || length != l+2 </span><span class="cov0" title="0">{
                                return false
                        }</span>
                        <span class="cov8" title="1">numCurves := l / 2
                        m.supportedCurves = make([]CurveID, numCurves)
                        d := data[2:]
                        for i := 0; i &lt; numCurves; i++ </span><span class="cov8" title="1">{
                                m.supportedCurves[i] = CurveID(d[0])&lt;&lt;8 | CurveID(d[1])
                                d = d[2:]
                        }</span>
                case extensionSupportedPoints:<span class="cov8" title="1">
                        // http://tools.ietf.org/html/rfc4492#section-5.5.2
                        if length &lt; 1 </span><span class="cov0" title="0">{
                                return false
                        }</span>
                        <span class="cov8" title="1">l := int(data[0])
                        if length != l+1 </span><span class="cov0" title="0">{
                                return false
                        }</span>
                        <span class="cov8" title="1">m.supportedPoints = make([]uint8, l)
                        copy(m.supportedPoints, data[1:])</span>
                case extensionSessionTicket:<span class="cov8" title="1">
                        // http://tools.ietf.org/html/rfc5077#section-3.2
                        m.ticketSupported = true
                        m.sessionTicket = data[:length]</span>
                case extensionSignatureAlgorithms:<span class="cov8" title="1">
                        // https://tools.ietf.org/html/rfc5246#section-7.4.1.4.1
                        if length &lt; 2 || length&amp;1 != 0 </span><span class="cov0" title="0">{
                                return false
                        }</span>
                        <span class="cov8" title="1">l := int(data[0])&lt;&lt;8 | int(data[1])
                        if l != length-2 </span><span class="cov0" title="0">{
                                return false
                        }</span>
                        <span class="cov8" title="1">n := l / 2
                        d := data[2:]
                        m.signatureAndHashes = make([]signatureAndHash, n)
                        for i := range m.signatureAndHashes </span><span class="cov8" title="1">{
                                m.signatureAndHashes[i].hash = d[0]
                                m.signatureAndHashes[i].signature = d[1]
                                d = d[2:]
                        }</span>
                case extensionRenegotiationInfo + 1:<span class="cov0" title="0">
                        if length != 1 || data[0] != 0 </span><span class="cov0" title="0">{
                                return false
                        }</span>
                        <span class="cov0" title="0">m.secureRenegotiation = true</span>
                case extensionALPN:<span class="cov8" title="1">
                        if length &lt; 2 </span><span class="cov0" title="0">{
                                return false
                        }</span>
                        <span class="cov8" title="1">l := int(data[0])&lt;&lt;8 | int(data[1])
                        if l != length-2 </span><span class="cov0" title="0">{
                                return false
                        }</span>
                        <span class="cov8" title="1">d := data[2:length]
                        for len(d) != 0 </span><span class="cov8" title="1">{
                                stringLen := int(d[0])
                                d = d[1:]
                                if stringLen == 0 || stringLen &gt; len(d) </span><span class="cov0" title="0">{
                                        return false
                                }</span>
                                <span class="cov8" title="1">m.alpnProtocols = append(m.alpnProtocols, string(d[:stringLen]))
                                d = d[stringLen:]</span>
                        }
                case extensionPadding:<span class="cov0" title="0">
                        m.padding = true</span>
                }
                <span class="cov8" title="1">data = data[length:]</span>
        }

        <span class="cov8" title="1">return true</span>
}

type serverHelloMsg struct {
        raw                 []byte
        vers                uint16
        random              []byte
        sessionId           []byte
        cipherSuite         uint16
        compressionMethod   uint8
        nextProtoNeg        bool
        nextProtos          []string
        ocspStapling        bool
        ticketSupported     bool
        secureRenegotiation bool
        alpnProtocol        string
}

func (m *serverHelloMsg) equal(i interface{}) bool <span class="cov8" title="1">{
        m1, ok := i.(*serverHelloMsg)
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">return bytes.Equal(m.raw, m1.raw) &amp;&amp;
                m.vers == m1.vers &amp;&amp;
                bytes.Equal(m.random, m1.random) &amp;&amp;
                bytes.Equal(m.sessionId, m1.sessionId) &amp;&amp;
                m.cipherSuite == m1.cipherSuite &amp;&amp;
                m.compressionMethod == m1.compressionMethod &amp;&amp;
                m.nextProtoNeg == m1.nextProtoNeg &amp;&amp;
                eqStrings(m.nextProtos, m1.nextProtos) &amp;&amp;
                m.ocspStapling == m1.ocspStapling &amp;&amp;
                m.ticketSupported == m1.ticketSupported &amp;&amp;
                m.secureRenegotiation == m1.secureRenegotiation &amp;&amp;
                m.alpnProtocol == m1.alpnProtocol</span>
}

func (m *serverHelloMsg) marshal() []byte <span class="cov8" title="1">{
        if m.raw != nil </span><span class="cov8" title="1">{
                return m.raw
        }</span>

        <span class="cov8" title="1">length := 38 + len(m.sessionId)
        numExtensions := 0
        extensionsLength := 0

        nextProtoLen := 0
        if m.nextProtoNeg </span><span class="cov8" title="1">{
                numExtensions++
                for _, v := range m.nextProtos </span><span class="cov8" title="1">{
                        nextProtoLen += len(v)
                }</span>
                <span class="cov8" title="1">nextProtoLen += len(m.nextProtos)
                extensionsLength += nextProtoLen</span>
        }
        <span class="cov8" title="1">if m.ocspStapling </span><span class="cov8" title="1">{
                numExtensions++
        }</span>
        <span class="cov8" title="1">if m.ticketSupported </span><span class="cov8" title="1">{
                numExtensions++
        }</span>
        <span class="cov8" title="1">if m.secureRenegotiation </span><span class="cov8" title="1">{
                extensionsLength += 1
                numExtensions++
        }</span>
        <span class="cov8" title="1">if alpnLen := len(m.alpnProtocol); alpnLen &gt; 0 </span><span class="cov8" title="1">{
                if alpnLen &gt;= 256 </span><span class="cov0" title="0">{
                        panic("invalid ALPN protocol")</span>
                }
                <span class="cov8" title="1">extensionsLength += 2 + 1 + alpnLen
                numExtensions++</span>
        }

        <span class="cov8" title="1">if numExtensions &gt; 0 </span><span class="cov8" title="1">{
                extensionsLength += 4 * numExtensions
                length += 2 + extensionsLength
        }</span>

        <span class="cov8" title="1">x := make([]byte, 4+length)
        x[0] = typeServerHello
        x[1] = uint8(length &gt;&gt; 16)
        x[2] = uint8(length &gt;&gt; 8)
        x[3] = uint8(length)
        x[4] = uint8(m.vers &gt;&gt; 8)
        x[5] = uint8(m.vers)
        copy(x[6:38], m.random)
        x[38] = uint8(len(m.sessionId))
        copy(x[39:39+len(m.sessionId)], m.sessionId)
        z := x[39+len(m.sessionId):]
        z[0] = uint8(m.cipherSuite &gt;&gt; 8)
        z[1] = uint8(m.cipherSuite)
        z[2] = uint8(m.compressionMethod)

        z = z[3:]
        if numExtensions &gt; 0 </span><span class="cov8" title="1">{
                z[0] = byte(extensionsLength &gt;&gt; 8)
                z[1] = byte(extensionsLength)
                z = z[2:]
        }</span>
        <span class="cov8" title="1">if m.nextProtoNeg </span><span class="cov8" title="1">{
                z[0] = byte(extensionNextProtoNeg &gt;&gt; 8)
                z[1] = byte(extensionNextProtoNeg &amp; 0xff)
                z[2] = byte(nextProtoLen &gt;&gt; 8)
                z[3] = byte(nextProtoLen)
                z = z[4:]

                for _, v := range m.nextProtos </span><span class="cov8" title="1">{
                        l := len(v)
                        if l &gt; 255 </span><span class="cov0" title="0">{
                                l = 255
                        }</span>
                        <span class="cov8" title="1">z[0] = byte(l)
                        copy(z[1:], []byte(v[0:l]))
                        z = z[1+l:]</span>
                }
        }
        <span class="cov8" title="1">if m.ocspStapling </span><span class="cov8" title="1">{
                z[0] = byte(extensionStatusRequest &gt;&gt; 8)
                z[1] = byte(extensionStatusRequest)
                z = z[4:]
        }</span>
        <span class="cov8" title="1">if m.ticketSupported </span><span class="cov8" title="1">{
                z[0] = byte(extensionSessionTicket &gt;&gt; 8)
                z[1] = byte(extensionSessionTicket)
                z = z[4:]
        }</span>
        <span class="cov8" title="1">if m.secureRenegotiation </span><span class="cov8" title="1">{
                z[0] = byte(extensionRenegotiationInfo &gt;&gt; 8)
                z[1] = byte(extensionRenegotiationInfo &amp; 0xff)
                z[2] = 0
                z[3] = 1
                z = z[5:]
        }</span>
        <span class="cov8" title="1">if alpnLen := len(m.alpnProtocol); alpnLen &gt; 0 </span><span class="cov8" title="1">{
                z[0] = byte(extensionALPN &gt;&gt; 8)
                z[1] = byte(extensionALPN &amp; 0xff)
                l := 2 + 1 + alpnLen
                z[2] = byte(l &gt;&gt; 8)
                z[3] = byte(l)
                l -= 2
                z[4] = byte(l &gt;&gt; 8)
                z[5] = byte(l)
                l -= 1
                z[6] = byte(l)
                copy(z[7:], []byte(m.alpnProtocol))
                z = z[7+alpnLen:]
        }</span>

        <span class="cov8" title="1">m.raw = x

        return x</span>
}

func (m *serverHelloMsg) unmarshal(data []byte) bool <span class="cov8" title="1">{
        if len(data) &lt; 42 </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">m.raw = data
        m.vers = uint16(data[4])&lt;&lt;8 | uint16(data[5])
        m.random = data[6:38]
        sessionIdLen := int(data[38])
        if sessionIdLen &gt; 32 || len(data) &lt; 39+sessionIdLen </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">m.sessionId = data[39 : 39+sessionIdLen]
        data = data[39+sessionIdLen:]
        if len(data) &lt; 3 </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">m.cipherSuite = uint16(data[0])&lt;&lt;8 | uint16(data[1])
        m.compressionMethod = data[2]
        data = data[3:]

        m.nextProtoNeg = false
        m.nextProtos = nil
        m.ocspStapling = false
        m.ticketSupported = false
        m.alpnProtocol = ""

        if len(data) == 0 </span><span class="cov8" title="1">{
                // ServerHello is optionally followed by extension data
                return true
        }</span>
        <span class="cov8" title="1">if len(data) &lt; 2 </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">extensionsLength := int(data[0])&lt;&lt;8 | int(data[1])
        data = data[2:]
        if len(data) != extensionsLength </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">for len(data) != 0 </span><span class="cov8" title="1">{
                if len(data) &lt; 4 </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov8" title="1">extension := uint16(data[0])&lt;&lt;8 | uint16(data[1])
                length := int(data[2])&lt;&lt;8 | int(data[3])
                data = data[4:]
                if len(data) &lt; length </span><span class="cov0" title="0">{
                        return false
                }</span>

                <span class="cov8" title="1">switch extension </span>{
                case extensionNextProtoNeg:<span class="cov8" title="1">
                        m.nextProtoNeg = true
                        d := data[:length]
                        for len(d) &gt; 0 </span><span class="cov8" title="1">{
                                l := int(d[0])
                                d = d[1:]
                                if l == 0 || l &gt; len(d) </span><span class="cov0" title="0">{
                                        return false
                                }</span>
                                <span class="cov8" title="1">m.nextProtos = append(m.nextProtos, string(d[:l]))
                                d = d[l:]</span>
                        }
                case extensionStatusRequest:<span class="cov8" title="1">
                        if length &gt; 0 </span><span class="cov0" title="0">{
                                return false
                        }</span>
                        <span class="cov8" title="1">m.ocspStapling = true</span>
                case extensionSessionTicket:<span class="cov8" title="1">
                        if length &gt; 0 </span><span class="cov0" title="0">{
                                return false
                        }</span>
                        <span class="cov8" title="1">m.ticketSupported = true</span>
                case extensionRenegotiationInfo:<span class="cov8" title="1">
                        if length != 1 || data[0] != 0 </span><span class="cov0" title="0">{
                                return false
                        }</span>
                        <span class="cov8" title="1">m.secureRenegotiation = true</span>
                case extensionALPN:<span class="cov8" title="1">
                        d := data[:length]
                        if len(d) &lt; 3 </span><span class="cov0" title="0">{
                                return false
                        }</span>
                        <span class="cov8" title="1">l := int(d[0])&lt;&lt;8 | int(d[1])
                        if l != len(d)-2 </span><span class="cov0" title="0">{
                                return false
                        }</span>
                        <span class="cov8" title="1">d = d[2:]
                        l = int(d[0])
                        if l != len(d)-1 </span><span class="cov0" title="0">{
                                return false
                        }</span>
                        <span class="cov8" title="1">d = d[1:]
                        m.alpnProtocol = string(d)</span>
                }
                <span class="cov8" title="1">data = data[length:]</span>
        }

        <span class="cov8" title="1">return true</span>
}

type certificateMsg struct {
        raw          []byte
        certificates [][]byte
}

func (m *certificateMsg) equal(i interface{}) bool <span class="cov8" title="1">{
        m1, ok := i.(*certificateMsg)
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">return bytes.Equal(m.raw, m1.raw) &amp;&amp;
                eqByteSlices(m.certificates, m1.certificates)</span>
}

func (m *certificateMsg) marshal() (x []byte) <span class="cov8" title="1">{
        if m.raw != nil </span><span class="cov8" title="1">{
                return m.raw
        }</span>

        <span class="cov8" title="1">var i int
        for _, slice := range m.certificates </span><span class="cov8" title="1">{
                i += len(slice)
        }</span>

        <span class="cov8" title="1">length := 3 + 3*len(m.certificates) + i
        x = make([]byte, 4+length)
        x[0] = typeCertificate
        x[1] = uint8(length &gt;&gt; 16)
        x[2] = uint8(length &gt;&gt; 8)
        x[3] = uint8(length)

        certificateOctets := length - 3
        x[4] = uint8(certificateOctets &gt;&gt; 16)
        x[5] = uint8(certificateOctets &gt;&gt; 8)
        x[6] = uint8(certificateOctets)

        y := x[7:]
        for _, slice := range m.certificates </span><span class="cov8" title="1">{
                y[0] = uint8(len(slice) &gt;&gt; 16)
                y[1] = uint8(len(slice) &gt;&gt; 8)
                y[2] = uint8(len(slice))
                copy(y[3:], slice)
                y = y[3+len(slice):]
        }</span>

        <span class="cov8" title="1">m.raw = x
        return</span>
}

func (m *certificateMsg) unmarshal(data []byte) bool <span class="cov8" title="1">{
        if len(data) &lt; 7 </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">m.raw = data
        certsLen := uint32(data[4])&lt;&lt;16 | uint32(data[5])&lt;&lt;8 | uint32(data[6])
        if uint32(len(data)) != certsLen+7 </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">numCerts := 0
        d := data[7:]
        for certsLen &gt; 0 </span><span class="cov8" title="1">{
                if len(d) &lt; 4 </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov8" title="1">certLen := uint32(d[0])&lt;&lt;16 | uint32(d[1])&lt;&lt;8 | uint32(d[2])
                if uint32(len(d)) &lt; 3+certLen </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov8" title="1">d = d[3+certLen:]
                certsLen -= 3 + certLen
                numCerts++</span>
        }

        <span class="cov8" title="1">m.certificates = make([][]byte, numCerts)
        d = data[7:]
        for i := 0; i &lt; numCerts; i++ </span><span class="cov8" title="1">{
                certLen := uint32(d[0])&lt;&lt;16 | uint32(d[1])&lt;&lt;8 | uint32(d[2])
                m.certificates[i] = d[3 : 3+certLen]
                d = d[3+certLen:]
        }</span>

        <span class="cov8" title="1">return true</span>
}

type serverKeyExchangeMsg struct {
        raw []byte
        key []byte
}

func (m *serverKeyExchangeMsg) equal(i interface{}) bool <span class="cov0" title="0">{
        m1, ok := i.(*serverKeyExchangeMsg)
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return bytes.Equal(m.raw, m1.raw) &amp;&amp;
                bytes.Equal(m.key, m1.key)</span>
}

func (m *serverKeyExchangeMsg) marshal() []byte <span class="cov8" title="1">{
        if m.raw != nil </span><span class="cov8" title="1">{
                return m.raw
        }</span>
        <span class="cov8" title="1">length := len(m.key)
        x := make([]byte, length+4)
        x[0] = typeServerKeyExchange
        x[1] = uint8(length &gt;&gt; 16)
        x[2] = uint8(length &gt;&gt; 8)
        x[3] = uint8(length)
        copy(x[4:], m.key)

        m.raw = x
        return x</span>
}

func (m *serverKeyExchangeMsg) unmarshal(data []byte) bool <span class="cov8" title="1">{
        m.raw = data
        if len(data) &lt; 4 </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">m.key = data[4:]
        return true</span>
}

type certificateStatusMsg struct {
        raw        []byte
        statusType uint8
        response   []byte
}

func (m *certificateStatusMsg) equal(i interface{}) bool <span class="cov8" title="1">{
        m1, ok := i.(*certificateStatusMsg)
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">return bytes.Equal(m.raw, m1.raw) &amp;&amp;
                m.statusType == m1.statusType &amp;&amp;
                bytes.Equal(m.response, m1.response)</span>
}

func (m *certificateStatusMsg) marshal() []byte <span class="cov8" title="1">{
        if m.raw != nil </span><span class="cov8" title="1">{
                return m.raw
        }</span>

        <span class="cov8" title="1">var x []byte
        if m.statusType == statusTypeOCSP </span><span class="cov8" title="1">{
                x = make([]byte, 4+4+len(m.response))
                x[0] = typeCertificateStatus
                l := len(m.response) + 4
                x[1] = byte(l &gt;&gt; 16)
                x[2] = byte(l &gt;&gt; 8)
                x[3] = byte(l)
                x[4] = statusTypeOCSP

                l -= 4
                x[5] = byte(l &gt;&gt; 16)
                x[6] = byte(l &gt;&gt; 8)
                x[7] = byte(l)
                copy(x[8:], m.response)
        }</span> else<span class="cov8" title="1"> {
                x = []byte{typeCertificateStatus, 0, 0, 1, m.statusType}
        }</span>

        <span class="cov8" title="1">m.raw = x
        return x</span>
}

func (m *certificateStatusMsg) unmarshal(data []byte) bool <span class="cov8" title="1">{
        m.raw = data
        if len(data) &lt; 5 </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">m.statusType = data[4]

        m.response = nil
        if m.statusType == statusTypeOCSP </span><span class="cov8" title="1">{
                if len(data) &lt; 8 </span><span class="cov8" title="1">{
                        return false
                }</span>
                <span class="cov8" title="1">respLen := uint32(data[5])&lt;&lt;16 | uint32(data[6])&lt;&lt;8 | uint32(data[7])
                if uint32(len(data)) != 4+4+respLen </span><span class="cov8" title="1">{
                        return false
                }</span>
                <span class="cov8" title="1">m.response = data[8:]</span>
        }
        <span class="cov8" title="1">return true</span>
}

type serverHelloDoneMsg struct{}

func (m *serverHelloDoneMsg) equal(i interface{}) bool <span class="cov0" title="0">{
        _, ok := i.(*serverHelloDoneMsg)
        return ok
}</span>

func (m *serverHelloDoneMsg) marshal() []byte <span class="cov8" title="1">{
        x := make([]byte, 4)
        x[0] = typeServerHelloDone
        return x
}</span>

func (m *serverHelloDoneMsg) unmarshal(data []byte) bool <span class="cov8" title="1">{
        return len(data) == 4
}</span>

type clientKeyExchangeMsg struct {
        raw        []byte
        ciphertext []byte
}

func (m *clientKeyExchangeMsg) equal(i interface{}) bool <span class="cov8" title="1">{
        m1, ok := i.(*clientKeyExchangeMsg)
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">return bytes.Equal(m.raw, m1.raw) &amp;&amp;
                bytes.Equal(m.ciphertext, m1.ciphertext)</span>
}

func (m *clientKeyExchangeMsg) marshal() []byte <span class="cov8" title="1">{
        if m.raw != nil </span><span class="cov8" title="1">{
                return m.raw
        }</span>
        <span class="cov8" title="1">length := len(m.ciphertext)
        x := make([]byte, length+4)
        x[0] = typeClientKeyExchange
        x[1] = uint8(length &gt;&gt; 16)
        x[2] = uint8(length &gt;&gt; 8)
        x[3] = uint8(length)
        copy(x[4:], m.ciphertext)

        m.raw = x
        return x</span>
}

func (m *clientKeyExchangeMsg) unmarshal(data []byte) bool <span class="cov8" title="1">{
        m.raw = data
        if len(data) &lt; 4 </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">l := int(data[1])&lt;&lt;16 | int(data[2])&lt;&lt;8 | int(data[3])
        if l != len(data)-4 </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">m.ciphertext = data[4:]
        return true</span>
}

type finishedMsg struct {
        raw        []byte
        verifyData []byte
}

func (m *finishedMsg) equal(i interface{}) bool <span class="cov8" title="1">{
        m1, ok := i.(*finishedMsg)
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">return bytes.Equal(m.raw, m1.raw) &amp;&amp;
                bytes.Equal(m.verifyData, m1.verifyData)</span>
}

func (m *finishedMsg) marshal() (x []byte) <span class="cov8" title="1">{
        if m.raw != nil </span><span class="cov8" title="1">{
                return m.raw
        }</span>

        <span class="cov8" title="1">x = make([]byte, 4+len(m.verifyData))
        x[0] = typeFinished
        x[3] = byte(len(m.verifyData))
        copy(x[4:], m.verifyData)
        m.raw = x
        return</span>
}

func (m *finishedMsg) unmarshal(data []byte) bool <span class="cov8" title="1">{
        m.raw = data
        if len(data) &lt; 4 </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">m.verifyData = data[4:]
        return true</span>
}

type nextProtoMsg struct {
        raw   []byte
        proto string
}

func (m *nextProtoMsg) equal(i interface{}) bool <span class="cov8" title="1">{
        m1, ok := i.(*nextProtoMsg)
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">return bytes.Equal(m.raw, m1.raw) &amp;&amp;
                m.proto == m1.proto</span>
}

func (m *nextProtoMsg) marshal() []byte <span class="cov8" title="1">{
        if m.raw != nil </span><span class="cov8" title="1">{
                return m.raw
        }</span>
        <span class="cov8" title="1">l := len(m.proto)
        if l &gt; 255 </span><span class="cov0" title="0">{
                l = 255
        }</span>

        <span class="cov8" title="1">padding := 32 - (l+2)%32
        length := l + padding + 2
        x := make([]byte, length+4)
        x[0] = typeNextProtocol
        x[1] = uint8(length &gt;&gt; 16)
        x[2] = uint8(length &gt;&gt; 8)
        x[3] = uint8(length)

        y := x[4:]
        y[0] = byte(l)
        copy(y[1:], []byte(m.proto[0:l]))
        y = y[1+l:]
        y[0] = byte(padding)

        m.raw = x

        return x</span>
}

func (m *nextProtoMsg) unmarshal(data []byte) bool <span class="cov8" title="1">{
        m.raw = data

        if len(data) &lt; 5 </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">data = data[4:]
        protoLen := int(data[0])
        data = data[1:]
        if len(data) &lt; protoLen </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">m.proto = string(data[0:protoLen])
        data = data[protoLen:]

        if len(data) &lt; 1 </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">paddingLen := int(data[0])
        data = data[1:]

        return len(data) == paddingLen</span>
}

type certificateRequestMsg struct {
        raw []byte
        // hasSignatureAndHash indicates whether this message includes a list
        // of signature and hash functions. This change was introduced with TLS
        // 1.2.
        hasSignatureAndHash bool

        certificateTypes       []byte
        signatureAndHashes     []signatureAndHash
        certificateAuthorities [][]byte
}

func (m *certificateRequestMsg) equal(i interface{}) bool <span class="cov8" title="1">{
        m1, ok := i.(*certificateRequestMsg)
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">return bytes.Equal(m.raw, m1.raw) &amp;&amp;
                bytes.Equal(m.certificateTypes, m1.certificateTypes) &amp;&amp;
                eqByteSlices(m.certificateAuthorities, m1.certificateAuthorities) &amp;&amp;
                eqSignatureAndHashes(m.signatureAndHashes, m1.signatureAndHashes)</span>
}

func (m *certificateRequestMsg) marshal() (x []byte) <span class="cov8" title="1">{
        if m.raw != nil </span><span class="cov8" title="1">{
                return m.raw
        }</span>

        // See http://tools.ietf.org/html/rfc4346#section-7.4.4
        <span class="cov8" title="1">length := 1 + len(m.certificateTypes) + 2
        casLength := 0
        for _, ca := range m.certificateAuthorities </span><span class="cov8" title="1">{
                casLength += 2 + len(ca)
        }</span>
        <span class="cov8" title="1">length += casLength

        if m.hasSignatureAndHash </span><span class="cov8" title="1">{
                length += 2 + 2*len(m.signatureAndHashes)
        }</span>

        <span class="cov8" title="1">x = make([]byte, 4+length)
        x[0] = typeCertificateRequest
        x[1] = uint8(length &gt;&gt; 16)
        x[2] = uint8(length &gt;&gt; 8)
        x[3] = uint8(length)

        x[4] = uint8(len(m.certificateTypes))

        copy(x[5:], m.certificateTypes)
        y := x[5+len(m.certificateTypes):]

        if m.hasSignatureAndHash </span><span class="cov8" title="1">{
                n := len(m.signatureAndHashes) * 2
                y[0] = uint8(n &gt;&gt; 8)
                y[1] = uint8(n)
                y = y[2:]
                for _, sigAndHash := range m.signatureAndHashes </span><span class="cov8" title="1">{
                        y[0] = sigAndHash.hash
                        y[1] = sigAndHash.signature
                        y = y[2:]
                }</span>
        }

        <span class="cov8" title="1">y[0] = uint8(casLength &gt;&gt; 8)
        y[1] = uint8(casLength)
        y = y[2:]
        for _, ca := range m.certificateAuthorities </span><span class="cov8" title="1">{
                y[0] = uint8(len(ca) &gt;&gt; 8)
                y[1] = uint8(len(ca))
                y = y[2:]
                copy(y, ca)
                y = y[len(ca):]
        }</span>

        <span class="cov8" title="1">m.raw = x
        return</span>
}

func (m *certificateRequestMsg) unmarshal(data []byte) bool <span class="cov8" title="1">{
        m.raw = data

        if len(data) &lt; 5 </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">length := uint32(data[1])&lt;&lt;16 | uint32(data[2])&lt;&lt;8 | uint32(data[3])
        if uint32(len(data))-4 != length </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">numCertTypes := int(data[4])
        data = data[5:]
        if numCertTypes == 0 || len(data) &lt;= numCertTypes </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">m.certificateTypes = make([]byte, numCertTypes)
        if copy(m.certificateTypes, data) != numCertTypes </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">data = data[numCertTypes:]

        if m.hasSignatureAndHash </span><span class="cov8" title="1">{
                if len(data) &lt; 2 </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov8" title="1">sigAndHashLen := uint16(data[0])&lt;&lt;8 | uint16(data[1])
                data = data[2:]
                if sigAndHashLen&amp;1 != 0 </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov8" title="1">if len(data) &lt; int(sigAndHashLen) </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov8" title="1">numSigAndHash := sigAndHashLen / 2
                m.signatureAndHashes = make([]signatureAndHash, numSigAndHash)
                for i := range m.signatureAndHashes </span><span class="cov8" title="1">{
                        m.signatureAndHashes[i].hash = data[0]
                        m.signatureAndHashes[i].signature = data[1]
                        data = data[2:]
                }</span>
        }

        <span class="cov8" title="1">if len(data) &lt; 2 </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">casLength := uint16(data[0])&lt;&lt;8 | uint16(data[1])
        data = data[2:]
        if len(data) &lt; int(casLength) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">cas := make([]byte, casLength)
        copy(cas, data)
        data = data[casLength:]

        m.certificateAuthorities = nil
        for len(cas) &gt; 0 </span><span class="cov8" title="1">{
                if len(cas) &lt; 2 </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov8" title="1">caLen := uint16(cas[0])&lt;&lt;8 | uint16(cas[1])
                cas = cas[2:]

                if len(cas) &lt; int(caLen) </span><span class="cov0" title="0">{
                        return false
                }</span>

                <span class="cov8" title="1">m.certificateAuthorities = append(m.certificateAuthorities, cas[:caLen])
                cas = cas[caLen:]</span>
        }

        <span class="cov8" title="1">return len(data) &lt;= 0</span>
}

type certificateVerifyMsg struct {
        raw                 []byte
        hasSignatureAndHash bool
        signatureAndHash    signatureAndHash
        signature           []byte
}

func (m *certificateVerifyMsg) equal(i interface{}) bool <span class="cov8" title="1">{
        m1, ok := i.(*certificateVerifyMsg)
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">return bytes.Equal(m.raw, m1.raw) &amp;&amp;
                m.hasSignatureAndHash == m1.hasSignatureAndHash &amp;&amp;
                m.signatureAndHash.hash == m1.signatureAndHash.hash &amp;&amp;
                m.signatureAndHash.signature == m1.signatureAndHash.signature &amp;&amp;
                bytes.Equal(m.signature, m1.signature)</span>
}

func (m *certificateVerifyMsg) marshal() (x []byte) <span class="cov8" title="1">{
        if m.raw != nil </span><span class="cov8" title="1">{
                return m.raw
        }</span>

        // See http://tools.ietf.org/html/rfc4346#section-7.4.8
        <span class="cov8" title="1">siglength := len(m.signature)
        length := 2 + siglength
        if m.hasSignatureAndHash </span><span class="cov8" title="1">{
                length += 2
        }</span>
        <span class="cov8" title="1">x = make([]byte, 4+length)
        x[0] = typeCertificateVerify
        x[1] = uint8(length &gt;&gt; 16)
        x[2] = uint8(length &gt;&gt; 8)
        x[3] = uint8(length)
        y := x[4:]
        if m.hasSignatureAndHash </span><span class="cov8" title="1">{
                y[0] = m.signatureAndHash.hash
                y[1] = m.signatureAndHash.signature
                y = y[2:]
        }</span>
        <span class="cov8" title="1">y[0] = uint8(siglength &gt;&gt; 8)
        y[1] = uint8(siglength)
        copy(y[2:], m.signature)

        m.raw = x

        return</span>
}

func (m *certificateVerifyMsg) unmarshal(data []byte) bool <span class="cov8" title="1">{
        m.raw = data

        if len(data) &lt; 6 </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">length := uint32(data[1])&lt;&lt;16 | uint32(data[2])&lt;&lt;8 | uint32(data[3])
        if uint32(len(data))-4 != length </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">data = data[4:]
        if m.hasSignatureAndHash </span><span class="cov8" title="1">{
                m.signatureAndHash.hash = data[0]
                m.signatureAndHash.signature = data[1]
                data = data[2:]
        }</span>

        <span class="cov8" title="1">if len(data) &lt; 2 </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">siglength := int(data[0])&lt;&lt;8 + int(data[1])
        data = data[2:]
        if len(data) != siglength </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">m.signature = data

        return true</span>
}

type newSessionTicketMsg struct {
        raw    []byte
        ticket []byte
}

func (m *newSessionTicketMsg) equal(i interface{}) bool <span class="cov8" title="1">{
        m1, ok := i.(*newSessionTicketMsg)
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">return bytes.Equal(m.raw, m1.raw) &amp;&amp;
                bytes.Equal(m.ticket, m1.ticket)</span>
}

func (m *newSessionTicketMsg) marshal() (x []byte) <span class="cov8" title="1">{
        if m.raw != nil </span><span class="cov8" title="1">{
                return m.raw
        }</span>

        // See http://tools.ietf.org/html/rfc5077#section-3.3
        <span class="cov8" title="1">ticketLen := len(m.ticket)
        length := 2 + 4 + ticketLen
        x = make([]byte, 4+length)
        x[0] = typeNewSessionTicket
        x[1] = uint8(length &gt;&gt; 16)
        x[2] = uint8(length &gt;&gt; 8)
        x[3] = uint8(length)
        x[8] = uint8(ticketLen &gt;&gt; 8)
        x[9] = uint8(ticketLen)
        copy(x[10:], m.ticket)

        m.raw = x

        return</span>
}

func (m *newSessionTicketMsg) unmarshal(data []byte) bool <span class="cov8" title="1">{
        m.raw = data

        if len(data) &lt; 10 </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">length := uint32(data[1])&lt;&lt;16 | uint32(data[2])&lt;&lt;8 | uint32(data[3])
        if uint32(len(data))-4 != length </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">ticketLen := int(data[8])&lt;&lt;8 + int(data[9])
        if len(data)-10 != ticketLen </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">m.ticket = data[10:]

        return true</span>
}

func eqUint16s(x, y []uint16) bool <span class="cov8" title="1">{
        if len(x) != len(y) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">for i, v := range x </span><span class="cov8" title="1">{
                if y[i] != v </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

func eqCurveIDs(x, y []CurveID) bool <span class="cov8" title="1">{
        if len(x) != len(y) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">for i, v := range x </span><span class="cov8" title="1">{
                if y[i] != v </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

func eqStrings(x, y []string) bool <span class="cov8" title="1">{
        if len(x) != len(y) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">for i, v := range x </span><span class="cov8" title="1">{
                if y[i] != v </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

func eqByteSlices(x, y [][]byte) bool <span class="cov8" title="1">{
        if len(x) != len(y) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">for i, v := range x </span><span class="cov8" title="1">{
                if !bytes.Equal(v, y[i]) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

func eqSignatureAndHashes(x, y []signatureAndHash) bool <span class="cov8" title="1">{
        if len(x) != len(y) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">for i, v := range x </span><span class="cov8" title="1">{
                v2 := y[i]
                if v.hash != v2.hash || v.signature != v2.signature </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}
</pre>
		
		<pre class="file" id="file258" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package bfe_tls

import (
        "crypto"
        "crypto/ecdsa"
        "crypto/md5"
        "crypto/rsa"
        "crypto/subtle"
        "crypto/x509"
        "encoding/asn1"
        "encoding/hex"
        "errors"
        "fmt"
        "io"
        "strings"
        "time"
)

// serverHandshakeState contains details of a server handshake in progress.
// It's discarded once the handshake has completed.
type serverHandshakeState struct {
        c               *Conn
        clientHello     *clientHelloMsg
        hello           *serverHelloMsg
        suite           *cipherSuite
        ellipticOk      bool
        ecdsaOk         bool
        chachaOk        bool
        sessionTicketOK bool
        useRC4          uint8
        sessionState    *sessionState
        finishedHash    finishedHash
        masterSecret    []byte
        certsFromClient [][]byte
        cert            *Certificate
}

// serverHandshake performs a TLS handshake as a server.
func (c *Conn) serverHandshake() error <span class="cov8" title="1">{
        handshakeStart := time.Now()
        config := c.config

        // If this is the first server handshake, we generate a random key to
        // encrypt the tickets with.
        config.serverInitOnce.Do(config.serverInit)

        hs := serverHandshakeState{
                c: c,
        }

        isResume, err := hs.readClientHello()
        if err == io.EOF &amp;&amp; 0 == c.readFromUntilLen </span><span class="cov8" title="1">{
                state.TlsHandshakeZeroData.Inc(1)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                state.TlsHandshakeReadClientHelloErr.Inc(1)
                return err
        }</span>

        // Record JA3 fingerprint for TLS client
        <span class="cov8" title="1">c.ja3Raw = hs.clientHello.JA3String()
        sum := md5.Sum([]byte(c.ja3Raw))
        c.ja3Hash = hex.EncodeToString(sum[:])

        // For an overview of TLS handshaking, see https://tools.ietf.org/html/rfc5246#section-7.3
        if isResume </span><span class="cov8" title="1">{
                state.TlsHandshakeResumeAll.Inc(1)
                // The client has included a session ticket and so we do an abbreviated handshake.
                if err := hs.doResumeHandshake(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if err := hs.establishKeys(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if err := hs.sendFinished(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if err := hs.readFinished(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">c.didResume = true
                state.TlsHandshakeResumeSucc.Inc(1)</span>
        } else<span class="cov8" title="1"> {
                state.TlsHandshakeFullAll.Inc(1)
                // The client didn't include a session ticket, or it wasn't
                // valid so we do a full handshake.
                if err := hs.doFullHandshake(); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">if err := hs.establishKeys(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if err := hs.readFinished(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if err := hs.sendSessionTicket(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if err := hs.sendFinished(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // update session cache
                <span class="cov8" title="1">if !c.config.SessionCacheDisabled &amp;&amp; c.config.ServerSessionCache != nil </span><span class="cov0" title="0">{
                        // If a server is planning on issuing a session ticket to a client that
                        // does not present one, it SHOULD include an empty Session ID in the ServerHello
                        // If the Session Id is not empty, the sever choose stateful resume(session id).
                        if len(hs.hello.sessionId) &gt; 0 </span><span class="cov0" title="0">{
                                state := &amp;sessionState{
                                        vers:         c.vers,
                                        cipherSuite:  hs.suite.id,
                                        sessionId:    hs.hello.sessionId,
                                        masterSecret: hs.masterSecret,
                                        certificates: hs.certsFromClient,
                                }
                                c.config.ServerSessionCache.Put(fmt.Sprintf("%x", hs.hello.sessionId),
                                        state.marshal())
                        }</span>
                }
                <span class="cov8" title="1">state.TlsHandshakeFullSucc.Inc(1)</span>
        }
        <span class="cov8" title="1">c.handshakeComplete = true
        c.handshakeTime = time.Since(handshakeStart)

        // Record master secret for established tls conn. Master secret may
        // saved in NSS key log format so that external programs (eg. wireshark)
        // can decrypt TLS connections for trouble shooting.
        c.clientRandom = hs.clientHello.random
        c.serverRandom = hs.hello.random
        c.masterSecret = hs.masterSecret

        return nil</span>
}

// readClientHello reads a ClientHello message from the client and decides
// whether we will perform session resumption.
func (hs *serverHandshakeState) readClientHello() (isResume bool, err error) <span class="cov8" title="1">{
        config := hs.c.config
        c := hs.c

        msg, err := c.readHandshake()
        if err != nil </span><span class="cov8" title="1">{
                return false, err
        }</span>
        <span class="cov8" title="1">var ok bool
        hs.clientHello, ok = msg.(*clientHelloMsg)
        if !ok </span><span class="cov8" title="1">{
                c.sendAlert(alertUnexpectedMessage)
                return false, unexpectedMessageError(hs.clientHello, msg)
        }</span>
        <span class="cov8" title="1">c.vers, ok = config.mutualVersion(hs.clientHello.vers)
        if !ok </span><span class="cov8" title="1">{
                c.sendAlert(alertProtocolVersion)
                return false, fmt.Errorf("tls: client offered an unsupported, maximum protocol version of %x", hs.clientHello.vers)
        }</span>

        <span class="cov8" title="1">if len(hs.clientHello.serverName) &gt; 0 </span><span class="cov8" title="1">{
                c.serverName = hs.clientHello.serverName
        }</span>

        // get customized config for current connection
        <span class="cov8" title="1">var rule *Rule
        if config.ServerRule != nil </span><span class="cov8" title="1">{
                rule = config.ServerRule.Get(c)
        }</span>

        <span class="cov8" title="1">c.grade = GradeC
        if rule != nil </span><span class="cov8" title="1">{
                c.grade = rule.Grade
                c.enableDynamicRecord = rule.DynamicRecord
        }</span>

        <span class="cov8" title="1">c.vers, ok = config.checkVersionGrade(c.vers, c.grade)
        if !ok </span><span class="cov0" title="0">{
                c.sendAlert(alertProtocolVersion)
                return false, fmt.Errorf("tls: client offered an unsupported suite for this grade, grade is %s", c.grade)
        }</span>

        <span class="cov8" title="1">c.haveVers = true

        hs.useRC4 = config.checkCipherGrade(c)

        hs.finishedHash = newFinishedHash(c.vers)
        if c.sslv2Data == nil </span><span class="cov8" title="1">{
                hs.finishedHash.Write(hs.clientHello.marshal())
        }</span> else<span class="cov0" title="0"> {
                hs.finishedHash.Write(c.sslv2Data)
                c.sslv2Data = nil
        }</span>

        <span class="cov8" title="1">hs.hello = new(serverHelloMsg)

        supportedCurve := false
        preferredCurves := config.curvePreferences()
Curves:
        for _, curve := range hs.clientHello.supportedCurves </span><span class="cov8" title="1">{
                for _, supported := range preferredCurves </span><span class="cov8" title="1">{
                        if supported == curve </span><span class="cov8" title="1">{
                                supportedCurve = true
                                break Curves</span>
                        }
                }
        }

        <span class="cov8" title="1">supportedPointFormat := false
        for _, pointFormat := range hs.clientHello.supportedPoints </span><span class="cov8" title="1">{
                if pointFormat == pointFormatUncompressed </span><span class="cov8" title="1">{
                        supportedPointFormat = true
                        break</span>
                }
        }
        <span class="cov8" title="1">hs.ellipticOk = supportedCurve &amp;&amp; supportedPointFormat

        foundCompression := false
        // We only support null compression, so check that the client offered it.
        for _, compression := range hs.clientHello.compressionMethods </span><span class="cov8" title="1">{
                if compression == compressionNone </span><span class="cov8" title="1">{
                        foundCompression = true
                        break</span>
                }
        }

        <span class="cov8" title="1">if !foundCompression </span><span class="cov8" title="1">{
                c.sendAlert(alertHandshakeFailure)
                return false, errors.New("tls: client does not support uncompressed connections")
        }</span>

        <span class="cov8" title="1">hs.hello.vers = c.vers
        hs.hello.random, err = generateHelloRandom(config.rand())
        if err != nil </span><span class="cov0" title="0">{
                c.sendAlert(alertInternalError)
                return false, err
        }</span>
        <span class="cov8" title="1">hs.hello.secureRenegotiation = hs.clientHello.secureRenegotiation
        hs.hello.compressionMethod = compressionNone

        nextProtos := config.NextProtos
        if rule != nil </span><span class="cov8" title="1">{
                nextProtos = rule.NextProtos.Get(c)
        }</span>

        <span class="cov8" title="1">if len(hs.clientHello.alpnProtocols) &gt; 0 </span><span class="cov8" title="1">{
                if selectedProto, fallback := mutualProtocol(hs.clientHello.alpnProtocols, nextProtos); !fallback </span><span class="cov8" title="1">{
                        hs.hello.alpnProtocol = selectedProto
                        c.clientProtocol = selectedProto
                }</span>
        } else<span class="cov8" title="1"> {
                // Although sending an NPN extension without h2 is reasonable, some client
                // has a bug around this. Best to send NPN without h2.
                nextProtos = checkAndRemoveH2(nextProtos)

                // Although sending an empty NPN extension is reasonable, Firefox has
                // had a bug around this. Best to send nothing at all if
                // config.NextProtos is empty. See
                // https://code.google.com/p/go/issues/detail?id=5445.
                if hs.clientHello.nextProtoNeg &amp;&amp; len(nextProtos) &gt; 0 </span><span class="cov0" title="0">{
                        hs.hello.nextProtoNeg = true
                        hs.hello.nextProtos = nextProtos
                }</span>
        }

        // Select certificate for current connection
        <span class="cov8" title="1">if len(config.Certificates) == 0 </span><span class="cov0" title="0">{
                c.sendAlert(alertInternalError)
                return false, errors.New("tls: no certificates configured")
        }</span>
        <span class="cov8" title="1">hs.cert = &amp;config.Certificates[0]
        if len(hs.clientHello.serverName) &gt; 0 </span><span class="cov8" title="1">{
                hs.cert = config.getCertificateForName(hs.clientHello.serverName)
        }</span>

        <span class="cov8" title="1">if tlsMultiCertificate != nil </span><span class="cov0" title="0">{
                // select certificate by third party policy
                if cert := tlsMultiCertificate.Get(c); cert != nil </span><span class="cov0" title="0">{
                        hs.cert = cert
                }</span>
        } else<span class="cov8" title="1"> if config.MultiCert != nil </span><span class="cov0" title="0">{
                // select certificate by default policy
                if cert := config.MultiCert.Get(c); cert != nil </span><span class="cov0" title="0">{
                        hs.cert = cert
                }</span>
        }

        <span class="cov8" title="1">_, hs.ecdsaOk = hs.cert.PrivateKey.(*ecdsa.PrivateKey)

        // Select client auth policy for current connection
        c.clientAuth = config.ClientAuth
        if rule != nil &amp;&amp; rule.ClientAuth </span><span class="cov0" title="0">{
                c.clientAuth = RequireAndVerifyClientCert
                c.clientCAs = rule.ClientCAs
                c.clientCAName = rule.ClientCAName
                c.clientCRLPool = rule.ClientCRLPool
        }</span>

        // check whether chacha20-poly1305 is enabled for current connection
        <span class="cov8" title="1">if rule != nil </span><span class="cov8" title="1">{
                hs.chachaOk = rule.Chacha20
        }</span>

        <span class="cov8" title="1">if hs.checkForResumption() </span><span class="cov8" title="1">{
                return true, nil
        }</span>

        <span class="cov8" title="1">var preferenceList, supportedList []uint16
        if c.config.PreferServerCipherSuites </span><span class="cov8" title="1">{
                preferenceList = c.config.cipherSuites()
                supportedList = hs.clientHello.cipherSuites
        }</span> else<span class="cov8" title="1"> {
                preferenceList = hs.clientHello.cipherSuites
                supportedList = c.config.cipherSuites()
        }</span>

        <span class="cov8" title="1">if c.config.PreferServerCipherSuites &amp;&amp; len(c.config.CipherSuitesPriority) == len(preferenceList) </span><span class="cov8" title="1">{
                // Equivalent cipher suite negotiation
                hs.suite = hs.negotiateEquivalentCipherSuites(supportedList, preferenceList)
        }</span> else<span class="cov8" title="1"> {
                // Normal cipher suite negotiation
                for _, id := range preferenceList </span><span class="cov8" title="1">{
                        if hs.suite, _ = c.tryCipherSuite(id, supportedList, c.vers,
                                hs.ellipticOk, hs.ecdsaOk, hs.chachaOk, hs.useRC4); hs.suite != nil </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
        }

        // no cipher suite supported by both client and server.
        <span class="cov8" title="1">if hs.suite == nil </span><span class="cov8" title="1">{
                // If client proposes ECDHE without ECC extensions, just try ECDHE cipher suite
                // and choose CurveP256 and Uncompressed point format for client.
                //
                // Note: A client that proposes ECC cipher suites may choose not to include
                // elliptic curves extension or elliptic point format extension. In this case,
                // the server is free to choose any one of the elliptic curves or point formats.
                //
                // For more information, see RFC 4492 Section 4
                ellipticMayOk := hs.checkEllipticMayOk(supportedCurve, supportedPointFormat)
                if ellipticMayOk </span><span class="cov8" title="1">{
                        for _, id := range preferenceList </span><span class="cov8" title="1">{
                                if !CheckSuiteECDHE(id) </span><span class="cov8" title="1">{
                                        continue</span>
                                }
                                <span class="cov0" title="0">if hs.suite, _ = c.tryCipherSuite(id, supportedList, c.vers, true, hs.ecdsaOk, hs.chachaOk, hs.useRC4); hs.suite != nil </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }

                        <span class="cov8" title="1">if hs.suite != nil </span><span class="cov0" title="0">{
                                state.TlsHandshakeAcceptEcdheWithoutExt.Inc(1)
                                hs.clientHello.supportedCurves = append(hs.clientHello.supportedCurves, CurveP256)
                                hs.clientHello.supportedPoints = append(hs.clientHello.supportedPoints, pointFormatUncompressed)
                        }</span>
                }
        }

        <span class="cov8" title="1">if hs.suite == nil </span><span class="cov8" title="1">{
                c.sendAlert(alertHandshakeFailure)
                state.TlsHandshakeNoSharedCipherSuite.Inc(1)
                return false, fmt.Errorf("tls: no cipher suite supported by both client and server: %v",
                        hs.clientHello.cipherSuites)
        }</span>

        // See https://tools.ietf.org/html/draft-ietf-tls-downgrade-scsv-00.
        <span class="cov8" title="1">for _, id := range hs.clientHello.cipherSuites </span><span class="cov8" title="1">{
                if id == TLS_FALLBACK_SCSV </span><span class="cov8" title="1">{
                        // The client is doing a fallback connection.
                        if hs.clientHello.vers &lt; c.config.MaxVersion </span><span class="cov8" title="1">{
                                c.sendAlert(alertInappropriateFallback)
                                return false, errors.New("tls: client using inppropriate protocol fallback")
                        }</span>
                        <span class="cov0" title="0">break</span>
                }
        }

        <span class="cov8" title="1">hs.validateHttp2Accepted()
        return false, nil</span>
}

// Equivalent cipher suite negotiation
// Note: for equivalent cipher suites (cipher suites with same priority in server side),
// selects the client's most preferred ciphersuite.
func (hs *serverHandshakeState) negotiateEquivalentCipherSuites(clientSuites, serverSuites []uint16) *cipherSuite <span class="cov8" title="1">{
        var suiteSelected *cipherSuite
        var suiteServerOrder uint16
        var suiteClientOrder int

        c := hs.c
        for index, serverOrder := range c.config.CipherSuitesPriority </span><span class="cov8" title="1">{
                id := serverSuites[index]

                // check whether current suite is acceptable by client and client's preference for it
                if suite, clientOrder := c.tryCipherSuite(id, clientSuites, c.vers,
                        hs.ellipticOk, hs.ecdsaOk, hs.chachaOk, hs.useRC4); suite != nil </span><span class="cov8" title="1">{
                        // if found first acceptable suite or better suite
                        if suiteSelected == nil || (serverOrder == suiteServerOrder &amp;&amp; clientOrder &lt; suiteClientOrder) </span><span class="cov8" title="1">{
                                suiteSelected = suite
                                suiteServerOrder = serverOrder
                                suiteClientOrder = clientOrder
                        }</span>
                }

                // stop check suite with lower priority
                <span class="cov8" title="1">if suiteSelected != nil &amp;&amp; suiteServerOrder &lt; serverOrder </span><span class="cov8" title="1">{
                        break</span>
                }
        }
        <span class="cov8" title="1">return suiteSelected</span>
}

func checkAndRemoveH2(protos []string) []string <span class="cov8" title="1">{
        nextProtos := make([]string, 0)
        for _, p := range protos </span><span class="cov8" title="1">{
                if p != "h2" </span><span class="cov8" title="1">{
                        nextProtos = append(nextProtos, p)
                }</span>
        }
        <span class="cov8" title="1">return nextProtos</span>
}

func (hs *serverHandshakeState) validateHttp2Accepted() <span class="cov8" title="1">{
        // Note: implementations for http2 Must use TLS1.2 or higher and SHOULD not use
        // any of the cipher suites that are listed in the cipher suite black list.
        // See RFC 7540 Section 9.2
        c := hs.c
        if hs.hello.alpnProtocol == "h2" </span><span class="cov0" title="0">{
                if !checkCipherSuiteHttp2Accepted(hs.suite.id) || c.vers &lt; VersionTLS12 </span><span class="cov0" title="0">{
                        hs.hello.alpnProtocol = "http/1.1"
                        c.clientProtocol = "http/1.1"
                }</span>
        }
}

func (hs *serverHandshakeState) checkEllipticMayOk(supportedCurve, supportedPointFormat bool) bool <span class="cov8" title="1">{
        if hs.c.vers &lt;= VersionSSL30 </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if supportedCurve &amp;&amp; len(hs.clientHello.supportedPoints) == 0 </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov8" title="1">if supportedPointFormat &amp;&amp; len(hs.clientHello.supportedCurves) == 0 </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov8" title="1">if len(hs.clientHello.supportedCurves) == 0 &amp;&amp; len(hs.clientHello.supportedPoints) == 0 </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov0" title="0">return false</span>
}

// checkForResumption returns true if we should perform resumption on this connection.
func (hs *serverHandshakeState) checkForResumption() bool <span class="cov8" title="1">{
        c := hs.c

        var ok bool
        // check session ticket
        if !c.config.SessionTicketsDisabled &amp;&amp; hs.clientHello.ticketSupported &amp;&amp; len(hs.clientHello.sessionTicket) != 0 </span><span class="cov8" title="1">{
                state.TlsHandshakeCheckResumeSessionTicket.Inc(1)
                hs.sessionTicketOK = true
                if hs.sessionState, ok = c.decryptTicket(hs.clientHello.sessionTicket); !ok </span><span class="cov8" title="1">{
                        return false
                }</span>
        } else<span class="cov8" title="1"> {
                // check session cache
                if len(hs.clientHello.sessionId) == 0 </span><span class="cov8" title="1">{
                        return false
                }</span>
                <span class="cov8" title="1">state.TlsHandshakeCheckResumeSessionCache.Inc(1)
                hs.sessionTicketOK = false
                hs.sessionState = nil
                if !c.config.SessionCacheDisabled &amp;&amp; c.config.ServerSessionCache != nil </span><span class="cov0" title="0">{
                        sessionCache := c.config.ServerSessionCache
                        sessionParam, ok := sessionCache.Get(fmt.Sprintf("%x", hs.clientHello.sessionId))
                        if !ok </span><span class="cov0" title="0">{
                                return false
                        }</span>

                        <span class="cov0" title="0">candidateSession := new(sessionState)
                        if ok := candidateSession.unmarshal(sessionParam); !ok </span><span class="cov0" title="0">{
                                return false
                        }</span>
                        <span class="cov0" title="0">hs.sessionState = candidateSession</span>
                }
        }

        <span class="cov8" title="1">if hs.sessionState == nil || hs.sessionState.vers &gt; hs.clientHello.vers </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if vers, ok := c.config.mutualVersion(hs.sessionState.vers); !ok || vers != hs.sessionState.vers </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">cipherSuiteOk := false
        // Check that the client is still offering the ciphersuite in the session.
        for _, id := range hs.clientHello.cipherSuites </span><span class="cov8" title="1">{
                if id == hs.sessionState.cipherSuite </span><span class="cov8" title="1">{
                        cipherSuiteOk = true
                        break</span>
                }
        }
        <span class="cov8" title="1">if !cipherSuiteOk </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check that we also support the ciphersuite from the session.
        <span class="cov8" title="1">hs.suite, _ = c.tryCipherSuite(hs.sessionState.cipherSuite, c.config.cipherSuites(), hs.sessionState.vers,
                hs.ellipticOk, hs.ecdsaOk, hs.chachaOk, hs.useRC4)
        if hs.suite == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">sessionHasClientCerts := len(hs.sessionState.certificates) != 0
        needClientCerts := c.clientAuth == RequireAnyClientCert || c.clientAuth == RequireAndVerifyClientCert
        if needClientCerts &amp;&amp; !sessionHasClientCerts </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if sessionHasClientCerts &amp;&amp; c.clientAuth == NoClientCert </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">if hs.sessionTicketOK </span><span class="cov8" title="1">{
                state.TlsHandshakeShouldResumeSessionTicket.Inc(1)
        }</span> else<span class="cov0" title="0"> {
                state.TlsHandshakeShouldResumeSessionCache.Inc(1)
        }</span>

        <span class="cov8" title="1">hs.validateHttp2Accepted()

        return true</span>
}

func (hs *serverHandshakeState) doResumeHandshake() error <span class="cov8" title="1">{
        c := hs.c

        hs.hello.cipherSuite = hs.suite.id
        // We echo the client's session ID in the ServerHello to let it know
        // that we're doing a resumption.
        hs.hello.sessionId = hs.clientHello.sessionId
        hs.finishedHash.Write(hs.hello.marshal())
        c.writeRecord(recordTypeHandshake, hs.hello.marshal())

        if len(hs.sessionState.certificates) &gt; 0 </span><span class="cov0" title="0">{
                if _, err := hs.processCertsFromClient(hs.sessionState.certificates); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">hs.masterSecret = hs.sessionState.masterSecret

        return nil</span>
}

// judge whether ocspstapling update time suitable for server time
func (hs *serverHandshakeState) ocspTimeCheck() bool <span class="cov0" title="0">{
        if hs.cert.OCSPParse == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if !OcspTimeRangeCheck(hs.cert.OCSPParse) </span><span class="cov0" title="0">{
                state.TlsHandshakeOcspTimeErr.Inc(1)
                return false
        }</span>

        <span class="cov0" title="0">return true</span>
}

func (hs *serverHandshakeState) doFullHandshake() error <span class="cov8" title="1">{
        config := hs.c.config
        c := hs.c

        if hs.clientHello.ocspStapling &amp;&amp; len(hs.cert.OCSPStaple) &gt; 0 </span><span class="cov0" title="0">{
                // check ocspstapling time
                if ocspOk := hs.ocspTimeCheck(); ocspOk </span><span class="cov0" title="0">{
                        hs.hello.ocspStapling = true
                        c.ocspStaple = true
                }</span>
        }
        <span class="cov8" title="1">if hs.clientHello.ocspStapling </span><span class="cov8" title="1">{
                state.TlsStatusRequestExtCount.Inc(1)
        }</span>

        <span class="cov8" title="1">hs.hello.ticketSupported = hs.clientHello.ticketSupported &amp;&amp; !config.SessionTicketsDisabled
        if !hs.hello.ticketSupported &amp;&amp; !c.config.SessionCacheDisabled </span><span class="cov8" title="1">{
                // create new session id
                hs.hello.sessionId = make([]byte, 32)
                if _, err := io.ReadFull(c.config.rand(), hs.hello.sessionId); err != nil </span><span class="cov0" title="0">{
                        c.sendAlert(alertInternalError)
                        return err
                }</span>
        }

        <span class="cov8" title="1">hs.hello.cipherSuite = hs.suite.id
        hs.finishedHash.Write(hs.hello.marshal())
        c.writeRecord(recordTypeHandshake, hs.hello.marshal())

        var certMsg *certificateMsg
        var certMsgData []byte

        if hs.cert.message != nil </span><span class="cov0" title="0">{
                certMsgData = hs.cert.message
        }</span> else<span class="cov8" title="1"> {
                certMsg := new(certificateMsg)
                certMsg.certificates = hs.cert.Certificate
                certMsgData = certMsg.marshal()
        }</span>

        <span class="cov8" title="1">hs.finishedHash.Write(certMsgData)
        c.writeRecord(recordTypeHandshake, certMsgData)

        if hs.hello.ocspStapling </span><span class="cov0" title="0">{
                certStatus := new(certificateStatusMsg)
                certStatus.statusType = statusTypeOCSP
                certStatus.response = hs.cert.OCSPStaple
                hs.finishedHash.Write(certStatus.marshal())
                c.writeRecord(recordTypeHandshake, certStatus.marshal())
        }</span>

        <span class="cov8" title="1">keyAgreement := hs.suite.ka(c.vers)
        skx, err := keyAgreement.generateServerKeyExchange(config, hs.cert, hs.clientHello, hs.hello)
        if err != nil </span><span class="cov0" title="0">{
                c.sendAlert(alertHandshakeFailure)
                return err
        }</span>
        <span class="cov8" title="1">if skx != nil </span><span class="cov8" title="1">{
                hs.finishedHash.Write(skx.marshal())
                c.writeRecord(recordTypeHandshake, skx.marshal())
        }</span>

        <span class="cov8" title="1">if c.clientAuth &gt;= RequestClientCert </span><span class="cov8" title="1">{
                // Request a client certificate
                certReq := new(certificateRequestMsg)
                certReq.certificateTypes = []byte{
                        byte(certTypeRSASign),
                        byte(certTypeECDSASign),
                }
                if c.vers &gt;= VersionTLS12 </span><span class="cov8" title="1">{
                        certReq.hasSignatureAndHash = true
                        certReq.signatureAndHashes = supportedClientCertSignatureAlgorithms
                }</span>

                // An empty list of certificateAuthorities signals to
                // the client that it may send any certificate in response
                // to our request. When we know the CAs we trust, then
                // we can send them down, so that the client can choose
                // an appropriate certificate to give to us.
                <span class="cov8" title="1">if clientCAs := c.getClientCAs(); clientCAs != nil </span><span class="cov0" title="0">{
                        certReq.certificateAuthorities = clientCAs.Subjects()
                }</span>
                <span class="cov8" title="1">hs.finishedHash.Write(certReq.marshal())
                c.writeRecord(recordTypeHandshake, certReq.marshal())</span>
        }

        <span class="cov8" title="1">helloDone := new(serverHelloDoneMsg)
        hs.finishedHash.Write(helloDone.marshal())
        c.writeRecord(recordTypeHandshake, helloDone.marshal())

        var pub crypto.PublicKey // public key for client auth, if any

        msg, err := c.readHandshake()
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">var ok bool
        // If we requested a client certificate, then the client must send a
        // certificate message, even if it's empty.
        if c.clientAuth &gt;= RequestClientCert </span><span class="cov8" title="1">{
                if certMsg, ok = msg.(*certificateMsg); !ok </span><span class="cov0" title="0">{
                        c.sendAlert(alertUnexpectedMessage)
                        return unexpectedMessageError(certMsg, msg)
                }</span>
                <span class="cov8" title="1">hs.finishedHash.Write(certMsg.marshal())

                if len(certMsg.certificates) == 0 </span><span class="cov8" title="1">{
                        // The client didn't actually send a certificate
                        switch c.clientAuth </span>{
                        case RequireAnyClientCert, RequireAndVerifyClientCert:<span class="cov0" title="0">
                                c.sendAlert(alertBadCertificate)
                                return errors.New("tls: client didn't provide a certificate")</span>
                        }
                }

                <span class="cov8" title="1">pub, err = hs.processCertsFromClient(certMsg.certificates)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">msg, err = c.readHandshake()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Get client key exchange
        <span class="cov8" title="1">ckx, ok := msg.(*clientKeyExchangeMsg)
        if !ok </span><span class="cov0" title="0">{
                c.sendAlert(alertUnexpectedMessage)
                return unexpectedMessageError(ckx, msg)
        }</span>
        <span class="cov8" title="1">hs.finishedHash.Write(ckx.marshal())

        // If we received a client cert in response to our certificate request message,
        // the client will send us a certificateVerifyMsg immediately after the
        // clientKeyExchangeMsg.  This message is a digest of all preceding
        // handshake-layer messages that is signed using the private key corresponding
        // to the client's certificate. This allows us to verify that the client is in
        // possession of the private key of the certificate.
        if len(c.peerCertificates) &gt; 0 </span><span class="cov8" title="1">{
                msg, err = c.readHandshake()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">certVerify, ok := msg.(*certificateVerifyMsg)
                if !ok </span><span class="cov0" title="0">{
                        c.sendAlert(alertUnexpectedMessage)
                        return unexpectedMessageError(certVerify, msg)
                }</span>

                <span class="cov8" title="1">switch key := pub.(type) </span>{
                case *ecdsa.PublicKey:<span class="cov8" title="1">
                        ecdsaSig := new(ecdsaSignature)
                        if _, err = asn1.Unmarshal(certVerify.signature, ecdsaSig); err != nil </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov8" title="1">if ecdsaSig.R.Sign() &lt;= 0 || ecdsaSig.S.Sign() &lt;= 0 </span><span class="cov0" title="0">{
                                err = errors.New("ECDSA signature contained zero or negative values")
                                break</span>
                        }
                        <span class="cov8" title="1">digest, _, _ := hs.finishedHash.hashForClientCertificate(signatureECDSA)
                        if !ecdsa.Verify(key, digest, ecdsaSig.R, ecdsaSig.S) </span><span class="cov0" title="0">{
                                err = errors.New("ECDSA verification failure")
                                break</span>
                        }
                case *rsa.PublicKey:<span class="cov8" title="1">
                        digest, hashFunc, _ := hs.finishedHash.hashForClientCertificate(signatureRSA)
                        err = rsa.VerifyPKCS1v15(key, hashFunc, digest, certVerify.signature)</span>
                }
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        c.sendAlert(alertBadCertificate)
                        return errors.New("could not validate signature of connection nonces: " + err.Error())
                }</span>

                <span class="cov8" title="1">hs.finishedHash.Write(certVerify.marshal())</span>
        }

        <span class="cov8" title="1">preMasterSecret, err := keyAgreement.processClientKeyExchange(config, hs.cert, ckx, c.vers)
        if err != nil </span><span class="cov0" title="0">{
                c.sendAlert(alertHandshakeFailure)
                return err
        }</span>
        <span class="cov8" title="1">hs.masterSecret = masterFromPreMasterSecret(c.vers, preMasterSecret, hs.clientHello.random, hs.hello.random)

        return nil</span>
}

func (hs *serverHandshakeState) establishKeys() error <span class="cov8" title="1">{
        c := hs.c

        clientMAC, serverMAC, clientKey, serverKey, clientIV, serverIV :=
                keysFromMasterSecret(c.vers, hs.masterSecret, hs.clientHello.random, hs.hello.random, hs.suite.macLen, hs.suite.keyLen, hs.suite.ivLen)

        var clientCipher, serverCipher interface{}
        var clientHash, serverHash macFunction

        if hs.suite.aead == nil </span><span class="cov8" title="1">{
                clientCipher = hs.suite.cipher(clientKey, clientIV, true /* for reading */)
                clientHash = hs.suite.mac(c.vers, clientMAC)
                serverCipher = hs.suite.cipher(serverKey, serverIV, false /* not for reading */)
                serverHash = hs.suite.mac(c.vers, serverMAC)
        }</span> else<span class="cov8" title="1"> {
                clientCipher = hs.suite.aead(clientKey, clientIV)
                serverCipher = hs.suite.aead(serverKey, serverIV)
        }</span>

        <span class="cov8" title="1">c.in.prepareCipherSpec(c.vers, clientCipher, clientHash)
        c.out.prepareCipherSpec(c.vers, serverCipher, serverHash)

        return nil</span>
}

func (hs *serverHandshakeState) readFinished() error <span class="cov8" title="1">{
        c := hs.c

        c.readRecord(recordTypeChangeCipherSpec)
        if err := c.in.error(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if hs.hello.nextProtoNeg </span><span class="cov0" title="0">{
                msg, err := c.readHandshake()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">nextProto, ok := msg.(*nextProtoMsg)
                if !ok </span><span class="cov0" title="0">{
                        c.sendAlert(alertUnexpectedMessage)
                        return unexpectedMessageError(nextProto, msg)
                }</span>
                <span class="cov0" title="0">hs.finishedHash.Write(nextProto.marshal())
                c.clientProtocol = nextProto.proto</span>
        }

        <span class="cov8" title="1">msg, err := c.readHandshake()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">clientFinished, ok := msg.(*finishedMsg)
        if !ok </span><span class="cov0" title="0">{
                c.sendAlert(alertUnexpectedMessage)
                return unexpectedMessageError(clientFinished, msg)
        }</span>

        <span class="cov8" title="1">verify := hs.finishedHash.clientSum(hs.masterSecret)
        if len(verify) != len(clientFinished.verifyData) ||
                subtle.ConstantTimeCompare(verify, clientFinished.verifyData) != 1 </span><span class="cov0" title="0">{
                c.sendAlert(alertHandshakeFailure)
                return errors.New("tls: client's Finished message is incorrect")
        }</span>

        <span class="cov8" title="1">hs.finishedHash.Write(clientFinished.marshal())
        return nil</span>
}

func (hs *serverHandshakeState) sendSessionTicket() error <span class="cov8" title="1">{
        if !hs.hello.ticketSupported </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">c := hs.c
        m := new(newSessionTicketMsg)

        var err error
        state := sessionState{
                vers:         c.vers,
                cipherSuite:  hs.suite.id,
                masterSecret: hs.masterSecret,
                certificates: hs.certsFromClient,
        }
        m.ticket, err = c.encryptTicket(&amp;state)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">hs.finishedHash.Write(m.marshal())
        c.writeRecord(recordTypeHandshake, m.marshal())

        return nil</span>
}

func (hs *serverHandshakeState) sendFinished() error <span class="cov8" title="1">{
        c := hs.c

        c.writeRecord(recordTypeChangeCipherSpec, []byte{1})

        finished := new(finishedMsg)
        finished.verifyData = hs.finishedHash.serverSum(hs.masterSecret)
        hs.finishedHash.Write(finished.marshal())

        c.writeRecord(recordTypeHandshake, finished.marshal())

        c.cipherSuite = hs.suite.id

        return nil
}</span>

// processCertsFromClient takes a chain of client certificates either from a
// Certificates message or from a sessionState and verifies them. It returns
// the public key of the leaf certificate.
func (hs *serverHandshakeState) processCertsFromClient(certificates [][]byte) (crypto.PublicKey, error) <span class="cov8" title="1">{
        c := hs.c

        hs.certsFromClient = certificates
        certs := make([]*x509.Certificate, len(certificates))
        var err error
        for i, asn1Data := range certificates </span><span class="cov8" title="1">{
                if certs[i], err = x509.ParseCertificate(asn1Data); err != nil </span><span class="cov0" title="0">{
                        c.sendAlert(alertBadCertificate)
                        return nil, errors.New("tls: failed to parse client certificate: " + err.Error())
                }</span>

                <span class="cov8" title="1">if c.clientCRLPool != nil &amp;&amp; c.clientCRLPool.CheckCertRevoked(certs[i]) </span><span class="cov0" title="0">{
                        c.sendAlert(alertCertificateRevoked)
                        return nil, fmt.Errorf("tls: revoked client certificate: %s %s", strings.ToUpper(certs[i].SerialNumber.Text(16)), certs[i].Subject.CommonName)
                }</span>
        }

        <span class="cov8" title="1">if c.clientAuth &gt;= VerifyClientCertIfGiven &amp;&amp; len(certs) &gt; 0 </span><span class="cov0" title="0">{
                opts := x509.VerifyOptions{
                        Roots:         c.getClientCAs(),
                        CurrentTime:   c.config.time(),
                        Intermediates: x509.NewCertPool(),
                        KeyUsages:     []x509.ExtKeyUsage{x509.ExtKeyUsageClientAuth},
                }

                for _, cert := range certs[1:] </span><span class="cov0" title="0">{
                        opts.Intermediates.AddCert(cert)
                }</span>

                <span class="cov0" title="0">chains, err := certs[0].Verify(opts)
                if err != nil </span><span class="cov0" title="0">{
                        c.sendAlert(alertBadCertificate)
                        return nil, errors.New("tls: failed to verify client's certificate: " + err.Error())
                }</span>

                <span class="cov0" title="0">ok := false
                for _, ku := range certs[0].ExtKeyUsage </span><span class="cov0" title="0">{
                        if ku == x509.ExtKeyUsageClientAuth </span><span class="cov0" title="0">{
                                ok = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !ok </span><span class="cov0" title="0">{
                        c.sendAlert(alertHandshakeFailure)
                        return nil, errors.New("tls: client's certificate's extended key usage doesn't permit it to be used for client authentication")
                }</span>

                <span class="cov0" title="0">c.verifiedChains = chains</span>
        }

        <span class="cov8" title="1">if len(certs) &gt; 0 </span><span class="cov8" title="1">{
                var pub crypto.PublicKey
                switch key := certs[0].PublicKey.(type) </span>{
                case *ecdsa.PublicKey, *rsa.PublicKey:<span class="cov8" title="1">
                        pub = key</span>
                default:<span class="cov0" title="0">
                        c.sendAlert(alertUnsupportedCertificate)
                        return nil, fmt.Errorf("tls: client's certificate contains an unsupported public key of type %T", certs[0].PublicKey)</span>
                }
                <span class="cov8" title="1">c.peerCertificates = certs
                return pub, nil</span>
        }

        <span class="cov8" title="1">return nil, nil</span>
}

// tryCipherSuite returns a cipherSuite with the given id if that cipher suite
// is acceptable to use.
func (c *Conn) tryCipherSuite(id uint16, supportedCipherSuites []uint16, version uint16,
        ellipticOk, ecdsaOk, chachaOk bool, useRC4 uint8) (*cipherSuite, int) <span class="cov8" title="1">{
        for i, supported := range supportedCipherSuites </span><span class="cov8" title="1">{
                if id == supported </span><span class="cov8" title="1">{
                        var candidate *cipherSuite

                        for _, s := range cipherSuites </span><span class="cov8" title="1">{
                                if s.id == id </span><span class="cov8" title="1">{
                                        candidate = s
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if candidate == nil </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        // Don't select a ciphersuite which we can't
                        // support for this client.
                        <span class="cov8" title="1">if (candidate.flags&amp;suiteECDHE != 0) &amp;&amp; !ellipticOk </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">if (candidate.flags&amp;suiteECDSA != 0) != ecdsaOk </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">if version &lt; VersionTLS12 &amp;&amp; candidate.flags&amp;suiteTLS12 != 0 </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">if candidate.flags&amp;suiteChacha20 != 0 &amp;&amp; !chachaOk </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">if candidate.flags&amp;suiteRC4 != 0 &amp;&amp; useRC4 == disableRC4 </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">if candidate.flags&amp;suiteRC4 == 0 &amp;&amp; useRC4 == onlyRC4 </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov8" title="1">return candidate, i</span>
                }
        }

        <span class="cov8" title="1">return nil, 0</span>
}

func IsEcdheCipherSuite(suite interface{}) bool <span class="cov8" title="1">{
        if s, ok := suite.(*cipherSuite); ok </span><span class="cov8" title="1">{
                return (s.flags &amp; suiteECDHE) != 0
        }</span>
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file259" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Copyright 2010 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package bfe_tls

import (
        "crypto"
        "crypto/ecdsa"
        "crypto/elliptic"
        "crypto/md5"
        "crypto/rsa"
        "crypto/sha1"
        "crypto/sha256"
        "crypto/x509"
        "encoding/asn1"
        "errors"
        "io"
        "math/big"
)

var errClientKeyExchange = errors.New("tls: invalid ClientKeyExchange message")
var errServerKeyExchange = errors.New("tls: invalid ServerKeyExchange message")

// rsaKeyAgreement implements the standard TLS key agreement where the client
// encrypts the pre-master secret to the server's public key.
type rsaKeyAgreement struct{}

func (ka rsaKeyAgreement) generateServerKeyExchange(config *Config, cert *Certificate, clientHello *clientHelloMsg, hello *serverHelloMsg) (*serverKeyExchangeMsg, error) <span class="cov8" title="1">{
        return nil, nil
}</span>

func (ka rsaKeyAgreement) processClientKeyExchange(config *Config, cert *Certificate, ckx *clientKeyExchangeMsg, version uint16) ([]byte, error) <span class="cov8" title="1">{
        preMasterSecret := make([]byte, 48)
        _, err := io.ReadFull(config.rand(), preMasterSecret[2:])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if len(ckx.ciphertext) &lt; 2 </span><span class="cov0" title="0">{
                return nil, errClientKeyExchange
        }</span>

        <span class="cov8" title="1">ciphertext := ckx.ciphertext
        if version != VersionSSL30 </span><span class="cov8" title="1">{
                ciphertextLen := int(ckx.ciphertext[0])&lt;&lt;8 | int(ckx.ciphertext[1])
                if ciphertextLen != len(ckx.ciphertext)-2 </span><span class="cov0" title="0">{
                        return nil, errClientKeyExchange
                }</span>
                <span class="cov8" title="1">ciphertext = ckx.ciphertext[2:]</span>
        }

        // if ciphertext is zero bytes
        <span class="cov8" title="1">c := new(big.Int).SetBytes(ciphertext)
        if len(c.Bytes()) == 0 </span><span class="cov0" title="0">{
                return nil, errClientKeyExchange
        }</span>

        <span class="cov8" title="1">err = rsa.DecryptPKCS1v15SessionKey(config.rand(), cert.PrivateKey.(*rsa.PrivateKey), ciphertext, preMasterSecret)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        // We don't check the version number in the premaster secret.  For one,
        // by checking it, we would leak information about the validity of the
        // encrypted pre-master secret. Secondly, it provides only a small
        // benefit against a downgrade attack and some implementations send the
        // wrong version anyway. See the discussion at the end of section
        // 7.4.7.1 of RFC 4346.
        <span class="cov8" title="1">return preMasterSecret, nil</span>
}

func (ka rsaKeyAgreement) processServerKeyExchange(config *Config, clientHello *clientHelloMsg, serverHello *serverHelloMsg, cert *x509.Certificate, skx *serverKeyExchangeMsg) error <span class="cov0" title="0">{
        return errors.New("tls: unexpected ServerKeyExchange")
}</span>

func (ka rsaKeyAgreement) generateClientKeyExchange(config *Config, clientHello *clientHelloMsg, cert *x509.Certificate) ([]byte, *clientKeyExchangeMsg, error) <span class="cov8" title="1">{
        preMasterSecret := make([]byte, 48)
        preMasterSecret[0] = byte(clientHello.vers &gt;&gt; 8)
        preMasterSecret[1] = byte(clientHello.vers)
        _, err := io.ReadFull(config.rand(), preMasterSecret[2:])
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov8" title="1">encrypted, err := rsa.EncryptPKCS1v15(config.rand(), cert.PublicKey.(*rsa.PublicKey), preMasterSecret)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov8" title="1">ckx := new(clientKeyExchangeMsg)
        ckx.ciphertext = make([]byte, len(encrypted)+2)
        ckx.ciphertext[0] = byte(len(encrypted) &gt;&gt; 8)
        ckx.ciphertext[1] = byte(len(encrypted))
        copy(ckx.ciphertext[2:], encrypted)
        return preMasterSecret, ckx, nil</span>
}

// sha1Hash calculates a SHA1 hash over the given byte slices.
func sha1Hash(slices [][]byte) []byte <span class="cov8" title="1">{
        hsha1 := sha1.New()
        for _, slice := range slices </span><span class="cov8" title="1">{
                hsha1.Write(slice)
        }</span>
        <span class="cov8" title="1">return hsha1.Sum(nil)</span>
}

// md5SHA1Hash implements TLS 1.0's hybrid hash function which consists of the
// concatenation of an MD5 and SHA1 hash.
func md5SHA1Hash(slices [][]byte) []byte <span class="cov8" title="1">{
        md5sha1 := make([]byte, md5.Size+sha1.Size)
        hmd5 := md5.New()
        for _, slice := range slices </span><span class="cov8" title="1">{
                hmd5.Write(slice)
        }</span>
        <span class="cov8" title="1">copy(md5sha1, hmd5.Sum(nil))
        copy(md5sha1[md5.Size:], sha1Hash(slices))
        return md5sha1</span>
}

// sha256Hash implements TLS 1.2's hash function.
func sha256Hash(slices [][]byte) []byte <span class="cov8" title="1">{
        h := sha256.New()
        for _, slice := range slices </span><span class="cov8" title="1">{
                h.Write(slice)
        }</span>
        <span class="cov8" title="1">return h.Sum(nil)</span>
}

// hashForServerKeyExchange hashes the given slices and returns their digest
// and the identifier of the hash function used. The hashFunc argument is only
// used for &gt;= TLS 1.2 and precisely identifies the hash function to use.
func hashForServerKeyExchange(sigType, hashFunc uint8, version uint16, slices ...[]byte) ([]byte, crypto.Hash, error) <span class="cov8" title="1">{
        if version &gt;= VersionTLS12 </span><span class="cov8" title="1">{
                switch hashFunc </span>{
                case hashSHA256:<span class="cov8" title="1">
                        return sha256Hash(slices), crypto.SHA256, nil</span>
                case hashSHA1:<span class="cov0" title="0">
                        return sha1Hash(slices), crypto.SHA1, nil</span>
                default:<span class="cov0" title="0">
                        return nil, crypto.Hash(0), errors.New("tls: unknown hash function used by peer")</span>
                }
        }
        <span class="cov8" title="1">if sigType == signatureECDSA </span><span class="cov8" title="1">{
                return sha1Hash(slices), crypto.SHA1, nil
        }</span>
        <span class="cov8" title="1">return md5SHA1Hash(slices), crypto.MD5SHA1, nil</span>
}

// pickTLS12HashForSignature returns a TLS 1.2 hash identifier for signing a
// ServerKeyExchange given the signature type being used and the client's
// advertised list of supported signature and hash combinations.
func pickTLS12HashForSignature(sigType uint8, clientSignatureAndHashes []signatureAndHash) (uint8, error) <span class="cov8" title="1">{
        if len(clientSignatureAndHashes) == 0 </span><span class="cov0" title="0">{
                // If the client didn't specify any signature_algorithms
                // extension then we can assume that it supports SHA1. See
                // http://tools.ietf.org/html/rfc5246#section-7.4.1.4.1
                return hashSHA1, nil
        }</span>

        <span class="cov8" title="1">for _, sigAndHash := range clientSignatureAndHashes </span><span class="cov8" title="1">{
                if sigAndHash.signature != sigType </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">switch sigAndHash.hash </span>{
                case hashSHA1, hashSHA256:<span class="cov8" title="1">
                        return sigAndHash.hash, nil</span>
                }
        }

        <span class="cov0" title="0">return 0, errors.New("tls: client doesn't support any common hash functions")</span>
}

func curveForCurveID(id CurveID) (elliptic.Curve, bool) <span class="cov8" title="1">{
        switch id </span>{
        case CurveP256:<span class="cov8" title="1">
                return elliptic.P256(), true</span>
        case CurveP384:<span class="cov0" title="0">
                return elliptic.P384(), true</span>
        case CurveP521:<span class="cov0" title="0">
                return elliptic.P521(), true</span>
        default:<span class="cov0" title="0">
                return nil, false</span>
        }

}

func CurveForCurveID(id CurveID) (elliptic.Curve, bool) <span class="cov0" title="0">{
        return curveForCurveID(id)
}</span>

// ecdheRSAKeyAgreement implements a TLS key agreement where the server
// generates a ephemeral EC public/private key pair and signs it. The
// pre-master secret is then calculated using ECDH. The signature may
// either be ECDSA or RSA.
type ecdheKeyAgreement struct {
        version    uint16
        sigType    uint8
        privateKey []byte
        curve      elliptic.Curve
        x, y       *big.Int
}

func (ka *ecdheKeyAgreement) generateServerKeyExchange(config *Config, cert *Certificate, clientHello *clientHelloMsg, hello *serverHelloMsg) (*serverKeyExchangeMsg, error) <span class="cov8" title="1">{
        var curveid CurveID
        preferredCurves := config.curvePreferences()

NextCandidate:
        for _, candidate := range preferredCurves </span><span class="cov8" title="1">{
                for _, c := range clientHello.supportedCurves </span><span class="cov8" title="1">{
                        if candidate == c </span><span class="cov8" title="1">{
                                curveid = c
                                break NextCandidate</span>
                        }
                }
        }

        <span class="cov8" title="1">if curveid == 0 </span><span class="cov0" title="0">{
                return nil, errors.New("tls: no supported elliptic curves offered")
        }</span>

        <span class="cov8" title="1">var ok bool
        if ka.curve, ok = curveForCurveID(curveid); !ok </span><span class="cov0" title="0">{
                return nil, errors.New("tls: preferredCurves includes unsupported curve")
        }</span>

        <span class="cov8" title="1">var x, y *big.Int
        var err error
        ka.privateKey, x, y, err = elliptic.GenerateKey(ka.curve, config.rand())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">ecdhePublic := elliptic.Marshal(ka.curve, x, y)

        // http://tools.ietf.org/html/rfc4492#section-5.4
        serverECDHParams := make([]byte, 1+2+1+len(ecdhePublic))
        serverECDHParams[0] = 3 // named curve
        serverECDHParams[1] = byte(curveid &gt;&gt; 8)
        serverECDHParams[2] = byte(curveid)
        serverECDHParams[3] = byte(len(ecdhePublic))
        copy(serverECDHParams[4:], ecdhePublic)

        var tls12HashId uint8
        if ka.version &gt;= VersionTLS12 </span><span class="cov8" title="1">{
                if tls12HashId, err = pickTLS12HashForSignature(ka.sigType, clientHello.signatureAndHashes); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">digest, hashFunc, err := hashForServerKeyExchange(ka.sigType, tls12HashId, ka.version, clientHello.random, hello.random, serverECDHParams)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">var sig []byte
        switch ka.sigType </span>{
        case signatureECDSA:<span class="cov8" title="1">
                privKey, ok := cert.PrivateKey.(*ecdsa.PrivateKey)
                if !ok </span><span class="cov0" title="0">{
                        return nil, errors.New("ECDHE ECDSA requires an ECDSA server private key")
                }</span>
                <span class="cov8" title="1">r, s, err := ecdsa.Sign(config.rand(), privKey, digest)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.New("failed to sign ECDHE parameters: " + err.Error())
                }</span>
                <span class="cov8" title="1">sig, err = asn1.Marshal(ecdsaSignature{r, s})
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.New("failed to sign ECDHE asn1 marshal: " + err.Error())
                }</span>
        case signatureRSA:<span class="cov8" title="1">
                privKey, ok := cert.PrivateKey.(*rsa.PrivateKey)
                if !ok </span><span class="cov0" title="0">{
                        return nil, errors.New("ECDHE RSA requires a RSA server private key")
                }</span>
                <span class="cov8" title="1">sig, err = rsa.SignPKCS1v15(config.rand(), privKey, hashFunc, digest)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.New("failed to sign ECDHE parameters: " + err.Error())
                }</span>
        default:<span class="cov0" title="0">
                return nil, errors.New("unknown ECDHE signature algorithm")</span>
        }

        <span class="cov8" title="1">skx := new(serverKeyExchangeMsg)
        sigAndHashLen := 0
        if ka.version &gt;= VersionTLS12 </span><span class="cov8" title="1">{
                sigAndHashLen = 2
        }</span>
        <span class="cov8" title="1">skx.key = make([]byte, len(serverECDHParams)+sigAndHashLen+2+len(sig))
        copy(skx.key, serverECDHParams)
        k := skx.key[len(serverECDHParams):]
        if ka.version &gt;= VersionTLS12 </span><span class="cov8" title="1">{
                k[0] = tls12HashId
                k[1] = ka.sigType
                k = k[2:]
        }</span>
        <span class="cov8" title="1">k[0] = byte(len(sig) &gt;&gt; 8)
        k[1] = byte(len(sig))
        copy(k[2:], sig)

        return skx, nil</span>
}

func (ka *ecdheKeyAgreement) processClientKeyExchange(config *Config, cert *Certificate, ckx *clientKeyExchangeMsg, version uint16) ([]byte, error) <span class="cov8" title="1">{
        if len(ckx.ciphertext) == 0 || int(ckx.ciphertext[0]) != len(ckx.ciphertext)-1 </span><span class="cov0" title="0">{
                return nil, errClientKeyExchange
        }</span>
        <span class="cov8" title="1">x, y := elliptic.Unmarshal(ka.curve, ckx.ciphertext[1:])
        if x == nil </span><span class="cov0" title="0">{
                return nil, errClientKeyExchange
        }</span>
        <span class="cov8" title="1">x, _ = ka.curve.ScalarMult(x, y, ka.privateKey)
        preMasterSecret := make([]byte, (ka.curve.Params().BitSize+7)&gt;&gt;3)
        xBytes := x.Bytes()
        copy(preMasterSecret[len(preMasterSecret)-len(xBytes):], xBytes)

        return preMasterSecret, nil</span>
}

func (ka *ecdheKeyAgreement) processServerKeyExchange(config *Config, clientHello *clientHelloMsg, serverHello *serverHelloMsg, cert *x509.Certificate, skx *serverKeyExchangeMsg) error <span class="cov8" title="1">{
        if len(skx.key) &lt; 4 </span><span class="cov0" title="0">{
                return errServerKeyExchange
        }</span>
        <span class="cov8" title="1">if skx.key[0] != 3 </span><span class="cov0" title="0">{ // named curve
                return errors.New("tls: server selected unsupported curve")
        }</span>
        <span class="cov8" title="1">curveid := CurveID(skx.key[1])&lt;&lt;8 | CurveID(skx.key[2])

        var ok bool
        if ka.curve, ok = curveForCurveID(curveid); !ok </span><span class="cov0" title="0">{
                return errors.New("tls: server selected unsupported curve")
        }</span>

        <span class="cov8" title="1">publicLen := int(skx.key[3])
        if publicLen+4 &gt; len(skx.key) </span><span class="cov0" title="0">{
                return errServerKeyExchange
        }</span>
        <span class="cov8" title="1">ka.x, ka.y = elliptic.Unmarshal(ka.curve, skx.key[4:4+publicLen])
        if ka.x == nil </span><span class="cov0" title="0">{
                return errServerKeyExchange
        }</span>
        <span class="cov8" title="1">serverECDHParams := skx.key[:4+publicLen]

        sig := skx.key[4+publicLen:]
        if len(sig) &lt; 2 </span><span class="cov0" title="0">{
                return errServerKeyExchange
        }</span>

        <span class="cov8" title="1">var tls12HashId uint8
        if ka.version &gt;= VersionTLS12 </span><span class="cov8" title="1">{
                // handle SignatureAndHashAlgorithm
                var sigAndHash []uint8
                sigAndHash, sig = sig[:2], sig[2:]
                if sigAndHash[1] != ka.sigType </span><span class="cov0" title="0">{
                        return errServerKeyExchange
                }</span>
                <span class="cov8" title="1">tls12HashId = sigAndHash[0]
                if len(sig) &lt; 2 </span><span class="cov0" title="0">{
                        return errServerKeyExchange
                }</span>
        }
        <span class="cov8" title="1">sigLen := int(sig[0])&lt;&lt;8 | int(sig[1])
        if sigLen+2 != len(sig) </span><span class="cov0" title="0">{
                return errServerKeyExchange
        }</span>
        <span class="cov8" title="1">sig = sig[2:]

        digest, hashFunc, err := hashForServerKeyExchange(ka.sigType, tls12HashId, ka.version, clientHello.random, serverHello.random, serverECDHParams)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">switch ka.sigType </span>{
        case signatureECDSA:<span class="cov8" title="1">
                pubKey, ok := cert.PublicKey.(*ecdsa.PublicKey)
                if !ok </span><span class="cov0" title="0">{
                        return errors.New("ECDHE ECDSA requires a ECDSA server public key")
                }</span>
                <span class="cov8" title="1">ecdsaSig := new(ecdsaSignature)
                if _, err := asn1.Unmarshal(sig, ecdsaSig); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if ecdsaSig.R.Sign() &lt;= 0 || ecdsaSig.S.Sign() &lt;= 0 </span><span class="cov0" title="0">{
                        return errors.New("ECDSA signature contained zero or negative values")
                }</span>
                <span class="cov8" title="1">if !ecdsa.Verify(pubKey, digest, ecdsaSig.R, ecdsaSig.S) </span><span class="cov0" title="0">{
                        return errors.New("ECDSA verification failure")
                }</span>
        case signatureRSA:<span class="cov8" title="1">
                pubKey, ok := cert.PublicKey.(*rsa.PublicKey)
                if !ok </span><span class="cov0" title="0">{
                        return errors.New("ECDHE RSA requires a RSA server public key")
                }</span>
                <span class="cov8" title="1">if err := rsa.VerifyPKCS1v15(pubKey, hashFunc, digest, sig); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        default:<span class="cov0" title="0">
                return errors.New("unknown ECDHE signature algorithm")</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (ka *ecdheKeyAgreement) generateClientKeyExchange(config *Config, clientHello *clientHelloMsg, cert *x509.Certificate) ([]byte, *clientKeyExchangeMsg, error) <span class="cov8" title="1">{
        if ka.curve == nil </span><span class="cov0" title="0">{
                return nil, nil, errors.New("missing ServerKeyExchange message")
        }</span>
        <span class="cov8" title="1">priv, mx, my, err := elliptic.GenerateKey(ka.curve, config.rand())
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov8" title="1">x, _ := ka.curve.ScalarMult(ka.x, ka.y, priv)
        preMasterSecret := make([]byte, (ka.curve.Params().BitSize+7)&gt;&gt;3)
        xBytes := x.Bytes()
        copy(preMasterSecret[len(preMasterSecret)-len(xBytes):], xBytes)

        serialized := elliptic.Marshal(ka.curve, mx, my)

        ckx := new(clientKeyExchangeMsg)
        ckx.ciphertext = make([]byte, 1+len(serialized))
        ckx.ciphertext[0] = byte(len(serialized))
        copy(ckx.ciphertext[1:], serialized)

        return preMasterSecret, ckx, nil</span>
}
</pre>
		
		<pre class="file" id="file260" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package bfe_tls

import (
        "crypto"
        "crypto/hmac"
        "crypto/md5"
        "crypto/sha1"
        "crypto/sha256"
        "hash"
)

// Split a premaster secret in two as specified in RFC 4346, section 5.
func splitPreMasterSecret(secret []byte) (s1, s2 []byte) <span class="cov8" title="1">{
        s1 = secret[0 : (len(secret)+1)/2]
        s2 = secret[len(secret)/2:]
        return
}</span>

// pHash implements the P_hash function, as defined in RFC 4346, section 5.
func pHash(result, secret, seed []byte, hash func() hash.Hash) <span class="cov8" title="1">{
        h := hmac.New(hash, secret)
        h.Write(seed)
        a := h.Sum(nil)

        j := 0
        for j &lt; len(result) </span><span class="cov8" title="1">{
                h.Reset()
                h.Write(a)
                h.Write(seed)
                b := h.Sum(nil)
                todo := len(b)
                if j+todo &gt; len(result) </span><span class="cov8" title="1">{
                        todo = len(result) - j
                }</span>
                <span class="cov8" title="1">copy(result[j:j+todo], b)
                j += todo

                h.Reset()
                h.Write(a)
                a = h.Sum(nil)</span>
        }
}

// prf10 implements the TLS 1.0 pseudo-random function, as defined in RFC 2246, section 5.
func prf10(result, secret, label, seed []byte) <span class="cov8" title="1">{
        hashSHA1 := sha1.New
        hashMD5 := md5.New

        labelAndSeed := make([]byte, len(label)+len(seed))
        copy(labelAndSeed, label)
        copy(labelAndSeed[len(label):], seed)

        s1, s2 := splitPreMasterSecret(secret)
        pHash(result, s1, labelAndSeed, hashMD5)
        result2 := make([]byte, len(result))
        pHash(result2, s2, labelAndSeed, hashSHA1)

        for i, b := range result2 </span><span class="cov8" title="1">{
                result[i] ^= b
        }</span>
}

// prf12 implements the TLS 1.2 pseudo-random function, as defined in RFC 5246, section 5.
func prf12(result, secret, label, seed []byte) <span class="cov8" title="1">{
        labelAndSeed := make([]byte, len(label)+len(seed))
        copy(labelAndSeed, label)
        copy(labelAndSeed[len(label):], seed)

        pHash(result, secret, labelAndSeed, sha256.New)
}</span>

// prf30 implements the SSL 3.0 pseudo-random function, as defined in
// www.mozilla.org/projects/security/pki/nss/ssl/draft302.txt section 6.
func prf30(result, secret, label, seed []byte) <span class="cov8" title="1">{
        hashSHA1 := sha1.New()
        hashMD5 := md5.New()

        done := 0
        i := 0
        // RFC5246 section 6.3 says that the largest PRF output needed is 128
        // bytes. Since no more cipher-suites will be added to SSLv3, this will
        // remain true. Each iteration gives us 16 bytes so 10 iterations will
        // be sufficient.
        var b [11]byte
        for done &lt; len(result) </span><span class="cov8" title="1">{
                for j := 0; j &lt;= i; j++ </span><span class="cov8" title="1">{
                        b[j] = 'A' + byte(i)
                }</span>

                <span class="cov8" title="1">hashSHA1.Reset()
                hashSHA1.Write(b[:i+1])
                hashSHA1.Write(secret)
                hashSHA1.Write(seed)
                digest := hashSHA1.Sum(nil)

                hashMD5.Reset()
                hashMD5.Write(secret)
                hashMD5.Write(digest)

                done += copy(result[done:], hashMD5.Sum(nil))
                i++</span>
        }
}

const (
        tlsRandomLength      = 32 // Length of a random nonce in TLS 1.1.
        masterSecretLength   = 48 // Length of a master secret in TLS 1.1.
        finishedVerifyLength = 12 // Length of verify_data in a Finished message.
)

var masterSecretLabel = []byte("master secret")
var keyExpansionLabel = []byte("key expansion")
var clientFinishedLabel = []byte("client finished")
var serverFinishedLabel = []byte("server finished")

func prfForVersion(version uint16) func(result, secret, label, seed []byte) <span class="cov8" title="1">{
        switch version </span>{
        case VersionSSL30:<span class="cov8" title="1">
                return prf30</span>
        case VersionTLS10, VersionTLS11:<span class="cov8" title="1">
                return prf10</span>
        case VersionTLS12:<span class="cov8" title="1">
                return prf12</span>
        default:<span class="cov0" title="0">
                panic("unknown version")</span>
        }
}

// masterFromPreMasterSecret generates the master secret from the pre-master
// secret. See http://tools.ietf.org/html/rfc5246#section-8.1
func masterFromPreMasterSecret(version uint16, preMasterSecret, clientRandom, serverRandom []byte) []byte <span class="cov8" title="1">{
        var seed [tlsRandomLength * 2]byte
        copy(seed[0:len(clientRandom)], clientRandom)
        copy(seed[len(clientRandom):], serverRandom)
        masterSecret := make([]byte, masterSecretLength)
        prfForVersion(version)(masterSecret, preMasterSecret, masterSecretLabel, seed[0:])
        return masterSecret
}</span>

// keysFromMasterSecret generates the connection keys from the master
// secret, given the lengths of the MAC key, cipher key and IV, as defined in
// RFC 2246, section 6.3.
func keysFromMasterSecret(version uint16, masterSecret, clientRandom, serverRandom []byte, macLen, keyLen, ivLen int) (clientMAC, serverMAC, clientKey, serverKey, clientIV, serverIV []byte) <span class="cov8" title="1">{
        var seed [tlsRandomLength * 2]byte
        copy(seed[0:len(clientRandom)], serverRandom)
        copy(seed[len(serverRandom):], clientRandom)

        n := 2*macLen + 2*keyLen + 2*ivLen
        keyMaterial := make([]byte, n)
        prfForVersion(version)(keyMaterial, masterSecret, keyExpansionLabel, seed[0:])
        clientMAC = keyMaterial[:macLen]
        keyMaterial = keyMaterial[macLen:]
        serverMAC = keyMaterial[:macLen]
        keyMaterial = keyMaterial[macLen:]
        clientKey = keyMaterial[:keyLen]
        keyMaterial = keyMaterial[keyLen:]
        serverKey = keyMaterial[:keyLen]
        keyMaterial = keyMaterial[keyLen:]
        clientIV = keyMaterial[:ivLen]
        keyMaterial = keyMaterial[ivLen:]
        serverIV = keyMaterial[:ivLen]
        return
}</span>

func newFinishedHash(version uint16) finishedHash <span class="cov8" title="1">{
        if version &gt;= VersionTLS12 </span><span class="cov8" title="1">{
                return finishedHash{sha256.New(), sha256.New(), nil, nil, version}
        }</span>
        <span class="cov8" title="1">return finishedHash{sha1.New(), sha1.New(), md5.New(), md5.New(), version}</span>
}

// A finishedHash calculates the hash of a set of handshake messages suitable
// for including in a Finished message.
type finishedHash struct {
        client hash.Hash
        server hash.Hash

        // Prior to TLS 1.2, an additional MD5 hash is required.
        clientMD5 hash.Hash
        serverMD5 hash.Hash

        version uint16
}

func (h finishedHash) Write(msg []byte) (n int, err error) <span class="cov8" title="1">{
        h.client.Write(msg)
        h.server.Write(msg)

        if h.version &lt; VersionTLS12 </span><span class="cov8" title="1">{
                h.clientMD5.Write(msg)
                h.serverMD5.Write(msg)
        }</span>
        <span class="cov8" title="1">return len(msg), nil</span>
}

// finishedSum30 calculates the contents of the verify_data member of a SSLv3
// Finished message given the MD5 and SHA1 hashes of a set of handshake
// messages.
func finishedSum30(md5, sha1 hash.Hash, masterSecret []byte, magic [4]byte) []byte <span class="cov8" title="1">{
        md5.Write(magic[:])
        md5.Write(masterSecret)
        md5.Write(ssl30Pad1[:])
        md5Digest := md5.Sum(nil)

        md5.Reset()
        md5.Write(masterSecret)
        md5.Write(ssl30Pad2[:])
        md5.Write(md5Digest)
        md5Digest = md5.Sum(nil)

        sha1.Write(magic[:])
        sha1.Write(masterSecret)
        sha1.Write(ssl30Pad1[:40])
        sha1Digest := sha1.Sum(nil)

        sha1.Reset()
        sha1.Write(masterSecret)
        sha1.Write(ssl30Pad2[:40])
        sha1.Write(sha1Digest)
        sha1Digest = sha1.Sum(nil)

        ret := make([]byte, len(md5Digest)+len(sha1Digest))
        copy(ret, md5Digest)
        copy(ret[len(md5Digest):], sha1Digest)
        return ret
}</span>

var ssl3ClientFinishedMagic = [4]byte{0x43, 0x4c, 0x4e, 0x54}
var ssl3ServerFinishedMagic = [4]byte{0x53, 0x52, 0x56, 0x52}

// clientSum returns the contents of the verify_data member of a client's
// Finished message.
func (h finishedHash) clientSum(masterSecret []byte) []byte <span class="cov8" title="1">{
        if h.version == VersionSSL30 </span><span class="cov8" title="1">{
                return finishedSum30(h.clientMD5, h.client, masterSecret, ssl3ClientFinishedMagic)
        }</span>

        <span class="cov8" title="1">out := make([]byte, finishedVerifyLength)
        if h.version &gt;= VersionTLS12 </span><span class="cov8" title="1">{
                seed := h.client.Sum(nil)
                prf12(out, masterSecret, clientFinishedLabel, seed)
        }</span> else<span class="cov8" title="1"> {
                seed := make([]byte, 0, md5.Size+sha1.Size)
                seed = h.clientMD5.Sum(seed)
                seed = h.client.Sum(seed)
                prf10(out, masterSecret, clientFinishedLabel, seed)
        }</span>
        <span class="cov8" title="1">return out</span>
}

// serverSum returns the contents of the verify_data member of a server's
// Finished message.
func (h finishedHash) serverSum(masterSecret []byte) []byte <span class="cov8" title="1">{
        if h.version == VersionSSL30 </span><span class="cov8" title="1">{
                return finishedSum30(h.serverMD5, h.server, masterSecret, ssl3ServerFinishedMagic)
        }</span>

        <span class="cov8" title="1">out := make([]byte, finishedVerifyLength)
        if h.version &gt;= VersionTLS12 </span><span class="cov8" title="1">{
                seed := h.server.Sum(nil)
                prf12(out, masterSecret, serverFinishedLabel, seed)
        }</span> else<span class="cov8" title="1"> {
                seed := make([]byte, 0, md5.Size+sha1.Size)
                seed = h.serverMD5.Sum(seed)
                seed = h.server.Sum(seed)
                prf10(out, masterSecret, serverFinishedLabel, seed)
        }</span>
        <span class="cov8" title="1">return out</span>
}

// hashForClientCertificate returns a digest, hash function, and TLS 1.2 hash
// id suitable for signing by a TLS client certificate.
func (h finishedHash) hashForClientCertificate(sigType uint8) ([]byte, crypto.Hash, uint8) <span class="cov8" title="1">{
        if h.version &gt;= VersionTLS12 </span><span class="cov8" title="1">{
                digest := h.server.Sum(nil)
                return digest, crypto.SHA256, hashSHA256
        }</span>
        <span class="cov8" title="1">if sigType == signatureECDSA </span><span class="cov8" title="1">{
                digest := h.server.Sum(nil)
                return digest, crypto.SHA1, hashSHA1
        }</span>

        <span class="cov8" title="1">digest := make([]byte, 0, 36)
        digest = h.serverMD5.Sum(digest)
        digest = h.server.Sum(digest)
        return digest, crypto.MD5SHA1, 0</span> /* not specified in TLS 1.2. */
}
</pre>
		
		<pre class="file" id="file261" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package bfe_tls

import (
        "github.com/baidu/go-lib/web-monitor/metrics"
)

type TlsState struct {
        TlsHandshakeReadClientHelloErr        *metrics.Counter
        TlsHandshakeFullAll                   *metrics.Counter
        TlsHandshakeFullSucc                  *metrics.Counter
        TlsHandshakeResumeAll                 *metrics.Counter
        TlsHandshakeResumeSucc                *metrics.Counter
        TlsHandshakeCheckResumeSessionTicket  *metrics.Counter
        TlsHandshakeShouldResumeSessionTicket *metrics.Counter
        TlsHandshakeCheckResumeSessionCache   *metrics.Counter
        TlsHandshakeShouldResumeSessionCache  *metrics.Counter
        TlsHandshakeAcceptSslv2ClientHello    *metrics.Counter
        TlsHandshakeAcceptEcdheWithoutExt     *metrics.Counter
        TlsHandshakeNoSharedCipherSuite       *metrics.Counter
        TlsHandshakeSslv2NotSupport           *metrics.Counter
        TlsHandshakeOcspTimeErr               *metrics.Counter
        TlsStatusRequestExtCount              *metrics.Counter
        TlsHandshakeZeroData                  *metrics.Counter
}

var state TlsState

func GetTlsState() *TlsState <span class="cov0" title="0">{
        return &amp;state
}</span>
</pre>
		
		<pre class="file" id="file262" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Copyright 2012 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package bfe_tls

import (
        "bytes"
        "crypto/aes"
        "crypto/cipher"
        "crypto/hmac"
        "crypto/sha256"
        "crypto/subtle"
        "errors"
        "io"
)

var sessionIdCtx = []byte("HTTP")

// sessionState contains the information that is serialized into a session
// ticket in order to later resume a connection.
type sessionState struct {
        vers         uint16
        cipherSuite  uint16
        masterSecret []byte
        certificates [][]byte

        // Note: SessionId will not be serialized if ticket format is TicketFormatRaw
        sessionId []byte // session id
}

func (s *sessionState) equal(i interface{}) bool <span class="cov8" title="1">{
        s1, ok := i.(*sessionState)
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">if s.vers != s1.vers ||
                s.cipherSuite != s1.cipherSuite ||
                !bytes.Equal(s.masterSecret, s1.masterSecret) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">if len(s.certificates) != len(s1.certificates) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">for i := range s.certificates </span><span class="cov8" title="1">{
                if !bytes.Equal(s.certificates[i], s1.certificates[i]) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return true</span>
}

func (s *sessionState) marshal() []byte <span class="cov8" title="1">{
        length := 2 + 2 + 2 + len(s.masterSecret) + 2
        for _, cert := range s.certificates </span><span class="cov8" title="1">{
                length += 4 + len(cert)
        }</span>

        <span class="cov8" title="1">ret := make([]byte, length)
        x := ret
        x[0] = byte(s.vers &gt;&gt; 8)
        x[1] = byte(s.vers)
        x[2] = byte(s.cipherSuite &gt;&gt; 8)
        x[3] = byte(s.cipherSuite)
        x[4] = byte(len(s.masterSecret) &gt;&gt; 8)
        x[5] = byte(len(s.masterSecret))
        x = x[6:]
        copy(x, s.masterSecret)
        x = x[len(s.masterSecret):]

        x[0] = byte(len(s.certificates) &gt;&gt; 8)
        x[1] = byte(len(s.certificates))
        x = x[2:]

        for _, cert := range s.certificates </span><span class="cov8" title="1">{
                x[0] = byte(len(cert) &gt;&gt; 24)
                x[1] = byte(len(cert) &gt;&gt; 16)
                x[2] = byte(len(cert) &gt;&gt; 8)
                x[3] = byte(len(cert))
                copy(x[4:], cert)
                x = x[4+len(cert):]
        }</span>

        <span class="cov8" title="1">return ret</span>
}

func (s *sessionState) unmarshal(data []byte) bool <span class="cov8" title="1">{
        if len(data) &lt; 8 </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">s.vers = uint16(data[0])&lt;&lt;8 | uint16(data[1])
        s.cipherSuite = uint16(data[2])&lt;&lt;8 | uint16(data[3])
        masterSecretLen := int(data[4])&lt;&lt;8 | int(data[5])
        data = data[6:]
        if len(data) &lt; masterSecretLen </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">s.masterSecret = data[:masterSecretLen]
        data = data[masterSecretLen:]

        if len(data) &lt; 2 </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">numCerts := int(data[0])&lt;&lt;8 | int(data[1])
        data = data[2:]

        s.certificates = make([][]byte, numCerts)
        for i := range s.certificates </span><span class="cov8" title="1">{
                if len(data) &lt; 4 </span><span class="cov8" title="1">{
                        return false
                }</span>
                <span class="cov8" title="1">certLen := int(data[0])&lt;&lt;24 | int(data[1])&lt;&lt;16 | int(data[2])&lt;&lt;8 | int(data[3])
                data = data[4:]
                if certLen &lt; 0 </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov8" title="1">if len(data) &lt; certLen </span><span class="cov8" title="1">{
                        return false
                }</span>
                <span class="cov8" title="1">s.certificates[i] = data[:certLen]
                data = data[certLen:]</span>
        }

        <span class="cov8" title="1">return len(data) &lt;= 0</span>
}

func (c *Conn) encryptTicket(state *sessionState) ([]byte, error) <span class="cov8" title="1">{
        serialized := state.marshal()
        encrypted := make([]byte, aes.BlockSize+len(serialized)+sha256.Size)
        iv := encrypted[:aes.BlockSize]
        macBytes := encrypted[len(encrypted)-sha256.Size:]

        if _, err := io.ReadFull(c.config.rand(), iv); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">block, err := aes.NewCipher(c.config.SessionTicketKey[:16])
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("tls: failed to create cipher while encrypting ticket: " + err.Error())
        }</span>
        <span class="cov8" title="1">cipher.NewCTR(block, iv).XORKeyStream(encrypted[aes.BlockSize:], serialized)

        mac := hmac.New(sha256.New, c.config.SessionTicketKey[16:32])
        mac.Write(encrypted[:len(encrypted)-sha256.Size])
        mac.Sum(macBytes[:0])

        return encrypted, nil</span>
}

func (c *Conn) decryptTicket(encrypted []byte) (*sessionState, bool) <span class="cov8" title="1">{
        if len(encrypted) &lt; aes.BlockSize+sha256.Size </span><span class="cov0" title="0">{
                return nil, false
        }</span>

        <span class="cov8" title="1">iv := encrypted[:aes.BlockSize]
        macBytes := encrypted[len(encrypted)-sha256.Size:]

        mac := hmac.New(sha256.New, c.config.SessionTicketKey[16:32])
        mac.Write(encrypted[:len(encrypted)-sha256.Size])
        expected := mac.Sum(nil)

        if subtle.ConstantTimeCompare(macBytes, expected) != 1 </span><span class="cov8" title="1">{
                return nil, false
        }</span>

        <span class="cov8" title="1">block, err := aes.NewCipher(c.config.SessionTicketKey[:16])
        if err != nil </span><span class="cov0" title="0">{
                return nil, false
        }</span>

        <span class="cov8" title="1">ciphertext := encrypted[aes.BlockSize : len(encrypted)-sha256.Size]
        plaintext := ciphertext
        cipher.NewCTR(block, iv).XORKeyStream(plaintext, ciphertext)

        state := new(sessionState)
        ok := state.unmarshal(plaintext)
        return state, ok</span>
}

func PKCS5Padding(ciphertext []byte, blockSize int) []byte <span class="cov0" title="0">{
        padding := blockSize - len(ciphertext)%blockSize
        padtext := bytes.Repeat([]byte{byte(padding)}, padding)
        return append(ciphertext, padtext...)
}</span>
</pre>
		
		<pre class="file" id="file263" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Package bfe_tls partially implements TLS 1.2, as specified in RFC 5246.
package bfe_tls

import (
        "crypto"
        "crypto/ecdsa"
        "crypto/rsa"
        "crypto/x509"
        "encoding/pem"
        "errors"
        "io/ioutil"
        "net"
        "strings"
        "sync"
        "time"
)

// Server returns a new TLS server side connection
// using conn as the underlying transport.
// The configuration config must be non-nil and must have
// at least one certificate.
func Server(conn net.Conn, config *Config) *Conn <span class="cov8" title="1">{
        return &amp;Conn{conn: conn, config: config}
}</span>

// Client returns a new TLS client side connection
// using conn as the underlying transport.
// The config cannot be nil: users must set either ServerName or
// InsecureSkipVerify in the config.
func Client(conn net.Conn, config *Config) *Conn <span class="cov8" title="1">{
        return &amp;Conn{conn: conn, config: config, isClient: true}
}</span>

// A listener implements a network listener (net.Listener) for TLS connections.
type listener struct {
        net.Listener
        config *Config
        lock   sync.RWMutex // lock for config
}

// Accept waits for and returns the next incoming TLS connection.
// The returned connection c is a *tls.Conn.
func (l *listener) Accept() (c net.Conn, err error) <span class="cov0" title="0">{
        c, err = l.Listener.Accept()
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">l.lock.RLock()
        c = Server(c, l.config)
        l.lock.RUnlock()
        return</span>
}

// NewListener creates a Listener which accepts connections from an inner
// Listener and wraps each connection with Server.
// The configuration config must be non-nil and must have
// at least one certificate.
func NewListener(inner net.Listener, config *Config) net.Listener <span class="cov0" title="0">{
        l := new(listener)
        l.Listener = inner
        l.config = config
        return l
}</span>

// UpdateListener updates config for tls listener
/*
 * Params:
 *     - ln  : a tls listener
 *     - conf: a tls config
 *
 * Return:
 *     - error
 *
 * Note:
 *     1. tls.listener will not modify tls.Config and just pass it
 * to accepted Connection.
 *     2. tls.Conn will just read tls.Config during handshake and
 * data transfer phase
 *     3. MUST specify a new tls.config when called
 */
func UpdateListener(ln net.Listener, conf *Config) error <span class="cov0" title="0">{
        l, ok := ln.(*listener)
        if !ok </span><span class="cov0" title="0">{
                return errors.New("tls.UpdateListener: type not tls.listener")
        }</span>

        <span class="cov0" title="0">l.lock.Lock()
        defer l.lock.Unlock()

        if l.config == conf </span><span class="cov0" title="0">{
                return errors.New("tls.UpdateListener: not safe to modify config in use")
        }</span>

        <span class="cov0" title="0">l.config = conf
        return nil</span>
}

// Listen creates a TLS listener accepting connections on the
// given network address using net.Listen.
// The configuration config must be non-nil and must have
// at least one certificate.
func Listen(network, laddr string, config *Config) (net.Listener, error) <span class="cov0" title="0">{
        if config == nil || len(config.Certificates) == 0 </span><span class="cov0" title="0">{
                return nil, errors.New("tls.Listen: no certificates in configuration")
        }</span>
        <span class="cov0" title="0">l, err := net.Listen(network, laddr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return NewListener(l, config), nil</span>
}

type timeoutError struct{}

func (timeoutError) Error() string   <span class="cov0" title="0">{ return "tls: DialWithDialer timed out" }</span>
func (timeoutError) Timeout() bool   <span class="cov8" title="1">{ return true }</span>
func (timeoutError) Temporary() bool <span class="cov0" title="0">{ return true }</span>

// DialWithDialer connects to the given network address using dialer.Dial and
// then initiates a TLS handshake, returning the resulting TLS connection. Any
// timeout or deadline given in the dialer apply to connection and TLS
// handshake as a whole.
//
// DialWithDialer interprets a nil configuration as equivalent to the zero
// configuration; see the documentation of Config for the defaults.
func DialWithDialer(dialer *net.Dialer, network, addr string, config *Config) (*Conn, error) <span class="cov8" title="1">{
        // We want the Timeout and Deadline values from dialer to cover the
        // whole process: TCP connection and TLS handshake. This means that we
        // also need to start our own timers now.
        timeout := dialer.Timeout

        if !dialer.Deadline.IsZero() </span><span class="cov0" title="0">{
                deadlineTimeout := dialer.Deadline.Sub(time.Now())
                if timeout == 0 || deadlineTimeout &lt; timeout </span><span class="cov0" title="0">{
                        timeout = deadlineTimeout
                }</span>
        }

        <span class="cov8" title="1">var errChannel chan error

        if timeout != 0 </span><span class="cov8" title="1">{
                errChannel = make(chan error, 2)
                time.AfterFunc(timeout, func() </span><span class="cov8" title="1">{
                        errChannel &lt;- timeoutError{}
                }</span>)
        }

        <span class="cov8" title="1">rawConn, err := dialer.Dial(network, addr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">colonPos := strings.LastIndex(addr, ":")
        if colonPos == -1 </span><span class="cov0" title="0">{
                colonPos = len(addr)
        }</span>
        <span class="cov8" title="1">hostname := addr[:colonPos]

        if config == nil </span><span class="cov8" title="1">{
                config = defaultConfig()
        }</span>
        // If no ServerName is set, infer the ServerName
        // from the hostname we're connecting to.
        <span class="cov8" title="1">if config.ServerName == "" </span><span class="cov8" title="1">{
                // Make a copy to avoid polluting argument or default.
                c := config.Clone()
                c.ServerName = hostname
                config = c
        }</span>

        <span class="cov8" title="1">conn := Client(rawConn, config)

        if timeout == 0 </span><span class="cov8" title="1">{
                err = conn.Handshake()
        }</span> else<span class="cov8" title="1"> {
                go func() </span><span class="cov8" title="1">{
                        errChannel &lt;- conn.Handshake()
                }</span>()

                <span class="cov8" title="1">err = &lt;-errChannel</span>
        }

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                rawConn.Close()
                return nil, err
        }</span>

        <span class="cov8" title="1">return conn, nil</span>
}

// Dial connects to the given network address using net.Dial
// and then initiates a TLS handshake, returning the resulting
// TLS connection.
// Dial interprets a nil configuration as equivalent to
// the zero configuration; see the documentation of Config
// for the defaults.
func Dial(network, addr string, config *Config) (*Conn, error) <span class="cov8" title="1">{
        return DialWithDialer(new(net.Dialer), network, addr, config)
}</span>

// LoadX509KeyPair reads and parses a public/private key pair from a pair of
// files. The files must contain PEM encoded data.
func LoadX509KeyPair(certFile, keyFile string) (cert Certificate, err error) <span class="cov0" title="0">{
        // try third party loader
        if keyPairLoader != nil </span><span class="cov0" title="0">{
                return keyPairLoader.LoadX509KeyPair(certFile, keyFile)
        }</span>

        <span class="cov0" title="0">certPEMBlock, err := ioutil.ReadFile(certFile)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">keyPEMBlock, err := ioutil.ReadFile(keyFile)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">return X509KeyPair(certPEMBlock, keyPEMBlock)</span>
}

// X509KeyPair parses a public/private key pair from a pair of
// PEM encoded data.
func X509KeyPair(certPEMBlock, keyPEMBlock []byte) (cert Certificate, err error) <span class="cov8" title="1">{
        var certDERBlock *pem.Block
        for </span><span class="cov8" title="1">{
                certDERBlock, certPEMBlock = pem.Decode(certPEMBlock)
                if certDERBlock == nil </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">if certDERBlock.Type == "CERTIFICATE" </span><span class="cov8" title="1">{
                        cert.Certificate = append(cert.Certificate, certDERBlock.Bytes)
                }</span>
        }

        <span class="cov8" title="1">if len(cert.Certificate) == 0 </span><span class="cov0" title="0">{
                err = errors.New("crypto/tls: failed to parse certificate PEM data")
                return
        }</span>
        <span class="cov8" title="1">cert.buildCertMsg() // prebuild cert message for tls handshake

        var keyDERBlock *pem.Block
        for </span><span class="cov8" title="1">{
                keyDERBlock, keyPEMBlock = pem.Decode(keyPEMBlock)
                if keyDERBlock == nil </span><span class="cov0" title="0">{
                        err = errors.New("crypto/tls: failed to parse key PEM data")
                        return
                }</span>
                <span class="cov8" title="1">if keyDERBlock.Type == "PRIVATE KEY" || strings.HasSuffix(keyDERBlock.Type, " PRIVATE KEY") </span><span class="cov8" title="1">{
                        break</span>
                }
        }

        <span class="cov8" title="1">cert.PrivateKey, err = parsePrivateKey(keyDERBlock.Bytes)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        // We don't need to parse the public key for TLS, but we so do anyway
        // to check that it looks sane and matches the private key.
        <span class="cov8" title="1">x509Cert, err := x509.ParseCertificate(cert.Certificate[0])
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">switch pub := x509Cert.PublicKey.(type) </span>{
        case *rsa.PublicKey:<span class="cov8" title="1">
                priv, ok := cert.PrivateKey.(*rsa.PrivateKey)
                if !ok </span><span class="cov8" title="1">{
                        err = errors.New("crypto/tls: private key type does not match public key type")
                        return
                }</span>
                <span class="cov8" title="1">if pub.N.Cmp(priv.N) != 0 </span><span class="cov0" title="0">{
                        err = errors.New("crypto/tls: private key does not match public key")
                        return
                }</span>
        case *ecdsa.PublicKey:<span class="cov8" title="1">
                priv, ok := cert.PrivateKey.(*ecdsa.PrivateKey)
                if !ok </span><span class="cov8" title="1">{
                        err = errors.New("crypto/tls: private key type does not match public key type")
                        return
                }</span>
                <span class="cov8" title="1">if pub.X.Cmp(priv.X) != 0 || pub.Y.Cmp(priv.Y) != 0 </span><span class="cov0" title="0">{
                        err = errors.New("crypto/tls: private key does not match public key")
                        return
                }</span>
        default:<span class="cov0" title="0">
                err = errors.New("crypto/tls: unknown public key algorithm")
                return</span>
        }

        <span class="cov8" title="1">return</span>
}

// Attempt to parse the given private key DER block. OpenSSL 0.9.8 generates
// PKCS#1 private keys by default, while OpenSSL 1.0.0 generates PKCS#8 keys.
// OpenSSL ecparam generates SEC1 EC private keys for ECDSA. We try all three.
func parsePrivateKey(der []byte) (crypto.PrivateKey, error) <span class="cov8" title="1">{
        if key, err := x509.ParsePKCS1PrivateKey(der); err == nil </span><span class="cov8" title="1">{
                return key, nil
        }</span>
        <span class="cov8" title="1">if key, err := x509.ParsePKCS8PrivateKey(der); err == nil </span><span class="cov0" title="0">{
                switch key := key.(type) </span>{
                case *rsa.PrivateKey, *ecdsa.PrivateKey:<span class="cov0" title="0">
                        return key, nil</span>
                default:<span class="cov0" title="0">
                        return nil, errors.New("crypto/tls: found unknown private key type in PKCS#8 wrapping")</span>
                }
        }
        <span class="cov8" title="1">if key, err := x509.ParseECPrivateKey(der); err == nil </span><span class="cov8" title="1">{
                return key, nil
        }</span>

        <span class="cov0" title="0">return nil, errors.New("crypto/tls: failed to parse private key")</span>
}
</pre>
		
		<pre class="file" id="file264" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package access_log

import (
        "fmt"
        "os"
        "path/filepath"
        "strings"

        "github.com/bfenetworks/bfe/bfe_util"
)

import (
        "github.com/baidu/go-lib/log/log4go"
)

type LogConfig struct {
        // Log directly to a single file (eg. /dev/stdout)
        LogFile string // log file path

        // Log with rotation under specified directory
        LogPrefix   string // log file prefix
        LogDir      string // log file dir
        RotateWhen  string // rotate time
        BackupCount int    // log file backup number
}

func (cfg *LogConfig) Check(confRoot string) error <span class="cov8" title="1">{
        if cfg.LogFile != "" </span><span class="cov8" title="1">{
                if cfg.LogPrefix != "" || cfg.LogDir != "" || cfg.RotateWhen != "" || cfg.BackupCount &gt; 0 </span><span class="cov8" title="1">{
                        return fmt.Errorf(`ModAccess.LogPrefix, ModAccess.LogDir, ModAccess.RotateWhen and ModAccess.BackupCount cannot be set when ModAccess.LogFile is set`)
                }</span>
                <span class="cov8" title="1">cfg.LogFile = bfe_util.ConfPathProc(cfg.LogFile, confRoot)</span>
        } else<span class="cov0" title="0"> {
                if cfg.LogPrefix == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("ModAccess.LogPrefix is empty")
                }</span>

                <span class="cov0" title="0">if cfg.LogDir == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("ModAccess.LogDir is empty")
                }</span>
                <span class="cov0" title="0">cfg.LogDir = bfe_util.ConfPathProc(cfg.LogDir, confRoot)

                if !log4go.WhenIsValid(cfg.RotateWhen) </span><span class="cov0" title="0">{
                        return fmt.Errorf("ModAccess.RotateWhen invalid: %s", cfg.RotateWhen)
                }</span>

                <span class="cov0" title="0">if cfg.BackupCount &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("ModAccess.BackupCount should &gt; 0: %d", cfg.BackupCount)
                }</span>

        }
        <span class="cov8" title="1">return nil</span>
}

// logDirCreate check and create dir if nonexist
func logDirCreate(logDir string) error <span class="cov0" title="0">{
        if _, err := os.Stat(logDir); os.IsNotExist(err) </span><span class="cov0" title="0">{
                err = os.MkdirAll(logDir, 0777)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// prefix2Name generate fileName from prefix
func prefix2Name(prefix string) string <span class="cov0" title="0">{
        return prefix + ".log"
}</span>

// LoggerInit initialize logger. Log file name is prefix.log
func LoggerInit(c LogConfig) (log4go.Logger, error) <span class="cov8" title="1">{
        if c.LogFile != "" </span><span class="cov8" title="1">{
                accessDefaultFormat := "%M"
                return loggerInitWithFilePath(c.LogFile, accessDefaultFormat)
        }</span> else<span class="cov0" title="0"> {
                fileName := prefix2Name(c.LogPrefix)
                return LoggerInit2(fileName, c.LogDir, c.RotateWhen, c.BackupCount)
        }</span>
}

// LoggerInit2 initialize logger. Log file name is fileName
func LoggerInit2(fileName, logDir, when string, backupCount int) (log4go.Logger, error) <span class="cov0" title="0">{
        accessDefaultFormat := "%M"
        return LoggerInitWithFormat2(fileName, logDir, when, backupCount, accessDefaultFormat)
}</span>

// LoggerInit3 initialize logger. FilePath should be provided
func LoggerInit3(filePath, when string, backupCount int) (log4go.Logger, error) <span class="cov0" title="0">{
        logDir, fileName := filepath.Split(filePath)
        return LoggerInit2(fileName, logDir, when, backupCount)
}</span>

// LoggerInitWithFormat initialize logger. Format should be provided
func LoggerInitWithFormat(c LogConfig, format string) (log4go.Logger, error) <span class="cov0" title="0">{
        fileName := prefix2Name(c.LogPrefix)
        return LoggerInitWithFormat2(fileName, c.LogDir, c.RotateWhen, c.BackupCount, format)
}</span>

// LoggerInitWithFormat2 is similar to LoggerInit, instead of prefix, fileName should be provided.
func LoggerInitWithFormat2(fileName, logDir, when string, backupCount int,
        format string) (log4go.Logger, error) <span class="cov0" title="0">{
        var logger log4go.Logger
        // check value of when is valid
        if !log4go.WhenIsValid(when) </span><span class="cov0" title="0">{
                log4go.Error("LoggerInitWithFormat(): invalid value of when(%s)", when)
                return logger, fmt.Errorf("invalid value of when: %s", when)
        }</span>
        // change when to upper
        <span class="cov0" title="0">when = strings.ToUpper(when)
        // check, and create dir if nonexist
        if err := logDirCreate(logDir); err != nil </span><span class="cov0" title="0">{
                log4go.Error("Init(), in logDirCreate(%s)", logDir)
                return logger, err
        }</span>
        // create logger
        <span class="cov0" title="0">logger = make(log4go.Logger)
        // create file writer for all log
        fullPath := filepath.Join(logDir, fileName)
        logWriter := log4go.NewTimeFileLogWriter(fullPath, when, backupCount)
        if logWriter == nil </span><span class="cov0" title="0">{
                return logger, fmt.Errorf("error in log4go.NewTimeFileLogWriter(%s)", fullPath)
        }</span>
        <span class="cov0" title="0">logWriter.SetFormat(format)
        logger.AddFilter("log", log4go.INFO, logWriter)
        return logger, nil</span>
}

// LoggerInitWithSvr initialize logger with remote log server.
func LoggerInitWithSvr(progName string, loggerName string,
        network string, svrAddr string) (log4go.Logger, error) <span class="cov0" title="0">{
        var logger log4go.Logger
        // create file writer for all log
        name := fmt.Sprintf("%s_%s", progName, loggerName)
        // create logger
        logger = make(log4go.Logger)
        logWriter := log4go.NewPacketWriter(name, network, svrAddr, log4go.LogFormat)
        if logWriter == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error in log4go.NewPacketWriter(%s)", name)
        }</span>
        <span class="cov0" title="0">logger.AddFilter(name, log4go.INFO, logWriter)
        return logger, nil</span>
}

// loggerInitWithFilePath initialize logger with a single file name and output logs to file simply.
func loggerInitWithFilePath(filePath, format string) (log4go.Logger, error) <span class="cov8" title="1">{
        // create logger
        var logger = make(log4go.Logger)
        logWriter := log4go.NewFileLogWriter(filePath, false)
        if logWriter == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error in log4go.NewFileLogWriter(%s)", filePath)
        }</span>
        <span class="cov8" title="1">logWriter.SetFormat(format)
        logger.AddFilter("log", log4go.INFO, logWriter)
        return logger, nil</span>
}
</pre>
		
		<pre class="file" id="file265" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package bns

import (
        "fmt"
)

type Client struct {
        //TODO: support thirdparty name service
}

func NewClient() *Client <span class="cov8" title="1">{
        return &amp;Client{}
}</span>

// Instance represents instance info
type Instance struct {
        Host   string // instance host
        Port   int    // instance port
        Weight int    // instance weight
}

// GetInstancesInfo returns instance addr and weight info of serviceName
func (c *Client) GetInstancesInfo(serviceName string) ([]Instance, error) <span class="cov8" title="1">{
        // check local conf
        if instances, ok := getInstancesLocal(serviceName); ok </span><span class="cov8" title="1">{
                return instances, nil
        }</span>

        // check name service
        //TODO: support thirdparty name service
        <span class="cov8" title="1">return nil, fmt.Errorf("unknown name: %s", serviceName)</span>
}

// GetInstancesAddr return instance addr info of serviceName
func (c *Client) GetInstancesAddr(serviceName string) ([]string, error) <span class="cov0" title="0">{
        instances, err := c.GetInstancesInfo(serviceName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">addrList := make([]string, 0)
        for _, instance := range instances </span><span class="cov0" title="0">{
                address := fmt.Sprintf("%s:%d", instance.Host, instance.Port)
                addrList = append(addrList, address)
        }</span>

        <span class="cov0" title="0">return addrList, nil</span>
}
</pre>
		
		<pre class="file" id="file266" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package bns

import (
        "fmt"
        "os"
        "sync"
)

import (
        "github.com/bfenetworks/bfe/bfe_util/json"
)

type LocalNameConf map[string][]Instance

type NameConf struct {
        Version string
        Config  LocalNameConf
}

var localNameConf LocalNameConf
var localNameLock sync.RWMutex

// LoadLocalNameConf loads name conf file
func LoadLocalNameConf(filename string) error <span class="cov8" title="1">{
        // load local name conf
        nameConf, err := parseLocalNameConf(filename)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // update local name map
        <span class="cov8" title="1">localNameLock.Lock()
        localNameConf = nameConf
        localNameLock.Unlock()
        return nil</span>
}

func getInstancesLocal(serviceName string) ([]Instance, bool) <span class="cov8" title="1">{
        localNameLock.RLock()
        instances, ok := localNameConf[serviceName]
        localNameLock.RUnlock()

        return instances, ok
}</span>

func parseLocalNameConf(filename string) (LocalNameConf, error) <span class="cov8" title="1">{
        var conf NameConf
        var err error

        // open the file
        file, err := os.Open(filename)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        // decode the file
        decoder := json.NewDecoder(file)
        if err = decoder.Decode(&amp;conf); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // check config
        <span class="cov8" title="1">err = checkLocalNameConf(conf)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return conf.Config, nil</span>
}

func checkLocalNameConf(conf NameConf) error <span class="cov8" title="1">{
        for name, instances := range conf.Config </span><span class="cov8" title="1">{
                for _, instance := range instances </span><span class="cov8" title="1">{
                        if err := checkInstance(instance); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("invalid instance for %s: %s", name, err)
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

func checkInstance(instance Instance) error <span class="cov8" title="1">{
        if len(instance.Host) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid host: %v", instance)
        }</span>
        <span class="cov8" title="1">if instance.Port &lt; 0 || instance.Port &gt; 65535 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid port: %v", instance)
        }</span>
        <span class="cov8" title="1">if instance.Weight &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid weight: %v", instance)
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file267" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package byte_pool

import "fmt"

type BytePool struct {
        buf         []byte
        length      []uint32
        maxElemSize int // max length of element
        maxElemNum  int // max element num
}

// NewBytePool creates a new BytePool
//
// PARAMS:
//   - elemNum: int, the max element num of BytePool
//   - maxElemSize: int, the max length of each element
//
// RETURNS:
//   - a pointer point to the BytePool
func NewBytePool(elemNum int, maxElemSize int) *BytePool <span class="cov8" title="1">{
        pool := new(BytePool)
        pool.buf = make([]byte, elemNum*maxElemSize)
        pool.length = make([]uint32, elemNum)
        pool.maxElemSize = maxElemSize
        pool.maxElemNum = elemNum

        return pool
}</span>

// Set sets the index node of BytePool with key
//
// PARAMS:
//   - index: index of the byte Pool
//   - key: []byte key
func (pool *BytePool) Set(index int32, key []byte) error <span class="cov8" title="1">{
        if int(index) &gt;= pool.maxElemNum </span><span class="cov8" title="1">{
                return fmt.Errorf("index out of range %d %d", index, pool.maxElemNum)
        }</span>

        <span class="cov8" title="1">if len(key) &gt; pool.maxElemSize </span><span class="cov8" title="1">{
                return fmt.Errorf("elemSize large than maxSize %d %d", len(key), pool.maxElemSize)
        }</span>

        <span class="cov8" title="1">start := int(index) * pool.maxElemSize
        copy(pool.buf[start:], key)

        pool.length[index] = uint32(len(key))

        return nil</span>
}

// Get the byte slice
//
// PARAMS:
//   - index: int, index of the BytePool
//
// RETURNS:
//   - key: []byte type store in the BytePool
func (pool *BytePool) Get(index int32) []byte <span class="cov8" title="1">{
        start := int(index) * pool.maxElemSize
        end := start + int(pool.length[index])

        return pool.buf[start:end]
}</span>

// MaxElemSize returns the space allocate for each element
func (pool *BytePool) MaxElemSize() int <span class="cov8" title="1">{
        return pool.maxElemSize
}</span>
</pre>
		
		<pre class="file" id="file268" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package byte_pool

import "fmt"

type FixedBytePool struct {
        buf        []byte
        elemSize   int // element length
        maxElemNum int // max element num
}

// NewFixedBytePool creates a new FixedBytePool
//
// PARAMS:
//   - elemNum: int, the max element num of FixedBytePool
//   - elemSize: int, the max length of each element
//
// RETURNS:
//   - a pointer point to the FixedBytePool
func NewFixedBytePool(elemNum int, elemSize int) *FixedBytePool <span class="cov8" title="1">{
        pool := new(FixedBytePool)
        pool.buf = make([]byte, elemNum*elemSize)
        pool.elemSize = elemSize
        pool.maxElemNum = elemNum

        return pool
}</span>

// Set sets the index node of FixedBytePool with key
//
// PARAMS:
//   - index: index of the byte Pool
//   - key: []byte key
func (pool *FixedBytePool) Set(index int32, key []byte) error <span class="cov8" title="1">{
        if int(index) &gt;= pool.maxElemNum </span><span class="cov8" title="1">{
                return fmt.Errorf("index out of range %d %d", index, pool.maxElemNum)
        }</span>

        <span class="cov8" title="1">if len(key) != pool.elemSize </span><span class="cov8" title="1">{
                return fmt.Errorf("length must be %d while %d", pool.elemSize, len(key))
        }</span>
        <span class="cov8" title="1">start := int(index) * pool.elemSize
        copy(pool.buf[start:], key)

        return nil</span>
}

// Get the byte slice of giving index and length
//
// PARAMS:
//   - index: int, index of the FixedBytePool
//
// RETURNS:
//   - key: []byte type store in the FixedBytePool
func (pool *FixedBytePool) Get(index int32) []byte <span class="cov8" title="1">{
        start := int(index) * pool.elemSize
        end := start + pool.elemSize

        return pool.buf[start:end]
}</span>

// MaxElemSize return the space allocate for each element
func (pool *FixedBytePool) MaxElemSize() int <span class="cov8" title="1">{
        return pool.elemSize
}</span>
</pre>
		
		<pre class="file" id="file269" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package bfe_util

import (
        "path"
        "strings"
)

// ConfPathProc return path of config file
//
// Params:
//      - confPath: origin path for config file
//      - confRoot: root path of ALL config
//
// Returns:
//      the final path of config file
//      (1) path starts with "/", it's absolute path, return path untouched
//      (2) else, it's relative path, return path.Join(confRoot, path)
//
func ConfPathProc(confPath string, confRoot string) string <span class="cov0" title="0">{
        if !strings.HasPrefix(confPath, "/") </span><span class="cov0" title="0">{
                // relative path to confRoot
                confPath = path.Join(confRoot, confPath)
        }</span>

        <span class="cov0" title="0">return confPath</span>
}
</pre>
		
		<pre class="file" id="file270" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package bfe_util

import (
        "errors"
        "io"
        "sync"
)

import (
        "github.com/bfenetworks/bfe/bfe_http"
)

var copyPool sync.Pool

// errInvalidWrite means that a writer returned an impossible count.
var errInvalidWrite = errors.New("invalid write result")

func newByteBuf() []byte <span class="cov8" title="1">{
        if v := copyPool.Get(); v != nil </span><span class="cov8" title="1">{
                return v.([]byte)
        }</span>
        <span class="cov8" title="1">return make([]byte, 32*1024)</span>
}

func putByteBuf(buf []byte) <span class="cov8" title="1">{
        copyPool.Put(buf)
}</span>

// CopyWithoutBuffer mimic the behavior of io.Copy.
func CopyWithoutBuffer(wf bfe_http.WriteFlusher, src io.Reader) (written int64, err error) <span class="cov8" title="1">{
        buf := newByteBuf()
        for </span><span class="cov8" title="1">{
                nr, er := src.Read(buf)
                if nr &gt; 0 </span><span class="cov8" title="1">{
                        nw, ew := wf.Write(buf[0:nr])
                        // flush immediately regardless of write result.
                        ef := wf.Flush()
                        if nw &lt; 0 || nr &lt; nw </span><span class="cov0" title="0">{
                                nw = 0
                                if ew == nil </span><span class="cov0" title="0">{
                                        ew = errInvalidWrite
                                }</span>
                        }
                        <span class="cov8" title="1">written += int64(nw)
                        if ew != nil </span><span class="cov0" title="0">{
                                err = ew
                                break</span>
                        }
                        <span class="cov8" title="1">if ef != nil </span><span class="cov0" title="0">{
                                err = ef
                                break</span>
                        }
                        <span class="cov8" title="1">if nr != nw </span><span class="cov0" title="0">{
                                err = io.ErrShortWrite
                                break</span>
                        }
                }
                <span class="cov8" title="1">if er != nil </span><span class="cov8" title="1">{
                        if er != io.EOF </span><span class="cov8" title="1">{
                                err = er
                        }</span>
                        <span class="cov8" title="1">break</span>
                }
        }
        <span class="cov8" title="1">putByteBuf(buf)
        return written, err</span>
}
</pre>
		
		<pre class="file" id="file271" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package bfe_util

import (
        "os"
)

import (
        "github.com/baidu/go-lib/log"
)

func AbnormalExit() <span class="cov0" title="0">{
        // waiting for logger finish jobs
        log.Logger.Close()
        // exit
        os.Exit(1)
}</span>
</pre>
		
		<pre class="file" id="file272" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package bfe_util

import (
        "fmt"
        "io"
        "io/ioutil"
        "os"
        "path"
)

// CopyFile copy src file to dst file.
// return file length, error
func CopyFile(src, dst string) (int64, error) <span class="cov0" title="0">{
        srcFile, err := os.Open(src)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("open src error %s", err)
        }</span>
        <span class="cov0" title="0">defer srcFile.Close()

        srcFileStat, err := srcFile.Stat()
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("stat src error %s", err)
        }</span>

        <span class="cov0" title="0">if !srcFileStat.Mode().IsRegular() </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("%s is not a regular file", src)
        }</span>

        // mkdir all dir
        <span class="cov0" title="0">dirPath := path.Dir(dst)
        if err = os.MkdirAll(dirPath, 0755); err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("MkdirALl err %s", err.Error())
        }</span>

        // create file
        <span class="cov0" title="0">dstFile, err := os.Create(dst)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("create dst error %s", dst)
        }</span>
        <span class="cov0" title="0">defer dstFile.Close()

        return io.Copy(dstFile, srcFile)</span>
}

// BackupFile backup given file.
func BackupFile(path string, bakPath string) error <span class="cov0" title="0">{
        // write to a temp file
        copyPath := fmt.Sprintf("%s.%d.bak", path, os.Getpid())
        if _, err := CopyFile(path, copyPath); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // rename temp file
        <span class="cov0" title="0">if err := os.Rename(copyPath, bakPath); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// CheckStaticFile check local file
func CheckStaticFile(filename string, sizeLimit int64) error <span class="cov0" title="0">{
        stat, err := os.Stat(filename)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if stat.IsDir() </span><span class="cov0" title="0">{
                return fmt.Errorf("%s is not regular file", filename)
        }</span>
        <span class="cov0" title="0">if stat.Size() &gt; sizeLimit </span><span class="cov0" title="0">{
                return fmt.Errorf("%s file size too large[&gt; %d]", filename, sizeLimit)
        }</span>
        <span class="cov0" title="0">if _, err := ioutil.ReadFile(filename); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("read %s: %s", filename, err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file273" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package bfe_util

import (
        "sync"
)

type FixedPool struct {
        pool sync.Pool // memory block pool
        size int       // memory block size
}

func NewFixedPool(size int) *FixedPool <span class="cov8" title="1">{
        p := new(FixedPool)
        p.size = size
        return p
}</span>

// GetBlock gets a byte slice from pool
func (p *FixedPool) GetBlock() []byte <span class="cov8" title="1">{
        if v := p.pool.Get(); v != nil </span><span class="cov8" title="1">{
                return v.([]byte)
        }</span>
        <span class="cov8" title="1">return make([]byte, p.size)</span>
}

// PutBlock releases a byte slice to pool
func (p *FixedPool) PutBlock(block []byte) <span class="cov8" title="1">{
        // just ignore block with mismatched size
        if len(block) != p.size </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">p.pool.Put(block)</span>
}
</pre>
		
		<pre class="file" id="file274" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package bfe_util

import (
        "fmt"
        "net"
)

import (
        "github.com/bfenetworks/bfe/bfe_tls"
)

// GetVipPort return vip and port for given conn
func GetVipPort(conn net.Conn) (net.IP, int, error) <span class="cov0" title="0">{
        // get underlying bfe conn, the given net.Conn may be wired like:
        //  - TLS Connection (optional)
        //  - BFE Connection (PROXY, optional)
        //  - TCP Connection
        if tc, ok := conn.(*bfe_tls.Conn); ok </span><span class="cov0" title="0">{
                conn = tc.GetNetConn()
        }</span>

        // get virtual vip
        <span class="cov0" title="0">if af, ok := conn.(AddressFetcher); ok </span><span class="cov0" title="0">{
                vaddr := af.VirtualAddr()
                if vaddr == nil </span><span class="cov0" title="0">{
                        return nil, 0, fmt.Errorf("vip unknown")
                }</span>
                <span class="cov0" title="0">return ParseIpAndPort(vaddr.String())</span>
        }

        <span class="cov0" title="0">return nil, 0, fmt.Errorf("can`t get vip and port when Layer4LoadBalancer is not set")</span>
}

// GetVip return vip for given conn
func GetVip(conn net.Conn) net.IP <span class="cov0" title="0">{
        vip, _, err := GetVipPort(conn)
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return vip</span>
}
</pre>
		
		<pre class="file" id="file275" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package bfe_util

import (
        "encoding/binary"
        "fmt"
        "net"
        "os"
        "reflect"
)

import (
        "github.com/bfenetworks/bfe/bfe_tls"
)

// CloseWriter is the interface that wraps the basic CloseWrite method.
type CloseWriter interface {
        CloseWrite() error
}

// AddressFetcher is the interface that group the address related method.
type AddressFetcher interface {
        // RemoteAddr returns the remote network address.
        RemoteAddr() net.Addr

        // LocalAddr returns the local network address.
        LocalAddr() net.Addr

        // VirtualAddr returns the virtual network address.
        VirtualAddr() net.Addr

        // BalancerAddr return the balancer network address. May be nil.
        BalancerAddr() net.Addr
}

// ConnFetcher is the interface that wrap the GetNetConn
type ConnFetcher interface {
        // GetNetConn returns the underlying net.Conn
        GetNetConn() net.Conn
}

// GetTCPConn returns underlying TCPConn of given conn.
func GetTCPConn(conn net.Conn) (*net.TCPConn, error) <span class="cov0" title="0">{
        switch value := conn.(type) </span>{
        case *bfe_tls.Conn:<span class="cov0" title="0">
                c := value.GetNetConn()
                return c.(*net.TCPConn), nil</span>
        case *net.TCPConn:<span class="cov0" title="0">
                return value, nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("GetTCPConn(): conn type not support %s", reflect.TypeOf(conn))</span>
        }
}

// GetConnFile get a copy of underlying os.File of tcp conn
func GetConnFile(conn net.Conn) (*os.File, error) <span class="cov0" title="0">{
        // get underlying net.Conn
        if c, ok := conn.(ConnFetcher); ok </span><span class="cov0" title="0">{
                conn = c.GetNetConn()
                return GetConnFile(conn)
        }</span>

        // the fd is tcpConn.fd.sysfd
        <span class="cov0" title="0">if c, ok := conn.(*net.TCPConn); ok </span><span class="cov0" title="0">{
                return c.File()
        }</span>

        <span class="cov0" title="0">return nil, fmt.Errorf("GetConnFd(): conn type not support %s", reflect.TypeOf(conn))</span>
}

// ParseIpAndPort return parsed ip address
func ParseIpAndPort(addr string) (net.IP, int, error) <span class="cov0" title="0">{
        taddr, err := net.ResolveTCPAddr("tcp", addr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>
        <span class="cov0" title="0">return taddr.IP, taddr.Port, nil</span>
}

func NativeUint16(data []byte) uint16 <span class="cov0" title="0">{
        if IsBigEndian() </span><span class="cov0" title="0">{
                return binary.BigEndian.Uint16(data)
        }</span> else<span class="cov0" title="0"> {
                return binary.LittleEndian.Uint16(data)
        }</span>
}

// IsBigEndian check machine is big endian or not
func IsBigEndian() bool <span class="cov0" title="0">{
        var i int32 = 0x12345678
        return byte(i) == 0x12
}</span>
</pre>
		
		<pre class="file" id="file276" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hash_set

import (
        "fmt"
)

import (
        "github.com/spaolacci/murmur3"
)

// LOAD_FACTOR
/* in order to reduce the conflict of hash
 * hash array can be LOAD_FACTOR times larger than nodePool
 */
const (
        LOAD_FACTOR = 5
)

// index table of hashSet
type hashArray []int32

// make a new hashArray and init it
func newHashArray(indexSize int) hashArray <span class="cov8" title="1">{
        ha := make(hashArray, indexSize)
        for i := 0; i &lt; indexSize; i += 1 </span><span class="cov8" title="1">{
                ha[i] = -1
        }</span>

        <span class="cov8" title="1">return ha</span>
}

type HashSet struct {
        ha          hashArray // hashArray, the index table for nodePool
        haSize      int       // hashArray size
        isFixKeyLen bool      // fixed element size or not

        np *nodePool // nodePool manage the elements of hashSet

        hashFunc func(key []byte) uint64 //function for hash
}

// NewHashSet creates a newHashSet
//
// PARAMS:
//   - elemNum: max element num of hashSet
//   - elemSize: maxSize of hashKey after it converted to []byte
//   - isFixKeyLen: fixed element size or not
//   - hashFunc: hash function
//
// RETURNS:
//  - (*HashSet, nil), if success
//  - (nil, error), if fail
func NewHashSet(elemNum int, elemSize int, isFixKeyLen bool,
        hashFunc func([]byte) uint64) (*HashSet, error) <span class="cov8" title="1">{
        if elemNum &lt;= 0 || elemSize &lt;= 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("elementNum/elementSize must &gt; 0")
        }</span>

        <span class="cov8" title="1">hashSet := new(HashSet)

        // hashArray is larger in order to reduce hash conflict
        hashSet.haSize = elemNum * LOAD_FACTOR
        hashSet.isFixKeyLen = isFixKeyLen
        hashSet.ha = newHashArray(hashSet.haSize)

        // create nodePool
        hashSet.np = newNodePool(elemNum, elemSize, isFixKeyLen)

        // if hashFunc is not given, use default murmur Hash
        if hashFunc != nil </span><span class="cov8" title="1">{
                hashSet.hashFunc = hashFunc
        }</span> else<span class="cov0" title="0"> {
                hashSet.hashFunc = murmur3.Sum64
        }</span>

        <span class="cov8" title="1">return hashSet, nil</span>
}

// Add - add an element into the set
//
// PARAMS:
//   - key: []byte, element of the set
//
// RETURNS:
//   - nil, if succeed
//   - error, if fail
func (set *HashSet) Add(key []byte) error <span class="cov8" title="1">{
        // check the whether hashSet if full
        if set.Full() </span><span class="cov0" title="0">{
                return fmt.Errorf("hashSet: Set is full")
        }</span>

        // validate hashKey
        <span class="cov8" title="1">err := set.np.validateKey(key)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 1. calculate the hash num
        <span class="cov8" title="1">hashNum := set.hashFunc(key) % uint64(set.haSize)

        // 2. check if the key slice exist
        if set.exist(hashNum, key) </span><span class="cov0" title="0">{
                return nil
        }</span>

        // 3. add the key into nodePool
        <span class="cov8" title="1">head := set.ha[hashNum]
        newHead, err := set.np.add(head, key)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 4. point to the new list head node
        <span class="cov8" title="1">set.ha[hashNum] = newHead

        return nil</span>
}

// Remove removes an element from the hashSet
//
// PARAMS:
//   - key: []byte, element of the set
//
// RETURNS:
//   - nil, if succeed
//   - error, if fail
func (set *HashSet) Remove(key []byte) error <span class="cov8" title="1">{
        // validate hashKey
        err := set.np.validateKey(key)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        //1. calculate the hash num
        <span class="cov8" title="1">hashNum := set.hashFunc(key) % uint64(set.haSize)

        //2. remove key from hashNode
        head := set.ha[hashNum]
        if head == -1 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">newHead := set.np.del(head, key)

        //3. point to the new list head node
        set.ha[hashNum] = newHead

        return nil</span>
}

// Exist checks if the element exist in Set
func (set *HashSet) Exist(key []byte) bool <span class="cov8" title="1">{
        //validate hashKey
        err := set.np.validateKey(key)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">hashNum := set.hashFunc(key) % uint64(set.haSize)
        return set.exist(hashNum, key)</span>
}

// exist checks the []byte exist in the giving list head
func (set *HashSet) exist(hashNum uint64, key []byte) bool <span class="cov8" title="1">{
        head := set.ha[hashNum]
        return set.np.exist(head, key)
}</span>

// Len returns element Num of hashSet
func (set *HashSet) Len() int <span class="cov8" title="1">{
        return set.np.elemNum()
}</span>

// Full checks if the hashSet full or not
func (set *HashSet) Full() bool <span class="cov8" title="1">{
        return set.np.full()
}</span>
</pre>
		
		<pre class="file" id="file277" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hash_set

import (
        "bytes"
        "fmt"
)

import (
        "github.com/bfenetworks/bfe/bfe_util/byte_pool"
)

/* hash node */
type hashNode struct {
        next int32 // link to the next node
}

/* a list of hash node */
type nodePool struct {
        array []hashNode //node array

        freeNode int32 // manage the freeNode of nodePool
        capacity int   // capacity of nodePool
        length   int   // length of nodePool

        pool byte_pool.IBytePool // reference to []byte pool
}

/*
 * create a new nodePool
 *
 * PARAMS:
 *  - elemNum: max num of elements
 *  - elemSize: max size of each element of hashSet
 *
 * RETURNS:
 *  - pointer to nodePool
 */
func newNodePool(elemNum, elemSize int, isFixedKeylen bool) *nodePool <span class="cov8" title="1">{
        np := new(nodePool)

        // make and init node array
        np.array = make([]hashNode, elemNum)
        for i := 0; i &lt; elemNum-1; i += 1 </span><span class="cov8" title="1">{
                np.array[i].next = int32(i + 1) // link to the next node
        }</span>
        <span class="cov8" title="1">np.array[elemNum-1].next = -1 //initial value == -1, means end of the list

        np.freeNode = 0 //free node start from 0
        np.capacity = elemNum
        np.length = 0

        if isFixedKeylen </span><span class="cov8" title="1">{
                np.pool = byte_pool.NewFixedBytePool(elemNum, elemSize)
        }</span> else<span class="cov8" title="1"> {
                np.pool = byte_pool.NewBytePool(elemNum, elemSize)
        }</span>
        <span class="cov8" title="1">return np</span>
}

/*
 * add
 *  - add key into the list starting from head
 *  - return the new headNode
 *
 * PARAMS:
 *  - head: first node of the list
 *  - key: []byte type
 *
 * RETURNS:
 *  - (newHead, nil), success, new headNode of the list
 *  - (-1, error), if fail
 */
func (np *nodePool) add(head int32, key []byte) (int32, error) <span class="cov8" title="1">{
        // get a bucket from freeNode List
        node, err := np.getFreeNode()
        if err != nil </span><span class="cov0" title="0">{
                return -1, err
        }</span>

        <span class="cov8" title="1">np.array[node].next = head
        //set the node with key
        np.pool.Set(node, key)

        np.length += 1
        return node, nil</span>
}

/*
 * del
 *  - remove the key([]byte) in the given list
 *  - return the new head of the list
 *
 * PARAMS:
 *  - head: int, the first node of the list
 *  - key: []byte, the key need to be del
 *
 * RETURNS:
 *  - newHead int, the new head node of the list
 */
func (np *nodePool) del(head int32, key []byte) int32 <span class="cov8" title="1">{
        var newHead int32
        // check at the head of List
        if np.compare(key, head) == 0 </span><span class="cov8" title="1">{
                newHead = np.array[head].next
                np.recycleNode(head) //recycle the node
                return newHead
        }</span>

        // check at the list
        <span class="cov8" title="1">pindex := head
        for </span><span class="cov8" title="1">{
                index := np.array[pindex].next
                if index == -1 </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">if np.compare(key, index) == 0 </span><span class="cov8" title="1">{
                        np.array[pindex].next = np.array[index].next
                        np.recycleNode(index) //recycle the node
                        return head
                }</span>
                <span class="cov0" title="0">pindex = index</span>
        }
        <span class="cov8" title="1">return head</span>
}

/* del the node, add the node into freeNode list */
func (np *nodePool) recycleNode(node int32) <span class="cov8" title="1">{
        index := np.freeNode
        np.freeNode = node
        np.array[node].next = index
        np.length -= 1
}</span>

/* check if the key exist in the list */
func (np *nodePool) exist(head int32, key []byte) bool <span class="cov8" title="1">{
        for index := head; index != -1; index = np.array[index].next </span><span class="cov8" title="1">{
                if np.compare(key, index) == 0 </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

/* get a free node from freeNode list */
func (np *nodePool) getFreeNode() (int32, error) <span class="cov8" title="1">{
        if np.freeNode == -1 </span><span class="cov0" title="0">{
                return -1, fmt.Errorf("NodePool: no more node to use")
        }</span>

        // return freeNode and make freeNode = freeNode.next
        <span class="cov8" title="1">node := np.freeNode
        np.freeNode = np.array[node].next
        np.array[node].next = -1

        return node, nil</span>
}

/* get node num in use of nodePool */
func (np *nodePool) elemNum() int <span class="cov8" title="1">{
        return np.length
}</span>

/* check if the node Pool is full */
func (np *nodePool) full() bool <span class="cov8" title="1">{
        return np.length &gt;= np.capacity
}</span>

/* compare the given key with index node */
func (np *nodePool) compare(key []byte, i int32) int <span class="cov8" title="1">{
        element := np.element(i)
        return bytes.Compare(key, element)
}</span>

/* get the element of the giving index*/
func (np *nodePool) element(i int32) []byte <span class="cov8" title="1">{
        return np.pool.Get(i)
}</span>

/* get the space allocate for each element */
func (np *nodePool) elemSize() int <span class="cov8" title="1">{
        return np.pool.MaxElemSize()
}</span>

/* check whtether the key is legal for the set */
func (np *nodePool) validateKey(key []byte) error <span class="cov8" title="1">{
        if len(key) &lt;= np.elemSize() </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return fmt.Errorf("element len[%d] &gt; bucketSize[%d]", len(key), np.elemSize())</span>
}
</pre>
		
		<pre class="file" id="file278" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package ipdict

import (
        "bytes"
        "errors"
        "fmt"
        "net"
        "sort"
)

const (
        IP_SIZE     = 16 // TODO: optimize memory usage for ipv4 address
        HEADER_LEN  = 32
        MAX_LINE    = 1000000
        MAX_LOC_LEN = 1024
)

// uppercasing the first letter for binary lib
type ipLocation struct {
        startIp  net.IP
        endIp    net.IP
        location []byte
}

// []byte to string ,remove last 0 in []bytes
func byteString(p []byte) string <span class="cov8" title="1">{
        for i := 0; i &lt; len(p); i++ </span><span class="cov8" title="1">{
                if p[i] == 0 </span><span class="cov8" title="1">{
                        return string(p[0:i])
                }</span>
        }
        <span class="cov0" title="0">return string(p)</span>
}

type IpLocationTable struct {
        Version   string
        maxSize   uint32
        LocLen    uint32
        offset    uint32
        locations []byte
}

func NewIpLocationTable(maxSize uint32, locLen uint32) (*IpLocationTable, error) <span class="cov8" title="1">{
        // maxSize max is MAX_LINE
        if maxSize == 0 || maxSize &gt; MAX_LINE </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("NewIpLocationTable caused by maxSize :%d", maxSize)
        }</span>

        // LocLen max size is MAX_LOC_LEN
        <span class="cov8" title="1">if locLen == 0 || locLen &gt; MAX_LOC_LEN </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("NewIpLocationTable caused by LocLen :%d", locLen)
        }</span>

        <span class="cov8" title="1">ipLocTable := new(IpLocationTable)
        ipLocTable.maxSize = maxSize
        ipLocTable.offset = 0
        ipLocTable.LocLen = locLen
        ipLocTable.locations = make([]byte, (HEADER_LEN+locLen)*maxSize)
        return ipLocTable, nil</span>
}

// write ipLocation Struct to locations by [HeaderLen+t.LocLen]byte
func (t *IpLocationTable) writeStruct(idx uint32, ipLoc ipLocation) <span class="cov8" title="1">{
        sOffset := idx * (t.LocLen + HEADER_LEN)
        copy(t.locations[sOffset:sOffset+IP_SIZE], ipLoc.startIp)
        copy(t.locations[sOffset+IP_SIZE:sOffset+HEADER_LEN], ipLoc.endIp)
        copy(t.locations[sOffset+HEADER_LEN:sOffset+HEADER_LEN+t.LocLen], ipLoc.location)
}</span>

// read ipLocation from locations by idx
func (t *IpLocationTable) readStruct(idx uint32) ipLocation <span class="cov8" title="1">{
        var ipLoc ipLocation
        sOffset := idx * (t.LocLen + HEADER_LEN)
        ipLoc.startIp = t.locations[sOffset : sOffset+IP_SIZE]
        ipLoc.endIp = t.locations[sOffset+IP_SIZE : sOffset+HEADER_LEN]
        ipLoc.location = t.locations[sOffset+HEADER_LEN : sOffset+HEADER_LEN+t.LocLen]
        return ipLoc
}</span>

// Add ip location dict to locations buffer
// assume add startIP:EndIP have been sorted
// every add startIP:EndIP region does not overlap
func (t *IpLocationTable) Add(startIP, endIP net.IP, location string) error <span class="cov8" title="1">{
        if err := checkIPPair(startIP, endIP); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Add failed: %s", err.Error())
        }</span>

        <span class="cov8" title="1">if t.offset &gt;= t.maxSize </span><span class="cov8" title="1">{
                return errors.New("Add():caused by table is full")
        }</span>

        <span class="cov8" title="1">startIP16 := startIP.To16()
        endIP16 := endIP.To16()

        // write unit(startip,endip,location) to locations buffer
        var loc ipLocation
        loc.startIp = startIP16
        loc.endIp = endIP16
        loc.location = make([]byte, t.LocLen)
        copy(loc.location[0:t.LocLen], location)
        t.writeStruct(t.offset, loc)

        t.offset++
        return nil</span>
}

// Search find the ip's location.
// search sort of array(order from small to large)
func (t *IpLocationTable) Search(cip net.IP) (string, error) <span class="cov8" title="1">{
        ipAddr16 := cip.To16()
        if ipAddr16 == nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("invalid cip: %s", cip.String())
        }</span>

        <span class="cov8" title="1">indexLen := t.offset
        if indexLen == 0 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("Search() error caused by locations is null")
        }</span>

        <span class="cov8" title="1">idx := sort.Search(int(indexLen),
                func(i int) bool </span><span class="cov8" title="1">{
                        s := uint32(i) * (HEADER_LEN + t.LocLen)
                        e := uint32(i)*(HEADER_LEN+t.LocLen) + IP_SIZE
                        b := t.locations[s:e]
                        return bytes.Compare(b, ipAddr16) &gt;= 0
                }</span>)

        // get idx corresponding ip section's first ip
        <span class="cov8" title="1">var firstIp net.IP
        if uint32(idx) &lt;= indexLen-1 </span><span class="cov8" title="1">{
                s := uint32(idx) * (HEADER_LEN + t.LocLen)
                e := uint32(idx)*(HEADER_LEN+t.LocLen) + IP_SIZE
                firstIp = t.locations[s:e]
        }</span>

        <span class="cov8" title="1">var preIdx uint32

        if uint32(idx) == indexLen </span><span class="cov8" title="1">{
                // consider ipAdd last element(uint32(idx) == indexLen)
                preIdx = indexLen - 1
        }</span> else<span class="cov8" title="1"> if firstIp.Equal(ipAddr16) || idx == 0 </span><span class="cov8" title="1">{
                // consider ipAdd locate in first section (idx == 0)
                // consider ipAdd is first ip in ip's section(firstIp == ipAddr16)
                preIdx = uint32(idx)
        }</span> else<span class="cov0" title="0"> {
                // other think ipAdd location previous section
                preIdx = uint32(idx - 1)
        }</span>

        // read unit(startip,endip,location) from locations buffer
        <span class="cov8" title="1">loc := t.readStruct(preIdx)
        if bytes.Compare(ipAddr16, loc.endIp) &lt;= 0 &amp;&amp; bytes.Compare(ipAddr16, loc.startIp) &gt;= 0 </span><span class="cov8" title="1">{
                return byteString(loc.location[0:]), nil
        }</span>
        <span class="cov0" title="0">return "", fmt.Errorf("Search() error caused by the ip's location does not exist")</span>
}
</pre>
		
		<pre class="file" id="file279" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package ipdict

import (
        "bytes"
        "fmt"
        "hash/fnv"
        "net"
        "sort"
)

import (
        "github.com/bfenetworks/bfe/bfe_util/hash_set"
)

const (
        IP_LENGTH = 16
)

// Hash is a hash method which convert net.IP to type uint64.
func Hash(ip []byte) uint64 <span class="cov8" title="1">{
        hash64 := fnv.New64()
        hash64.Write(ip)
        return hash64.Sum64()
}</span>

type ipPair struct {
        startIP net.IP
        endIP   net.IP
}

type ipPairs []ipPair

// IPItems manage single IP(hashSet) and ipPairs
type IPItems struct {
        ipSet   *hash_set.HashSet
        items   ipPairs
        Version string
}

// NewIPItems creates new IPItems
func NewIPItems(maxSingleIPNum int, maxPairIPNum int) (*IPItems, error) <span class="cov8" title="1">{
        // maxSingleIPNum &amp;&amp; maxPairIPNum must &gt;= 0
        if maxSingleIPNum &lt; 0 || maxPairIPNum &lt; 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("SingleIPNum/PairIPNum must &gt;= 0")
        }</span>

        <span class="cov8" title="1">var err error
        ipItems := new(IPItems)

        // create a hashSet for single IPs
        isFixedSize := true // ip address is fixed size(IP_LENGTH)
        maxSingleIPNum += 1 // +1, hash_set don't support maxSingleIPNum == 0
        ipItems.ipSet, err = hash_set.NewHashSet(maxSingleIPNum, IP_LENGTH, isFixedSize, Hash)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // create item array for pair IPs
        <span class="cov8" title="1">ipItems.items = make(ipPairs, 0, maxPairIPNum)
        return ipItems, nil</span>
}

// Len returns num of items
func (items ipPairs) Len() int <span class="cov8" title="1">{
        return len(items)
}</span>

// Less compares specified items
func (items ipPairs) Less(i, j int) bool <span class="cov8" title="1">{
        return bytes.Compare(items[i].startIP, items[j].startIP) &gt;= 0
}</span>

// Swap swaps specified items
func (items ipPairs) Swap(i, j int) <span class="cov8" title="1">{
        items[i], items[j] = items[j], items[i]
}</span>

// checkMerge merge items between index i and j in sorted items.
// If items[i] and items[j] can merge, then merge all items between index i and j
// Others do not merge.
// Constraint: j &gt; i, items[j].endIP &gt;= items[i].startIP
func (ipItems *IPItems) checkMerge(i, j int) int <span class="cov8" title="1">{
        var mergedNum int

        items := ipItems.items

        if bytes.Compare(items[j].endIP, items[i].startIP) &gt;= 0 </span><span class="cov8" title="1">{
                items[i].startIP = items[j].startIP
                if bytes.Compare(items[j].endIP, items[i].endIP) &gt;= 0 </span><span class="cov8" title="1">{
                        items[i].endIP = items[j].endIP
                }</span>

                <span class="cov8" title="1">items[j].startIP = net.IPv6zero
                items[j].endIP = net.IPv6zero

                mergedNum++

                // Merge items [i+1, j)
                for k := i + 1; k &lt; j; k++ </span><span class="cov8" title="1">{
                        if items[k].endIP.Equal(net.IPv6zero) || items[k].endIP.Equal(net.IPv4zero) </span><span class="cov8" title="1">{
                                continue</span>
                        }

                        <span class="cov8" title="1">items[k].startIP = net.IPv6zero
                        items[k].endIP = net.IPv6zero
                        mergedNum++</span>
                }
        }

        <span class="cov8" title="1">return mergedNum</span>
}

// mergeItems provides for merging sorted items
// 1. Sorted dict
//  startIPStr   endIPStr
// ------------------------
// 10.26.74.55 10.26.74.255
// 10.23.77.88 10.23.77.240
// 10.21.34.5  10.23.77.100
// 10.12.14.2  10.12.14.50
// ------------------------
// 2. Merged sorted dict
//  startIPStr   endIPStr
// ------------------------
// 10.26.74.55 10.26.74.255
// 10.21.34.5  10.23.77.240
// 10.12.14.2  10.12.14.50
// 0.0.0.0     0.0.0.0
// ------------------------
func (ipItems *IPItems) mergeItems() int <span class="cov8" title="1">{
        var mergedNum int

        items := ipItems.items
        length := len(items)

        for i := 0; i &lt; length-1; i++ </span><span class="cov8" title="1">{

                if items[i].endIP.Equal(net.IPv6zero) || items[i].endIP.Equal(net.IPv4zero) </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">for j := i + 1; j &lt; length; j++ </span><span class="cov8" title="1">{
                        if items[j].endIP.Equal(net.IPv6zero) || items[i].endIP.Equal(net.IPv4zero) </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov8" title="1">mergedNum += ipItems.checkMerge(i, j)</span>
                }
        }

        <span class="cov8" title="1">return mergedNum</span>
}

// InsertPair provides insert startIP,endIP into IpItems
func (ipItems *IPItems) InsertPair(startIP, endIP net.IP) error <span class="cov8" title="1">{
        if err := checkIPPair(startIP, endIP); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("InsertPair failed: %s", err.Error())
        }</span>

        <span class="cov8" title="1">startIP16 := startIP.To16()
        endIP16 := endIP.To16()

        ipItems.items = append(ipItems.items, ipPair{startIP16, endIP16})
        return nil</span>
}

// InsertSingle insert single ip into ipitems
func (ipItems *IPItems) InsertSingle(ip net.IP) error <span class="cov8" title="1">{
        ip16 := ip.To16()
        if ip16 == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("InsertSingle(): err, invalid ip: %s", ip.String())
        }</span>
        <span class="cov0" title="0">return ipItems.ipSet.Add(ip16)</span>
}

// Sort provides for sorting dict according startIP by descending order
// 1. Origin dict
//  startIPStr   endIPStr
// ------------------------
// 10.26.74.55 10.26.74.255
// 10.12.14.2  10.12.14.50
// 10.21.34.5  10.23.77.100
// 10.23.77.88 10.23.77.240
// ------------------------
// 2. Sorted dict
//  startIPStr   endIPStr
// ------------------------
// 10.26.74.55 10.26.74.255
// 10.23.77.88 10.23.77.240
// 10.21.34.5  10.23.77.100
// 10.12.14.2  10.12.14.50
// ------------------------
// 3. Merged sorted dict
//  startIPStr   endIPStr
// ------------------------
// 10.26.74.55 10.26.74.255
// 10.21.34.5  10.23.77.240
// 10.12.14.2  10.12.14.50
// 0.0.0.0     0.0.0.0
// ------------------------
// 4. Dict after resliced
//  startIPStr   endIPStr
// ------------------------
// 10.26.74.55 10.26.74.255
// 10.21.34.5  10.23.77.240
// 10.12.14.2  10.12.14.50
// ------------------------
func (ipItems *IPItems) Sort() <span class="cov8" title="1">{

        // Sort items according startIP by descending order
        sort.Sort(ipItems.items)

        // Merge item lines
        mergedNum := ipItems.mergeItems()
        length := len(ipItems.items) - mergedNum

        // Sort items according startIP by descending order
        sort.Sort(ipItems.items)

        // Reslice
        ipItems.items = ipItems.items[0:length]
}</span>

// Length return num of IPItems
func (ipItems *IPItems) Length() int <span class="cov8" title="1">{
        num := len(ipItems.items)
        num += ipItems.ipSet.Len()

        return num
}</span>
</pre>
		
		<pre class="file" id="file280" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package ipdict

import (
        "bytes"
        "fmt"
        "net"
)

type ipStr struct {
        start string
        end   string
}

type ipStrs []ipStr

// util func for unit test
// load ip to IPItems from struct string
func loadIPStr(ips ipStrs) (*IPItems, error) <span class="cov8" title="1">{

        ipItems, err := NewIPItems(1000, 1000)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">for _, ip := range ips </span><span class="cov8" title="1">{
                startIP := net.ParseIP(ip.start)
                endIP := net.ParseIP(ip.end)
                err := ipItems.InsertPair(startIP, endIP)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">return ipItems, nil</span>
}

func checkIPPair(startIP, endIP net.IP) error <span class="cov8" title="1">{
        startIP16 := startIP.To16()
        if startIP16 == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid startIP: %s", startIP.String())
        }</span>
        <span class="cov8" title="1">endIP16 := endIP.To16()
        if endIP16 == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid endIP: %s", endIP.String())
        }</span>

        <span class="cov8" title="1">if (startIP.To4() != nil &amp;&amp; endIP.To4() == nil) || (startIP.To4() == nil &amp;&amp; endIP.To4() != nil) </span><span class="cov8" title="1">{
                return fmt.Errorf("startIP and endIP should both be ipv4 or non-ipv4")
        }</span>
        <span class="cov8" title="1">if bytes.Compare(startIP16, endIP16) == 1 </span><span class="cov8" title="1">{
                return fmt.Errorf("startIPStr %s &gt; endIPStr %s", startIP.String(), endIP.String())
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file281" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package ipdict

import (
        "bytes"
        "net"
        "sort"
        "sync"
)

type IPTable struct {
        lock    sync.RWMutex
        ipItems *IPItems
}

func NewIPTable() *IPTable <span class="cov8" title="1">{
        table := new(IPTable)
        return table
}</span>

func (t *IPTable) Version() string <span class="cov0" title="0">{
        t.lock.RLock()
        ipItems := t.ipItems
        t.lock.RUnlock()

        if ipItems != nil </span><span class="cov0" title="0">{
                return ipItems.Version
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// Update provides for thread-safe switching items
func (t *IPTable) Update(items *IPItems) <span class="cov8" title="1">{
        t.lock.Lock()
        t.ipItems = items
        t.lock.Unlock()
}</span>

// Search provides for binary search IP in dict
func (t *IPTable) Search(srcIP net.IP) bool <span class="cov8" title="1">{
        var hit bool
        t.lock.RLock()
        ipItems := t.ipItems
        t.lock.RUnlock()

        // check ipItems
        if ipItems == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        // convert ip to ipv6
        <span class="cov8" title="1">ip16 := srcIP.To16()

        if ip16 == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // 1. check at the ip set
        <span class="cov8" title="1">if ipItems.ipSet.Exist(ip16) </span><span class="cov0" title="0">{
                return true
        }</span>

        // 2. check at the item array
        <span class="cov8" title="1">items := ipItems.items
        itemsLen := len(items)

        i := sort.Search(itemsLen,
                func(i int) bool </span><span class="cov8" title="1">{ return bytes.Compare(items[i].startIP, ip16) &lt;= 0 }</span>)

        <span class="cov8" title="1">if i &lt; itemsLen </span><span class="cov8" title="1">{
                if bytes.Compare(items[i].endIP, ip16) &gt;= 0 </span><span class="cov8" title="1">{
                        hit = true
                }</span>
        }

        <span class="cov8" title="1">return hit</span>
}
</pre>
		
		<pre class="file" id="file282" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package txt_load

import (
        "bufio"
        "fmt"
        "net"
        "os"
        "strings"
)

import (
        "github.com/bfenetworks/bfe/bfe_util/json"
)

type MetaInfo struct {
        Version     string
        SingleIPNum int // single IP num
        PairIPNum   int // Pair IP num
}

/*
* getFileInfo - get file meta info.
*
* get file meta info from first line, if failed, get actual IPNums
*
* PARAMS:
*   - path: path of file
*
* RETURNS:
*   - (*MetaInfo, nil), if success ,return file metaInfo
*   - (nil error), if failed
 */
func getFileInfo(path string) (*MetaInfo, error) <span class="cov8" title="1">{
        // get meta info from comment(first line)
        if metaInfo, err := getCommentFileInfo(path); err == nil </span><span class="cov8" title="1">{
                return metaInfo, nil
        }</span>

        <span class="cov8" title="1">return getActualFileInfo(path)</span>
}

/*
* getCommentFileInfo - read the first Line, decode the json string, and return
*
* eg. #{ "version":"1.2.3.4","singleIPNum": 1234, "pairIPNum": 1234}
*
* PARAMS:
*   - path: path of file
*
* RETURNS:
*   - (*MetaInfo, nil), if success ,return file metaInfo
*   - (nil error), if failed
 */
func getCommentFileInfo(path string) (*MetaInfo, error) <span class="cov8" title="1">{
        // open file
        file, err := os.Open(path)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        // read the first line
        reader := bufio.NewReader(file)
        line, _, err := reader.ReadLine()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // get meta data
        <span class="cov8" title="1">firstLine := strings.Trim(string(line), " \t\r\n")
        if !strings.HasPrefix(firstLine, "#") </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("firstLine don't contail meta info")
        }</span>

        // decode the json string
        <span class="cov8" title="1">metaInfo := &amp;MetaInfo{SingleIPNum: -1, PairIPNum: -1}
        metaString := strings.Trim(firstLine, "#")
        decoder := json.NewDecoder(strings.NewReader(metaString))
        err = decoder.Decode(metaInfo)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // check metaInfo
        <span class="cov8" title="1">err = checkMetaInfo(*metaInfo)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return metaInfo, nil</span>
}

// getActualFileInfo: cal meta info from file
func getActualFileInfo(path string) (*MetaInfo, error) <span class="cov8" title="1">{
        var startIP, endIP net.IP

        // open file
        file, err := os.Open(path)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("open(): %s, %s", path, err.Error())
        }</span>
        <span class="cov8" title="1">defer file.Close()

        singleIPCounter := 0
        pairIPCounter := 0
        // scan the file line by line
        scanner := bufio.NewScanner(file)
        for scanner.Scan() </span><span class="cov8" title="1">{
                // Remove all leading and trailing spaces and tabs
                line := strings.Trim(scanner.Text(), " \t")
                //Line begins with "#" is considered as a comment
                if strings.HasPrefix(line, "#") || len(line) == 0 </span><span class="cov8" title="1">{
                        continue</span>
                }

                // Check line format
                <span class="cov8" title="1">startIP, endIP, err = checkLine(line)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("checkLine(): line[%s] err[%s]", line, err.Error())
                }</span>

                // insert start ip and end ip into dict
                <span class="cov8" title="1">if startIP.Equal(endIP) </span><span class="cov0" title="0">{
                        singleIPCounter += 1
                }</span> else<span class="cov8" title="1"> {
                        pairIPCounter += 1
                }</span>
        }
        <span class="cov8" title="1">err = scanner.Err()
        // Scan meets error
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("scan file: err, %s", err.Error())
        }</span>

        <span class="cov8" title="1">return &amp;MetaInfo{
                Version:     "",
                SingleIPNum: singleIPCounter,
                PairIPNum:   pairIPCounter,
        }, nil</span>
}

/* check meta info */
func checkMetaInfo(info MetaInfo) error <span class="cov8" title="1">{
        if info.Version == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("metaInfo:Version is empty string")
        }</span>

        /* PairIPNum/SingleIPNum must &gt;= 0 */
        <span class="cov8" title="1">if info.PairIPNum &lt; 0 || info.SingleIPNum &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("metaInfo:PairIPNum || SingleIPNum &lt; 0")
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file283" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package txt_load

import (
        "bufio"
        "bytes"
        "encoding/binary"
        "errors"
        "fmt"
        "math/big"
        "net"
        "os"
        "strings"
)

import (
        "github.com/bfenetworks/bfe/bfe_util/ipdict"
)

var (
        // file version not change, needn't load the file
        ErrNoNeedUpdate = errors.New("Version no change no need update")
        // line num of file larger than maxline configured
        ErrMaxLineExceed = errors.New("Max line exceed")
        // wrong meta info
        ErrWrongMetaInfo = errors.New("Wrong meta info")
)

type TxtFileLoader struct {
        fileName string
        maxLine  int
}

func NewTxtFileLoader(fileName string) *TxtFileLoader <span class="cov8" title="1">{
        f := new(TxtFileLoader)
        f.fileName = fileName
        f.maxLine = -1
        return f
}</span>

// set max line num
func (f *TxtFileLoader) SetMaxLine(maxLine int) <span class="cov0" title="0">{
        f.maxLine = maxLine
}</span>

/*
   checkSplit checks line split format
   legal start ip and end ip is separated by space[s]/tab[s]
*/
func checkSplit(line string, sep string) (net.IP, net.IP, error) <span class="cov8" title="1">{
        var startIPStr, endIPStr string
        var startIP, endIP net.IP

        segments := strings.SplitN(line, sep, 2)
        segLen := len(segments)

        // Segments[0] : start ip string
        // Segments[1] : end ip string(start ip string instead when no end ip string found)
        if segLen == 1 </span><span class="cov8" title="1">{
                startIPStr, endIPStr = segments[0], segments[0]
        }</span> else<span class="cov8" title="1"> if len(segments) == 2 </span><span class="cov8" title="1">{
                startIPStr = strings.Trim(segments[0], " \t")
                endIPStr = strings.Trim(segments[1], " \t")
        }</span> else<span class="cov0" title="0"> {
                return nil, nil, fmt.Errorf("checkSplit(): err, line is: %s", line)
        }</span>

        // startIPStr format err
        <span class="cov8" title="1">if startIP = net.ParseIP(startIPStr); startIP == nil </span><span class="cov8" title="1">{
                return nil, nil, fmt.Errorf("checkSplit(): line %s format err", line)
        }</span>

        // endIPStr format err
        <span class="cov8" title="1">if endIP = net.ParseIP(endIPStr); endIP == nil </span><span class="cov8" title="1">{
                return nil, nil, fmt.Errorf("checkSplit(): line %s format err", line)
        }</span>

        <span class="cov8" title="1">return startIP, endIP, nil</span>
}

// checkLine checks line format
func checkLine(line string) (net.IP, net.IP, error) <span class="cov8" title="1">{
        var startIP, endIP net.IP
        var err error

        // check cidr format first
        startIP, endIP, err = checkCIDR(line)
        if startIP != nil &amp;&amp; endIP != nil &amp;&amp; err == nil </span><span class="cov8" title="1">{
                return startIP, endIP, nil
        }</span>

        // check space split segment
        <span class="cov8" title="1">startIP, endIP, err = checkSplit(line, " ")
        if err != nil </span><span class="cov8" title="1">{
                // check tab split segment
                startIP, endIP, err = checkSplit(line, "\t")
                if err != nil </span><span class="cov8" title="1">{
                        return nil, nil, fmt.Errorf("checkLine(): err, %s", err.Error())
                }</span>
        }

        <span class="cov8" title="1">return startIP, endIP, err</span>
}

// checkCIDR check cidr format
// legal format is [ipv4|ipv6]/xxx
func checkCIDR(line string) (net.IP, net.IP, error) <span class="cov8" title="1">{
        _, netIP, err := net.ParseCIDR(line)
        if err != nil </span><span class="cov8" title="1">{
                return nil, nil, err
        }</span>
        <span class="cov8" title="1">return netIP.IP, getLastIPAddress(netIP), nil</span>
}

/* check Version num and load IP txt file to IP items in memory */
func (f TxtFileLoader) CheckAndLoad(curVersion string) (*ipdict.IPItems, error) <span class="cov8" title="1">{
        var startIP, endIP net.IP

        fileName := f.fileName
        // get file Version and lineNum
        metaInfo, err := getFileInfo(fileName)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("loadFile(): %s %s", fileName, err.Error())
        }</span>
        <span class="cov8" title="1">newVersion := metaInfo.Version
        singleIPNum := metaInfo.SingleIPNum
        pairIPNum := metaInfo.PairIPNum

        // if singleIPNum + pairIPNum &gt; maxLine
        // use maxline for singleIPNum and pairIPNum(protect malloc failed)
        // but the dict will still cut off by maxLine
        if f.maxLine != -1 &amp;&amp; singleIPNum+pairIPNum &gt; f.maxLine </span><span class="cov0" title="0">{
                singleIPNum = f.maxLine
                pairIPNum = f.maxLine
        }</span>

        // check version
        <span class="cov8" title="1">if newVersion == curVersion &amp;&amp; newVersion != "" </span><span class="cov0" title="0">{
                return nil, ErrNoNeedUpdate
        }</span>

        // init counter for singleIP &amp; pairIP
        <span class="cov8" title="1">singleIPCounter := 0
        pairIPCounter := 0
        lineCounter := 0
        // open file
        file, err := os.Open(fileName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("loadFile(): %s, %s", fileName, err.Error())
        }</span>
        <span class="cov8" title="1">defer file.Close()
        // create ipItems
        ipItems, err := ipdict.NewIPItems(singleIPNum, pairIPNum)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        // scan the file line by line
        <span class="cov8" title="1">scanner := bufio.NewScanner(file)
        for scanner.Scan() </span><span class="cov8" title="1">{

                // Remove all leading and trailing spaces and tabs
                line := strings.Trim(scanner.Text(), " \t")
                //Line begins with "#" is considered as a comment
                if strings.HasPrefix(line, "#") || len(line) == 0 </span><span class="cov8" title="1">{
                        continue</span>
                }

                // Check line format
                <span class="cov8" title="1">startIP, endIP, err = checkLine(line)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("loadFile(): err, %s", err.Error())
                }</span>

                // insert start ip and end ip into dict
                <span class="cov8" title="1">if bytes.Equal(startIP, endIP) </span><span class="cov0" title="0">{
                        // startIp == endIP insert single
                        err = ipItems.InsertSingle(startIP)
                        singleIPCounter += 1
                }</span> else<span class="cov8" title="1"> {
                        err = ipItems.InsertPair(startIP, endIP)
                        pairIPCounter += 1
                }</span>
                <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("loadFile(): err, %s", err.Error())
                }</span>

                // check if lineCounter &gt; maxLine or not
                <span class="cov8" title="1">lineCounter += 1
                if f.maxLine != -1 &amp;&amp; lineCounter &gt; f.maxLine </span><span class="cov0" title="0">{
                        //sort dict
                        ipItems.Sort()
                        ipItems.Version = newVersion
                        return ipItems, ErrMaxLineExceed
                }</span>

                // if ipcounter &gt; max ipnum
                <span class="cov8" title="1">if singleIPCounter &gt; singleIPNum || pairIPCounter &gt; pairIPNum </span><span class="cov0" title="0">{
                        //sort dict
                        ipItems.Sort()
                        ipItems.Version = newVersion
                        return ipItems, ErrMaxLineExceed
                }</span>
        }

        <span class="cov8" title="1">err = scanner.Err()
        // Scan meets error
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("loadFile(): err, %s", err.Error())
        }</span>

        // Load succ, sort dict
        <span class="cov8" title="1">ipItems.Sort()
        ipItems.Version = newVersion
        return ipItems, nil</span>
}

// getLastIPAddress
// get last ip address for cidr
// 192.168.1.1/20 last address is 192.168.15.255
const (
        ipv4BitsLen = 32
        ipv6BitsLen = 128
)

func getLastIPAddress(ipNet *net.IPNet) net.IP <span class="cov8" title="1">{
        if ipNet == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">ones, bits := ipNet.Mask.Size()
        lastIP := make(net.IP, 4) // default set ipv4

        switch bits </span>{
        case ipv6BitsLen:<span class="cov8" title="1">
                ipv6Count := (&amp;big.Int{}).Lsh(big.NewInt(1), uint(bits-ones))
                startIPBytes := (&amp;big.Int{}).SetBytes(ipNet.IP)

                lastIP = (&amp;big.Int{}).Add(startIPBytes, big.NewInt(0).Sub(ipv6Count, big.NewInt(1))).Bytes()</span>
        case ipv4BitsLen:<span class="cov8" title="1">
                ipv4Count := uint32(1 &lt;&lt; (bits - ones))
                startIPBytes := binary.BigEndian.Uint32(ipNet.IP)

                binary.BigEndian.PutUint32(lastIP, startIPBytes+ipv4Count-1)</span>
        default:<span class="cov0" title="0">
                return nil</span>
        }
        <span class="cov8" title="1">return lastIP</span>
}
</pre>
		
		<pre class="file" id="file284" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package json

import (
        "io"
)

import (
        jsoniter "github.com/json-iterator/go"
)

func NewDecoder(reader io.Reader) *jsoniter.Decoder <span class="cov8" title="1">{
        return jsoniter.ConfigCompatibleWithStandardLibrary.NewDecoder(reader)
}</span>

func NewEncoder(writer io.Writer) *jsoniter.Encoder <span class="cov0" title="0">{
        return jsoniter.ConfigCompatibleWithStandardLibrary.NewEncoder(writer)
}</span>

func Marshal(v interface{}) ([]byte, error) <span class="cov8" title="1">{
        return jsoniter.ConfigCompatibleWithStandardLibrary.Marshal(v)
}</span>

func MarshalToString(v interface{}) (string, error) <span class="cov8" title="1">{
        return jsoniter.ConfigCompatibleWithStandardLibrary.MarshalToString(v)

}</span>

func MarshalIndent(v interface{}, prefix, indent string) ([]byte, error) <span class="cov8" title="1">{
        return jsoniter.ConfigCompatibleWithStandardLibrary.MarshalIndent(v, prefix, indent)

}</span>

func UnmarshalFromString(str string, v interface{}) error <span class="cov8" title="1">{
        return jsoniter.UnmarshalFromString(str, v)
}</span>

func Unmarshal(data []byte, v interface{}) error <span class="cov8" title="1">{
        return jsoniter.Unmarshal(data, v)
}</span>
</pre>
		
		<pre class="file" id="file285" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package bfe_util

import (
        "fmt"
        "io/ioutil"
        "os"
        "path"
        "reflect"
)

import (
        "github.com/bfenetworks/bfe/bfe_util/json"
)

// LoadJsonFile loads json content from file, unmarshal to jsonObject.
// check if all field is set if checkNilPointer is true
// check if any field is not pointer type if allowNoPointerField is false
func LoadJsonFile(path string, jsonObject interface{}) error <span class="cov0" title="0">{
        buf, err := ioutil.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := json.Unmarshal(buf, jsonObject); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// DumpJson dumps json file.
func DumpJson(jsonObject interface{}, filePath string, perm os.FileMode) error <span class="cov0" title="0">{
        buf, err := json.MarshalIndent(jsonObject, "", "    ")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("marshal err %s", err)
        }</span>

        // mkdir all dir
        <span class="cov0" title="0">dirPath := path.Dir(filePath)
        if err = os.MkdirAll(dirPath, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("MkdirALl err %s", err.Error())
        }</span>
        <span class="cov0" title="0">return ioutil.WriteFile(filePath, buf, perm)</span>
}

// CheckNilField check if a struct has a nil field
// if allowNoPointerField is false, it also check if fields are all pointers
// if param object is not a struct , return nil
func CheckNilField(object interface{}, allowNoPointerField bool) error <span class="cov0" title="0">{
        v := reflect.ValueOf(object)
        if v.Kind() != reflect.Struct </span><span class="cov0" title="0">{
                return fmt.Errorf("input is not struct")
        }</span>

        <span class="cov0" title="0">typeOfV := v.Type()
        for i := 0; i &lt; v.NumField(); i++ </span><span class="cov0" title="0">{
                f := v.Field(i)
                if f.Kind() != reflect.Ptr </span><span class="cov0" title="0">{
                        if !allowNoPointerField </span><span class="cov0" title="0">{
                                return fmt.Errorf("%s field %s is not a pointer", typeOfV, typeOfV.Field(i).Name)
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }

                <span class="cov0" title="0">if f.IsNil() </span><span class="cov0" title="0">{
                        return fmt.Errorf("%s field %s is not set", typeOfV, typeOfV.Field(i).Name)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file286" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package bfe_util

import (
        "fmt"
        "net"
        "sync"
        "time"
)

import (
        http "github.com/bfenetworks/bfe/bfe_http"
        tls "github.com/bfenetworks/bfe/bfe_tls"
)

// A MockServer is an tls/tcp server listening on a system-chosen port on the
// local loopback interface, for use in end-to-end tests.
type MockServer struct {
        Listener net.Listener

        // optional fields for tls server
        TLS    *tls.Config
        Config *http.Server

        // optional fields for tcp server
        Handler MockHandler
}

// A MockHandler is an handler to process established conn on server side
type MockHandler func(conn net.Conn)

// NewUnstartedServer returns a new Server but doesn't start it.
// After changing its configuration, the caller should call StartTLS.
// The caller should call Close when finished, to shut it down.
func NewUnstartedServer(handler interface{}) *MockServer <span class="cov0" title="0">{
        ms := new(MockServer)
        ms.Listener = newLocalListener()
        ms.Config = &amp;http.Server{
                CloseNotifyCh:           make(chan bool),
                GracefulShutdownTimeout: 3 * time.Second,
                ReadTimeout:             60 * time.Second,
        }

        switch h := handler.(type) </span>{
        case http.Handler:<span class="cov0" title="0">
                ms.Config.Handler = h</span>

        case MockHandler:<span class="cov0" title="0">
                ms.Handler = h</span>
        }

        <span class="cov0" title="0">return ms</span>
}

// StartTLS starts TLS on a server from NewUnstartedServer.
func (s *MockServer) StartTLS() <span class="cov0" title="0">{
        cert, err := tls.X509KeyPair(localhostCert, localhostKey)
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("NewTLSServer: %v", err))</span>
        }

        // init tls config and tls listener
        <span class="cov0" title="0">if s.TLS == nil </span><span class="cov0" title="0">{
                s.TLS = new(tls.Config)
        }</span>
        <span class="cov0" title="0">if len(s.TLS.Certificates) == 0 </span><span class="cov0" title="0">{
                s.TLS.Certificates = []tls.Certificate{cert}
        }</span>
        <span class="cov0" title="0">tlsListener := tls.NewListener(s.Listener, s.TLS)
        s.Listener = &amp;historyListener{Listener: tlsListener}

        // start tls server
        go s.Serve(s.Listener)</span>
}

// StartTCP starts TCP on a server from NewUnstartedServer.
func (s *MockServer) StartTCP() <span class="cov0" title="0">{
        s.Listener = &amp;historyListener{Listener: s.Listener}
        go s.Serve(s.Listener)
}</span>

func (s *MockServer) Serve(l net.Listener) error <span class="cov0" title="0">{
        defer l.Close()
        for </span><span class="cov0" title="0">{
                rw, e := l.Accept()
                if e != nil </span><span class="cov0" title="0">{
                        if ne, ok := e.(net.Error); ok &amp;&amp; ne.Temporary() </span><span class="cov0" title="0">{
                                time.Sleep(5 * time.Millisecond)
                                continue</span>
                        }
                        <span class="cov0" title="0">return e</span>
                }
                <span class="cov0" title="0">c := MockConn{server: s, rwc: rw}
                go c.serve()</span>
        }
}

// Close shuts down the server and blocks until all outstanding
// requests on this server have completed.
func (s *MockServer) Close() <span class="cov0" title="0">{
        s.Listener.Close()
        s.CloseClientConnections()
}</span>

// CloseClientConnections closes any currently open HTTP connections
// to the test Server.
func (s *MockServer) CloseClientConnections() <span class="cov0" title="0">{
        hl, ok := s.Listener.(*historyListener)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">hl.Lock()
        for _, conn := range hl.history </span><span class="cov0" title="0">{
                conn.Close()
        }</span>
        <span class="cov0" title="0">hl.Unlock()</span>
}

// historyListener keeps track of all connections that it's ever
// accepted.
type historyListener struct {
        net.Listener
        sync.Mutex // protects history
        history    []net.Conn
}

func (hs *historyListener) Accept() (c net.Conn, err error) <span class="cov0" title="0">{
        c, err = hs.Listener.Accept()
        if err == nil </span><span class="cov0" title="0">{
                hs.Lock()
                hs.history = append(hs.history, c)
                hs.Unlock()
        }</span>
        <span class="cov0" title="0">return</span>
}

func newLocalListener() net.Listener <span class="cov0" title="0">{
        l, err := net.Listen("tcp", "127.0.0.1:0")
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("failed to listen on a port: %v", err))</span>
        }
        <span class="cov0" title="0">return l</span>
}

type MockConn struct {
        server *MockServer
        rwc    net.Conn
}

// Serve a new connection.
func (c *MockConn) serve() <span class="cov0" title="0">{
        if tlsConn, ok := c.rwc.(*tls.Conn); ok </span><span class="cov0" title="0">{
                if err := tlsConn.Handshake(); err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">tlsState := tlsConn.ConnectionState()
                proto := tlsState.NegotiatedProtocol
                if fn := c.server.Config.TLSNextProto[proto]; fn != nil </span><span class="cov0" title="0">{
                        h := c.server.Config.Handler
                        fn(c.server.Config, tlsConn, h)
                }</span>
        } else<span class="cov0" title="0"> {
                fn := c.server.Handler
                fn(c.rwc)
        }</span>
}

// LocalhostCert is a PEM-encoded TLS cert with SAN IPs
// "127.0.0.1" and "[::1]", expiring at Jan 29 16:00:00 2084 GMT.
// generated from src/crypto/tls:
// go run generate_cert.go  --rsa-bits 1024 --host 127.0.0.1,::1,example.com --ca --start-date "Jan 1 00:00:00 1970" --duration=1000000h
var localhostCert = []byte(`-----BEGIN CERTIFICATE-----
MIICEzCCAXygAwIBAgIQMIMChMLGrR+QvmQvpwAU6zANBgkqhkiG9w0BAQsFADAS
MRAwDgYDVQQKEwdBY21lIENvMCAXDTcwMDEwMTAwMDAwMFoYDzIwODQwMTI5MTYw
MDAwWjASMRAwDgYDVQQKEwdBY21lIENvMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCB
iQKBgQDuLnQAI3mDgey3VBzWnB2L39JUU4txjeVE6myuDqkM/uGlfjb9SjY1bIw4
iA5sBBZzHi3z0h1YV8QPuxEbi4nW91IJm2gsvvZhIrCHS3l6afab4pZBl2+XsDul
rKBxKKtD1rGxlG4LjncdabFn9gvLZad2bSysqz/qTAUStTvqJQIDAQABo2gwZjAO
BgNVHQ8BAf8EBAMCAqQwEwYDVR0lBAwwCgYIKwYBBQUHAwEwDwYDVR0TAQH/BAUw
AwEB/zAuBgNVHREEJzAlggtleGFtcGxlLmNvbYcEfwAAAYcQAAAAAAAAAAAAAAAA
AAAAATANBgkqhkiG9w0BAQsFAAOBgQCEcetwO59EWk7WiJsG4x8SY+UIAA+flUI9
tyC4lNhbcF2Idq9greZwbYCqTTTr2XiRNSMLCOjKyI7ukPoPjo16ocHj+P3vZGfs
h1fIw3cSS2OolhloGw/XM6RWPWtPAlGykKLciQrBru5NAPvCMsb/I1DAceTiotQM
fblo6RBxUQ==
-----END CERTIFICATE-----`)

// LocalhostKey is the private key for localhostCert.
var localhostKey = []byte(`-----BEGIN RSA PRIVATE KEY-----
MIICXgIBAAKBgQDuLnQAI3mDgey3VBzWnB2L39JUU4txjeVE6myuDqkM/uGlfjb9
SjY1bIw4iA5sBBZzHi3z0h1YV8QPuxEbi4nW91IJm2gsvvZhIrCHS3l6afab4pZB
l2+XsDulrKBxKKtD1rGxlG4LjncdabFn9gvLZad2bSysqz/qTAUStTvqJQIDAQAB
AoGAGRzwwir7XvBOAy5tM/uV6e+Zf6anZzus1s1Y1ClbjbE6HXbnWWF/wbZGOpet
3Zm4vD6MXc7jpTLryzTQIvVdfQbRc6+MUVeLKwZatTXtdZrhu+Jk7hx0nTPy8Jcb
uJqFk541aEw+mMogY/xEcfbWd6IOkp+4xqjlFLBEDytgbIECQQDvH/E6nk+hgN4H
qzzVtxxr397vWrjrIgPbJpQvBsafG7b0dA4AFjwVbFLmQcj2PprIMmPcQrooz8vp
jy4SHEg1AkEA/v13/5M47K9vCxmb8QeD/asydfsgS5TeuNi8DoUBEmiSJwma7FXY
fFUtxuvL7XvjwjN5B30pNEbc6Iuyt7y4MQJBAIt21su4b3sjXNueLKH85Q+phy2U
fQtuUE9txblTu14q3N7gHRZB4ZMhFYyDy8CKrN2cPg/Fvyt0Xlp/DoCzjA0CQQDU
y2ptGsuSmgUtWj3NM9xuwYPm+Z/F84K6+ARYiZ6PYj013sovGKUFfYAqVXVlxtIX
qyUBnu3X9ps8ZfjLZO7BAkEAlT4R5Yl6cGhaJQYZHOde3JEMhNRcVFMO8dJDaFeo
f9Oeos0UUothgiDktdQHxdNEwLjQf7lJJBzV+5OtwswCWA==
-----END RSA PRIVATE KEY-----`)
</pre>
		
		<pre class="file" id="file287" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package net_util

import (
        "bufio"
        "errors"
        "fmt"
        "os"
        "strings"
        "sync"
        "time"
)

import (
        "github.com/zmap/go-iptree/iptree"
)

const (
        ACL_NOT_FOUND = "acl_not_found" // it is used when clientip is not found in acl table
)

type AclTable struct {
        reloadTimestamp string         // timestamp of reloading acl table, e.g. "20171201145259"
        ipTree          *iptree.IPTree // tree for ip string to acl name, e.g. "yunnan.cmnet"
        mutex           sync.RWMutex   // mutex for access the ipTree and reloadTimestamp
}

func NewAclTable() *AclTable <span class="cov0" title="0">{
        aclTable := new(AclTable)
        aclTable.ipTree = iptree.New()
        return aclTable
}</span>

func (t *AclTable) GetAclName(ip string) string <span class="cov0" title="0">{
        t.mutex.RLock()
        curTree := t.ipTree
        t.mutex.RUnlock()

        val, found, err := curTree.GetByString(ip)
        if err != nil || !found </span><span class="cov0" title="0">{
                return ACL_NOT_FOUND
        }</span>

        <span class="cov0" title="0">return val.(string)</span>
}

func (t *AclTable) LoadFromFile(file *os.File) error <span class="cov0" title="0">{
        scanner := bufio.NewScanner(file)
        parsing := "header" // "header" or "data"

        // make new ip tree
        newIpTree := iptree.New()

        // parse acl conf file, write new ip tree and acl map
        var err error
        var aclName string
        for scanner.Scan() </span><span class="cov0" title="0">{
                line := scanner.Text()
                if parsing == "header" </span><span class="cov0" title="0">{
                        // get header
                        if line[0:3] == "acl" </span><span class="cov0" title="0">{
                                aclName, err = parseAclHeaderLine(line)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">parsing = "data"</span>
                        }
                } else<span class="cov0" title="0"> if parsing == "data" </span><span class="cov0" title="0">{
                        if line == "};" </span><span class="cov0" title="0">{
                                parsing = "header"
                        }</span> else<span class="cov0" title="0"> {
                                ip, err := parseAclDataLine(line)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>

                                <span class="cov0" title="0">newIpTree.AddByString(ip, aclName)</span>
                        }
                }
        }

        <span class="cov0" title="0">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // get current timestamp
        <span class="cov0" title="0">now := time.Now()
        timestamp := fmt.Sprintf("%d%02d%02d%02d%02d%02d\n",
                now.Year(), now.Month(), now.Day(), now.Hour(), now.Minute(), now.Second())

        // update acl table members synchronously
        t.mutex.Lock()
        t.ipTree = newIpTree
        t.reloadTimestamp = timestamp
        t.mutex.Unlock()

        return nil</span>
}

// parse acl line, e.g.,: acl "henan.cnc" {
func parseAclHeaderLine(line string) (string, error) <span class="cov0" title="0">{
        var aclName string
        if line[0:3] == "acl" </span><span class="cov0" title="0">{
                tokens := strings.Split(line, " ")
                if len(tokens) != 3 </span><span class="cov0" title="0">{
                        return aclName, errors.New("format error:" + line)
                }</span>

                <span class="cov0" title="0">aclName = tokens[1]
                aclName = strings.Trim(aclName, "\"")
                return aclName, nil</span>
        }

        <span class="cov0" title="0">return aclName, errors.New("format error:" + line)</span>
}

// parse acl data line, e.g.: 36.193.110.0/23;
func parseAclDataLine(line string) (string, error) <span class="cov0" title="0">{
        var ip string
        n := len(line)
        if line[n-1] == ';' </span><span class="cov0" title="0">{
                ip = line[0 : n-1]
                return ip, nil
        }</span>

        <span class="cov0" title="0">return ip, errors.New("format error:" + line)</span>
}
</pre>
		
		<pre class="file" id="file288" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package net_util

import (
        "bytes"
        "fmt"
        "net"
)

//IpRange - a structure that holds the start and end of a range of ip addresses
type IpRange struct {
        start net.IP
        end   net.IP
}

// private ip range
var privateRanges = []IpRange{
        {
                start: net.ParseIP("10.0.0.0").To4(),
                end:   net.ParseIP("10.255.255.255").To4(),
        },
        {
                start: net.ParseIP("172.16.0.0").To4(),
                end:   net.ParseIP("172.31.255.255").To4(),
        },
        {
                start: net.ParseIP("192.168.0.0").To4(),
                end:   net.ParseIP("192.168.255.255").To4(),
        },
}

// InRange checks whether a given ip address is within a range given
func InRange(r IpRange, ip net.IP) bool <span class="cov8" title="1">{
        return bytes.Compare(ip, r.start) &gt;= 0 &amp;&amp; bytes.Compare(ip, r.end) &lt;= 0
}</span>

// ParseIPv4 parse IP addr from string to net.IP
//
// Params:
//     - s: IP addr in string, e.g., "1.2.3.4"
//
// Returns:
//     IP addr in net.IP
func ParseIPv4(s string) net.IP <span class="cov8" title="1">{
        ip := net.ParseIP(s)

        if ip != nil </span><span class="cov8" title="1">{
                ip = ip.To4()
        }</span>

        <span class="cov8" title="1">return ip</span>
}

// IPv4ToUint32 convert net.IP to uint32
//
// e.g., 1.2.3.4 to 0x01020304
//
// Params:
//     - ipBytes: IPv4 addr in net.IP
//
// Returns:
//     IPv4 addr in uint32
func IPv4ToUint32(ipBytes net.IP) (uint32, error) <span class="cov8" title="1">{
        if len(ipBytes) != 4 </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("ip bytes len: %d", len(ipBytes))
        }</span>

        <span class="cov8" title="1">var ipNum uint32
        var tmp uint32

        for i, b := range ipBytes </span><span class="cov8" title="1">{
                tmp = uint32(b)
                ipNum |= (tmp &lt;&lt; uint((3-i)*8))
        }</span>

        <span class="cov8" title="1">return ipNum, nil</span>
}

// IPv4StrToUint32 convert IPv4 string to uint32
//
// e.g., "1.2.3.4" to 0x01020304
//
// Params:
//     - ipStr: IPv4 addr in string
//
// Returns:
//     IPv4 addr in uint32
func IPv4StrToUint32(ipStr string) (uint32, error) <span class="cov8" title="1">{
        ip := ParseIPv4(ipStr)
        if ip == nil </span><span class="cov8" title="1">{
                return 0, fmt.Errorf("invalid IPv4 addr string: %s", ipStr)
        }</span>

        <span class="cov8" title="1">return IPv4ToUint32(ip)</span>
}

// Uint32ToIPv4 convert uint32 net.IP
//
// e.g., 0x01020304 to 1.2.3.4
//
// Params:
//     - ipNum: IPv4 addr in uint32
//
// Returns:
//     IPv4 addr in net.IP
func Uint32ToIPv4(ipNum uint32) net.IP <span class="cov8" title="1">{
        var ipBytes [4]byte

        for i := 0; i &lt; 4; i++ </span><span class="cov8" title="1">{
                ipBytes[3-i] = byte(ipNum &amp; 0xFF)
                ipNum &gt;&gt;= 8
        }</span>

        <span class="cov8" title="1">return net.IPv4(ipBytes[0], ipBytes[1], ipBytes[2], ipBytes[3]).To4()</span>
}

// Uint32ToIPv4Str convert uint32 to str
//
// e.g., 0x01020304 to "1.2.3.4"
//
// Params:
//     - ipNum: IPv4 addr in uint32
//
// Returns:
//     IPv4 addr in string
func Uint32ToIPv4Str(ipNum uint32) string <span class="cov8" title="1">{
        str := fmt.Sprintf("%d.%d.%d.%d", byte(ipNum&gt;&gt;24), byte(ipNum&gt;&gt;16), byte(ipNum&gt;&gt;8), byte(ipNum))

        return str
}</span>

// IsIPv4Address Check input is ipv4 address or not.
//
// param:
//     - input: a string
// return:
//     bool
func IsIPv4Address(input string) bool <span class="cov8" title="1">{
        return net.ParseIP(input).To4() != nil
}</span>

// IsPrivateIp Check to see if an ip is in a private subnet.
//
// param:
//     - input: an ip string
// return:
//     bool
func IsPrivateIp(input string) bool <span class="cov8" title="1">{
        if ip := net.ParseIP(input).To4(); ip != nil </span><span class="cov8" title="1">{
                for _, r := range privateRanges </span><span class="cov8" title="1">{
                        if InRange(r, ip) </span><span class="cov8" title="1">{
                                return true
                        }</span>
                }
        }
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file289" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Copyright 2014 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package pipe

import (
        "errors"
)

// FixedBuffer is an io.ReadWriter backed by a fixed size buffer.
// It never allocates, but moves old data as new data is written.
type FixedBuffer struct {
        buf  []byte
        r, w int
}

var (
        errReadEmpty = errors.New("read from empty FixedBuffer")
        errWriteFull = errors.New("write on full FixedBuffer")
)

// Read copies bytes from the buffer into p.
// It is an error to read when no data is available.
func (b *FixedBuffer) Read(p []byte) (n int, err error) <span class="cov8" title="1">{
        if b.r == b.w </span><span class="cov8" title="1">{
                return 0, errReadEmpty
        }</span>
        <span class="cov8" title="1">n = copy(p, b.buf[b.r:b.w])
        b.r += n
        if b.r == b.w </span><span class="cov8" title="1">{
                b.r = 0
                b.w = 0
        }</span>
        <span class="cov8" title="1">return n, nil</span>
}

// Len returns the number of bytes of the unread portion of the buffer.
func (b *FixedBuffer) Len() int <span class="cov0" title="0">{
        return b.w - b.r
}</span>

// Write copies bytes from p into the buffer.
// It is an error to write more data than the buffer can hold.
func (b *FixedBuffer) Write(p []byte) (n int, err error) <span class="cov8" title="1">{
        // Slide existing data to beginning.
        if b.r &gt; 0 &amp;&amp; len(p) &gt; len(b.buf)-b.w </span><span class="cov8" title="1">{
                copy(b.buf, b.buf[b.r:b.w])
                b.w -= b.r
                b.r = 0
        }</span>

        // Write new data.
        <span class="cov8" title="1">n = copy(b.buf[b.w:], p)
        b.w += n
        if n &lt; len(p) </span><span class="cov8" title="1">{
                err = errWriteFull
        }</span>
        <span class="cov8" title="1">return n, err</span>
}

func NewFixedBuffer(buf []byte) *FixedBuffer <span class="cov0" title="0">{
        b := new(FixedBuffer)
        b.buf = buf
        return b
}</span>

// Reset clear state of FixedBuffer.
func (b *FixedBuffer) Reset() <span class="cov0" title="0">{
        b.w = 0
        b.r = 0
}</span>
</pre>
		
		<pre class="file" id="file290" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Copyright 2014 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// A goroutine-safe Reader/Writer pair

package pipe

import (
        "errors"
        "io"
        "sync"
)

// Pipe is a goroutine-safe io.Reader/io.Writer pair.  It's like
// io.Pipe except there are no PipeReader/PipeWriter halves, and the
// underlying buffer is an interface. (io.Pipe is always unbuffered)
type Pipe struct {
        mu       sync.Mutex
        c        sync.Cond // c.L lazily initialized to &amp;p.mu
        b        PipeBuffer
        err      error         // read error once empty. non-nil means closed.
        breakErr error         // immediate read error (caller doesn't see rest of b)
        donec    chan struct{} // closed on error
        readFn   func()        // optional code to run in Read before error
}

type PipeBuffer interface {
        Len() int
        Reset()
        io.Writer
        io.Reader
}

// Read waits until data is available and copies bytes
// from the buffer into p.
func (p *Pipe) Read(d []byte) (n int, err error) <span class="cov8" title="1">{
        p.mu.Lock()
        defer p.mu.Unlock()
        if p.c.L == nil </span><span class="cov0" title="0">{
                p.c.L = &amp;p.mu
        }</span>
        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                if p.breakErr != nil </span><span class="cov8" title="1">{
                        return 0, p.breakErr
                }</span>
                <span class="cov8" title="1">if p.b != nil &amp;&amp; p.b.Len() &gt; 0 </span><span class="cov8" title="1">{
                        return p.b.Read(d)
                }</span>
                <span class="cov8" title="1">if p.err != nil </span><span class="cov8" title="1">{
                        if p.readFn != nil </span><span class="cov0" title="0">{
                                p.readFn()     // e.g. copy trailers
                                p.readFn = nil // not sticky like p.err
                        }</span>
                        <span class="cov8" title="1">return 0, p.err</span>
                }
                <span class="cov0" title="0">p.c.Wait()</span>
        }
}

var errClosedPipeWrite = errors.New("write on closed buffer")

// Write copies bytes from p into the buffer and wakes a reader.
// It is an error to write more data than the buffer can hold.
func (p *Pipe) Write(d []byte) (n int, err error) <span class="cov8" title="1">{
        p.mu.Lock()
        defer p.mu.Unlock()
        if p.c.L == nil </span><span class="cov8" title="1">{
                p.c.L = &amp;p.mu
        }</span>
        <span class="cov8" title="1">defer p.c.Signal()
        if p.err != nil </span><span class="cov0" title="0">{
                return 0, errClosedPipeWrite
        }</span>
        <span class="cov8" title="1">if p.b == nil </span><span class="cov0" title="0">{
                return 0, errClosedPipeWrite
        }</span>
        <span class="cov8" title="1">return p.b.Write(d)</span>
}

// CloseWithError causes the next Read (waking up a current blocked
// Read if needed) to return the provided err after all data has been
// read.
//
// The error must be non-nil.
func (p *Pipe) CloseWithError(err error) <span class="cov8" title="1">{ p.closeWithError(&amp;p.err, err, nil) }</span>

// BreakWithError causes the next Read (waking up a current blocked
// Read if needed) to return the provided err immediately, without
// waiting for unread data.
func (p *Pipe) BreakWithError(err error) <span class="cov8" title="1">{ p.closeWithError(&amp;p.breakErr, err, nil) }</span>

// CloseWithErrorAndCode is like CloseWithError but also sets some code to run
// in the caller's goroutine before returning the error.
func (p *Pipe) CloseWithErrorAndCode(err error, fn func()) <span class="cov0" title="0">{ p.closeWithError(&amp;p.err, err, fn) }</span>

func (p *Pipe) closeWithError(dst *error, err error, fn func()) <span class="cov8" title="1">{
        if err == nil </span><span class="cov0" title="0">{
                panic("err must be non-nil")</span>
        }
        <span class="cov8" title="1">p.mu.Lock()
        defer p.mu.Unlock()
        if p.c.L == nil </span><span class="cov8" title="1">{
                p.c.L = &amp;p.mu
        }</span>
        <span class="cov8" title="1">defer p.c.Signal()
        if *dst != nil </span><span class="cov8" title="1">{
                // Note: Here we do not consider the existing io.EOF(i.e. *dst) as a real error
                // and replace it if necessary. The error handling policy allows us to release
                // underlying resource(eg. PipeBuffer) as soon as possible.
                if *dst == io.EOF </span><span class="cov0" title="0">{
                        *dst = err
                }</span>
                // Already been done.
                <span class="cov8" title="1">return</span>
        }
        <span class="cov8" title="1">p.readFn = fn
        *dst = err
        p.closeDoneLocked()</span>
}

// requires p.mu be held.
func (p *Pipe) closeDoneLocked() <span class="cov8" title="1">{
        if p.donec == nil </span><span class="cov8" title="1">{
                return
        }</span>
        // Close if unclosed. This isn't racy since we always
        // hold p.mu while closing.
        <span class="cov8" title="1">select </span>{
        case &lt;-p.donec:<span class="cov0" title="0"></span>
        default:<span class="cov8" title="1">
                close(p.donec)</span>
        }
}

// Err returns the error (if any) first set by BreakWithError or CloseWithError.
func (p *Pipe) Err() error <span class="cov0" title="0">{
        p.mu.Lock()
        defer p.mu.Unlock()
        if p.breakErr != nil </span><span class="cov0" title="0">{
                return p.breakErr
        }</span>
        <span class="cov0" title="0">return p.err</span>
}

// Done returns a channel which is closed if and when this pipe is closed
// with CloseWithError.
func (p *Pipe) Done() &lt;-chan struct{} <span class="cov8" title="1">{
        p.mu.Lock()
        defer p.mu.Unlock()
        if p.donec == nil </span><span class="cov8" title="1">{
                p.donec = make(chan struct{})
                if p.err != nil || p.breakErr != nil </span><span class="cov8" title="1">{
                        // Already hit an error.
                        p.closeDoneLocked()
                }</span>
        }
        <span class="cov8" title="1">return p.donec</span>
}

func NewPipeWithSize(size uint32) *Pipe <span class="cov0" title="0">{
        p := new(Pipe)
        p.b = NewFixedBuffer(make([]byte, size))
        return p
}</span>

func NewPipeFromBufferPool(pool *sync.Pool) *Pipe <span class="cov0" title="0">{
        p := new(Pipe)
        p.b = pool.Get().(PipeBuffer)
        return p
}</span>

// Release releases underlying fixed buffer
func (p *Pipe) Release(pool *sync.Pool) <span class="cov0" title="0">{
        p.mu.Lock()
        defer p.mu.Unlock()

        p.b.Reset()
        pool.Put(p.b)
        p.b = nil
}</span>
</pre>
		
		<pre class="file" id="file291" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package semver

import (
        "errors"
        "strconv"
        "strings"
)

var (
        ErrSemverEmpty  = errors.New("version string empty")
        ErrSemverFormat = errors.New("version format error")
)

type Version struct {
        Major         uint64
        Minor         uint64
        Patch         uint64
        Blank         string // "-" or "+"
        BuildMetadata string
}

func New(ver string) (v Version, err error) <span class="cov8" title="1">{
        return parse(ver)
}</span>

func parse(ver string) (v Version, err error) <span class="cov8" title="1">{
        v = Version{}

        if ver == "" </span><span class="cov0" title="0">{
                return v, ErrSemverEmpty
        }</span>

        // major.minor.patch
        <span class="cov8" title="1">version := strings.SplitN(ver, ".", 3)
        if len(version) != 3 </span><span class="cov0" title="0">{
                return v, ErrSemverFormat
        }</span>

        // major
        <span class="cov8" title="1">v.Major, err = strconv.ParseUint(version[0], 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return v, err
        }</span>

        // minor
        <span class="cov8" title="1">v.Minor, err = strconv.ParseUint(version[1], 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return v, err
        }</span>

        // patch &amp; blank &amp; buildMetaData
        <span class="cov8" title="1">patchStr := version[2]
        inx := strings.IndexFunc(patchStr, func(r rune) bool </span><span class="cov8" title="1">{
                return r == '-' || r == '+'
        }</span>)

        <span class="cov8" title="1">if inx &gt; 0 </span><span class="cov8" title="1">{
                patch := patchStr[:inx]
                blank := patchStr[inx : inx+1]
                buildMetaData := patchStr[inx+1:]

                v.Patch, err = strconv.ParseUint(patch, 10, 64)
                if err != nil </span><span class="cov0" title="0">{
                        return v, err
                }</span>

                <span class="cov8" title="1">v.Blank = blank
                v.BuildMetadata = buildMetaData</span>
        } else<span class="cov8" title="1"> {
                v.Patch, err = strconv.ParseUint(patchStr, 10, 64)
                if err != nil </span><span class="cov0" title="0">{
                        return v, err
                }</span>
        }

        <span class="cov8" title="1">return</span>
}

func (v Version) String() string <span class="cov8" title="1">{
        b := make([]byte, 0, 5)
        b = strconv.AppendUint(b, v.Major, 10)
        b = append(b, '.')
        b = strconv.AppendUint(b, v.Minor, 10)
        b = append(b, '.')
        b = strconv.AppendUint(b, v.Patch, 10)

        if v.Blank != "" </span><span class="cov8" title="1">{
                b = append(b, []byte(v.Blank)...)
                b = append(b, []byte(v.BuildMetadata)...)
        }</span>

        <span class="cov8" title="1">return string(b)</span>
}

// Equal compares Versions v to x:
// -1 == v is less than x
// 0 == v is equal to x
// 1 == v is greater than x
func (v Version) Equal(x Version) bool <span class="cov8" title="1">{
        return v.CompareMajor(x) == 0 &amp;&amp; v.CompareMinor(x) == 0 &amp;&amp; v.ComparePatch(x) == 0
}</span>

func (v Version) CompareMajor(x Version) int <span class="cov8" title="1">{
        if v.Major != x.Major </span><span class="cov0" title="0">{
                if v.Major &gt; x.Major </span><span class="cov0" title="0">{
                        return 1
                }</span>
                <span class="cov0" title="0">return -1</span>
        }
        <span class="cov8" title="1">return 0</span>
}

func (v Version) CompareMinor(x Version) int <span class="cov8" title="1">{
        if v.Minor != x.Minor </span><span class="cov0" title="0">{
                if v.Minor &gt; x.Minor </span><span class="cov0" title="0">{
                        return 1
                }</span>
                <span class="cov0" title="0">return -1</span>
        }
        <span class="cov8" title="1">return 0</span>
}

func (v Version) ComparePatch(x Version) int <span class="cov8" title="1">{
        if v.Patch != x.Patch </span><span class="cov0" title="0">{
                if v.Patch &gt; x.Patch </span><span class="cov0" title="0">{
                        return 1
                }</span>
                <span class="cov0" title="0">return -1</span>
        }
        <span class="cov8" title="1">return 0</span>
}
</pre>
		
		<pre class="file" id="file292" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package signal_table

import (
        "syscall"
)

// RegisterSignalHandlers register signal handlers
func RegisterSignalHandlers(signalTable *SignalTable) <span class="cov0" title="0">{
        // term handlers
        signalTable.Register(syscall.SIGTERM, TermHandler)

        // ignore handlers
        signalTable.Register(syscall.SIGHUP, IgnoreHandler)
        signalTable.Register(syscall.SIGQUIT, IgnoreHandler)
        signalTable.Register(syscall.SIGILL, IgnoreHandler)
        signalTable.Register(syscall.SIGTRAP, IgnoreHandler)
        signalTable.Register(syscall.SIGABRT, IgnoreHandler)
}</span>
</pre>
		
		<pre class="file" id="file293" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package signal_table

import (
        "os"
)

import (
        "github.com/baidu/go-lib/log"
)

// TermHandler deal with the signal that should terminate the process
func TermHandler(s os.Signal) <span class="cov0" title="0">{
        log.Logger.Info("termHandler(): receive signal[%v], terminate.", s)
        log.Logger.Close()
        os.Exit(0)
}</span>

// IgnoreHandler deal with the signal that should be ignored
func IgnoreHandler(s os.Signal) <span class="cov8" title="1">{
        log.Logger.Info("ignoreHandler(): receive signal[%v], ignore.", s)
}</span>
</pre>
		
		<pre class="file" id="file294" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package signal_table

import (
        "os"
        "os/signal"
)

import (
        "github.com/baidu/go-lib/web-monitor/module_state2"
)

import (
        "github.com/bfenetworks/bfe/bfe_util/json"
)

type signalHandler func(s os.Signal)

type SignalTable struct {
        shs   map[os.Signal]signalHandler // signal handle table
        state module_state2.State         // signal handle state
}

// NewSignalTable creates and init signal table
func NewSignalTable() *SignalTable <span class="cov8" title="1">{
        table := new(SignalTable)
        table.shs = make(map[os.Signal]signalHandler)
        table.state.Init()
        return table
}</span>

// Register registers signal handle to the table
func (t *SignalTable) Register(s os.Signal, handler signalHandler) <span class="cov8" title="1">{
        if _, ok := t.shs[s]; !ok </span><span class="cov8" title="1">{
                t.shs[s] = handler
        }</span>
}

// handle handles the related signal
func (t *SignalTable) handle(sig os.Signal) <span class="cov8" title="1">{
        t.state.Inc(sig.String(), 1)

        if handler, ok := t.shs[sig]; ok </span><span class="cov8" title="1">{
                handler(sig)
        }</span>
}

// signalHandle is the signal handle loop
func (t *SignalTable) signalHandle() <span class="cov0" title="0">{

        var sigs []os.Signal
        for sig := range t.shs </span><span class="cov0" title="0">{
                sigs = append(sigs, sig)
        }</span>

        <span class="cov0" title="0">c := make(chan os.Signal, len(sigs))
        signal.Notify(c, sigs...)

        for </span><span class="cov0" title="0">{
                sig := &lt;-c
                t.handle(sig)
        }</span>
}

// StartSignalHandle start go-routine for signal handle
func (t *SignalTable) StartSignalHandle() <span class="cov0" title="0">{
        go t.signalHandle()
}</span>

// SignalStateGet get state counter of signal handle
func (t *SignalTable) SignalStateGet() ([]byte, error) <span class="cov0" title="0">{

        buff, err := json.Marshal(t.state.GetAll())

        return buff, err
}</span>

// SetKeyPrefix set key prefix
func (t *SignalTable) SetKeyPrefix(key string) <span class="cov0" title="0">{
        t.state.SetKeyPrefix(key)
}</span>

// GetKeyPrefix get key prefix
func (t *SignalTable) GetKeyPrefix() string <span class="cov0" title="0">{
        return t.state.GetKeyPrefix()
}</span>
</pre>
		
		<pre class="file" id="file295" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

//go:build !windows
// +build !windows

package bfe_util

import (
        sys "golang.org/x/sys/unix"
)

// GetsockoptMultiByte returns the value of the socket option opt for the
// socket associated with fd at the given socket level.
func GetsockoptMultiByte(fd, level, opt int) ([]byte, error) <span class="cov0" title="0">{
        val, err := sys.GetsockoptString(fd, level, opt)
        return []byte(val), err
}</span>
</pre>
		
		<pre class="file" id="file296" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package bfe_util

import (
        "fmt"
        "strings"
        "time"
)

var (
        // TimeZoneMap reference: https://en.wikipedia.org/wiki/List_of_military_time_zones
        TimeZoneMap = map[string]int{ // alphabet =&gt; time offset
                "Y": -12 * 3600, // UTC-12
                "X": -11 * 3600,
                "W": -10 * 3600,
                "V": -9 * 3600,
                "U": -8 * 3600,
                "T": -7 * 3600,
                "S": -6 * 3600,
                "R": -5 * 3600,
                "Q": -4 * 3600,
                "P": -3 * 3600,
                "O": -2 * 3600,
                "N": -1 * 3600, // UTC-1
                "Z": 0,         // UTC
                "A": 1 * 3600,  // UTC-1
                "B": 2 * 3600,
                "C": 3 * 3600,
                "D": 4 * 3600,
                "E": 5 * 3600,
                "F": 6 * 3600,
                "G": 7 * 3600,
                "H": 8 * 3600,
                "I": 9 * 3600,
                "K": 10 * 3600,
                "L": 11 * 3600,
                "M": 12 * 3600, // UTC+12
        }
)

// ParseTime returns a time in UTC+0 time zone.
// Note: currently, we do not use time.LoadLocation func, because it has two issues:
// 1. abusing opening files: https://github.com/golang/go/issues/24844
// 2. the version of zone info file in all machines may differ.
func ParseTime(timeStr string) (time.Time, error) <span class="cov8" title="1">{
        format := "%14s%s"
        var prefixTimeStr, zone string
        _, err := fmt.Sscanf(timeStr, format, &amp;prefixTimeStr, &amp;zone)
        if err != nil </span><span class="cov8" title="1">{
                return time.Time{}, fmt.Errorf("invalid time string:%s, err:%s", timeStr, err.Error())
        }</span>
        <span class="cov8" title="1">tm, err := time.Parse("20060102150405", prefixTimeStr)
        if err != nil </span><span class="cov0" title="0">{
                return time.Time{}, fmt.Errorf("invalid time string:%s, err:%s", timeStr, err.Error())
        }</span>
        <span class="cov8" title="1">offset, ok := TimeZoneMap[strings.ToUpper(zone)]
        if !ok </span><span class="cov8" title="1">{
                return time.Time{}, fmt.Errorf("invalid zone:%s", zone)
        }</span>
        <span class="cov8" title="1">return tm.Add(time.Duration(-offset) * time.Second), nil</span>
}

// ParseTimeOfDay parser time string of a day
// timeStr: hhmmssZ, Z represents timezone
// return parsed time and offset of timezone
func ParseTimeOfDay(timeStr string) (time.Time, int, error) <span class="cov8" title="1">{
        format := "%6s%s"
        var prefixTimeStr, zone string
        _, err := fmt.Sscanf(timeStr, format, &amp;prefixTimeStr, &amp;zone)
        if err != nil </span><span class="cov8" title="1">{
                return time.Time{}, 0, fmt.Errorf("invalid time string:%s, err:%s", timeStr, err.Error())
        }</span>
        <span class="cov8" title="1">ts, err := time.Parse("15:04:05", fmt.Sprintf("%s:%s:%s", timeStr[0:2], timeStr[2:4], timeStr[4:6]))
        if err != nil </span><span class="cov0" title="0">{
                return time.Time{}, 0, fmt.Errorf("time format invalid, err:%s", err.Error())
        }</span>
        <span class="cov8" title="1">offset, ok := TimeZoneMap[strings.ToUpper(zone)]
        if !ok </span><span class="cov8" title="1">{
                return time.Time{}, 0, fmt.Errorf("invalid zone:%s", zone)
        }</span>
        <span class="cov8" title="1">return ts, offset, nil</span>
}
</pre>
		
		<pre class="file" id="file297" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package bfe_websocket

import (
        "errors"
        "net"
        "strings"
)

import (
        "github.com/bfenetworks/bfe/bfe_balance/backend"
        http "github.com/bfenetworks/bfe/bfe_http"
        tls "github.com/bfenetworks/bfe/bfe_tls"
)

import (
        "github.com/baidu/go-lib/web-monitor/metrics"
)

const (
        WebSocket = "websocket"
)

var (
        errBalanceHandler = errors.New("bfe_websocket: balanceHandler uninitial")
        errRetryTooMany   = errors.New("bfe_websocket: proxy retry too many")
)

// CheckUpgradeWebSocket checks whether client request for WebSocket protocol.
func CheckUpgradeWebSocket(req *http.Request) bool <span class="cov8" title="1">{
        if req.Method != "GET" </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if strings.ToLower(req.Header.Get("Upgrade")) != WebSocket </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if !strings.Contains(strings.ToLower(req.Header.Get("Connection")), "upgrade") </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return true</span>
}

// CheckAcceptWebSocket checks whether server accept WebSocket protocol.
func CheckAcceptWebSocket(rsp *http.Response) bool <span class="cov8" title="1">{
        if rsp.StatusCode != http.StatusSwitchingProtocols </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if strings.ToLower(rsp.Header.Get("Upgrade")) != WebSocket </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if strings.ToLower(rsp.Header.Get("Connection")) != "upgrade" </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">return true</span>
}

// Scheme returns scheme of current websocket conn.
func Scheme(c net.Conn) string <span class="cov0" title="0">{
        if _, ok := c.(*tls.Conn); ok </span><span class="cov0" title="0">{
                return "wss" // websocket over https
        }</span>
        <span class="cov0" title="0">return "ws"</span> // websocket over http
}

// BalanceHandler selects backend for current conn.
type BalanceHandler func(req interface{}) (*backend.BfeBackend, error)

// WebSocketState is internal state for WebSocket.
type WebSocketState struct {
        WebSocketErrBalance       *metrics.Counter
        WebSocketErrConnect       *metrics.Counter
        WebSocketErrProxy         *metrics.Counter
        WebSocketErrHandshake     *metrics.Counter
        WebSocketErrBackendReject *metrics.Counter
        WebSocketErrTransfer      *metrics.Counter
        WebSocketPanicConn        *metrics.Counter
        WebSocketBytesRecv        *metrics.Counter
        WebSocketBytesSent        *metrics.Counter
}

var state WebSocketState

// GetWebSocketState returns internal state for WebSocket.
func GetWebSocketState() *WebSocketState <span class="cov0" title="0">{
        return &amp;state
}</span>
</pre>
		
		<pre class="file" id="file298" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package bfe_websocket

import (
        "github.com/baidu/go-lib/gotrack"
)

import (
        http "github.com/bfenetworks/bfe/bfe_http"
)

const (
        defaultConnectTimeout  = 1000 // ms
        defaultConnectRetryMax = 3
)

type Server struct {
        // ConnectTimeout optionally specifies the timeout value (ms) to
        // connect backend. If zero, a default value is used.
        ConnectTimeout int

        // ConnectRetryMax optionally specifies the upper limit of connect
        // retris. If zero, a default value is used
        ConnectRetryMax int

        // BalanceHandler optionally specifies the handler for backends balance
        // BalanceHandler should not be nil.
        BalanceHandler BalanceHandler
}

func (s *Server) connectTimeout() int <span class="cov8" title="1">{
        if v := s.ConnectTimeout; v &gt; 0 </span><span class="cov8" title="1">{
                return v
        }</span>
        <span class="cov8" title="1">return defaultConnectTimeout</span>
}

func (s *Server) connectRetryMax() int <span class="cov8" title="1">{
        if v := s.ConnectRetryMax; v &gt; 0 </span><span class="cov8" title="1">{
                return v
        }</span>
        <span class="cov8" title="1">return defaultConnectRetryMax</span>
}

func (s *Server) balanceHandler() BalanceHandler <span class="cov8" title="1">{
        return s.BalanceHandler
}</span>

func (s *Server) handleConn(hs *http.Server, rw http.ResponseWriter, req *http.Request) *serverConn <span class="cov8" title="1">{
        sc := new(serverConn)
        sc.srv = s
        sc.hs = hs
        sc.rw = rw
        sc.req = req

        sc.closeNotifyCh = hs.CloseNotifyCh
        sc.errCh = make(chan error, 2)
        sc.serveG = gotrack.NewGoroutineLock()

        return sc
}</span>

// NewProtoHandler returns protocol handler for websocket.
func NewProtoHandler(conf *Server) func(*http.Server, http.ResponseWriter, *http.Request) <span class="cov8" title="1">{
        if conf == nil </span><span class="cov0" title="0">{
                conf = new(Server)
        }</span>

        <span class="cov8" title="1">protoHandler := func(hs *http.Server, w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                if sc := conf.handleConn(hs, w, r); sc != nil </span><span class="cov8" title="1">{
                        sc.serve()
                }</span>
        }
        <span class="cov8" title="1">return protoHandler</span>
}
</pre>
		
		<pre class="file" id="file299" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// websocket connection for server side

package bfe_websocket

import (
        "fmt"
        "io"
        "net"
        "time"
)

import (
        "github.com/baidu/go-lib/gotrack"
        "github.com/baidu/go-lib/log"
)

import (
        "github.com/bfenetworks/bfe/bfe_balance/backend"
        bufio "github.com/bfenetworks/bfe/bfe_bufio"
        http "github.com/bfenetworks/bfe/bfe_http"
)

type serverConn struct {
        // Immutable:
        srv           *Server             // server config for websocket proxy
        hs            *http.Server        // server config for http
        req           *http.Request       // handshake request
        rw            http.ResponseWriter // for handshake response
        cconn         net.Conn            // underlying conn to client
        bconn         net.Conn            // underlying conn to backend
        bbr           *bufio.Reader       // buffer reader to backend
        closeNotifyCh chan bool           // from outside -&gt; serve
        errCh         chan error          // from copy goroutine -&gt; serve

        // Everything following is owned by the serve loop
        serveG          gotrack.GoroutineLock // to verify funcs are on serve()
        shutdownTimerCh &lt;-chan time.Time      // nil until used
        shutdownTimer   *time.Timer           // nil until used
}

func (sc *serverConn) serve() <span class="cov8" title="1">{
        var err error
        var back *backend.BfeBackend

        sc.serveG.Check()
        defer sc.notePanic()
        defer func() </span><span class="cov8" title="1">{
                if sc.cconn != nil </span><span class="cov8" title="1">{
                        sc.cconn.Close()
                }</span>
                <span class="cov8" title="1">if sc.bconn != nil </span><span class="cov8" title="1">{
                        sc.bconn.Close()
                }</span>
        }()

        // select and connect to backend
        <span class="cov8" title="1">sc.bconn, back, err = sc.findBackend(sc.req)
        if err != nil </span><span class="cov8" title="1">{
                log.Logger.Info("bfe_websocket: findBackend() select backend failed: %s (%s)", err, sc.req.Host)
                return
        }</span>
        <span class="cov8" title="1">log.Logger.Debug("bfe_websocket: proxy websocket connection to %v", sc.bconn.RemoteAddr())
        defer back.DecConnNum()

        // websocket handshake
        if err := sc.websocketHandshake(); err != nil </span><span class="cov8" title="1">{
                log.Logger.Info("bfe_websocket: websocket handshake fail: %v (%v)", err, sc.bconn.RemoteAddr())
                state.WebSocketErrHandshake.Inc(1)
                return
        }</span>

        // websocket data transfer
        <span class="cov8" title="1">sc.websocketDataTransfer()

        // wait for finish
        for </span><span class="cov8" title="1">{
                select </span>{
                case err := &lt;-sc.errCh:<span class="cov8" title="1">
                        log.Logger.Debug("bfe_websocket: websocket conn finish %v: %v", sc.cconn.RemoteAddr(), err)
                        if err != nil </span><span class="cov0" title="0">{
                                state.WebSocketErrTransfer.Inc(1)
                        }</span>
                        <span class="cov8" title="1">sc.shutDownIn(250 * time.Millisecond)</span>

                case &lt;-sc.closeNotifyCh:<span class="cov8" title="1">
                        log.Logger.Debug("bfe_websocket: closing conn from %v", sc.cconn.RemoteAddr())
                        sc.shutDownIn(sc.hs.GracefulShutdownTimeout)
                        sc.closeNotifyCh = nil</span>

                case &lt;-sc.shutdownTimerCh:<span class="cov8" title="1">
                        return</span>
                }
        }
}

func (sc *serverConn) findBackend(req *http.Request) (net.Conn, *backend.BfeBackend, error) <span class="cov8" title="1">{
        balanceHandler := sc.srv.balanceHandler()
        if balanceHandler == nil </span><span class="cov0" title="0">{
                return nil, nil, errBalanceHandler
        }</span>

        <span class="cov8" title="1">for i := 0; i &lt; sc.srv.connectRetryMax(); i++ </span><span class="cov8" title="1">{
                // balance backend for current client
                backend, err := balanceHandler(req)
                if err != nil </span><span class="cov8" title="1">{
                        state.WebSocketErrBalance.Inc(1)
                        log.Logger.Debug("bfe_websocket: balance error: %s ", err)
                        continue</span>
                }
                <span class="cov8" title="1">backend.IncConnNum()

                // establish tcp conn to backend
                timeout := time.Duration(sc.srv.connectTimeout()) * time.Millisecond
                bAddr := backend.GetAddrInfo()
                bc, err := net.DialTimeout("tcp", bAddr, timeout)
                if err != nil </span><span class="cov8" title="1">{
                        // connect backend failed, desc connection num
                        backend.DecConnNum()
                        state.WebSocketErrConnect.Inc(1)
                        log.Logger.Debug("bfe_websocket: connect %s error: %s", bAddr, err)
                        continue</span>
                }

                <span class="cov8" title="1">return bc, backend, nil</span>
        }

        <span class="cov8" title="1">state.WebSocketErrProxy.Inc(1)
        return nil, nil, errRetryTooMany</span>
}

func (sc *serverConn) websocketHandshake() error <span class="cov8" title="1">{
        rw, req := sc.rw, sc.req

        // write client request to backend
        if err := req.Write(sc.bconn); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // read response from backend
        <span class="cov8" title="1">sc.bbr = bufio.NewReader(sc.bconn)
        rsp, err := http.ReadResponse(sc.bbr, req)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // check whether backend accept websocket upgrade
        <span class="cov8" title="1">if !CheckAcceptWebSocket(rsp) </span><span class="cov8" title="1">{
                state.WebSocketErrBackendReject.Inc(1)
                // write response anyway and finish conn
                sendResponse(rw, rsp)
                return fmt.Errorf("server reject upgrade to websocket (%v)", rsp.Status)
        }</span>

        // write 101 response
        <span class="cov8" title="1">return sendResponse(rw, rsp)</span>
}

func (sc *serverConn) websocketDataTransfer() <span class="cov8" title="1">{
        var cbr *bufio.ReadWriter
        var err error
        errCh := sc.errCh

        // take over the underlying connection from client
        sc.cconn, cbr, err = sc.rw.(http.Hijacker).Hijack()
        if err != nil </span><span class="cov0" title="0">{
                /* never come here */
                errCh &lt;- fmt.Errorf("Hijack failed: " + err.Error())
                return
        }</span>

        // if underlying buffer contain unprocessed data
        <span class="cov8" title="1">cbuf, err := peekBufferedData(cbr.Reader)
        if err != nil </span><span class="cov0" title="0">{
                errCh &lt;- err
                return
        }</span>
        <span class="cov8" title="1">if len(cbuf) &gt; 0 </span><span class="cov0" title="0">{
                if _, err := sc.bconn.Write(cbuf); err != nil </span><span class="cov0" title="0">{
                        errCh &lt;- err
                        return
                }</span>
        }

        <span class="cov8" title="1">bbuf, err := peekBufferedData(sc.bbr)
        if err != nil </span><span class="cov0" title="0">{
                errCh &lt;- err
                return
        }</span>
        <span class="cov8" title="1">if len(bbuf) &gt; 0 </span><span class="cov0" title="0">{
                if _, err := sc.cconn.Write(bbuf); err != nil </span><span class="cov0" title="0">{
                        errCh &lt;- err
                        return
                }</span>
        }

        // proxy data from client to backend
        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                n, err := io.Copy(sc.bconn, sc.cconn)
                state.WebSocketBytesRecv.Inc(uint(n))
                errCh &lt;- err
        }</span>()

        // proxy data from backend to client
        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                n, err := io.Copy(sc.cconn, sc.bconn)
                state.WebSocketBytesSent.Inc(uint(n))
                errCh &lt;- err
        }</span>()
}

func sendResponse(rw http.ResponseWriter, rsp *http.Response) error <span class="cov8" title="1">{
        http.CopyHeader(rw.Header(), rsp.Header)
        rw.WriteHeader(rsp.StatusCode)

        if _, err := io.Copy(rw, rsp.Body); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if f, ok := rw.(http.Flusher); ok </span><span class="cov8" title="1">{
                if err := f.Flush(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func peekBufferedData(r *bufio.Reader) ([]byte, error) <span class="cov8" title="1">{
        n := r.Buffered()
        if n &lt;= 0 </span><span class="cov8" title="1">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">b, err := r.Peek(n)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return b, nil</span>
}

func (sc *serverConn) shutDownIn(d time.Duration) <span class="cov8" title="1">{
        sc.serveG.Check()
        if sc.shutdownTimer != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">sc.shutdownTimer = time.NewTimer(d)
        sc.shutdownTimerCh = sc.shutdownTimer.C</span>
}

func (sc *serverConn) notePanic() <span class="cov8" title="1">{
        if e := recover(); e != nil </span><span class="cov8" title="1">{
                log.Logger.Warn("bfe_websocket: panic serving :%v\n%s",
                        e, gotrack.CurrentStackTrace(0))
                state.WebSocketPanicConn.Inc(1)
        }</span>
}
</pre>
		
		<pre class="file" id="file300" style="display: none">// Copyright (c) 2019 The BFE Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package bfe_websocket

import (
        "fmt"
        "io"
        "net"
        "net/http"
        "net/http/httptest"
        "strings"
        "testing"
        "time"
)

import (
        "golang.org/x/net/websocket"
)

import (
        "github.com/bfenetworks/bfe/bfe_balance/backend"
        "github.com/bfenetworks/bfe/bfe_bufio"
        "github.com/bfenetworks/bfe/bfe_http"
        "github.com/bfenetworks/bfe/bfe_util"
)

type ServerTester struct {
        t testing.TB

        // for websocket client
        cc net.Conn
        wc *websocket.Conn

        // for websocket proxy
        mp *bfe_util.MockServer
        hl func(*bfe_http.Server, bfe_http.ResponseWriter, *bfe_http.Request)

        // for websocket server
        mb *httptest.Server
}

func NewServerTester(t testing.TB, h HandlerMap, c *Server) *ServerTester <span class="cov8" title="1">{
        st := &amp;ServerTester{t: t}

        // init websocket server
        st.startWebsocketServer(h)

        // init websocket proxy
        if c == nil </span><span class="cov8" title="1">{
                c = new(Server)
        }</span>
        <span class="cov8" title="1">if c.BalanceHandler == nil </span><span class="cov8" title="1">{
                c.BalanceHandler = func(req interface{}) (*backend.BfeBackend, error) </span><span class="cov8" title="1">{
                        b := backend.NewBfeBackend()
                        b.AddrInfo = st.mb.Listener.Addr().String()
                        return b, nil
                }</span>
        }
        <span class="cov8" title="1">st.hl = NewProtoHandler(c)
        st.mp = bfe_util.NewUnstartedServer(bfe_util.MockHandler(st.handleWebsocketConn))
        st.mp.StartTCP()

        // init websocket client
        cc, err := net.Dial("tcp", st.mp.Listener.Addr().String())
        if err != nil </span><span class="cov0" title="0">{
                t.Fatal(err)
        }</span>
        <span class="cov8" title="1">st.cc = cc

        return st</span>
}

func (st *ServerTester) startWebsocketServer(handlers HandlerMap) <span class="cov8" title="1">{
        // register websocet handlers
        for uri, handler := range handlers </span><span class="cov8" title="1">{
                http.Handle(uri, handler)
        }</span>
        // start websocket server
        <span class="cov8" title="1">st.mb = httptest.NewServer(nil)</span>
}

func (st *ServerTester) handleWebsocketConn(conn net.Conn) <span class="cov8" title="1">{
        defer conn.Close()

        // read first request from conn
        br := bfe_bufio.NewReader(conn)
        bw := bfe_bufio.NewWriter(conn)
        wr := bfe_bufio.NewReadWriter(br, bw)
        req, err := bfe_http.ReadRequest(wr.Reader, 1024)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        // create ResponseWriter
        <span class="cov8" title="1">rw := NewMockResponseWriter(conn, wr)

        // check and process websocket upgrade
        if CheckUpgradeWebSocket(req) </span><span class="cov8" title="1">{
                st.hl(st.mp.Config, rw, req)
                return
        }</span>
}

// WebSocketHandshake starts websocket handshake (client perspective)
func (st *ServerTester) WebSocketHandshake(c *websocket.Config) error <span class="cov8" title="1">{
        var err error
        st.wc, err = websocket.NewClient(c, st.cc)
        return err
}</span>

// WebSocketWrite sends webscoket message (client perspective)
func (st *ServerTester) WebSocketWrite(data []byte) (int, error) <span class="cov8" title="1">{
        return st.wc.Write(data)
}</span>

// WebSocketRead recv websocket message (client perspective)
func (st *ServerTester) WebSocketRead(msg []byte) (int, error) <span class="cov8" title="1">{
        return st.wc.Read(msg)
}</span>

// Read reads until timeout (client perspective)
func (st *ServerTester) Read(buf []byte) error <span class="cov8" title="1">{
        st.cc.SetReadDeadline(time.Now().Add(4 * time.Second))
        _, err := io.ReadFull(st.cc, buf)
        return err
}</span>

// Write writes raw data (client perspective)
func (st *ServerTester) Write(data []byte) error <span class="cov8" title="1">{
        _, err := st.cc.Write(data)
        return err
}</span>

// WantError read and check error (client perspective)
func (st *ServerTester) WantError(e string) <span class="cov8" title="1">{
        err := st.Read(make([]byte, 256))
        if err == nil </span><span class="cov0" title="0">{
                st.t.Fatalf("Expecting error")
        }</span>
        <span class="cov8" title="1">if !strings.Contains(err.Error(), e) </span><span class="cov0" title="0">{
                st.t.Fatalf("Expecting error got %v ; want %v", err.Error(), e)
        }</span>
}

func (st *ServerTester) Close() <span class="cov8" title="1">{
        st.cc.Close()
        st.mp.Close()
        st.mb.Close()
}</span>

type HandlerMap map[string]http.Handler

func websocketHandlers(uri string, h websocket.Handler) HandlerMap <span class="cov8" title="1">{
        m := make(HandlerMap)
        m[uri] = h
        return m
}</span>

type MockResponseWriter struct {
        conn        net.Conn
        brw         *bfe_bufio.ReadWriter
        header      bfe_http.Header
        wroteHeader bool
}

func NewMockResponseWriter(conn net.Conn, brw *bfe_bufio.ReadWriter) *MockResponseWriter <span class="cov8" title="1">{
        rw := new(MockResponseWriter)
        rw.conn = conn
        rw.brw = brw
        rw.header = make(bfe_http.Header)
        return rw
}</span>

// Header returns the header map that will be sent by WriteHeader.
// Changing the header after a call to WriteHeader (or Write) has no effect.
func (rw *MockResponseWriter) Header() bfe_http.Header <span class="cov8" title="1">{
        return rw.header
}</span>

// Write writes the data to the connection as part of an HTTP reply.
func (rw *MockResponseWriter) Write(data []byte) (int, error) <span class="cov8" title="1">{
        if !rw.wroteHeader </span><span class="cov0" title="0">{
                rw.WriteHeader(bfe_http.StatusOK)
        }</span>

        // not support chunked-encoding
        <span class="cov8" title="1">n, err := rw.brw.Write(data)
        if err != nil </span><span class="cov0" title="0">{
                return n, err
        }</span>
        <span class="cov8" title="1">err = rw.brw.Flush()
        return n, err</span>
}

// WriteHeader sends an HTTP response header with status code.
func (rw *MockResponseWriter) WriteHeader(code int) <span class="cov8" title="1">{
        if rw.wroteHeader </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">rw.wroteHeader = true

        statusLine := fmt.Sprintf("HTTP/1.1 %d %s\r\n", code, bfe_http.StatusText[code])
        rw.brw.Write([]byte(statusLine))
        rw.header.Write(rw.brw.Writer)
        rw.brw.Write([]byte("\r\n"))
        rw.brw.Flush()</span>
}

func (rw *MockResponseWriter) Flush() error <span class="cov8" title="1">{
        return nil
}</span>

func (rw *MockResponseWriter) Hijack() (rwc net.Conn, buf *bfe_bufio.ReadWriter, err error) <span class="cov8" title="1">{
        return rw.conn, rw.brw, nil
}</span>

func testWebSocketProxy(t *testing.T, f func(st *ServerTester), h HandlerMap, c *Server) <span class="cov8" title="1">{
        // create server tester
        st := NewServerTester(t, h, c)
        defer st.Close()

        // perform test actions
        f(st)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
